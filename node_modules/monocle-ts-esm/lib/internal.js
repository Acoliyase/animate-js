"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.atReadonlyRecord = exports.at = exports.indexReadonlyRecord = exports.indexReadonlyNonEmptyArray = exports.indexReadonlyArray = exports.index = exports.traversalTraverse = exports.fromTraversable = exports.ApplicativeIdentity = exports.traversalComposeTraversal = exports.traversal = exports.optionalFindFirstNonEmpty = exports.optionalFindFirst = exports.optionalKey = exports.optionalIndexNonEmpty = exports.optionalIndex = exports.optionalComposeOptional = exports.optionalModify = exports.optionalModifyOption = exports.optionalAsTraversal = exports.optional = exports.prismLeft = exports.prismRight = exports.prismSome = exports.prismFromPredicate = exports.prismFromNullable = exports.prismComposeLens = exports.prismSet = exports.prismModify = exports.prismModifyOption = exports.prismAsTraversal = exports.prismAsOptional = exports.prism = exports.lensAtKey = exports.lensComponent = exports.lensProps = exports.lensProp = exports.lensId = exports.lensComposePrism = exports.prismComposePrism = exports.lensComposeLens = exports.lensAsTraversal = exports.lensAsOptional = exports.lens = exports.isoAsTraversal = exports.isoAsOptional = exports.isoAsPrism = exports.isoAsLens = exports.iso = void 0;
const RA = __importStar(require("fp-ts-esm/ReadonlyArray"));
const RR = __importStar(require("fp-ts-esm/ReadonlyRecord"));
const function_1 = require("fp-ts-esm/function");
const O = __importStar(require("fp-ts-esm/Option"));
const E = __importStar(require("fp-ts-esm/Either"));
const pipeable_1 = require("fp-ts-esm/pipeable");
// -------------------------------------------------------------------------------------
// Iso
// -------------------------------------------------------------------------------------
/** @internal */
const iso = (get, reverseGet) => ({
    get,
    reverseGet
});
exports.iso = iso;
/** @internal */
const isoAsLens = (sa) => (0, exports.lens)(sa.get, (0, function_1.flow)(sa.reverseGet, function_1.constant));
exports.isoAsLens = isoAsLens;
/** @internal */
const isoAsPrism = (sa) => (0, exports.prism)((0, function_1.flow)(sa.get, O.some), sa.reverseGet);
exports.isoAsPrism = isoAsPrism;
/** @internal */
const isoAsOptional = (sa) => (0, exports.optional)((0, function_1.flow)(sa.get, O.some), (0, function_1.flow)(sa.reverseGet, function_1.constant));
exports.isoAsOptional = isoAsOptional;
/** @internal */
const isoAsTraversal = (sa) => (0, exports.traversal)((F) => (f) => (s) => 
// @ts-expect-error
F.map(f(sa.get(s)), (a) => sa.reverseGet(a)));
exports.isoAsTraversal = isoAsTraversal;
// -------------------------------------------------------------------------------------
// Lens
// -------------------------------------------------------------------------------------
/** @internal */
const lens = (get, set) => ({ get, set });
exports.lens = lens;
/** @internal */
const lensAsOptional = (sa) => (0, exports.optional)((0, function_1.flow)(sa.get, O.some), sa.set);
exports.lensAsOptional = lensAsOptional;
/** @internal */
const lensAsTraversal = (sa) => 
// @ts-expect-error
(0, exports.traversal)((F) => (f) => (s) => F.map(f(sa.get(s)), (a) => sa.set(a)(s)));
exports.lensAsTraversal = lensAsTraversal;
/** @internal */
const lensComposeLens = (ab) => (sa) => (0, exports.lens)((s) => ab.get(sa.get(s)), (b) => (s) => sa.set(ab.set(b)(sa.get(s)))(s));
exports.lensComposeLens = lensComposeLens;
/** @internal */
const prismComposePrism = (ab) => (sa) => (0, exports.prism)((0, function_1.flow)(sa.getOption, O.chain(ab.getOption)), (0, function_1.flow)(ab.reverseGet, sa.reverseGet));
exports.prismComposePrism = prismComposePrism;
/** @internal */
const lensComposePrism = (ab) => (sa) => (0, exports.optionalComposeOptional)((0, exports.prismAsOptional)(ab))((0, exports.lensAsOptional)(sa));
exports.lensComposePrism = lensComposePrism;
/** @internal */
const lensId = () => (0, exports.lens)(function_1.identity, function_1.constant);
exports.lensId = lensId;
/** @internal */
const lensProp = (prop) => (sa) => (0, exports.lens)((s) => sa.get(s)[prop], (ap) => (s) => {
    const oa = sa.get(s);
    if (ap === oa[prop]) {
        return s;
    }
    return sa.set(Object.assign({}, oa, { [prop]: ap }))(s);
});
exports.lensProp = lensProp;
/** @internal */
const lensProps = (...props) => (sa) => (0, exports.lens)((s) => {
    const a = sa.get(s);
    const r = {};
    for (const k of props) {
        r[k] = a[k];
    }
    return r;
}, (a) => (s) => {
    const oa = sa.get(s);
    for (const k of props) {
        if (a[k] !== oa[k]) {
            return sa.set(Object.assign({}, oa, a))(s);
        }
    }
    return s;
});
exports.lensProps = lensProps;
/** @internal */
const lensComponent = (prop) => (sa) => (0, exports.lens)((s) => sa.get(s)[prop], (ap) => (s) => {
    const oa = sa.get(s);
    if (ap === oa[prop]) {
        return s;
    }
    const copy = oa.slice();
    copy[prop] = ap;
    return sa.set(copy)(s);
});
exports.lensComponent = lensComponent;
/** @internal */
const lensAtKey = (key) => (sa) => (0, pipeable_1.pipe)(sa, (0, exports.lensComposeLens)(atReadonlyRecord().at(key)));
exports.lensAtKey = lensAtKey;
// -------------------------------------------------------------------------------------
// Prism
// -------------------------------------------------------------------------------------
/** @internal */
const prism = (getOption, reverseGet) => ({ getOption, reverseGet });
exports.prism = prism;
/** @internal */
const prismAsOptional = (sa) => (0, exports.optional)(sa.getOption, (a) => (0, exports.prismSet)(a)(sa));
exports.prismAsOptional = prismAsOptional;
/** @internal */
const prismAsTraversal = (sa) => (0, exports.traversal)((F) => (f) => (s) => (0, pipeable_1.pipe)(sa.getOption(s), O.fold(() => F.of(s), 
// @ts-expect-error
(a) => F.map(f(a), (a) => (0, exports.prismSet)(a)(sa)(s)))));
exports.prismAsTraversal = prismAsTraversal;
/** @internal */
const prismModifyOption = (f) => (sa) => (s) => (0, pipeable_1.pipe)(sa.getOption(s), O.map((o) => {
    const n = f(o);
    return n === o ? s : sa.reverseGet(n);
}));
exports.prismModifyOption = prismModifyOption;
/** @internal */
const prismModify = (f) => (sa) => {
    const g = (0, exports.prismModifyOption)(f)(sa);
    return (s) => (0, pipeable_1.pipe)(g(s), O.getOrElse(() => s));
};
exports.prismModify = prismModify;
/** @internal */
const prismSet = (a) => (0, exports.prismModify)(() => a);
exports.prismSet = prismSet;
/** @internal */
const prismComposeLens = (ab) => (sa) => (0, exports.optionalComposeOptional)((0, exports.lensAsOptional)(ab))((0, exports.prismAsOptional)(sa));
exports.prismComposeLens = prismComposeLens;
/** @internal */
const prismFromNullable = () => (0, exports.prism)(O.fromNullable, function_1.identity);
exports.prismFromNullable = prismFromNullable;
/** @internal */
const prismFromPredicate = (predicate) => (0, exports.prism)(O.fromPredicate(predicate), function_1.identity);
exports.prismFromPredicate = prismFromPredicate;
/** @internal */
const prismSome = () => (0, exports.prism)(function_1.identity, O.some);
exports.prismSome = prismSome;
/** @internal */
const prismRight = () => (0, exports.prism)(O.fromEither, E.right);
exports.prismRight = prismRight;
/** @internal */
const prismLeft = () => (0, exports.prism)((s) => (E.isLeft(s) ? O.some(s.left) : O.none), // TODO: replace with E.getLeft in v3
E.left);
exports.prismLeft = prismLeft;
// -------------------------------------------------------------------------------------
// Optional
// -------------------------------------------------------------------------------------
/** @internal */
const optional = (getOption, set) => ({
    getOption,
    set
});
exports.optional = optional;
/** @internal */
const optionalAsTraversal = (sa) => (0, exports.traversal)((F) => (f) => (s) => (0, pipeable_1.pipe)(sa.getOption(s), O.fold(() => F.of(s), (a) => F.map(f(a), (a) => sa.set(a)(s)))));
exports.optionalAsTraversal = optionalAsTraversal;
/** @internal */
const optionalModifyOption = (f) => (optional) => (s) => (0, pipeable_1.pipe)(optional.getOption(s), O.map((a) => {
    const n = f(a);
    return n === a ? s : optional.set(n)(s);
}));
exports.optionalModifyOption = optionalModifyOption;
/** @internal */
const optionalModify = (f) => (optional) => {
    const g = (0, exports.optionalModifyOption)(f)(optional);
    return (s) => (0, pipeable_1.pipe)(g(s), O.getOrElse(() => s));
};
exports.optionalModify = optionalModify;
/** @internal */
const optionalComposeOptional = (ab) => (sa) => (0, exports.optional)((0, function_1.flow)(sa.getOption, O.chain(ab.getOption)), (b) => (0, exports.optionalModify)(ab.set(b))(sa));
exports.optionalComposeOptional = optionalComposeOptional;
/** @internal */
const optionalIndex = (i) => (sa) => (0, pipeable_1.pipe)(sa, (0, exports.optionalComposeOptional)((0, exports.indexReadonlyArray)().index(i)));
exports.optionalIndex = optionalIndex;
/** @internal */
const optionalIndexNonEmpty = (i) => (sa) => (0, pipeable_1.pipe)(sa, (0, exports.optionalComposeOptional)((0, exports.indexReadonlyNonEmptyArray)().index(i)));
exports.optionalIndexNonEmpty = optionalIndexNonEmpty;
/** @internal */
const optionalKey = (key) => (sa) => (0, pipeable_1.pipe)(sa, (0, exports.optionalComposeOptional)((0, exports.indexReadonlyRecord)().index(key)));
exports.optionalKey = optionalKey;
/** @internal */
const optionalFindFirst = (predicate) => (0, exports.optional)(RA.findFirst(predicate), (a) => (s) => (0, pipeable_1.pipe)(RA.findIndex(predicate)(s), O.fold(() => s, (i) => RA.unsafeUpdateAt(i, a, s))));
exports.optionalFindFirst = optionalFindFirst;
const unsafeUpdateAt = (i, a, as) => {
    if (as[i] === a) {
        return as;
    }
    else {
        const xs = [as[0], ...as.slice(1)];
        xs[i] = a;
        return xs;
    }
};
/** @internal */
const optionalFindFirstNonEmpty = (predicate) => (0, exports.optional)(RA.findFirst(predicate), (a) => (as) => (0, pipeable_1.pipe)(RA.findIndex(predicate)(as), O.fold(() => as, (i) => unsafeUpdateAt(i, a, as))));
exports.optionalFindFirstNonEmpty = optionalFindFirstNonEmpty;
// -------------------------------------------------------------------------------------
// Traversal
// -------------------------------------------------------------------------------------
/** @internal */
const traversal = (modifyF) => ({
    modifyF
});
exports.traversal = traversal;
/** @internal */
function traversalComposeTraversal(ab) {
    return (sa) => (0, exports.traversal)((F) => (f) => sa.modifyF(F)(ab.modifyF(F)(f)));
}
exports.traversalComposeTraversal = traversalComposeTraversal;
/** @internal */
exports.ApplicativeIdentity = {
    URI: 'Identity',
    map: (fa, f) => f(fa),
    of: function_1.identity,
    ap: 
    /* istanbul ignore next */
    (fab, fa) => fab(fa)
};
const isIdentity = (F) => F.URI === 'Identity';
function fromTraversable(T) {
    return () => (0, exports.traversal)((F) => {
        // if `F` is `Identity` then `traverseF = map`
        const traverseF = isIdentity(F)
            ? T.map
            : T.traverse(F);
        return (f) => (s) => traverseF(s, f);
    });
}
exports.fromTraversable = fromTraversable;
/** @internal */
function traversalTraverse(T) {
    return traversalComposeTraversal(fromTraversable(T)());
}
exports.traversalTraverse = traversalTraverse;
// -------------------------------------------------------------------------------------
// Ix
// -------------------------------------------------------------------------------------
/** @internal */
const index = (index) => ({ index });
exports.index = index;
/** @internal */
const indexReadonlyArray = () => (0, exports.index)((i) => (0, exports.optional)((as) => RA.lookup(i, as), (a) => (as) => (0, pipeable_1.pipe)(RA.lookup(i, as), O.fold(() => as, () => RA.unsafeUpdateAt(i, a, as)))));
exports.indexReadonlyArray = indexReadonlyArray;
/** @internal */
const indexReadonlyNonEmptyArray = () => (0, exports.index)((i) => (0, exports.optional)((as) => RA.lookup(i, as), (a) => (as) => (0, pipeable_1.pipe)(RA.lookup(i, as), O.fold(() => as, () => unsafeUpdateAt(i, a, as)))));
exports.indexReadonlyNonEmptyArray = indexReadonlyNonEmptyArray;
/** @internal */
const indexReadonlyRecord = () => (0, exports.index)((k) => (0, exports.optional)((r) => RR.lookup(k, r), (a) => (r) => {
    if (r[k] === a || O.isNone(RR.lookup(k, r))) {
        return r;
    }
    return RR.insertAt(k, a)(r);
}));
exports.indexReadonlyRecord = indexReadonlyRecord;
// -------------------------------------------------------------------------------------
// At
// -------------------------------------------------------------------------------------
/** @internal */
const at = (at) => ({ at });
exports.at = at;
/** @internal */
function atReadonlyRecord() {
    return (0, exports.at)((key) => (0, exports.lens)((r) => RR.lookup(key, r), O.fold(() => RR.deleteAt(key), (a) => RR.insertAt(key, a))));
}
exports.atReadonlyRecord = atReadonlyRecord;
