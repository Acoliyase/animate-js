import * as C from 'fp-ts-esm/Const';
import { flow, identity } from 'fp-ts-esm/function';
import { pipe } from 'fp-ts-esm/pipeable';
import * as RA from 'fp-ts-esm/ReadonlyArray';
import * as _ from './internal.js';
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.3.8
 */
export const traversal = _.traversal;
/**
 * @category constructors
 * @since 2.3.0
 */
export const id = () => traversal((_) => (f) => f);
/**
 * Create a `Traversal` from a `Traversable`.
 *
 * @category constructor
 * @since 2.3.0
 */
export const fromTraversable = _.fromTraversable;
// -------------------------------------------------------------------------------------
// compositions
// -------------------------------------------------------------------------------------
/**
 * Compose a `Traversal` with a `Traversal`.
 *
 * @category compositions
 * @since 2.3.0
 */
export const compose = _.traversalComposeTraversal;
/**
 * Alias of `compose`.
 *
 * @category compositions
 * @since 2.3.8
 */
export const composeTraversal = compose;
/**
 * Compose a `Traversal` with a `Iso`.
 *
 * @category compositions
 * @since 2.3.8
 */
export const composeIso = 
/*#__PURE__*/
flow(_.isoAsTraversal, compose);
/**
 * Compose a `Traversal` with a `Lens`.
 *
 * @category compositions
 * @since 2.3.8
 */
export const composeLens = 
/*#__PURE__*/
flow(_.lensAsTraversal, _.traversalComposeTraversal);
/**
 * Compose a `Traversal` with a `Prism`.
 *
 * @category compositions
 * @since 2.3.8
 */
export const composePrism = 
/*#__PURE__*/
flow(_.prismAsTraversal, _.traversalComposeTraversal);
/**
 * Compose a `Traversal` with a `Optional`.
 *
 * @category compositions
 * @since 2.3.8
 */
export const composeOptional = 
/*#__PURE__*/
flow(_.optionalAsTraversal, _.traversalComposeTraversal);
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category combinators
 * @since 2.3.0
 */
export const modify = (f) => (sa) => sa.modifyF(_.ApplicativeIdentity)(f);
/**
 * @category combinators
 * @since 2.3.0
 */
export const set = (a) => modify(() => a);
/**
 * Return a `Traversal` from a `Traversal` focused on a nullable value.
 *
 * @category combinators
 * @since 2.3.0
 */
export const fromNullable = (sa) => composePrism(_.prismFromNullable())(sa);
export function filter(predicate) {
    return compose(_.prismAsTraversal(_.prismFromPredicate(predicate)));
}
/**
 * Return a `Traversal` from a `Traversal` and a prop.
 *
 * @category combinators
 * @since 2.3.0
 */
export const prop = (prop) => compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsTraversal));
/**
 * Return a `Traversal` from a `Traversal` and a list of props.
 *
 * @category combinators
 * @since 2.3.0
 */
export const props = (...props) => compose(pipe(_.lensId(), _.lensProps(...props), _.lensAsTraversal));
/**
 * Return a `Traversal` from a `Traversal` focused on a component of a tuple.
 *
 * @category combinators
 * @since 2.3.0
 */
export const component = (prop) => compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));
/**
 * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.
 *
 * @category combinators
 * @since 2.3.0
 */
export const index = (i) => (sa) => pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));
/**
 * @category combinators
 * @since 2.3.8
 */
export const indexNonEmpty = (i) => (sa) => pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));
/**
 * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.
 *
 * @category combinators
 * @since 2.3.0
 */
export const key = (key) => (sa) => pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));
/**
 * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.
 *
 * @category combinators
 * @since 2.3.0
 */
export const atKey = (key) => (sa) => pipe(sa, compose(_.lensAsTraversal(_.atReadonlyRecord().at(key))));
/**
 * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.
 *
 * @category combinators
 * @since 2.3.0
 */
export const some = 
/*#__PURE__*/
compose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));
/**
 * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.
 *
 * @category combinators
 * @since 2.3.0
 */
export const right = 
/*#__PURE__*/
compose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));
/**
 * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.
 *
 * @category combinators
 * @since 2.3.0
 */
export const left = 
/*#__PURE__*/
compose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));
/**
 * Return a `Traversal` from a `Traversal` focused on a `Traversable`.
 *
 * @category combinators
 * @since 2.3.0
 */
export const traverse = _.traversalTraverse;
export function findFirst(predicate) {
    return composeOptional(_.optionalFindFirst(predicate));
}
export function findFirstNonEmpty(predicate) {
    return composeOptional(_.optionalFindFirstNonEmpty(predicate));
}
/**
 * Map each target to a `Monoid` and combine the results.
 *
 * @category combinators
 * @since 2.3.0
 */
export const foldMap = (M) => (f) => (sa) => sa.modifyF(C.getApplicative(M))((a) => C.make(f(a)));
/**
 * Map each target to a `Monoid` and combine the results.
 *
 * @category combinators
 * @since 2.3.0
 */
export const fold = (M) => foldMap(M)(identity);
/**
 * Get all the targets of a `Traversal`.
 *
 * @category combinators
 * @since 2.3.0
 */
export const getAll = (s) => (sa) => foldMap(RA.getMonoid())(RA.of)(sa)(s);
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.3.0
 */
export const URI = 'monocle-ts/Traversal';
/**
 * @category instances
 * @since 2.3.8
 */
export const Semigroupoid = {
    URI,
    compose: (ab, ea) => compose(ab)(ea)
};
/**
 * @category instances
 * @since 2.3.0
 */
export const Category = {
    URI,
    compose: Semigroupoid.compose,
    id
};
