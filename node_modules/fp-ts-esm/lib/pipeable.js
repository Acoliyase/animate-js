"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pipe = void 0;
exports.map = map;
exports.contramap = contramap;
exports.mapWithIndex = mapWithIndex;
exports.ap = ap;
exports.chain = chain;
exports.bimap = bimap;
exports.mapLeft = mapLeft;
exports.extend = extend;
exports.reduce = reduce;
exports.foldMap = foldMap;
exports.reduceRight = reduceRight;
exports.reduceWithIndex = reduceWithIndex;
exports.foldMapWithIndex = foldMapWithIndex;
exports.reduceRightWithIndex = reduceRightWithIndex;
exports.alt = alt;
exports.filter = filter;
exports.filterMap = filterMap;
exports.partition = partition;
exports.partitionMap = partitionMap;
exports.filterWithIndex = filterWithIndex;
exports.filterMapWithIndex = filterMapWithIndex;
exports.partitionWithIndex = partitionWithIndex;
exports.partitionMapWithIndex = partitionMapWithIndex;
exports.promap = promap;
exports.compose = compose;
exports.pipeable = pipeable;
const Apply_js_1 = require("./Apply.js");
const Chain_js_1 = require("./Chain.js");
const function_js_1 = require("./function.js");
function map(F) {
    return (f) => (fa) => F.map(fa, f);
}
function contramap(F) {
    return (f) => (fa) => F.contramap(fa, f);
}
function mapWithIndex(F) {
    return (f) => (fa) => F.mapWithIndex(fa, f);
}
function ap(F) {
    return (fa) => (fab) => F.ap(fab, fa);
}
function chain(F) {
    return (f) => (fa) => F.chain(fa, f);
}
function bimap(F) {
    return (f, g) => (fea) => F.bimap(fea, f, g);
}
function mapLeft(F) {
    return (f) => (fea) => F.mapLeft(fea, f);
}
function extend(F) {
    return (f) => (wa) => F.extend(wa, f);
}
function reduce(F) {
    return (b, f) => (fa) => F.reduce(fa, b, f);
}
function foldMap(F) {
    return (M) => {
        const foldMapM = F.foldMap(M);
        return (f) => (fa) => foldMapM(fa, f);
    };
}
function reduceRight(F) {
    return (b, f) => (fa) => F.reduceRight(fa, b, f);
}
function reduceWithIndex(F) {
    return (b, f) => (fa) => F.reduceWithIndex(fa, b, f);
}
function foldMapWithIndex(F) {
    return (M) => {
        const foldMapWithIndexM = F.foldMapWithIndex(M);
        return (f) => (fa) => foldMapWithIndexM(fa, f);
    };
}
function reduceRightWithIndex(F) {
    return (b, f) => (fa) => F.reduceRightWithIndex(fa, b, f);
}
function alt(F) {
    return (that) => (fa) => F.alt(fa, that);
}
function filter(F) {
    return (predicate) => (fa) => F.filter(fa, predicate);
}
function filterMap(F) {
    return (f) => (fa) => F.filterMap(fa, f);
}
function partition(F) {
    return (f) => (fa) => F.partition(fa, f);
}
function partitionMap(F) {
    return (f) => (fa) => F.partitionMap(fa, f);
}
function filterWithIndex(F) {
    return (predicate) => (fa) => F.filterWithIndex(fa, predicate);
}
function filterMapWithIndex(F) {
    return (f) => (fa) => F.filterMapWithIndex(fa, f);
}
function partitionWithIndex(F) {
    return (f) => (fa) => F.partitionWithIndex(fa, f);
}
function partitionMapWithIndex(F) {
    return (f) => (fa) => F.partitionMapWithIndex(fa, f);
}
function promap(F) {
    return (f, g) => (fbc) => F.promap(fbc, f, g);
}
function compose(F) {
    return (ea) => (ab) => F.compose(ab, ea);
}
const isFunctor = (I) => typeof I.map === 'function';
const isContravariant = (I) => typeof I.contramap === 'function';
const isFunctorWithIndex = (I) => typeof I.mapWithIndex === 'function';
const isApply = (I) => typeof I.ap === 'function';
const isChain = (I) => typeof I.chain === 'function';
const isBifunctor = (I) => typeof I.bimap === 'function';
const isExtend = (I) => typeof I.extend === 'function';
const isFoldable = (I) => typeof I.reduce === 'function';
const isFoldableWithIndex = (I) => typeof I.reduceWithIndex === 'function';
const isAlt = (I) => typeof I.alt === 'function';
const isCompactable = (I) => typeof I.compact === 'function';
const isFilterable = (I) => typeof I.filter === 'function';
const isFilterableWithIndex = (I) => typeof I.filterWithIndex === 'function';
const isProfunctor = (I) => typeof I.promap === 'function';
const isSemigroupoid = (I) => typeof I.compose === 'function';
const isMonadThrow = (I) => typeof I.throwError === 'function';
/** @deprecated */
function pipeable(I) {
    const r = {};
    if (isFunctor(I)) {
        r.map = map(I);
    }
    if (isContravariant(I)) {
        r.contramap = contramap(I);
    }
    if (isFunctorWithIndex(I)) {
        r.mapWithIndex = mapWithIndex(I);
    }
    if (isApply(I)) {
        r.ap = ap(I);
        r.apFirst = (0, Apply_js_1.apFirst)(I);
        r.apSecond = (0, Apply_js_1.apSecond)(I);
    }
    if (isChain(I)) {
        r.chain = chain(I);
        r.chainFirst = (0, Chain_js_1.chainFirst)(I);
        r.flatten = r.chain(function_js_1.identity);
    }
    if (isBifunctor(I)) {
        r.bimap = bimap(I);
        r.mapLeft = mapLeft(I);
    }
    if (isExtend(I)) {
        r.extend = extend(I);
        r.duplicate = r.extend(function_js_1.identity);
    }
    if (isFoldable(I)) {
        r.reduce = reduce(I);
        r.foldMap = foldMap(I);
        r.reduceRight = reduceRight(I);
    }
    if (isFoldableWithIndex(I)) {
        r.reduceWithIndex = reduceWithIndex(I);
        r.foldMapWithIndex = foldMapWithIndex(I);
        r.reduceRightWithIndex = reduceRightWithIndex(I);
    }
    if (isAlt(I)) {
        r.alt = alt(I);
    }
    if (isCompactable(I)) {
        r.compact = I.compact;
        r.separate = I.separate;
    }
    if (isFilterable(I)) {
        r.filter = filter(I);
        r.filterMap = filterMap(I);
        r.partition = partition(I);
        r.partitionMap = partitionMap(I);
    }
    if (isFilterableWithIndex(I)) {
        r.filterWithIndex = filterWithIndex(I);
        r.filterMapWithIndex = filterMapWithIndex(I);
        r.partitionWithIndex = partitionWithIndex(I);
        r.partitionMapWithIndex = partitionMapWithIndex(I);
    }
    if (isProfunctor(I)) {
        r.promap = promap(I);
    }
    if (isSemigroupoid(I)) {
        r.compose = compose(I);
    }
    if (isMonadThrow(I)) {
        const fromOption = (onNone) => (ma) => ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);
        const fromEither = (ma) => ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);
        const fromPredicate = (predicate, onFalse) => (a) => predicate(a) ? I.of(a) : I.throwError(onFalse(a));
        const filterOrElse = (predicate, onFalse) => (ma) => I.chain(ma, (a) => (predicate(a) ? I.of(a) : I.throwError(onFalse(a))));
        r.fromOption = fromOption;
        r.fromEither = fromEither;
        r.fromPredicate = fromPredicate;
        r.filterOrElse = filterOrElse;
    }
    return r;
}
/**
 * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
 *
 * @since 2.0.0
 * @deprecated
 */
exports.pipe = function_js_1.pipe;
