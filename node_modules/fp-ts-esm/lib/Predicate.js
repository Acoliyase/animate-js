"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;
const function_js_1 = require("./function.js");
const contramap_ = (predicate, f) => (0, function_js_1.pipe)(predicate, (0, exports.contramap)(f));
/**
 * @since 2.11.0
 */
const contramap = (f) => (predicate) => (0, function_js_1.flow)(f, predicate);
exports.contramap = contramap;
/**
 * @category type lambdas
 * @since 2.11.0
 */
exports.URI = 'Predicate';
/**
 * @category instances
 * @since 2.11.0
 */
const getSemigroupAny = () => ({
    concat: (first, second) => (0, function_js_1.pipe)(first, (0, exports.or)(second))
});
exports.getSemigroupAny = getSemigroupAny;
/**
 * @category instances
 * @since 2.11.0
 */
const getMonoidAny = () => ({
    concat: (0, exports.getSemigroupAny)().concat,
    empty: function_js_1.constFalse
});
exports.getMonoidAny = getMonoidAny;
/**
 * @category instances
 * @since 2.11.0
 */
const getSemigroupAll = () => ({
    concat: (first, second) => (0, function_js_1.pipe)(first, (0, exports.and)(second))
});
exports.getSemigroupAll = getSemigroupAll;
/**
 * @category instances
 * @since 2.11.0
 */
const getMonoidAll = () => ({
    concat: (0, exports.getSemigroupAll)().concat,
    empty: function_js_1.constTrue
});
exports.getMonoidAll = getMonoidAll;
/**
 * @category instances
 * @since 2.11.0
 */
exports.Contravariant = {
    URI: exports.URI,
    contramap: contramap_
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
const not = (predicate) => (a) => !predicate(a);
exports.not = not;
/**
 * @since 2.11.0
 */
const or = (second) => (first) => (a) => first(a) || second(a);
exports.or = or;
/**
 * @since 2.11.0
 */
const and = (second) => (first) => (a) => first(a) && second(a);
exports.and = and;
