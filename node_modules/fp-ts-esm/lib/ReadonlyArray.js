"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortBy = exports.uniq = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zipWith = exports.sort = exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.findLastIndex = exports.findLastMap = exports.findFirstMap = exports.findIndex = exports.dropRight = exports.dropLeft = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.foldMap = exports.reduce = exports.foldMapWithIndex = exports.duplicate = exports.extend = exports.filterWithIndex = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.filter = exports.separate = exports.mapWithIndex = exports.map = exports.flatten = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.zero = exports.of = exports._chainRecBreadthFirst = exports._chainRecDepthFirst = exports.concat = exports.concatW = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = void 0;
exports.cons = exports.range = exports.chain = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = exports.some = exports.empty = exports.fromArray = exports.toArray = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.Witherable = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = void 0;
exports.readonlyArray = exports.prependToAll = exports.snoc = void 0;
exports.fromPredicate = fromPredicate;
exports.lookup = lookup;
exports.takeLeftWhile = takeLeftWhile;
exports.spanLeft = spanLeft;
exports.dropLeftWhile = dropLeftWhile;
exports.findFirst = findFirst;
exports.findLast = findLast;
exports.zip = zip;
exports.elem = elem;
exports.comprehension = comprehension;
exports.union = union;
exports.intersection = intersection;
exports.difference = difference;
exports.every = every;
const Apply_js_1 = require("./Apply.js");
const Chain_js_1 = require("./Chain.js");
const Eq_js_1 = require("./Eq.js");
const FromEither_js_1 = require("./FromEither.js");
const function_js_1 = require("./function.js");
const Functor_js_1 = require("./Functor.js");
const _ = __importStar(require("./internal.js"));
const N = __importStar(require("./number.js"));
const Ord_js_1 = require("./Ord.js");
const RNEA = __importStar(require("./ReadonlyNonEmptyArray.js"));
const Separated_js_1 = require("./Separated.js");
const Witherable_js_1 = require("./Witherable.js");
const Zero_js_1 = require("./Zero.js");
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Test whether a `ReadonlyArray` is empty.
 *
 * @example
 * import { isEmpty } from 'fp-ts/ReadonlyArray'
 *
 * assert.strictEqual(isEmpty([]), true)
 *
 * @category refinements
 * @since 2.5.0
 */
const isEmpty = (as) => as.length === 0;
exports.isEmpty = isEmpty;
/**
 * Test whether a `ReadonlyArray` is non empty.
 *
 * @category refinements
 * @since 2.5.0
 */
exports.isNonEmpty = RNEA.isNonEmpty;
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
 *
 * @example
 * import { prepend } from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])
 *
 * @since 2.10.0
 */
exports.prepend = RNEA.prepend;
/**
 * Less strict version of [`prepend`](#prepend).
 *
 * @since 2.11.0
 */
exports.prependW = RNEA.prependW;
/**
 * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
 *
 * @example
 * import { append } from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])
 *
 * @since 2.10.0
 */
exports.append = RNEA.append;
/**
 * Less strict version of [`append`](#append).
 *
 * @since 2.11.0
 */
exports.appendW = RNEA.appendW;
/**
 * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { makeBy } from 'fp-ts/ReadonlyArray'
 *
 * const double = (n: number): number => n * 2
 * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])
 *
 * @category constructors
 * @since 2.5.0
 */
const makeBy = (n, f) => (n <= 0 ? exports.empty : RNEA.makeBy(f)(n));
exports.makeBy = makeBy;
/**
 * Create a `ReadonlyArray` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { replicate } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])
 *
 * @category constructors
 * @since 2.5.0
 */
const replicate = (n, a) => (0, exports.makeBy)(n, () => a);
exports.replicate = replicate;
function fromPredicate(predicate) {
    return (a) => (predicate(a) ? [a] : exports.empty);
}
// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * @category conversions
 * @since 2.11.0
 */
const fromOption = (ma) => (_.isNone(ma) ? exports.empty : [ma.value]);
exports.fromOption = fromOption;
/**
 * Transforms an `Either` to a `ReadonlyArray`.
 *
 * @category conversions
 * @since 2.11.0
 */
const fromEither = (e) => (_.isLeft(e) ? exports.empty : [e.right]);
exports.fromEither = fromEither;
/**
 * Less strict version of [`match`](#match).
 *
 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
 *
 * @category pattern matching
 * @since 2.11.0
 */
const matchW = (onEmpty, onNonEmpty) => (as) => (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
exports.matchW = matchW;
/**
 * @category pattern matching
 * @since 2.11.0
 */
exports.match = exports.matchW;
/**
 * Less strict version of [`matchLeft`](#matchleft).
 *
 * @category pattern matching
 * @since 2.11.0
 */
const matchLeftW = (onEmpty, onNonEmpty) => (as) => (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();
exports.matchLeftW = matchLeftW;
/**
 * Break a `ReadonlyArray` into its first element and remaining elements.
 *
 * @example
 * import { matchLeft } from 'fp-ts/ReadonlyArray'
 *
 * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))
 * assert.strictEqual(len([1, 2, 3]), 3)
 *
 * @category pattern matching
 * @since 2.10.0
 */
exports.matchLeft = exports.matchLeftW;
/**
 * Alias of [`matchLeft`](#matchleft).
 *
 * @category pattern matching
 * @since 2.5.0
 */
exports.foldLeft = exports.matchLeft;
/**
 * Less strict version of [`matchRight`](#matchright).
 *
 * @category pattern matching
 * @since 2.11.0
 */
const matchRightW = (onEmpty, onNonEmpty) => (as) => (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();
exports.matchRightW = matchRightW;
/**
 * Break a `ReadonlyArray` into its initial elements and the last element.
 *
 * @category pattern matching
 * @since 2.10.0
 */
exports.matchRight = exports.matchRightW;
/**
 * Alias of [`matchRight`](#matchright).
 *
 * @category pattern matching
 * @since 2.5.0
 */
exports.foldRight = exports.matchRight;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category sequencing
 * @since 2.7.0
 */
const chainWithIndex = (f) => (as) => {
    if ((0, exports.isEmpty)(as)) {
        return exports.empty;
    }
    const out = [];
    for (let i = 0; i < as.length; i++) {
        const bs = f(i, as[i]);
        for (let j = 0; j < bs.length; j++) {
            out.push(bs[j]);
        }
    }
    return out;
};
exports.chainWithIndex = chainWithIndex;
/**
 * Same as `reduce` but it carries over the intermediate steps.
 *
 * @example
 * import { scanLeft } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])
 *
 * @since 2.5.0
 */
const scanLeft = (b, f) => (as) => {
    const len = as.length;
    const out = new Array(len + 1);
    out[0] = b;
    for (let i = 0; i < len; i++) {
        out[i + 1] = f(out[i], as[i]);
    }
    return out;
};
exports.scanLeft = scanLeft;
/**
 * Fold an array from the right, keeping all intermediate results instead of only the final result
 *
 * @example
 * import { scanRight } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])
 *
 * @since 2.5.0
 */
const scanRight = (b, f) => (as) => {
    const len = as.length;
    const out = new Array(len + 1);
    out[len] = b;
    for (let i = len - 1; i >= 0; i--) {
        out[i] = f(as[i], out[i + 1]);
    }
    return out;
};
exports.scanRight = scanRight;
/**
 * Calculate the number of elements in a `ReadonlyArray`.
 *
 * @since 2.10.0
 */
const size = (as) => as.length;
exports.size = size;
/**
 * Test whether an array contains a particular index
 *
 * @since 2.5.0
 */
exports.isOutOfBound = RNEA.isOutOfBound;
function lookup(i, as) {
    return as === undefined ? (as) => lookup(i, as) : (0, exports.isOutOfBound)(i, as) ? _.none : _.some(as[i]);
}
/**
 * Get the first element in an array, or `None` if the array is empty
 *
 * @example
 * import { head } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(head([1, 2, 3]), some(1))
 * assert.deepStrictEqual(head([]), none)
 *
 * @since 2.5.0
 */
const head = (as) => ((0, exports.isNonEmpty)(as) ? _.some(RNEA.head(as)) : _.none);
exports.head = head;
/**
 * Get the last element in an array, or `None` if the array is empty
 *
 * @example
 * import { last } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(last([1, 2, 3]), some(3))
 * assert.deepStrictEqual(last([]), none)
 *
 * @since 2.5.0
 */
const last = (as) => ((0, exports.isNonEmpty)(as) ? _.some(RNEA.last(as)) : _.none);
exports.last = last;
/**
 * Get all but the first element of an array, creating a new array, or `None` if the array is empty
 *
 * @example
 * import { tail } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))
 * assert.deepStrictEqual(tail([]), none)
 *
 * @since 2.5.0
 */
const tail = (as) => (0, exports.isNonEmpty)(as) ? _.some(RNEA.tail(as)) : _.none;
exports.tail = tail;
/**
 * Get all but the last element of an array, creating a new array, or `None` if the array is empty
 *
 * @example
 * import { init } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))
 * assert.deepStrictEqual(init([]), none)
 *
 * @since 2.5.0
 */
const init = (as) => (0, exports.isNonEmpty)(as) ? _.some(RNEA.init(as)) : _.none;
exports.init = init;
/**
 * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])
 *
 * // out of bounds
 * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)
 * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)
 *
 * @since 2.5.0
 */
const takeLeft = (n) => (as) => (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(0, n);
exports.takeLeft = takeLeft;
/**
 * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])
 *
 * // out of bounds
 * assert.strictEqual(pipe(input, RA.takeRight(4)), input)
 * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)
 *
 * @since 2.5.0
 */
const takeRight = (n) => (as) => (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(-n);
exports.takeRight = takeRight;
function takeLeftWhile(predicate) {
    return (as) => {
        const out = [];
        for (const a of as) {
            if (!predicate(a)) {
                break;
            }
            out.push(a);
        }
        const len = out.length;
        return len === as.length ? as : len === 0 ? exports.empty : out;
    };
}
const spanLeftIndex = (as, predicate) => {
    const l = as.length;
    let i = 0;
    for (; i < l; i++) {
        if (!predicate(as[i])) {
            break;
        }
    }
    return i;
};
function spanLeft(predicate) {
    return (as) => {
        const [init, rest] = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as);
        return { init, rest };
    };
}
/**
 * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])
 * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)
 * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)
 *
 * @since 2.5.0
 */
const dropLeft = (n) => (as) => n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(n, as.length);
exports.dropLeft = dropLeft;
/**
 * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])
 * assert.strictEqual(pipe(input, RA.dropRight(0)), input)
 * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)
 *
 * @since 2.5.0
 */
const dropRight = (n) => (as) => n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(0, as.length - n);
exports.dropRight = dropRight;
function dropLeftWhile(predicate) {
    return (as) => {
        const i = spanLeftIndex(as, predicate);
        return i === 0 ? as : i === as.length ? exports.empty : as.slice(i);
    };
}
/**
 * Find the first index for which a predicate holds
 *
 * @example
 * import { findIndex } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
 *
 * @since 2.5.0
 */
const findIndex = (predicate) => (as) => {
    for (let i = 0; i < as.length; i++) {
        if (predicate(as[i])) {
            return _.some(i);
        }
    }
    return _.none;
};
exports.findIndex = findIndex;
function findFirst(predicate) {
    return (as) => {
        for (let i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
                return _.some(as[i]);
            }
        }
        return _.none;
    };
}
/**
 * Find the first element returned by an option based selector function
 *
 * @example
 * import { findFirstMap } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age?: number
 * }
 *
 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
 *
 * // returns the name of the first person that has an age
 * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))
 *
 * @since 2.5.0
 */
const findFirstMap = (f) => (as) => {
    for (let i = 0; i < as.length; i++) {
        const out = f(as[i]);
        if (_.isSome(out)) {
            return out;
        }
    }
    return _.none;
};
exports.findFirstMap = findFirstMap;
function findLast(predicate) {
    return (as) => {
        for (let i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
                return _.some(as[i]);
            }
        }
        return _.none;
    };
}
/**
 * Find the last element returned by an option based selector function
 *
 * @example
 * import { findLastMap } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age?: number
 * }
 *
 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
 *
 * // returns the name of the last person that has an age
 * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))
 *
 * @since 2.5.0
 */
const findLastMap = (f) => (as) => {
    for (let i = as.length - 1; i >= 0; i--) {
        const out = f(as[i]);
        if (_.isSome(out)) {
            return out;
        }
    }
    return _.none;
};
exports.findLastMap = findLastMap;
/**
 * Returns the index of the last element of the list which matches the predicate
 *
 * @example
 * import { findLastIndex } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface X {
 *   readonly a: number
 *   readonly b: number
 * }
 * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]
 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))
 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)
 *
 *
 * @since 2.5.0
 */
const findLastIndex = (predicate) => (as) => {
    for (let i = as.length - 1; i >= 0; i--) {
        if (predicate(as[i])) {
            return _.some(i);
        }
    }
    return _.none;
};
exports.findLastIndex = findLastIndex;
/**
 * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 *
 * @example
 * import { insertAt } from 'fp-ts/ReadonlyArray'
 * import { some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))
 *
 * @since 2.5.0
 */
const insertAt = (i, a) => (as) => i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));
exports.insertAt = insertAt;
/**
 * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 *
 * @example
 * import { updateAt } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))
 * assert.deepStrictEqual(updateAt(1, 1)([]), none)
 *
 * @since 2.5.0
 */
const updateAt = (i, a) => (0, exports.modifyAt)(i, () => a);
exports.updateAt = updateAt;
/**
 * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 *
 * @example
 * import { deleteAt } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))
 * assert.deepStrictEqual(deleteAt(1)([]), none)
 *
 * @since 2.5.0
 */
const deleteAt = (i) => (as) => (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
exports.deleteAt = deleteAt;
/**
 * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
 * of bounds
 *
 * @example
 * import { modifyAt } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * const double = (x: number): number => x * 2
 * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))
 * assert.deepStrictEqual(modifyAt(1, double)([]), none)
 *
 * @since 2.5.0
 */
const modifyAt = (i, f) => (as) => (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
exports.modifyAt = modifyAt;
/**
 * Reverse an array, creating a new array
 *
 * @example
 * import { reverse } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])
 *
 * @since 2.5.0
 */
const reverse = (as) => (as.length <= 1 ? as : as.slice().reverse());
exports.reverse = reverse;
/**
 * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order
 *
 * @example
 * import { rights } from 'fp-ts/ReadonlyArray'
 * import { right, left } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])
 *
 * @since 2.5.0
 */
const rights = (as) => {
    const r = [];
    for (let i = 0; i < as.length; i++) {
        const a = as[i];
        if (a._tag === 'Right') {
            r.push(a.right);
        }
    }
    return r;
};
exports.rights = rights;
/**
 * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order
 *
 * @example
 * import { lefts } from 'fp-ts/ReadonlyArray'
 * import { left, right } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])
 *
 * @since 2.5.0
 */
const lefts = (as) => {
    const r = [];
    for (let i = 0; i < as.length; i++) {
        const a = as[i];
        if (a._tag === 'Left') {
            r.push(a.left);
        }
    }
    return r;
};
exports.lefts = lefts;
/**
 * Sort the elements of an array in increasing order, creating a new array
 *
 * @example
 * import { sort } from 'fp-ts/ReadonlyArray'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])
 *
 * @since 2.5.0
 */
const sort = (O) => (as) => as.length <= 1 ? as : as.slice().sort(O.compare);
exports.sort = sort;
// TODO: curry and make data-last in v3
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
 * input array is short, excess elements of the longer array are discarded.
 *
 * @example
 * import { zipWith } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])
 *
 * @since 2.5.0
 */
const zipWith = (fa, fb, f) => {
    const fc = [];
    const len = Math.min(fa.length, fb.length);
    for (let i = 0; i < len; i++) {
        fc[i] = f(fa[i], fb[i]);
    }
    return fc;
};
exports.zipWith = zipWith;
function zip(as, bs) {
    if (bs === undefined) {
        return (bs) => zip(bs, as);
    }
    return (0, exports.zipWith)(as, bs, (a, b) => [a, b]);
}
/**
 * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays
 *
 * @example
 * import { unzip } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])
 *
 * @since 2.5.0
 */
const unzip = (as) => {
    const fa = [];
    const fb = [];
    for (let i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
    }
    return [fa, fb];
};
exports.unzip = unzip;
/**
 * Prepend an element to every member of an array
 *
 * @example
 * import { prependAll } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.10.0
 */
const prependAll = (middle) => {
    const f = RNEA.prependAll(middle);
    return (as) => ((0, exports.isNonEmpty)(as) ? f(as) : as);
};
exports.prependAll = prependAll;
/**
 * Places an element in between members of an array
 *
 * @example
 * import { intersperse } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.9.0
 */
const intersperse = (middle) => {
    const f = RNEA.intersperse(middle);
    return (as) => ((0, exports.isNonEmpty)(as) ? f(as) : as);
};
exports.intersperse = intersperse;
/**
 * Rotate a `ReadonlyArray` by `n` steps.
 *
 * @example
 * import { rotate } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
 *
 * @since 2.5.0
 */
const rotate = (n) => {
    const f = RNEA.rotate(n);
    return (as) => ((0, exports.isNonEmpty)(as) ? f(as) : as);
};
exports.rotate = rotate;
function elem(E) {
    return (a, as) => {
        if (as === undefined) {
            const elemE = elem(E);
            return (as) => elemE(a, as);
        }
        const predicate = (element) => E.equals(element, a);
        let i = 0;
        for (; i < as.length; i++) {
            if (predicate(as[i])) {
                return true;
            }
        }
        return false;
    };
}
/**
 * Remove duplicates from an array, keeping the first occurrence of an element.
 *
 * @example
 * import { uniq } from 'fp-ts/ReadonlyArray'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
 *
 * @since 2.5.0
 */
const uniq = (E) => {
    const f = RNEA.uniq(E);
    return (as) => ((0, exports.isNonEmpty)(as) ? f(as) : as);
};
exports.uniq = uniq;
/**
 * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
 * etc...
 *
 * @example
 * import { sortBy } from 'fp-ts/ReadonlyArray'
 * import { contramap } from 'fp-ts/Ord'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age: number
 * }
 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
 *
 * const sortByNameByAge = sortBy([byName, byAge])
 *
 * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]
 * assert.deepStrictEqual(sortByNameByAge(persons), [
 *   { name: 'a', age: 1 },
 *   { name: 'b', age: 2 },
 *   { name: 'b', age: 3 },
 *   { name: 'c', age: 2 }
 * ])
 *
 * @since 2.5.0
 */
const sortBy = (ords) => {
    const f = RNEA.sortBy(ords);
    return (as) => ((0, exports.isNonEmpty)(as) ? f(as) : as);
};
exports.sortBy = sortBy;
/**
 * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for "chopping" up the input
 * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a
 * value and the tail of the `ReadonlyArray`.
 *
 * @example
 * import { Eq } from 'fp-ts/Eq'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {
 *   return RA.chop(as => {
 *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))
 *     return [init, rest]
 *   })
 * }
 * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])
 *
 * @since 2.5.0
 */
const chop = (f) => {
    const g = RNEA.chop(f);
    return (as) => ((0, exports.isNonEmpty)(as) ? g(as) : exports.empty);
};
exports.chop = chop;
/**
 * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.
 *
 * @example
 * import { splitAt } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])
 *
 * @since 2.5.0
 */
const splitAt = (n) => (as) => n >= 1 && (0, exports.isNonEmpty)(as) ? RNEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [as, exports.empty] : [exports.empty, as];
exports.splitAt = splitAt;
/**
 * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
 * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
 * definition of `chunksOf`; it satisfies the property that:
 *
 * ```ts
 * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
 * ```
 *
 * whenever `n` evenly divides the length of `as`.
 *
 * @example
 * import { chunksOf } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])
 *
 * @since 2.5.0
 */
const chunksOf = (n) => {
    const f = RNEA.chunksOf(n);
    return (as) => ((0, exports.isNonEmpty)(as) ? f(as) : exports.empty);
};
exports.chunksOf = chunksOf;
/**
 * @category lifting
 * @since 2.11.0
 */
const fromOptionK = (f) => (...a) => (0, exports.fromOption)(f(...a));
exports.fromOptionK = fromOptionK;
function comprehension(input, f, g = () => true) {
    const go = (scope, input) => (0, exports.isNonEmpty)(input)
        ? (0, exports.flatMap)(RNEA.head(input), (a) => go((0, function_js_1.pipe)(scope, (0, exports.append)(a)), RNEA.tail(input)))
        : g(...scope)
            ? [f(...scope)]
            : exports.empty;
    return go(exports.empty, input);
}
/**
 * @since 2.11.0
 */
const concatW = (second) => (first) => (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
exports.concatW = concatW;
/**
 * @since 2.11.0
 */
exports.concat = exports.concatW;
function union(E) {
    const unionE = RNEA.union(E);
    return (first, second) => {
        if (second === undefined) {
            const unionE = union(E);
            return (second) => unionE(second, first);
        }
        return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? first : second;
    };
}
function intersection(E) {
    const elemE = elem(E);
    return (xs, ys) => {
        if (ys === undefined) {
            const intersectionE = intersection(E);
            return (ys) => intersectionE(ys, xs);
        }
        return xs.filter((a) => elemE(a, ys));
    };
}
function difference(E) {
    const elemE = elem(E);
    return (xs, ys) => {
        if (ys === undefined) {
            const differenceE = difference(E);
            return (ys) => differenceE(ys, xs);
        }
        return xs.filter((a) => !elemE(a, ys));
    };
}
const _map = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.map)(f));
const _mapWithIndex = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.mapWithIndex)(f));
const _ap = (fab, fa) => (0, function_js_1.pipe)(fab, (0, exports.ap)(fa));
const _filter = (fa, predicate) => (0, function_js_1.pipe)(fa, (0, exports.filter)(predicate));
const _filterMap = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.filterMap)(f));
const _partition = (fa, predicate) => (0, function_js_1.pipe)(fa, (0, exports.partition)(predicate));
const _partitionMap = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.partitionMap)(f));
const _partitionWithIndex = (fa, predicateWithIndex) => (0, function_js_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex));
const _partitionMapWithIndex = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f));
const _alt = (fa, that) => (0, function_js_1.pipe)(fa, (0, exports.alt)(that));
const _reduce = (fa, b, f) => (0, function_js_1.pipe)(fa, (0, exports.reduce)(b, f));
const _foldMap = (M) => {
    const foldMapM = (0, exports.foldMap)(M);
    return (fa, f) => (0, function_js_1.pipe)(fa, foldMapM(f));
};
const _reduceRight = (fa, b, f) => (0, function_js_1.pipe)(fa, (0, exports.reduceRight)(b, f));
const _reduceWithIndex = (fa, b, f) => (0, function_js_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
const _foldMapWithIndex = (M) => {
    const foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
    return (fa, f) => (0, function_js_1.pipe)(fa, foldMapWithIndexM(f));
};
const _reduceRightWithIndex = (fa, b, f) => (0, function_js_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
const _filterMapWithIndex = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.filterMapWithIndex)(f));
const _filterWithIndex = (fa, predicateWithIndex) => (0, function_js_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex));
const _extend = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.extend)(f));
const _traverse = (F) => {
    const traverseF = (0, exports.traverse)(F);
    return (ta, f) => (0, function_js_1.pipe)(ta, traverseF(f));
};
/* istanbul ignore next */
const _traverseWithIndex = (F) => {
    const traverseWithIndexF = (0, exports.traverseWithIndex)(F);
    return (ta, f) => (0, function_js_1.pipe)(ta, traverseWithIndexF(f));
};
/** @internal */
const _chainRecDepthFirst = (a, f) => (0, function_js_1.pipe)(a, (0, exports.chainRecDepthFirst)(f));
exports._chainRecDepthFirst = _chainRecDepthFirst;
/** @internal */
const _chainRecBreadthFirst = (a, f) => (0, function_js_1.pipe)(a, (0, exports.chainRecBreadthFirst)(f));
exports._chainRecBreadthFirst = _chainRecBreadthFirst;
/**
 * @category constructors
 * @since 2.5.0
 */
exports.of = RNEA.of;
/**
 * @since 2.7.0
 */
const zero = () => exports.empty;
exports.zero = zero;
/**
 * Less strict version of [`alt`](#alt).
 *
 * The `W` suffix (short for **W**idening) means that the return types will be merged.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.altW(() => ['a', 'b'])
 *   ),
 *   [1, 2, 3, 'a', 'b']
 * )
 *
 * @category error handling
 * @since 2.9.0
 */
const altW = (that) => (fa) => fa.concat(that());
exports.altW = altW;
/**
 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
 * types of kind `* -> *`.
 *
 * In case of `ReadonlyArray` concatenates the inputs into a single array.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.alt(() => [4, 5])
 *   ),
 *   [1, 2, 3, 4, 5]
 * )
 *
 * @category error handling
 * @since 2.5.0
 */
exports.alt = exports.altW;
/**
 * @since 2.5.0
 */
const ap = (fa) => (0, exports.flatMap)((f) => (0, function_js_1.pipe)(fa, (0, exports.map)(f)));
exports.ap = ap;
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.flatMap((n) => [`a${n}`, `b${n}`])
 *   ),
 *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.flatMap(() => [])
 *   ),
 *   []
 * )
 *
 * @category sequencing
 * @since 2.14.0
 */
exports.flatMap = (0, function_js_1.dual)(2, (ma, f) => (0, function_js_1.pipe)(ma, (0, exports.chainWithIndex)((i, a) => f(a, i))));
/**
 * @category sequencing
 * @since 2.5.0
 */
exports.flatten = (0, exports.flatMap)(function_js_1.identity);
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.5.0
 */
const map = (f) => (fa) => fa.map((a) => f(a));
exports.map = map;
/**
 * @category mapping
 * @since 2.5.0
 */
const mapWithIndex = (f) => (fa) => fa.map((a, i) => f(i, a));
exports.mapWithIndex = mapWithIndex;
/**
 * @category filtering
 * @since 2.5.0
 */
const separate = (fa) => {
    const left = [];
    const right = [];
    for (const e of fa) {
        if (e._tag === 'Left') {
            left.push(e.left);
        }
        else {
            right.push(e.right);
        }
    }
    return (0, Separated_js_1.separated)(left, right);
};
exports.separate = separate;
/**
 * @category filtering
 * @since 2.5.0
 */
const filter = (predicate) => (as) => as.filter(predicate);
exports.filter = filter;
/**
 * @category filtering
 * @since 2.5.0
 */
const filterMapWithIndex = (f) => (fa) => {
    const out = [];
    for (let i = 0; i < fa.length; i++) {
        const optionB = f(i, fa[i]);
        if (_.isSome(optionB)) {
            out.push(optionB.value);
        }
    }
    return out;
};
exports.filterMapWithIndex = filterMapWithIndex;
/**
 * @category filtering
 * @since 2.5.0
 */
const filterMap = (f) => (0, exports.filterMapWithIndex)((_, a) => f(a));
exports.filterMap = filterMap;
/**
 * @category filtering
 * @since 2.5.0
 */
exports.compact = (0, exports.filterMap)(function_js_1.identity);
/**
 * @category filtering
 * @since 2.5.0
 */
const partition = (predicate) => (0, exports.partitionWithIndex)((_, a) => predicate(a));
exports.partition = partition;
/**
 * @category filtering
 * @since 2.5.0
 */
const partitionWithIndex = (predicateWithIndex) => (as) => {
    const left = [];
    const right = [];
    for (let i = 0; i < as.length; i++) {
        const a = as[i];
        if (predicateWithIndex(i, a)) {
            right.push(a);
        }
        else {
            left.push(a);
        }
    }
    return (0, Separated_js_1.separated)(left, right);
};
exports.partitionWithIndex = partitionWithIndex;
/**
 * @category filtering
 * @since 2.5.0
 */
const partitionMap = (f) => (0, exports.partitionMapWithIndex)((_, a) => f(a));
exports.partitionMap = partitionMap;
/**
 * @category filtering
 * @since 2.5.0
 */
const partitionMapWithIndex = (f) => (fa) => {
    const left = [];
    const right = [];
    for (let i = 0; i < fa.length; i++) {
        const e = f(i, fa[i]);
        if (e._tag === 'Left') {
            left.push(e.left);
        }
        else {
            right.push(e.right);
        }
    }
    return (0, Separated_js_1.separated)(left, right);
};
exports.partitionMapWithIndex = partitionMapWithIndex;
/**
 * @category filtering
 * @since 2.5.0
 */
const filterWithIndex = (predicateWithIndex) => (as) => as.filter((a, i) => predicateWithIndex(i, a));
exports.filterWithIndex = filterWithIndex;
/**
 * @since 2.5.0
 */
const extend = (f) => (wa) => wa.map((_, i) => f(wa.slice(i)));
exports.extend = extend;
/**
 * @since 2.5.0
 */
exports.duplicate = (0, exports.extend)(function_js_1.identity);
/**
 * @category folding
 * @since 2.5.0
 */
const foldMapWithIndex = (M) => (f) => (fa) => fa.reduce((b, a, i) => M.concat(b, f(i, a)), M.empty);
exports.foldMapWithIndex = foldMapWithIndex;
/**
 * @category folding
 * @since 2.5.0
 */
const reduce = (b, f) => (0, exports.reduceWithIndex)(b, (_, b, a) => f(b, a));
exports.reduce = reduce;
/**
 * @category folding
 * @since 2.5.0
 */
const foldMap = (M) => {
    const foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
    return (f) => foldMapWithIndexM((_, a) => f(a));
};
exports.foldMap = foldMap;
/**
 * @category folding
 * @since 2.5.0
 */
const reduceWithIndex = (b, f) => (fa) => {
    const len = fa.length;
    let out = b;
    for (let i = 0; i < len; i++) {
        out = f(i, out, fa[i]);
    }
    return out;
};
exports.reduceWithIndex = reduceWithIndex;
/**
 * @category folding
 * @since 2.5.0
 */
const reduceRight = (b, f) => (0, exports.reduceRightWithIndex)(b, (_, a, b) => f(a, b));
exports.reduceRight = reduceRight;
/**
 * @category folding
 * @since 2.5.0
 */
const reduceRightWithIndex = (b, f) => (fa) => fa.reduceRight((b, a, i) => f(i, a, b), b);
exports.reduceRightWithIndex = reduceRightWithIndex;
/**
 * @category traversing
 * @since 2.6.3
 */
const traverse = (F) => {
    const traverseWithIndexF = (0, exports.traverseWithIndex)(F);
    return (f) => traverseWithIndexF((_, a) => f(a));
};
exports.traverse = traverse;
/**
 * @category traversing
 * @since 2.6.3
 */
const sequence = (F) => (ta) => {
    return _reduce(ta, F.of((0, exports.zero)()), (fas, fa) => F.ap(F.map(fas, (as) => (a) => (0, function_js_1.pipe)(as, (0, exports.append)(a))), fa));
};
exports.sequence = sequence;
/**
 * @category sequencing
 * @since 2.6.3
 */
const traverseWithIndex = (F) => (f) => (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), (i, fbs, a) => F.ap(F.map(fbs, (bs) => (b) => (0, function_js_1.pipe)(bs, (0, exports.append)(b))), f(i, a)));
exports.traverseWithIndex = traverseWithIndex;
/**
 * @category filtering
 * @since 2.6.5
 */
const wither = (F) => {
    const _witherF = _wither(F);
    return (f) => (fa) => _witherF(fa, f);
};
exports.wither = wither;
/**
 * @category filtering
 * @since 2.6.5
 */
const wilt = (F) => {
    const _wiltF = _wilt(F);
    return (f) => (fa) => _wiltF(fa, f);
};
exports.wilt = wilt;
/**
 * @since 2.6.6
 */
const unfold = (b, f) => {
    const out = [];
    let bb = b;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const mt = f(bb);
        if (_.isSome(mt)) {
            const [a, b] = mt.value;
            out.push(a);
            bb = b;
        }
        else {
            break;
        }
    }
    return out;
};
exports.unfold = unfold;
/**
 * @category type lambdas
 * @since 2.5.0
 */
exports.URI = 'ReadonlyArray';
/**
 * @category instances
 * @since 2.5.0
 */
const getShow = (S) => ({
    show: (as) => `[${as.map(S.show).join(', ')}]`
});
exports.getShow = getShow;
/**
 * @category instances
 * @since 2.5.0
 */
const getSemigroup = () => ({
    concat: (first, second) => ((0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second))
});
exports.getSemigroup = getSemigroup;
/**
 * Returns a `Monoid` for `ReadonlyArray<A>`.
 *
 * @example
 * import { getMonoid } from 'fp-ts/ReadonlyArray'
 *
 * const M = getMonoid<number>()
 * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])
 *
 * @category instances
 * @since 2.5.0
 */
const getMonoid = () => ({
    concat: (0, exports.getSemigroup)().concat,
    empty: exports.empty
});
exports.getMonoid = getMonoid;
/**
 * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two
 * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of
 * different lengths, the result is non equality.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { getEq } from 'fp-ts/ReadonlyArray'
 *
 * const E = getEq(S.Eq)
 * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)
 * assert.strictEqual(E.equals(['a'], []), false)
 *
 * @category instances
 * @since 2.5.0
 */
const getEq = (E) => (0, Eq_js_1.fromEquals)((xs, ys) => xs.length === ys.length && xs.every((x, i) => E.equals(x, ys[i])));
exports.getEq = getEq;
/**
 * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such
 * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in
 * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
 * the same length, the result is equality.
 *
 * @example
 * import { getOrd } from 'fp-ts/ReadonlyArray'
 * import * as S from 'fp-ts/string'
 *
 * const O = getOrd(S.Ord)
 * assert.strictEqual(O.compare(['b'], ['a']), 1)
 * assert.strictEqual(O.compare(['a'], ['a']), 0)
 * assert.strictEqual(O.compare(['a'], ['b']), -1)
 *
 *
 * @category instances
 * @since 2.5.0
 */
const getOrd = (O) => (0, Ord_js_1.fromCompare)((a, b) => {
    const aLen = a.length;
    const bLen = b.length;
    const len = Math.min(aLen, bLen);
    for (let i = 0; i < len; i++) {
        const ordering = O.compare(a[i], b[i]);
        if (ordering !== 0) {
            return ordering;
        }
    }
    return N.Ord.compare(aLen, bLen);
});
exports.getOrd = getOrd;
/**
 * @category instances
 * @since 2.11.0
 */
const getUnionSemigroup = (E) => {
    const unionE = union(E);
    return {
        concat: (first, second) => unionE(second)(first)
    };
};
exports.getUnionSemigroup = getUnionSemigroup;
/**
 * @category instances
 * @since 2.11.0
 */
const getUnionMonoid = (E) => ({
    concat: (0, exports.getUnionSemigroup)(E).concat,
    empty: exports.empty
});
exports.getUnionMonoid = getUnionMonoid;
/**
 * @category instances
 * @since 2.11.0
 */
const getIntersectionSemigroup = (E) => {
    const intersectionE = intersection(E);
    return {
        concat: (first, second) => intersectionE(second)(first)
    };
};
exports.getIntersectionSemigroup = getIntersectionSemigroup;
/**
 * @category instances
 * @since 2.11.0
 */
const getDifferenceMagma = (E) => {
    const differenceE = difference(E);
    return {
        concat: (first, second) => differenceE(second)(first)
    };
};
exports.getDifferenceMagma = getDifferenceMagma;
/**
 * @category instances
 * @since 2.7.0
 */
exports.Functor = {
    URI: exports.URI,
    map: _map
};
/**
 * @category mapping
 * @since 2.10.0
 */
exports.flap = (0, Functor_js_1.flap)(exports.Functor);
/**
 * @category instances
 * @since 2.10.0
 */
exports.Pointed = {
    URI: exports.URI,
    of: exports.of
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.FunctorWithIndex = {
    URI: exports.URI,
    map: _map,
    mapWithIndex: _mapWithIndex
};
/**
 * @category instances
 * @since 2.10.0
 */
exports.Apply = {
    URI: exports.URI,
    map: _map,
    ap: _ap
};
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * @since 2.5.0
 */
exports.apFirst = (0, Apply_js_1.apFirst)(exports.Apply);
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * @since 2.5.0
 */
exports.apSecond = (0, Apply_js_1.apSecond)(exports.Apply);
/**
 * @category instances
 * @since 2.7.0
 */
exports.Applicative = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    of: exports.of
};
/**
 * @category instances
 * @since 2.10.0
 */
exports.Chain = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    chain: exports.flatMap
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Monad = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    of: exports.of,
    chain: exports.flatMap
};
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.chainFirst(() => ['a', 'b'])
 *   ),
 *   [1, 1, 2, 2, 3, 3]
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.chainFirst(() => [])
 *   ),
 *   []
 * )
 *
 * @category sequencing
 * @since 2.5.0
 */
exports.chainFirst = 
/*#__PURE__*/ (0, Chain_js_1.chainFirst)(exports.Chain);
/**
 * @category instances
 * @since 2.7.0
 */
exports.Unfoldable = {
    URI: exports.URI,
    unfold: exports.unfold
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Alt = {
    URI: exports.URI,
    map: _map,
    alt: _alt
};
/**
 * @category instances
 * @since 2.11.0
 */
exports.Zero = {
    URI: exports.URI,
    zero: exports.zero
};
/**
 * @category do notation
 * @since 2.11.0
 */
exports.guard = (0, Zero_js_1.guard)(exports.Zero, exports.Pointed);
/**
 * @category instances
 * @since 2.7.0
 */
exports.Alternative = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    of: exports.of,
    alt: _alt,
    zero: exports.zero
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Extend = {
    URI: exports.URI,
    map: _map,
    extend: _extend
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Compactable = {
    URI: exports.URI,
    compact: exports.compact,
    separate: exports.separate
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Filterable = {
    URI: exports.URI,
    map: _map,
    compact: exports.compact,
    separate: exports.separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.FilterableWithIndex = {
    URI: exports.URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    compact: exports.compact,
    separate: exports.separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Foldable = {
    URI: exports.URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.FoldableWithIndex = {
    URI: exports.URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Traversable = {
    URI: exports.URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: exports.sequence
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.TraversableWithIndex = {
    URI: exports.URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverse: _traverse,
    sequence: exports.sequence,
    traverseWithIndex: _traverseWithIndex
};
/**
 * @category sequencing
 * @since 2.11.0
 */
const chainRecDepthFirst = (f) => (a) => {
    const todo = [...f(a)];
    const out = [];
    while (todo.length > 0) {
        const e = todo.shift();
        if (_.isLeft(e)) {
            todo.unshift(...f(e.left));
        }
        else {
            out.push(e.right);
        }
    }
    return out;
};
exports.chainRecDepthFirst = chainRecDepthFirst;
/**
 * @category instances
 * @since 2.11.0
 */
exports.ChainRecDepthFirst = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    chain: exports.flatMap,
    chainRec: exports._chainRecDepthFirst
};
/**
 * @category sequencing
 * @since 2.11.0
 */
const chainRecBreadthFirst = (f) => (a) => {
    const initial = f(a);
    const todo = [];
    const out = [];
    function go(e) {
        if (_.isLeft(e)) {
            f(e.left).forEach((v) => todo.push(v));
        }
        else {
            out.push(e.right);
        }
    }
    for (const e of initial) {
        go(e);
    }
    while (todo.length > 0) {
        go(todo.shift());
    }
    return out;
};
exports.chainRecBreadthFirst = chainRecBreadthFirst;
/**
 * @category instances
 * @since 2.11.0
 */
exports.ChainRecBreadthFirst = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    chain: exports.flatMap,
    chainRec: exports._chainRecBreadthFirst
};
const _wither = /*#__PURE__*/ (0, Witherable_js_1.witherDefault)(exports.Traversable, exports.Compactable);
const _wilt = /*#__PURE__*/ (0, Witherable_js_1.wiltDefault)(exports.Traversable, exports.Compactable);
/**
 * @category instances
 * @since 2.7.0
 */
exports.Witherable = {
    URI: exports.URI,
    map: _map,
    compact: exports.compact,
    separate: exports.separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: exports.sequence,
    wither: _wither,
    wilt: _wilt
};
/**
 * Filter values inside a context.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as T from 'fp-ts/Task'
 *
 * const filterE = RA.filterE(T.ApplicativePar)
 * async function test() {
 *   assert.deepStrictEqual(
 *     await pipe(
 *       [-1, 2, 3],
 *       filterE((n) => T.of(n > 0))
 *     )(),
 *     [2, 3]
 *   )
 * }
 * test()
 *
 * @since 2.11.0
 */
exports.filterE = (0, Witherable_js_1.filterE)(exports.Witherable);
/**
 * @category instances
 * @since 2.11.0
 */
exports.FromEither = {
    URI: exports.URI,
    fromEither: exports.fromEither
};
/**
 * @category lifting
 * @since 2.11.0
 */
exports.fromEitherK = (0, FromEither_js_1.fromEitherK)(exports.FromEither);
// -------------------------------------------------------------------------------------
// unsafe
// -------------------------------------------------------------------------------------
/**
 * @category unsafe
 * @since 2.5.0
 */
exports.unsafeInsertAt = RNEA.unsafeInsertAt;
/**
 * @category unsafe
 * @since 2.5.0
 */
const unsafeUpdateAt = (i, a, as) => (0, exports.isNonEmpty)(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;
exports.unsafeUpdateAt = unsafeUpdateAt;
/**
 * @category unsafe
 * @since 2.5.0
 */
const unsafeDeleteAt = (i, as) => {
    const xs = as.slice();
    xs.splice(i, 1);
    return xs;
};
exports.unsafeDeleteAt = unsafeDeleteAt;
/**
 * @category conversions
 * @since 2.5.0
 */
const toArray = (as) => as.slice();
exports.toArray = toArray;
/**
 * @category conversions
 * @since 2.5.0
 */
const fromArray = (as) => ((0, exports.isEmpty)(as) ? exports.empty : as.slice());
exports.fromArray = fromArray;
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * An empty array
 *
 * @since 2.5.0
 */
exports.empty = RNEA.empty;
function every(predicate) {
    return (as) => as.every(predicate);
}
/**
 * Check if a predicate holds true for any array member.
 *
 * @example
 * import { some } from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const isPositive = (n: number): boolean => n > 0
 *
 * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)
 * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)
 *
 * @since 2.9.0
 */
const some = (predicate) => (as) => as.some(predicate);
exports.some = some;
/**
 * Alias of [`some`](#some)
 *
 * @since 2.11.0
 */
exports.exists = exports.some;
/**
 * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { intercalate } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
 *
 * @since 2.12.0
 */
const intercalate = (M) => {
    const intercalateM = RNEA.intercalate(M);
    return (middle) => (0, exports.match)(() => M.empty, intercalateM(middle));
};
exports.intercalate = intercalate;
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */
exports.Do = (0, exports.of)(_.emptyRecord);
/**
 * @category do notation
 * @since 2.8.0
 */
exports.bindTo = (0, Functor_js_1.bindTo)(exports.Functor);
const let_ = /*#__PURE__*/ (0, Functor_js_1.let)(exports.Functor);
exports.let = let_;
/**
 * @category do notation
 * @since 2.8.0
 */
exports.bind = (0, Chain_js_1.bind)(exports.Chain);
/**
 * @category do notation
 * @since 2.8.0
 */
exports.apS = (0, Apply_js_1.apS)(exports.Apply);
// -------------------------------------------------------------------------------------
// legacy
// -------------------------------------------------------------------------------------
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.5.0
 */
exports.chain = exports.flatMap;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `ReadonlyNonEmptyArray` module instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
exports.range = RNEA.range;
/**
 * Use [`prepend`](#prepend) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
exports.cons = RNEA.cons;
/**
 * Use [`append`](#append) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
exports.snoc = RNEA.snoc;
/**
 * Use [`prependAll`](#prependall) instead.
 *
 * @category zone of death
 * @since 2.9.0
 * @deprecated
 */
exports.prependToAll = exports.prependAll;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`
 * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
exports.readonlyArray = {
    URI: exports.URI,
    compact: exports.compact,
    separate: exports.separate,
    map: _map,
    ap: _ap,
    of: exports.of,
    chain: exports.flatMap,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    mapWithIndex: _mapWithIndex,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex,
    alt: _alt,
    zero: exports.zero,
    unfold: exports.unfold,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: exports.sequence,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverseWithIndex: _traverseWithIndex,
    extend: _extend,
    wither: _wither,
    wilt: _wilt
};
