"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readonlyMap = exports.insertAt = exports.difference = exports.intersection = exports.union = exports.getTraversableWithIndex = exports.getTraversable = exports.getFoldableWithIndex = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.getFoldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Filterable = exports.Compactable = exports.getFunctorWithIndex = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.URI = exports.separate = exports.partitionMap = exports.partition = exports.mapWithIndex = exports.map = exports.filterMap = exports.filter = exports.compact = exports.filterMapWithIndex = exports.partitionMapWithIndex = exports.singleton = exports.empty = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.upsertAt = exports.toReadonlyArray = exports.values = exports.keys = exports.isEmpty = exports.size = exports.fromMap = void 0;
exports.toMap = toMap;
exports.getShow = getShow;
exports.member = member;
exports.elem = elem;
exports.collect = collect;
exports.toUnfoldable = toUnfoldable;
exports.pop = pop;
exports.lookupWithKey = lookupWithKey;
exports.lookup = lookup;
exports.isSubmap = isSubmap;
exports.getEq = getEq;
exports.getMonoid = getMonoid;
exports.fromFoldable = fromFoldable;
exports.partitionWithIndex = partitionWithIndex;
exports.filterWithIndex = filterWithIndex;
exports.getFilterableWithIndex = getFilterableWithIndex;
exports.getWitherable = getWitherable;
const Eq_js_1 = require("./Eq.js");
const function_js_1 = require("./function.js");
const Functor_js_1 = require("./Functor.js");
const _ = __importStar(require("./internal.js"));
const O = __importStar(require("./Option.js"));
const Separated_js_1 = require("./Separated.js");
const Witherable_js_1 = require("./Witherable.js");
/**
 * @category conversions
 * @since 2.5.0
 */
const fromMap = (m) => new Map(m);
exports.fromMap = fromMap;
/**
 * @category conversions
 * @since 2.5.0
 */
function toMap(m) {
    return new Map(m);
}
/**
 * @category instances
 * @since 2.5.0
 */
function getShow(SK, SA) {
    return {
        show: (m) => {
            const entries = [];
            m.forEach((a, k) => {
                entries.push(`[${SK.show(k)}, ${SA.show(a)}]`);
            });
            return `new Map([${entries.sort().join(', ')}])`;
        }
    };
}
/**
 * Calculate the number of key/value pairs in a map
 *
 * @since 2.5.0
 */
const size = (m) => m.size;
exports.size = size;
/**
 * Test whether or not a map is empty
 *
 * @since 2.5.0
 */
const isEmpty = (m) => m.size === 0;
exports.isEmpty = isEmpty;
function member(E) {
    const lookupE = lookup(E);
    return (k, m) => {
        if (m === undefined) {
            const memberE = member(E);
            return (m) => memberE(k, m);
        }
        return _.isSome(lookupE(k, m));
    };
}
function elem(E) {
    return (a, m) => {
        if (m === undefined) {
            const elemE = elem(E);
            return (m) => elemE(a, m);
        }
        const values = m.values();
        let e;
        while (!(e = values.next()).done) {
            const v = e.value;
            if (E.equals(a, v)) {
                return true;
            }
        }
        return false;
    };
}
/**
 * Get a sorted `ReadonlyArray` of the keys contained in a `ReadonlyMap`.
 *
 * @since 2.5.0
 */
const keys = (O) => (m) => Array.from(m.keys()).sort(O.compare);
exports.keys = keys;
/**
 * Get a sorted `ReadonlyArray` of the values contained in a `ReadonlyMap`.
 *
 * @since 2.5.0
 */
const values = (O) => (m) => Array.from(m.values()).sort(O.compare);
exports.values = values;
/**
 * @since 2.5.0
 */
function collect(O) {
    const keysO = (0, exports.keys)(O);
    return (f) => (m) => {
        const out = [];
        const ks = keysO(m);
        for (const key of ks) {
            out.push(f(key, m.get(key)));
        }
        return out;
    };
}
/**
 * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyMap`.
 *
 * @category conversions
 * @since 2.5.0
 */
const toReadonlyArray = (O) => collect(O)((k, a) => [k, a]);
exports.toReadonlyArray = toReadonlyArray;
function toUnfoldable(ord, U) {
    const toReadonlyArrayO = (0, exports.toReadonlyArray)(ord);
    return (d) => {
        const kas = toReadonlyArrayO(d);
        const len = kas.length;
        return U.unfold(0, (b) => (b < len ? _.some([kas[b], b + 1]) : _.none));
    };
}
/**
 * Insert or replace a key/value pair in a `ReadonlyMap`.
 *
 * @since 2.10.0
 */
const upsertAt = (E) => {
    const lookupWithKeyE = lookupWithKey(E);
    return (k, a) => {
        const lookupWithKeyEk = lookupWithKeyE(k);
        return (m) => {
            const found = lookupWithKeyEk(m);
            if (_.isNone(found)) {
                const out = new Map(m);
                out.set(k, a);
                return out;
            }
            else if (found.value[1] !== a) {
                const out = new Map(m);
                out.set(found.value[0], a);
                return out;
            }
            return m;
        };
    };
};
exports.upsertAt = upsertAt;
/**
 * Delete a key and value from a map
 *
 * @since 2.5.0
 */
const deleteAt = (E) => {
    const lookupWithKeyE = lookupWithKey(E);
    return (k) => (m) => {
        const found = lookupWithKeyE(k, m);
        if (_.isSome(found)) {
            const r = new Map(m);
            r.delete(found.value[0]);
            return r;
        }
        return m;
    };
};
exports.deleteAt = deleteAt;
/**
 * @since 2.5.0
 */
const updateAt = (E) => {
    const modifyAtE = (0, exports.modifyAt)(E);
    return (k, a) => modifyAtE(k, () => a);
};
exports.updateAt = updateAt;
/**
 * @since 2.5.0
 */
const modifyAt = (E) => {
    const lookupWithKeyE = lookupWithKey(E);
    return (k, f) => (m) => {
        const found = lookupWithKeyE(k, m);
        if (_.isNone(found)) {
            return _.none;
        }
        const [fk, fv] = found.value;
        const next = f(fv);
        if (next === fv) {
            return _.some(m);
        }
        const r = new Map(m);
        r.set(fk, next);
        return _.some(r);
    };
};
exports.modifyAt = modifyAt;
/**
 * Delete a key and value from a map, returning the value as well as the subsequent map
 *
 * @since 2.5.0
 */
function pop(E) {
    const lookupE = lookup(E);
    const deleteAtE = (0, exports.deleteAt)(E);
    return (k) => {
        const deleteAtEk = deleteAtE(k);
        return (m) => (0, function_js_1.pipe)(lookupE(k, m), O.map((a) => [a, deleteAtEk(m)]));
    };
}
function lookupWithKey(E) {
    return (k, m) => {
        if (m === undefined) {
            const lookupWithKeyE = lookupWithKey(E);
            return (m) => lookupWithKeyE(k, m);
        }
        const entries = m.entries();
        let e;
        while (!(e = entries.next()).done) {
            const [ka, a] = e.value;
            if (E.equals(ka, k)) {
                return _.some([ka, a]);
            }
        }
        return _.none;
    };
}
function lookup(E) {
    const lookupWithKeyE = lookupWithKey(E);
    return (k, m) => {
        if (m === undefined) {
            const lookupE = lookup(E);
            return (m) => lookupE(k, m);
        }
        return (0, function_js_1.pipe)(lookupWithKeyE(k, m), O.map(([_, a]) => a));
    };
}
function isSubmap(SK, SA) {
    const lookupWithKeyS = lookupWithKey(SK);
    return (me, that) => {
        if (that === undefined) {
            const isSubmapSKSA = isSubmap(SK, SA);
            return (that) => isSubmapSKSA(that, me);
        }
        const entries = me.entries();
        let e;
        while (!(e = entries.next()).done) {
            const [k, a] = e.value;
            const d2OptA = lookupWithKeyS(k, that);
            if (_.isNone(d2OptA) || !SK.equals(k, d2OptA.value[0]) || !SA.equals(a, d2OptA.value[1])) {
                return false;
            }
        }
        return true;
    };
}
/**
 * @since 2.5.0
 */
exports.empty = 
// the type annotation here is intended (otherwise it doesn't type-check)
new Map();
/**
 * @category instances
 * @since 2.5.0
 */
function getEq(SK, SA) {
    const isSubmapSKSA = isSubmap(SK, SA);
    return (0, Eq_js_1.fromEquals)((x, y) => isSubmapSKSA(x, y) && isSubmapSKSA(y, x));
}
/**
 * Gets `Monoid` instance for Maps given `Semigroup` instance for their values
 *
 * @category instances
 * @since 2.5.0
 */
function getMonoid(SK, SA) {
    const lookupWithKeyS = lookupWithKey(SK);
    return {
        concat: (mx, my) => {
            if ((0, exports.isEmpty)(mx)) {
                return my;
            }
            if ((0, exports.isEmpty)(my)) {
                return mx;
            }
            const r = new Map(mx);
            const entries = my.entries();
            let e;
            while (!(e = entries.next()).done) {
                const [k, a] = e.value;
                const mxOptA = lookupWithKeyS(k, mx);
                if (_.isSome(mxOptA)) {
                    r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a));
                }
                else {
                    r.set(k, a);
                }
            }
            return r;
        },
        empty: exports.empty
    };
}
/**
 * Create a map with one key/value pair
 *
 * @category constructors
 * @since 2.5.0
 */
const singleton = (k, a) => new Map([[k, a]]);
exports.singleton = singleton;
function fromFoldable(E, M, F) {
    return (fka) => {
        const lookupWithKeyE = lookupWithKey(E);
        return F.reduce(fka, new Map(), (b, [k, a]) => {
            const bOpt = lookupWithKeyE(k, b);
            if (_.isSome(bOpt)) {
                b.set(bOpt.value[0], M.concat(bOpt.value[1], a));
            }
            else {
                b.set(k, a);
            }
            return b;
        });
    };
}
const _mapWithIndex = (fa, f) => {
    const m = new Map();
    const entries = fa.entries();
    let e;
    while (!(e = entries.next()).done) {
        const [key, a] = e.value;
        m.set(key, f(key, a));
    }
    return m;
};
/**
 * @since 2.10.0
 */
const partitionMapWithIndex = (f) => (fa) => {
    const left = new Map();
    const right = new Map();
    const entries = fa.entries();
    let e;
    while (!(e = entries.next()).done) {
        const [k, a] = e.value;
        const ei = f(k, a);
        if (_.isLeft(ei)) {
            left.set(k, ei.left);
        }
        else {
            right.set(k, ei.right);
        }
    }
    return (0, Separated_js_1.separated)(left, right);
};
exports.partitionMapWithIndex = partitionMapWithIndex;
function partitionWithIndex(predicateWithIndex) {
    return (m) => {
        const left = new Map();
        const right = new Map();
        const entries = m.entries();
        let e;
        while (!(e = entries.next()).done) {
            const [k, a] = e.value;
            if (predicateWithIndex(k, a)) {
                right.set(k, a);
            }
            else {
                left.set(k, a);
            }
        }
        return (0, Separated_js_1.separated)(left, right);
    };
}
/**
 * @since 2.10.0
 */
const filterMapWithIndex = (f) => (fa) => {
    const m = new Map();
    const entries = fa.entries();
    let e;
    while (!(e = entries.next()).done) {
        const [k, a] = e.value;
        const o = f(k, a);
        if (_.isSome(o)) {
            m.set(k, o.value);
        }
    }
    return m;
};
exports.filterMapWithIndex = filterMapWithIndex;
function filterWithIndex(predicateWithIndex) {
    return (m) => {
        const out = new Map();
        const entries = m.entries();
        let e;
        while (!(e = entries.next()).done) {
            const [k, a] = e.value;
            if (predicateWithIndex(k, a)) {
                out.set(k, a);
            }
        }
        return out;
    };
}
const _map = (fa, f) => _mapWithIndex(fa, (_, a) => f(a));
const _filter = (fa, p) => _filterWithIndex(fa, (_, a) => p(a));
const _filterMap = (fa, f) => _filterMapWithIndex(fa, (_, a) => f(a));
const _partition = (fa, predicate) => _partitionWithIndex(fa, (_, a) => predicate(a));
const _partitionMap = (fa, f) => _partitionMapWithIndex(fa, (_, a) => f(a));
const _filterWithIndex = (fa, p) => (0, function_js_1.pipe)(fa, filterWithIndex(p));
const _filterMapWithIndex = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.filterMapWithIndex)(f));
const _partitionWithIndex = (fa, p) => (0, function_js_1.pipe)(fa, partitionWithIndex(p));
const _partitionMapWithIndex = (fa, f) => (0, function_js_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f));
/**
 * @category filtering
 * @since 2.5.0
 */
const compact = (fa) => {
    const m = new Map();
    const entries = fa.entries();
    let e;
    while (!(e = entries.next()).done) {
        const [k, oa] = e.value;
        if (_.isSome(oa)) {
            m.set(k, oa.value);
        }
    }
    return m;
};
exports.compact = compact;
/**
 * @category filtering
 * @since 2.5.0
 */
const filter = (predicate) => (fa) => _filter(fa, predicate);
exports.filter = filter;
/**
 * @category filtering
 * @since 2.5.0
 */
const filterMap = (f) => (fa) => _filterMap(fa, f);
exports.filterMap = filterMap;
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.5.0
 */
const map = (f) => (fa) => _map(fa, f);
exports.map = map;
/**
 * @category mapping
 * @since 2.7.1
 */
const mapWithIndex = (f) => (fa) => _mapWithIndex(fa, f);
exports.mapWithIndex = mapWithIndex;
/**
 * @category filtering
 * @since 2.5.0
 */
const partition = (predicate) => (fa) => _partition(fa, predicate);
exports.partition = partition;
/**
 * @category filtering
 * @since 2.5.0
 */
const partitionMap = (f) => (fa) => _partitionMap(fa, f);
exports.partitionMap = partitionMap;
/**
 * @category filtering
 * @since 2.5.0
 */
const separate = (fa) => {
    const left = new Map();
    const right = new Map();
    const entries = fa.entries();
    let e;
    while (!(e = entries.next()).done) {
        const [k, ei] = e.value;
        if (_.isLeft(ei)) {
            left.set(k, ei.left);
        }
        else {
            right.set(k, ei.right);
        }
    }
    return (0, Separated_js_1.separated)(left, right);
};
exports.separate = separate;
/**
 * @category type lambdas
 * @since 2.5.0
 */
exports.URI = 'ReadonlyMap';
/**
 * @category instances
 * @since 2.11.0
 */
const getUnionSemigroup = (E, S) => {
    const unionES = (0, exports.union)(E, S);
    return {
        concat: (first, second) => unionES(second)(first)
    };
};
exports.getUnionSemigroup = getUnionSemigroup;
/**
 * @category instances
 * @since 2.11.0
 */
const getUnionMonoid = (E, S) => ({
    concat: (0, exports.getUnionSemigroup)(E, S).concat,
    empty: exports.empty
});
exports.getUnionMonoid = getUnionMonoid;
/**
 * @category instances
 * @since 2.11.0
 */
const getIntersectionSemigroup = (E, S) => {
    const intersectionES = (0, exports.intersection)(E, S);
    return {
        concat: (first, second) => intersectionES(second)(first)
    };
};
exports.getIntersectionSemigroup = getIntersectionSemigroup;
/**
 * @category instances
 * @since 2.11.0
 */
const getDifferenceMagma = (E) => () => {
    const differenceE = (0, exports.difference)(E);
    return {
        concat: (first, second) => differenceE(second)(first)
    };
};
exports.getDifferenceMagma = getDifferenceMagma;
/**
 * @category filtering
 * @since 2.5.0
 */
function getFilterableWithIndex() {
    return {
        URI: exports.URI,
        _E: undefined,
        map: _map,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex
    };
}
/**
 * @category instances
 * @since 2.7.0
 */
exports.Functor = {
    URI: exports.URI,
    map: _map
};
/**
 * @category mapping
 * @since 2.10.0
 */
exports.flap = (0, Functor_js_1.flap)(exports.Functor);
/**
 * @category instances
 * @since 2.10.0
 */
const getFunctorWithIndex = () => ({
    URI: exports.URI,
    _E: undefined,
    map: _map,
    mapWithIndex: _mapWithIndex
});
exports.getFunctorWithIndex = getFunctorWithIndex;
/**
 * @category instances
 * @since 2.7.0
 */
exports.Compactable = {
    URI: exports.URI,
    compact: exports.compact,
    separate: exports.separate
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Filterable = {
    URI: exports.URI,
    map: _map,
    compact: exports.compact,
    separate: exports.separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
/**
 * @category folding
 * @since 2.11.0
 */
const reduce = (O) => {
    const reduceWithIndexO = (0, exports.reduceWithIndex)(O);
    return (b, f) => reduceWithIndexO(b, (_, b, a) => f(b, a));
};
exports.reduce = reduce;
/**
 * @category folding
 * @since 2.11.0
 */
const foldMap = (O) => {
    const foldMapWithIndexO = (0, exports.foldMapWithIndex)(O);
    return (M) => {
        const foldMapWithIndexOM = foldMapWithIndexO(M);
        return (f) => foldMapWithIndexOM((_, a) => f(a));
    };
};
exports.foldMap = foldMap;
/**
 * @category folding
 * @since 2.11.0
 */
const reduceRight = (O) => {
    const reduceRightWithIndexO = (0, exports.reduceRightWithIndex)(O);
    return (b, f) => reduceRightWithIndexO(b, (_, b, a) => f(b, a));
};
exports.reduceRight = reduceRight;
/**
 * @category folding
 * @since 2.10.0
 */
const getFoldable = (O) => {
    const reduceO = (0, exports.reduce)(O);
    const foldMapO = (0, exports.foldMap)(O);
    const reduceRightO = (0, exports.reduceRight)(O);
    return {
        URI: exports.URI,
        _E: undefined,
        reduce: (fa, b, f) => (0, function_js_1.pipe)(fa, reduceO(b, f)),
        foldMap: (M) => {
            const foldMapOM = foldMapO(M);
            return (fa, f) => (0, function_js_1.pipe)(fa, foldMapOM(f));
        },
        reduceRight: (fa, b, f) => (0, function_js_1.pipe)(fa, reduceRightO(b, f))
    };
};
exports.getFoldable = getFoldable;
/**
 * @category folding
 * @since 2.11.0
 */
const reduceWithIndex = (O) => {
    const keysO = (0, exports.keys)(O);
    return (b, f) => (m) => {
        let out = b;
        for (const k of keysO(m)) {
            out = f(k, out, m.get(k));
        }
        return out;
    };
};
exports.reduceWithIndex = reduceWithIndex;
/**
 * @category folding
 * @since 2.11.0
 */
const foldMapWithIndex = (O) => {
    const keysO = (0, exports.keys)(O);
    return (M) => (f) => (m) => {
        let out = M.empty;
        for (const k of keysO(m)) {
            out = M.concat(out, f(k, m.get(k)));
        }
        return out;
    };
};
exports.foldMapWithIndex = foldMapWithIndex;
/**
 * @category folding
 * @since 2.11.0
 */
const reduceRightWithIndex = (O) => {
    const keysO = (0, exports.keys)(O);
    return (b, f) => (m) => {
        let out = b;
        const ks = keysO(m);
        const len = ks.length;
        for (let i = len - 1; i >= 0; i--) {
            const k = ks[i];
            out = f(k, m.get(k), out);
        }
        return out;
    };
};
exports.reduceRightWithIndex = reduceRightWithIndex;
/**
 * @category folding
 * @since 2.10.0
 */
const getFoldableWithIndex = (O) => {
    const F = (0, exports.getFoldable)(O);
    const reduceWithIndexO = (0, exports.reduceWithIndex)(O);
    const foldMapWithIndexO = (0, exports.foldMapWithIndex)(O);
    const reduceRightWithIndexO = (0, exports.reduceRightWithIndex)(O);
    return {
        URI: exports.URI,
        _E: undefined,
        reduce: F.reduce,
        foldMap: F.foldMap,
        reduceRight: F.reduceRight,
        reduceWithIndex: (fa, b, f) => (0, function_js_1.pipe)(fa, reduceWithIndexO(b, f)),
        foldMapWithIndex: (M) => {
            const foldMapWithIndexOM = foldMapWithIndexO(M);
            return (fa, f) => (0, function_js_1.pipe)(fa, foldMapWithIndexOM(f));
        },
        reduceRightWithIndex: (fa, b, f) => (0, function_js_1.pipe)(fa, reduceRightWithIndexO(b, f))
    };
};
exports.getFoldableWithIndex = getFoldableWithIndex;
/**
 * @category traversing
 * @since 2.10.0
 */
const getTraversable = (O) => {
    const TWI = (0, exports.getTraversableWithIndex)(O);
    const F = (0, exports.getFoldable)(O);
    return {
        URI: exports.URI,
        _E: undefined,
        map: _map,
        reduce: F.reduce,
        foldMap: F.foldMap,
        reduceRight: F.reduceRight,
        traverse: TWI.traverse,
        sequence: TWI.sequence
    };
};
exports.getTraversable = getTraversable;
/**
 * @category traversing
 * @since 2.10.0
 */
const getTraversableWithIndex = (O) => {
    const FWI = (0, exports.getFoldableWithIndex)(O);
    const keysO = (0, exports.keys)(O);
    const traverseWithIndex = (F) => {
        return (ta, f) => {
            let fm = F.of(new Map());
            const ks = keysO(ta);
            const len = ks.length;
            for (let i = 0; i < len; i++) {
                const key = ks[i];
                const a = ta.get(key);
                fm = F.ap(F.map(fm, (m) => (b) => m.set(key, b)), f(key, a));
            }
            return fm;
        };
    };
    const traverse = (F) => {
        const traverseWithIndexF = traverseWithIndex(F);
        return (ta, f) => traverseWithIndexF(ta, (_, a) => f(a));
    };
    const sequence = (F) => {
        const traverseWithIndexF = traverseWithIndex(F);
        return (ta) => traverseWithIndexF(ta, function_js_1.SK);
    };
    return {
        URI: exports.URI,
        _E: undefined,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: FWI.reduce,
        foldMap: FWI.foldMap,
        reduceRight: FWI.reduceRight,
        reduceWithIndex: FWI.reduceWithIndex,
        foldMapWithIndex: FWI.foldMapWithIndex,
        reduceRightWithIndex: FWI.reduceRightWithIndex,
        traverse,
        sequence,
        traverseWithIndex
    };
};
exports.getTraversableWithIndex = getTraversableWithIndex;
/**
 * @category filtering
 * @since 2.5.0
 */
function getWitherable(O) {
    const TWI = (0, exports.getTraversableWithIndex)(O);
    return {
        URI: exports.URI,
        _E: undefined,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        reduce: TWI.reduce,
        foldMap: TWI.foldMap,
        reduceRight: TWI.reduceRight,
        traverse: TWI.traverse,
        sequence: TWI.sequence,
        mapWithIndex: _mapWithIndex,
        reduceWithIndex: TWI.reduceWithIndex,
        foldMapWithIndex: TWI.foldMapWithIndex,
        reduceRightWithIndex: TWI.reduceRightWithIndex,
        traverseWithIndex: TWI.traverseWithIndex,
        wilt: (0, Witherable_js_1.wiltDefault)(TWI, exports.Compactable),
        wither: (0, Witherable_js_1.witherDefault)(TWI, exports.Compactable)
    };
}
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
const union = (E, M) => {
    const lookupE = lookup(E);
    return (second) => (first) => {
        if ((0, exports.isEmpty)(first)) {
            return second;
        }
        if ((0, exports.isEmpty)(second)) {
            return first;
        }
        const out = new Map();
        const firstEntries = first.entries();
        let e;
        while (!(e = firstEntries.next()).done) {
            const [k, a] = e.value;
            const oka = lookupE(k)(second);
            if (_.isSome(oka)) {
                out.set(k, M.concat(a, oka.value));
            }
            else {
                out.set(k, a);
            }
        }
        const secondEntries = second.entries();
        while (!(e = secondEntries.next()).done) {
            const [k, a] = e.value;
            const oka = lookupE(k)(out);
            if (_.isNone(oka)) {
                out.set(k, a);
            }
        }
        return out;
    };
};
exports.union = union;
/**
 * @since 2.11.0
 */
const intersection = (E, M) => {
    const lookupE = lookup(E);
    return (second) => (first) => {
        if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
            return exports.empty;
        }
        const out = new Map();
        const entries = first.entries();
        let e;
        while (!(e = entries.next()).done) {
            const [k, a] = e.value;
            const oka = lookupE(k)(second);
            if (_.isSome(oka)) {
                out.set(k, M.concat(a, oka.value));
            }
        }
        return out;
    };
};
exports.intersection = intersection;
/**
 * @since 2.11.0
 */
const difference = (E) => {
    const memberE = member(E);
    return (second) => (first) => {
        if ((0, exports.isEmpty)(first)) {
            return second;
        }
        if ((0, exports.isEmpty)(second)) {
            return first;
        }
        const out = new Map();
        const firstEntries = first.entries();
        let e;
        while (!(e = firstEntries.next()).done) {
            const [k, a] = e.value;
            if (!memberE(k)(second)) {
                out.set(k, a);
            }
        }
        const secondEntries = second.entries();
        while (!(e = secondEntries.next()).done) {
            const [k, a] = e.value;
            if (!memberE(k)(first)) {
                out.set(k, a);
            }
        }
        return out;
    };
};
exports.difference = difference;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`upsertAt`](#upsertat) instead.
 *
 @category zone of death
 * @since 2.5.0
 * @deprecated
 */
exports.insertAt = exports.upsertAt;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `RM.Functor` instead of `RM.readonlyMap`
 * (where `RM` is from `import RM from 'fp-ts/ReadonlyMap'`)
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
exports.readonlyMap = {
    URI: exports.URI,
    map: _map,
    compact: exports.compact,
    separate: exports.separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
