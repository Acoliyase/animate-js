"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subset = exports.toArray = exports.elem = exports.isSubset = exports.every = exports.some = exports.size = exports.isEmpty = exports.empty = exports.compact = exports.fromArray = exports.toggle = exports.remove = exports.singleton = exports.reduceRight = exports.foldMap = exports.reduce = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getEq = exports.getShow = void 0;
exports.map = map;
exports.chain = chain;
exports.filter = filter;
exports.partition = partition;
exports.union = union;
exports.intersection = intersection;
exports.partitionMap = partitionMap;
exports.difference = difference;
exports.insert = insert;
exports.separate = separate;
exports.filterMap = filterMap;
const function_js_1 = require("./function.js");
const RS = __importStar(require("./ReadonlySet.js"));
const Separated_js_1 = require("./Separated.js");
/**
 * @category instances
 * @since 2.0.0
 */
exports.getShow = RS.getShow;
/**
 * @category instances
 * @since 2.0.0
 */
exports.getEq = RS.getEq;
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @since 2.0.0
 */
function map(E) {
    const elemE = (0, exports.elem)(E);
    return (f) => (set) => {
        const r = new Set();
        set.forEach((e) => {
            const v = f(e);
            if (!elemE(v, r)) {
                r.add(v);
            }
        });
        return r;
    };
}
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation.
 *
 * @since 2.0.0
 */
function chain(E) {
    const elemE = (0, exports.elem)(E);
    return (f) => (set) => {
        const r = new Set();
        set.forEach((e) => {
            f(e).forEach((e) => {
                if (!elemE(e, r)) {
                    r.add(e);
                }
            });
        });
        return r;
    };
}
function filter(predicate) {
    return (set) => {
        const values = set.values();
        let e;
        const r = new Set();
        while (!(e = values.next()).done) {
            const a = e.value;
            if (predicate(a)) {
                r.add(a);
            }
        }
        return r;
    };
}
function partition(predicate) {
    return (set) => {
        const values = set.values();
        let e;
        const right = new Set();
        const left = new Set();
        while (!(e = values.next()).done) {
            const a = e.value;
            if (predicate(a)) {
                right.add(a);
            }
            else {
                left.add(a);
            }
        }
        return (0, Separated_js_1.separated)(left, right);
    };
}
function union(E) {
    const elemE = (0, exports.elem)(E);
    return (me, that) => {
        if (that === undefined) {
            const unionE = union(E);
            return (that) => unionE(me, that);
        }
        if ((0, exports.isEmpty)(me)) {
            return that;
        }
        if ((0, exports.isEmpty)(that)) {
            return me;
        }
        const r = new Set(me);
        that.forEach((e) => {
            if (!elemE(e, r)) {
                r.add(e);
            }
        });
        return r;
    };
}
function intersection(E) {
    const elemE = (0, exports.elem)(E);
    return (me, that) => {
        if (that === undefined) {
            const intersectionE = intersection(E);
            return (that) => intersectionE(that, me);
        }
        if ((0, exports.isEmpty)(me) || (0, exports.isEmpty)(that)) {
            return new Set();
        }
        const r = new Set();
        me.forEach((e) => {
            if (elemE(e, that)) {
                r.add(e);
            }
        });
        return r;
    };
}
/**
 * @since 2.0.0
 */
function partitionMap(EB, EC) {
    return (f) => (set) => {
        const values = set.values();
        let e;
        const left = new Set();
        const right = new Set();
        const hasB = (0, exports.elem)(EB);
        const hasC = (0, exports.elem)(EC);
        while (!(e = values.next()).done) {
            const v = f(e.value);
            switch (v._tag) {
                case 'Left':
                    if (!hasB(v.left, left)) {
                        left.add(v.left);
                    }
                    break;
                case 'Right':
                    if (!hasC(v.right, right)) {
                        right.add(v.right);
                    }
                    break;
            }
        }
        return (0, Separated_js_1.separated)(left, right);
    };
}
function difference(E) {
    const elemE = (0, exports.elem)(E);
    return (me, that) => {
        if (that === undefined) {
            const differenceE = difference(E);
            return (that) => differenceE(that, me);
        }
        return filter((a) => !elemE(a, that))(me);
    };
}
/**
 * @category instances
 * @since 2.11.0
 */
const getUnionSemigroup = (E) => ({
    concat: union(E)
});
exports.getUnionSemigroup = getUnionSemigroup;
/**
 * @category instances
 * @since 2.0.0
 */
const getUnionMonoid = (E) => ({
    concat: (0, exports.getUnionSemigroup)(E).concat,
    empty: new Set()
});
exports.getUnionMonoid = getUnionMonoid;
/**
 * @category instances
 * @since 2.0.0
 */
const getIntersectionSemigroup = (E) => ({
    concat: intersection(E)
});
exports.getIntersectionSemigroup = getIntersectionSemigroup;
/**
 * @category instances
 * @since 2.11.0
 */
const getDifferenceMagma = (E) => ({
    concat: difference(E)
});
exports.getDifferenceMagma = getDifferenceMagma;
/**
 * @category folding
 * @since 2.0.0
 */
exports.reduce = RS.reduce;
/**
 * @category folding
 * @since 2.0.0
 */
exports.foldMap = RS.foldMap;
/**
 * @category folding
 * @since 2.11.0
 */
exports.reduceRight = RS.reduceRight;
/**
 * Create a set with one element
 *
 * @category constructors
 * @since 2.0.0
 */
const singleton = (a) => new Set([a]);
exports.singleton = singleton;
/**
 * Insert a value into a set
 *
 * @since 2.0.0
 */
function insert(E) {
    const elemE = (0, exports.elem)(E);
    return (a) => (set) => {
        if (!elemE(a)(set)) {
            const r = new Set(set);
            r.add(a);
            return r;
        }
        else {
            return set;
        }
    };
}
/**
 * Delete a value from a set
 *
 * @since 2.0.0
 */
const remove = (E) => (a) => (set) => filter((ax) => !E.equals(a, ax))(set);
exports.remove = remove;
/**
 * Checks an element is a member of a set;
 * If yes, removes the value from the set
 * If no, inserts the value to the set
 *
 * @since 2.5.0
 */
const toggle = (E) => {
    const elemE = (0, exports.elem)(E);
    const removeE = (0, exports.remove)(E);
    const insertE = insert(E);
    return (a) => (set) => (elemE(a, set) ? removeE : insertE)(a)(set);
};
exports.toggle = toggle;
/**
 * Create a set from an array
 *
 * @category conversions
 * @since 2.0.0
 */
const fromArray = (E) => (as) => {
    const len = as.length;
    const out = new Set();
    const has = (0, exports.elem)(E);
    for (let i = 0; i < len; i++) {
        const a = as[i];
        if (!has(a, out)) {
            out.add(a);
        }
    }
    return out;
};
exports.fromArray = fromArray;
/**
 * @since 2.0.0
 */
const compact = (E) => filterMap(E)(function_js_1.identity);
exports.compact = compact;
/**
 * @since 2.0.0
 */
function separate(EE, EA) {
    return (fa) => {
        const elemEE = (0, exports.elem)(EE);
        const elemEA = (0, exports.elem)(EA);
        const left = new Set();
        const right = new Set();
        fa.forEach((e) => {
            switch (e._tag) {
                case 'Left':
                    if (!elemEE(e.left, left)) {
                        left.add(e.left);
                    }
                    break;
                case 'Right':
                    if (!elemEA(e.right, right)) {
                        right.add(e.right);
                    }
                    break;
            }
        });
        return (0, Separated_js_1.separated)(left, right);
    };
}
/**
 * @since 2.0.0
 */
function filterMap(E) {
    const elemE = (0, exports.elem)(E);
    return (f) => (fa) => {
        const r = new Set();
        fa.forEach((a) => {
            const ob = f(a);
            if (ob._tag === 'Some' && !elemE(ob.value, r)) {
                r.add(ob.value);
            }
        });
        return r;
    };
}
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 */
exports.empty = new Set();
/**
 * Test whether a `Set` is empty.
 *
 * @since 2.10.0
 */
const isEmpty = (set) => set.size === 0;
exports.isEmpty = isEmpty;
/**
 * Calculate the number of elements in a `Set`.
 *
 * @since 2.10.0
 */
const size = (set) => set.size;
exports.size = size;
/**
 * @since 2.0.0
 */
exports.some = RS.some;
/**
 * @since 2.0.0
 */
exports.every = RS.every;
/**
 * @since 2.10.0
 */
exports.isSubset = RS.isSubset;
// TODO: remove non-curried overloading in v3
/**
 * Test if a value is a member of a set
 *
 * @since 2.0.0
 */
exports.elem = RS.elem;
/**
 * Get a sorted `Array` of the values contained in a `Set`.
 *
 * @category conversions
 * @since 2.0.0
 */
const toArray = (O) => (set) => {
    const out = [];
    set.forEach((e) => out.push(e));
    return out.sort(O.compare);
};
exports.toArray = toArray;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`isSubset`](#issubset) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.subset = RS.isSubset;
