import React, { useEffect } from 'react';
import Emitter from './emitter.js';
import { proxy } from './proxy.js';
import { utils } from 'pro-gallery-lib';
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function mouseFollower(container) {
    const emitter = new Emitter();
    let state = {
        mouseIn: false,
        position: [0, 0],
    };
    emitter.listen.mouseEnterState((mouseIn, ...position) => {
        state = {
            mouseIn,
            position,
        };
    });
    emitter.listen.mouseMove((x, y) => {
        state = Object.assign(Object.assign({}, state), { position: [x, y] });
    });
    const getMousePosition = (event) => {
        const bounding = container.getBoundingClientRect();
        const position = [event.clientX - bounding.left, event.clientY - bounding.top];
        return position;
    };
    function onMouseEnter(event) {
        const position = getMousePosition(event);
        emitter.call.mouseEnterState(!isHoveringClickableElement(container, event, ...position), ...position);
    }
    function onMouseMove(event) {
        const position = getMousePosition(event);
        emitter.call.mouseEnterState(!isHoveringClickableElement(container, event, ...position), ...position);
        emitter.call.mouseMove(...position);
    }
    function onMouseLeave() {
        emitter.call.mouseEnterState(false, 0, 0);
    }
    function onMouseClickInteractionEvent(event) {
        emitter.call.mouseClickInteractionEvent(event);
    }
    container.addEventListener('mouseenter', onMouseEnter);
    container.addEventListener('mousemove', onMouseMove);
    container.addEventListener('mouseleave', onMouseLeave);
    container.addEventListener('click', onMouseClickInteractionEvent);
    container.addEventListener('mousedown', onMouseClickInteractionEvent);
    container.addEventListener('mouseup', onMouseClickInteractionEvent);
    return {
        listen: emitter.listen,
        get state() {
            return state;
        },
        destroy: () => {
            container.removeEventListener('mouseenter', onMouseEnter);
            container.removeEventListener('mousemove', onMouseMove);
            container.removeEventListener('mouseleave', onMouseLeave);
            container.removeEventListener('click', onMouseClickInteractionEvent);
            container.removeEventListener('mousedown', onMouseClickInteractionEvent);
            container.removeEventListener('mouseup', onMouseClickInteractionEvent);
        },
    };
}
const getContainerById = (id) => document.getElementById(`pro-gallery-container-${id}`);
const MouseFollowerContext = React.createContext(undefined);
export const MouseFollowerProvider = ({ children, id }) => {
    const [mouseFollowerValue, setMouseFollowerValue] = React.useState();
    useEffect(() => {
        const container = getContainerById(id);
        const mouseFollowerValue = mouseFollower(container);
        setMouseFollowerValue(mouseFollowerValue);
        return () => {
            mouseFollowerValue.destroy();
        };
    }, [id]);
    return (React.createElement(MouseFollowerContext.Provider, { value: mouseFollowerValue }, mouseFollowerValue && children));
};
export class MouseCursor extends React.Component {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.state = {
            position: ((_a = this.context) === null || _a === void 0 ? void 0 : _a.state.position) || [0, 0],
            mouseIn: ((_b = this.context) === null || _b === void 0 ? void 0 : _b.state.mouseIn) || false,
        };
    }
    componentDidMount() {
        if (!this.context) {
            throw new Error('MouseFollowerContext is undefined');
        }
        const removeMoveListener = this.context.listen.mouseMove(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        utils.throttle(() => {
            this.setState({
                position: this.context.state.position,
            });
        }, this.props.throttle));
        const removeEnterListener = this.context.listen.mouseEnterState(() => {
            const { mouseIn, position } = this.context.state;
            if (this.state.mouseIn !== mouseIn) {
                this.setState({
                    mouseIn: mouseIn,
                    position,
                });
                if (this.props.onEnterState) {
                    this.props.onEnterState(mouseIn);
                }
            }
        });
        const removeClickListener = this.context.listen.mouseClickInteractionEvent((e) => {
            if (!this.state.mouseIn) {
                return;
            }
            const [x, y] = this.state.position;
            if (!this.props.shouldRenderAtPosition(x, y)) {
                return;
            }
            if (e.type === 'mousedown' || e.type === 'mouseup') {
                this.props.onMouseDownOrUp(e);
                return;
            }
            this.props.onClick(e);
        });
        this.cleanup = () => {
            removeMoveListener();
            removeEnterListener();
            removeClickListener();
        };
    }
    componentWillUnmount() {
        var _a;
        (_a = this.cleanup) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    render() {
        if (!this.state.mouseIn) {
            return null;
        }
        const [x, y] = this.state.position;
        if (!this.props.shouldRenderAtPosition(x, y)) {
            return null;
        }
        return this.props.render(this.state.position[0], this.state.position[1]);
    }
}
MouseCursor.contextType = MouseFollowerContext;
const CLICKABLE_ATTR = 'pg-clickable';
const isHoveringClickableElement = (element, e, x, y) => {
    // cancel the click event
    for (const ele of e.composedPath()) {
        if (ele instanceof HTMLElement && ele.getAttribute(CLICKABLE_ATTR) === 'true') {
            return true;
        }
    }
    const bounding = element.getBoundingClientRect();
    const elementUnderMouse = document.elementFromPoint(x + bounding.left, y + bounding.top);
    if (!elementUnderMouse) {
        return false;
    }
    let parent = elementUnderMouse;
    while (parent) {
        if (parent.getAttribute(CLICKABLE_ATTR) === 'true') {
            return true;
        }
        parent = parent.parentElement;
    }
    return false;
};
export class ArrowFollower extends React.Component {
    constructor() {
        super(...arguments);
        this.shouldRender = (x) => {
            const element = getContainerById(this.props.id);
            const containerWidth = element.offsetWidth;
            const realMaxWidth = Math.min(this.props.mouseCursorContainerMaxWidth, this.props.isTheOnlyArrow ? 100 : 50);
            const amountOfPixelsNeeded = containerWidth * (realMaxWidth / 100);
            const isLeft = amountOfPixelsNeeded >= x;
            const isRight = x > containerWidth - amountOfPixelsNeeded;
            return this.props.direction === 'left' ? isLeft : isRight;
        };
        this.onNavigation = (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.props.onNavigate();
        };
    }
    render() {
        return (React.createElement(MouseCursor, { getElement: () => getContainerById(this.props.id), render: (x, y) => {
                var _a;
                return (React.createElement(React.Fragment, null,
                    this.props.children(x, y),
                    React.createElement("style", null, `
                  #${(_a = getContainerById(this.props.id)) === null || _a === void 0 ? void 0 : _a.id} * {
                    cursor: none !important;
                  }
              `)));
            }, shouldRenderAtPosition: this.shouldRender, onClick: this.onNavigation, onMouseDownOrUp: (e) => e.stopPropagation(), throttle: 50 }));
    }
}
export function clickableFactory() {
    const instances = new Map();
    return proxy((name) => {
        if (!instances.get(name)) {
            instances.set(name, (props) => {
                return React.createElement(name, Object.assign(Object.assign({}, props), { [CLICKABLE_ATTR]: 'true' }));
            });
        }
        return instances.get(name);
    });
}
export const clickable = clickableFactory();
//# sourceMappingURL=mouseCursorPosition.js.map