import { GALLERY_CONSTS, optionsMap } from 'pro-gallery-lib';
export function getItemsInViewportOrMarginByActiveGroup({ groups, options, virtualizationSettings, galleryWidth, galleryHeight, activeIndex, }) {
    const { enabled = false, forwardItemMargin = 3, backwardItemMargin = 3, forwardItemScrollMargin = 10, backwardItemScrollMargin = 10, } = virtualizationSettings || {};
    const isHorizontal = options[optionsMap.layoutParams.structure.scrollDirection] ===
        GALLERY_CONSTS[optionsMap.layoutParams.structure.scrollDirection].HORIZONTAL;
    const isScrollable = !isHorizontal ||
        options[optionsMap.behaviourParams.gallery.horizontal.slideAnimation] ===
            GALLERY_CONSTS[optionsMap.behaviourParams.gallery.horizontal.slideAnimation].SCROLL;
    if (!enabled) {
        return groups.map((group) => ({
            group,
            shouldRender: true,
        }));
    }
    const size = isHorizontal ? galleryWidth : galleryHeight;
    const unit = isHorizontal ? 'width' : 'height';
    const rightRenderBuffer = isScrollable ? forwardItemScrollMargin : forwardItemMargin;
    const leftRenderBuffer = isScrollable ? backwardItemScrollMargin : backwardItemMargin;
    const activeGroupIndex = groups.findIndex((group) => {
        var _a, _b;
        const { items } = group;
        const first = items[0];
        const last = items[items.length - 1];
        const firstIndex = (_a = first.idx) !== null && _a !== void 0 ? _a : first.fullscreenIdx;
        const lastIndex = (_b = last.idx) !== null && _b !== void 0 ? _b : last.fullscreenIdx;
        return firstIndex <= activeIndex && lastIndex >= activeIndex;
    });
    const activeGroup = groups[activeGroupIndex];
    const activeGroupPrecOfScreen = activeGroup[unit] / size;
    let accoumilatedRightMargin = activeGroupPrecOfScreen;
    let accoumilatedLeftMargin = activeGroupPrecOfScreen;
    const groupsToRender = [activeGroup];
    for (let index = 1; accoumilatedRightMargin < rightRenderBuffer || accoumilatedLeftMargin < leftRenderBuffer; index++) {
        const groupToRight = groups[activeGroupIndex + index];
        const groupToLeft = groups[activeGroupIndex - index];
        if (groupToRight && accoumilatedRightMargin < rightRenderBuffer) {
            const groupPrecOfScreen = groupToRight[unit] / size;
            accoumilatedRightMargin += groupPrecOfScreen;
            groupsToRender.push(groupToRight);
        }
        if (groupToLeft && accoumilatedLeftMargin < leftRenderBuffer) {
            const groupPrecOfScreen = groupToLeft[unit] / size;
            accoumilatedLeftMargin += groupPrecOfScreen;
            groupsToRender.push(groupToLeft);
        }
        if (!groupToLeft && !groupToRight) {
            break;
        }
    }
    return groups.map((group) => {
        return { group, shouldRender: groupsToRender.includes(group) };
    });
}
export function getItemsInViewportOrMarginByScrollLocation({ items, options, virtualizationSettings, galleryWidth, galleryHeight, scrollPosition, }) {
    const { enabled = false, forwardItemScrollMargin = 10, backwardItemScrollMargin = 10 } = virtualizationSettings || {};
    if (!enabled) {
        return items.map((item) => ({
            item,
            shouldRender: true,
        }));
    }
    const isHorizontal = options[optionsMap.layoutParams.structure.scrollDirection] ===
        GALLERY_CONSTS[optionsMap.layoutParams.structure.scrollDirection].HORIZONTAL;
    const size = isHorizontal ? galleryWidth : galleryHeight;
    const unit = isHorizontal ? 'width' : 'height';
    function shouldRenderItem(item) {
        const group = item.group;
        const locationUnit = unit === 'height' ? 'top' : 'left';
        const location = group[locationUnit];
        const locationEnd = location + group[unit];
        const viewportStart = scrollPosition - size * backwardItemScrollMargin;
        const viewportEnd = scrollPosition + size * forwardItemScrollMargin;
        return location > viewportStart && locationEnd < viewportEnd;
    }
    return items.map((item) => ({
        item,
        shouldRender: shouldRenderItem(item),
    }));
}
//# sourceMappingURL=virtualization.js.map