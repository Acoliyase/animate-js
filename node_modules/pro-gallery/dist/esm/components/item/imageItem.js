import { __rest } from "tslib";
import React from 'react';
import { GALLERY_CONSTS, optionsMap, utils } from 'pro-gallery-lib';
import ImageRenderer from './imageRenderer.js';
class ImageItem extends React.Component {
    constructor(props) {
        super(props);
        this.getImageContainer = this.getImageContainer.bind(this);
        this.getImageContainerClassNames = this.getImageContainerClassNames.bind(this);
        this.state = {
            isHighResImageLoaded: false,
        };
        this.handleHighResImageLoad = this.handleHighResImageLoad.bind(this);
    }
    componentDidMount() {
        try {
            if (typeof this.props.actions.setItemLoaded === 'function') {
                this.props.actions.setItemLoaded();
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    handleHighResImageLoad() {
        this.setState({ isHighResImageLoaded: true });
        try {
            this.props.actions.setItemLoaded();
        }
        catch (e) {
            console.error('Failed to load high res image', e);
        }
    }
    getImageContainerClassNames() {
        const { isCurrentHover, options } = this.props;
        const { isHighResImageLoaded } = this.state;
        const imageContainerClassNames = [
            'gallery-item-content',
            isCurrentHover ? 'item-content-hover' : 'item-content-regular',
            'image-item',
            'gallery-item-visible',
            'gallery-item',
            'gallery-item-preloaded',
            options[optionsMap.layoutParams.crop.enable] &&
                options[optionsMap.layoutParams.crop.method] === GALLERY_CONSTS[optionsMap.layoutParams.crop.method].FIT
                ? 'grid-fit'
                : '',
            options[optionsMap.behaviourParams.item.content.loader] ===
                GALLERY_CONSTS[optionsMap.behaviourParams.item.content.loader].COLOR
                ? `load-with-color ${isHighResImageLoaded ? 'image-loaded' : ''}`
                : '',
        ].join(' ');
        return imageContainerClassNames;
    }
    getImageContainer(imageRenderer, classNames, extraNodes) {
        const { imageDimensions, id, actions } = this.props;
        return (React.createElement("div", { className: classNames, onTouchStart: actions.handleItemMouseDown, onTouchEnd: actions.handleItemMouseUp, key: 'image_container-' + id, "data-hook": 'image-item', style: imageDimensions },
            imageRenderer(),
            extraNodes));
    }
    getImageAnimationOverlay() {
        const { imageDimensions, options, createUrl, id } = this.props;
        let imageAnimationUrl = null;
        switch (options[optionsMap.behaviourParams.gallery.scrollAnimation]) {
            case GALLERY_CONSTS[optionsMap.behaviourParams.gallery.scrollAnimation].BLUR:
                imageAnimationUrl = createUrl(GALLERY_CONSTS.urlSizes.RESIZED, GALLERY_CONSTS.urlTypes.LOW_RES);
                break;
            case GALLERY_CONSTS[optionsMap.behaviourParams.gallery.scrollAnimation].MAIN_COLOR:
                imageAnimationUrl = createUrl(GALLERY_CONSTS.urlSizes.PIXEL, GALLERY_CONSTS.urlTypes.HIGH_RES);
                break;
        }
        return (imageAnimationUrl && (React.createElement("div", { key: 'image_container-overlay-' + id, "data-hook": 'image-item-overlay', style: Object.assign(Object.assign({}, imageDimensions), { backgroundImage: `url(${imageAnimationUrl})`, backgroundSize: 'cover', pointerEvents: 'none', position: 'absolute', top: 0, left: 0 }) })));
    }
    getImageElement() {
        const { alt, imageDimensions, createUrl, id, idx, settings = {}, options } = this.props;
        const { isHighResImageLoaded } = this.state;
        const imageProps = settings && settings.imageProps && typeof settings.imageProps === 'function' ? settings.imageProps(id) : {};
        // eslint-disable-next-line no-unused-vars
        const { marginLeft, marginTop } = imageDimensions, imageSizing = __rest(imageDimensions, ["marginLeft", "marginTop"]);
        const image = () => {
            var _a, _b, _c;
            const imagesComponents = [];
            const altText = typeof alt === 'string' ? alt : 'untitled image';
            const blockDownloadStyles = utils.isMobile() && this.props.options[optionsMap.behaviourParams.gallery.blockContextMenu]
                ? {
                    WebkitUserSelect: 'none',
                    WebkitTouchCallout: 'none',
                }
                : {};
            const preloadStyles = this.props.isPrerenderMode
                ? {
                    width: '100%',
                    height: '100%',
                }
                : {};
            if (!isHighResImageLoaded) {
                let preload = null;
                const preloadProps = Object.assign({ className: 'gallery-item-visible gallery-item gallery-item-preloaded', key: 'gallery-item-image-img-preload', 'data-hook': 'gallery-item-image-img-preload', loading: 'eager' }, imageProps);
                switch (options[optionsMap.behaviourParams.item.content.loader]) {
                    case GALLERY_CONSTS[optionsMap.behaviourParams.item.content.loader].BLUR:
                        preload = (React.createElement(ImageRenderer, Object.assign({ alt: altText, key: 'image_preload_blur-' + id, src: createUrl(GALLERY_CONSTS.urlSizes.RESIZED, GALLERY_CONSTS.urlTypes.LOW_RES), style: Object.assign(Object.assign(Object.assign({}, imageSizing), preloadStyles), blockDownloadStyles) }, preloadProps, { customImageRenderer: (_a = this.props.customComponents) === null || _a === void 0 ? void 0 : _a.customImageRenderer })));
                        break;
                    case GALLERY_CONSTS[optionsMap.behaviourParams.item.content.loader].MAIN_COLOR:
                        preload = (React.createElement(ImageRenderer, Object.assign({ alt: altText, key: 'image_preload_main_color-' + id, src: createUrl(GALLERY_CONSTS.urlSizes.PIXEL, GALLERY_CONSTS.urlTypes.HIGH_RES), style: Object.assign(Object.assign(Object.assign({}, imageSizing), preloadStyles), blockDownloadStyles) }, preloadProps, { customImageRenderer: (_b = this.props.customComponents) === null || _b === void 0 ? void 0 : _b.customImageRenderer })));
                        break;
                }
                imagesComponents.push(preload);
            }
            const shouldRenderHighResImages = !this.props.isPrerenderMode;
            const imageType = options[optionsMap.stylingParams.itemResolutionMode] ===
                GALLERY_CONSTS[optionsMap.stylingParams.itemResolutionMode].FULL
                ? GALLERY_CONSTS.urlSizes.FULL
                : GALLERY_CONSTS.urlSizes.MULTI;
            const src = createUrl(imageType, GALLERY_CONSTS.urlTypes.HIGH_RES);
            const highres = (React.createElement(ImageRenderer, Object.assign({ key: 'image_highres-' + id, className: `gallery-item-visible gallery-item gallery-item-preloaded`, "data-hook": "gallery-item-image-img", "data-idx": idx, src: src, alt: altText, onLoad: this.handleHighResImageLoad, loading: this.props.isPrerenderMode ? 'lazy' : 'eager', style: Object.assign(Object.assign(Object.assign({}, imageSizing), blockDownloadStyles), (!shouldRenderHighResImages && preloadStyles)) }, imageProps, { customImageRenderer: (_c = this.props.customComponents) === null || _c === void 0 ? void 0 : _c.customImageRenderer })));
            imagesComponents.push(highres);
            return imagesComponents;
        };
        return image;
    }
    render() {
        const imageRenderer = this.getImageElement();
        const imageContainerClassNames = `${this.getImageContainerClassNames()} ${this.props.extraClasses || ''}`;
        const animationOverlay = this.props.overlay || this.getImageAnimationOverlay();
        const renderedItem = this.getImageContainer(imageRenderer, imageContainerClassNames, animationOverlay);
        return renderedItem;
    }
}
/* eslint-enable prettier/prettier */
export default ImageItem;
//# sourceMappingURL=imageItem.js.map