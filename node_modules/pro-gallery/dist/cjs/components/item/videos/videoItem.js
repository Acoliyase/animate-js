"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const pro_gallery_lib_1 = require("pro-gallery-lib");
const itemHelper_js_1 = require("../itemHelper.js");
const getStyle_js_1 = require("./getStyle.js");
class VideoItem extends react_1.default.Component {
    constructor(props) {
        super(props);
        this.pause = this.pause.bind(this);
        this.play = this.play.bind(this);
        this.playVideoIfNeeded = this.playVideoIfNeeded.bind(this);
        this.state = {
            playedOnce: false,
            loadVideo: props.loadVideo || props.shouldPlay,
            isPlaying: false,
            shouldPlay: props.shouldPlay,
            reactPlayerLoaded: false,
            vimeoPlayerLoaded: false,
            hlsPlayerLoaded: false,
        };
    }
    componentDidMount() {
        this.dynamiclyImportVideoPlayers();
    }
    dynamiclyImportVideoPlayers() {
        if (!(pro_gallery_lib_1.window && pro_gallery_lib_1.window.ReactPlayer)) {
            Promise.resolve().then(() => tslib_1.__importStar(require(/* webpackChunkName: "proGallery_reactPlayer" */ 'react-player'))).then((ReactPlayer) => {
                // cjs/esm interop hack
                if (ReactPlayer.default.default) {
                    pro_gallery_lib_1.window.ReactPlayer = ReactPlayer.default.default;
                }
                else {
                    pro_gallery_lib_1.window.ReactPlayer = ReactPlayer.default;
                }
                this.setState({ reactPlayerLoaded: true });
                this.playVideoIfNeeded();
            });
        }
        if (
        //Vimeo player must be loaded by us, problem with requireJS
        !(pro_gallery_lib_1.window && pro_gallery_lib_1.window.Vimeo) &&
            this.props.videoUrl &&
            this.props.videoUrl.includes('vimeo.com')) {
            Promise.resolve().then(() => tslib_1.__importStar(require(/* webpackChunkName: "proGallery_vimeoPlayer" */ '@vimeo/player'))).then((Player) => {
                pro_gallery_lib_1.window.Vimeo = { Player: Player.default };
                this.setState({ vimeoPlayerLoaded: true });
                this.playVideoIfNeeded();
            });
        }
        if (
        //Hls player must be loaded by us, problem with requireJS
        !(pro_gallery_lib_1.window && pro_gallery_lib_1.window.Hls) &&
            this.isHLSVideo()) {
            Promise.resolve().then(() => tslib_1.__importStar(require(/* webpackChunkName: "proGallery_HlsPlayer" */ 'hls.js'))).then((Player) => {
                pro_gallery_lib_1.window.Hls = Player.default;
                this.setState({ hlsPlayerLoaded: true });
                this.playVideoIfNeeded();
            });
        }
    }
    isHLSVideo() {
        return this.props.videoUrl && (this.props.videoUrl.includes('/hls') || this.props.videoUrl.includes('.m3u8'));
    }
    shouldUseHlsPlayer() {
        return this.isHLSVideo() && !pro_gallery_lib_1.utils.isiOS();
    }
    shouldForceVideoForHLS() {
        return this.isHLSVideo() && pro_gallery_lib_1.utils.isiOS();
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        if (nextProps.shouldPlay || nextProps.firstUserInteractionExecuted) {
            this.setState({ loadVideo: true });
        }
        if (nextProps.shouldPlay) {
            this.setState({ shouldPlay: true });
        }
        this.playVideoIfNeeded(nextProps);
    }
    componentDidUpdate(prevProps) {
        if (prevProps.activeIndex !== this.props.activeIndex) {
            this.fixIFrameTabIndexIfNeeded();
        }
        if (prevProps.type === 'image' && this.props.type === 'video') {
            this.dynamiclyImportVideoPlayers();
        }
        this.playVideoIfNeeded();
    }
    play() {
        this.props.playVideo(this.props.idx);
    }
    pause() {
        this.props.pauseVideo();
    }
    isPrefersReducedMotion() {
        return pro_gallery_lib_1.window.matchMedia && pro_gallery_lib_1.window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    }
    playVideoIfNeeded(props = this.props) {
        try {
            const { shouldPlay } = props;
            if (shouldPlay && !this.isPlaying && !this.isPrefersReducedMotion()) {
                this.videoElement =
                    this.videoElement || pro_gallery_lib_1.window.document.querySelector(`#video-${this.props.id}-${this.props.galleryId} video`);
                if (this.videoElement) {
                    this.isPlaying = true;
                    this.videoElement.play();
                    pro_gallery_lib_1.utils.isVerbose() && console.log('[VIDEO] Playing video #' + this.props.idx, this.videoElement);
                }
            }
        }
        catch (e) {
            console.error('[VIDEO] Could not play video #' + this.props.idx, this.videoElement, e);
        }
    }
    //-----------------------------------------| UTILS |--------------------------------------------//
    createPlayerElement() {
        //video dimensions are for videos in grid fill - placing the video with negative margins to crop into a square
        if (!(pro_gallery_lib_1.window && pro_gallery_lib_1.window.ReactPlayer && (this.state.loadVideo || this.props.playing))) {
            return null;
        }
        const PlayerElement = pro_gallery_lib_1.window.ReactPlayer;
        const isWiderThenContainer = this.props.style.ratio >= this.props.cropRatio;
        // adding 1 pixel to compensate for the difference we have sometimes from layouter in grid fill
        const isCrop = this.props.options[pro_gallery_lib_1.optionsMap.layoutParams.crop.enable] &&
            this.props.options[pro_gallery_lib_1.optionsMap.layoutParams.crop.method] ===
                pro_gallery_lib_1.GALLERY_CONSTS[pro_gallery_lib_1.optionsMap.layoutParams.crop.method].FILL;
        const url = this.props.videoUrl
            ? this.props.videoUrl
            : this.props.createUrl(pro_gallery_lib_1.GALLERY_CONSTS.urlSizes.RESIZED, pro_gallery_lib_1.GALLERY_CONSTS.urlTypes.VIDEO);
        const attributes = {
            controlsList: 'nodownload',
            disablePictureInPicture: true,
            muted: !this.props.options[pro_gallery_lib_1.optionsMap.behaviourParams.item.video.volume],
            preload: 'metadata',
            style: (0, getStyle_js_1.getStyle)(isCrop, isWiderThenContainer),
            type: 'video/mp4',
        };
        if ((0, itemHelper_js_1.shouldCreateVideoPlaceholder)(this.props.options)) {
            attributes.poster = this.props.createUrl(pro_gallery_lib_1.GALLERY_CONSTS.urlSizes.SCALED, pro_gallery_lib_1.GALLERY_CONSTS.urlTypes.HIGH_RES);
        }
        return (react_1.default.createElement(PlayerElement, { playsinline: true, className: 'gallery-item-visible video gallery-item', id: `video-${this.props.id}-${this.props.galleryId}`, width: "100%", height: "100%", url: url, alt: typeof this.props.alt === 'string' ? this.props.alt : 'untitled video', loop: !!this.props.options[pro_gallery_lib_1.optionsMap.behaviourParams.item.video.loop], ref: (player) => (this.video = player), volume: this.props.options[pro_gallery_lib_1.optionsMap.behaviourParams.item.video.volume] ? 0.8 : 0, playing: this.state.shouldPlay && !this.isPrefersReducedMotion(), onEnded: () => {
                this.setState({ isPlaying: false });
                this.props.actions.eventsListener(pro_gallery_lib_1.GALLERY_CONSTS.events.VIDEO_ENDED, this.props);
            }, onPause: () => {
                this.setState({ isPlaying: false });
            }, onError: (e) => {
                this.props.actions.eventsListener(pro_gallery_lib_1.GALLERY_CONSTS.events.VIDEO_ERROR, Object.assign(Object.assign({}, this.props), { videoError: e }));
            }, playbackRate: Number(this.props.options[pro_gallery_lib_1.optionsMap.behaviourParams.item.video.speed]) || 1, onStart: () => {
                if (!this.state.playedOnce) {
                    this.setState({ playedOnce: true });
                }
            }, onPlay: () => {
                this.props.actions.eventsListener(pro_gallery_lib_1.GALLERY_CONSTS.events.VIDEO_PLAYED, this.props);
                this.setState({ isPlaying: true });
            }, onReady: () => {
                this.playVideoIfNeeded();
                this.fixIFrameTabIndexIfNeeded();
                this.props.actions.setItemLoaded();
                this.setState({ ready: true });
            }, onProgress: () => {
                if (!this.props.shouldPlay) {
                    this.setState({ shouldPlay: false });
                }
            }, controls: this.props.activeIndex === this.props.idx &&
                this.props.options[pro_gallery_lib_1.optionsMap.behaviourParams.item.video.enableControls], config: {
                file: {
                    attributes,
                    forceHLS: this.shouldUseHlsPlayer(),
                    forceVideo: this.shouldForceVideoForHLS(),
                },
            }, key: 'video-' + this.props.id }));
    }
    fixIFrameTabIndexIfNeeded() {
        if (this.props.isExternalVideo) {
            const videoGalleryItem = pro_gallery_lib_1.window.document &&
                pro_gallery_lib_1.window.document.querySelector(`#pro-gallery-${this.props.galleryId} #video-${this.props.id}`);
            const videoIFrames = videoGalleryItem && videoGalleryItem.getElementsByTagName('iframe');
            const videoIFrame = videoIFrames && videoIFrames[0];
            if (videoIFrame) {
                if (this.props.activeIndex === this.props.idx) {
                    videoIFrame.setAttribute('tabIndex', '0');
                }
                else {
                    videoIFrame.setAttribute('tabIndex', '-1');
                }
            }
        }
    }
    getVideoContainerStyles() {
        const videoContainerStyle = Object.assign({}, this.props.imageDimensions);
        if (pro_gallery_lib_1.utils.deviceHasMemoryIssues() || this.state.ready || !(0, itemHelper_js_1.shouldCreateVideoPlaceholder)(this.props.options)) {
            // videoContainerStyle.backgroundColor = 'black';
        }
        else {
            videoContainerStyle.backgroundImage = `url(${this.props.createUrl(pro_gallery_lib_1.GALLERY_CONSTS.urlSizes.RESIZED, pro_gallery_lib_1.GALLERY_CONSTS.urlTypes.HIGH_RES)})`;
        }
        return videoContainerStyle;
    }
    //-----------------------------------------| RENDER |--------------------------------------------//
    render() {
        const { thumbnail, hover } = this.props;
        let baseClassName = [
            'gallery-item-content',
            'gallery-item-visible',
            'gallery-item-preloaded',
            'gallery-item-video',
            'gallery-item',
            'video-item',
        ];
        if (pro_gallery_lib_1.utils.isiPhone()) {
            baseClassName.push('ios');
        }
        if (this.state.isPlaying) {
            baseClassName.push('playing');
        }
        if (this.state.playedOnce && this.state.ready) {
            baseClassName.push('playedOnce');
        }
        if (this.props.isCurrentHover) {
            baseClassName.push('item-content-hover');
        }
        else {
            baseClassName.push('item-content-regular');
        }
        // eslint-disable-next-line no-unused-vars
        const video = (react_1.default.createElement("div", { className: baseClassName.join(' '), "data-hook": "video_container-video-player-element", key: 'video_container-' + this.props.id, style: this.getVideoContainerStyles() },
            this.createPlayerElement(),
            this.state.isPlaying ? null : this.props.videoPlayButton));
        return (react_1.default.createElement("div", { key: 'video-and-hover-container' + this.props.idx },
            video,
            (0, itemHelper_js_1.shouldCreateVideoPlaceholder)(this.props.options) && thumbnail,
            hover));
    }
}
exports.default = VideoItem;
//# sourceMappingURL=videoItem.js.map