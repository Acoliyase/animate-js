"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const pro_gallery_lib_1 = require("pro-gallery-lib");
const galleryDebugMessage_js_1 = tslib_1.__importDefault(require("./galleryDebugMessage.js"));
const itemView_js_1 = tslib_1.__importDefault(require("../../item/itemView.js"));
const virtualization_js_1 = require("../../helpers/virtualization.js");
class GalleryView extends react_1.default.Component {
    constructor(props) {
        super(props);
        this.handleKeys = this.handleKeys.bind(this);
        this.showMoreItems = this.showMoreItems.bind(this);
        this.onLoadMoreButtonKeyDown = this.onLoadMoreButtonKeyDown.bind(this);
        this.onLoadMoreButtonKeyUp = this.onLoadMoreButtonKeyUp.bind(this);
        this.createGalleryConfig = this.createGalleryConfig.bind(this);
        this.screenLogs = this.screenLogs.bind(this);
        this.createGallery = this.createGallery.bind(this);
        this.id = Date.now() + '|' + Math.floor(Math.random() * 10000);
        this.state = {
            activeIndex: 0,
        };
    }
    handleKeys(e) {
        const activeItemIdx = pro_gallery_lib_1.window.document.activeElement.getAttribute('data-idx');
        if (activeItemIdx) {
            const findNeighborItem = this.props.actions.findNeighborItem || this.props.galleryStructure.findNeighborItem || (() => { }); //temp change for tests to pass
            const idx = Number(activeItemIdx);
            let newIdx = -1;
            switch (e.keyCode || e.charCode) {
                case 38: //up
                    newIdx = findNeighborItem(idx, 'up');
                    break;
                case 37: //left
                    newIdx = findNeighborItem(idx, this.props.options[pro_gallery_lib_1.optionsMap.behaviourParams.gallery.layoutDirection] ===
                        pro_gallery_lib_1.GALLERY_CONSTS[pro_gallery_lib_1.optionsMap.behaviourParams.gallery.layoutDirection].RIGHT_TO_LEFT
                        ? 'right'
                        : 'left');
                    break;
                case 40: //down
                    newIdx = findNeighborItem(idx, 'down');
                    if (this.props.totalItemsCount - 1 === newIdx && newIdx === this.state.activeIndex) {
                        // If we are on the last item in the gallery and we pressed the down arrow
                        // we want to move the focus to the out0fGallery element
                        e.stopPropagation();
                        pro_gallery_lib_1.utils.focusGalleryElement(this.props.outOfViewComponent);
                        return false;
                    }
                    break;
                case 39: //right
                    newIdx = findNeighborItem(idx, this.props.options[pro_gallery_lib_1.optionsMap.behaviourParams.gallery.layoutDirection] ===
                        pro_gallery_lib_1.GALLERY_CONSTS[pro_gallery_lib_1.optionsMap.behaviourParams.gallery.layoutDirection].RIGHT_TO_LEFT
                        ? 'left'
                        : 'right');
                    break;
                case 27: //esc
                    // e.stopPropagation();
                    // utils.focusGalleryElement(this.props.galleryContainerRef);
                    return false;
            }
            //if nextIdx is below the lastVisibleItemIdx (higher idx), we will ignore the findNeighborItem answer and stay on the same item
            if (newIdx > this.lastVisibleItemIdx()) {
                newIdx = idx;
            }
            if (newIdx >= 0) {
                e.preventDefault();
                e.stopPropagation();
                pro_gallery_lib_1.utils.setStateAndLog(this, 'Set Gallery Current Item', {
                    activeIndex: newIdx,
                });
                return false;
            }
        }
        return true;
    }
    lastVisibleItemIdxInHeight(height) {
        for (let i = this.props.galleryStructure.items.length - 1; i >= 0; i--) {
            const item = this.props.galleryStructure.items[i];
            const isVisible = item.offset.top < height;
            if (isVisible) {
                return i;
            }
        }
        return this.items.length - 1;
    }
    lastVisibleItemIdx() {
        let galleryHeight = this.props.displayShowMore ? this.props.container.height : this.props.galleryStructure.height;
        //the item must be visible and above the show more button
        return this.lastVisibleItemIdxInHeight(galleryHeight - 100);
    }
    showMoreItems() {
        var _a;
        if ((_a = this.props.settings) === null || _a === void 0 ? void 0 : _a.isAccessible) {
            // tal - I left this check since we do not want to focus the last item in non-accessibility mode
            //find the last visible item and focus on it
            try {
                const lastItemIdx = this.lastVisibleItemIdx();
                pro_gallery_lib_1.utils.setStateAndLog(this, 'Focus on Last Gallery Item', {
                    activeIndex: lastItemIdx + 1,
                }, () => {
                    this.props.actions.toggleLoadMoreItems();
                });
            }
            catch (e) {
                console.warn('showMoreItems: Cannot find item to focus', e);
            }
        }
        else {
            this.props.actions.toggleLoadMoreItems();
        }
    }
    onLoadMoreButtonKeyDown(e) {
        switch (e.keyCode || e.charCode) {
            case 32: // space
            case 13: // enter
                e.preventDefault();
                e.stopPropagation();
                return false;
            default:
                break;
        }
    }
    onLoadMoreButtonKeyUp(e) {
        switch (e.keyCode || e.charCode) {
            case 32: // space
            case 13: // enter
                e.stopPropagation();
                pro_gallery_lib_1.utils.setStateAndLog(this, 'Set Gallery Current Item', {
                    activeIndex: this.lastVisibleItemIdx(),
                });
                // this is to make sure that the focus is moved to the items first before the "load more" button disappears
                // other wise the gallery will lose focus to the body
                setTimeout(() => {
                    this.props.actions.toggleLoadMoreItems();
                }, 0);
                return false;
            default:
                break;
        }
    }
    createGallery(showMore) {
        var _a;
        const { options, settings, container, galleryStructure, getVisibleItems, virtualizationSettings, scrollTop } = this.props;
        const galleryConfig = this.createGalleryConfig();
        const showMoreContainerHeight = 138; //according to the scss
        const debugMsg = react_1.default.createElement(galleryDebugMessage_js_1.default, Object.assign({}, this.props.debug));
        let galleryHeight;
        if (showMore) {
            galleryHeight = container.galleryHeight - showMoreContainerHeight;
        }
        else {
            galleryHeight = galleryStructure.height + 'px';
        }
        const galleryWidth = this.props.isPrerenderMode
            ? 'auto'
            : this.props.container.galleryWidth - options[pro_gallery_lib_1.optionsMap.layoutParams.structure.itemSpacing];
        const items = getVisibleItems(galleryStructure.galleryItems, container, this.props.isPrerenderMode);
        const itemsWithVirtualizationData = (0, virtualization_js_1.getItemsInViewportOrMarginByScrollLocation)({
            items,
            options,
            virtualizationSettings,
            galleryHeight: Math.min(galleryStructure.height, ((_a = container.screen) === null || _a === void 0 ? void 0 : _a.height) || galleryStructure.height),
            scrollPosition: scrollTop || 0,
        });
        const layout = itemsWithVirtualizationData.map(({ item, shouldRender }, index) => {
            const itemProps = item.renderProps(Object.assign(Object.assign({}, galleryConfig), { visible: item.isVisible, key: `itemView-${item.id}-${index}` }));
            return react_1.default.createElement(itemView_js_1.default, Object.assign(Object.assign({}, itemProps), { type: shouldRender ? itemProps.type : 'dummy' }));
        });
        return (react_1.default.createElement("div", { id: this.props.galleryContainerId, className: 'pro-gallery inline-styles ' +
                (options[pro_gallery_lib_1.optionsMap.layoutParams.structure.scrollDirection] ===
                    pro_gallery_lib_1.GALLERY_CONSTS[pro_gallery_lib_1.optionsMap.layoutParams.structure.scrollDirection].HORIZONTAL
                    ? ' one-row slider hide-scrollbars '
                    : '') +
                ((settings === null || settings === void 0 ? void 0 : settings.isAccessible) ? ' accessible ' : '') +
                (options[pro_gallery_lib_1.optionsMap.behaviourParams.gallery.layoutDirection] ===
                    pro_gallery_lib_1.GALLERY_CONSTS[pro_gallery_lib_1.optionsMap.behaviourParams.gallery.layoutDirection].RIGHT_TO_LEFT
                    ? ' rtl '
                    : ' ltr '), style: {
                height: galleryHeight,
                overflowX: 'hidden',
                //  width: this.props.container.galleryWidth,
            }, onKeyDown: this.handleKeys },
            react_1.default.createElement("div", { id: `pro-gallery-margin-container-${this.props.id}`, className: 'pro-gallery-margin-container', style: {
                    margin: (this.props.options.galleryMargin ||
                        this.props.options[pro_gallery_lib_1.optionsMap.layoutParams.structure.gallerySpacing]) + 'px',
                    height: galleryHeight,
                    width: galleryWidth,
                    overflow: 'visible',
                    position: 'relative',
                } },
                debugMsg,
                layout)));
    }
    createGalleryConfig() {
        return {
            scrollingElement: this.props.scrollingElement,
            scroll: this.props.scroll,
            container: this.props.container,
            options: this.props.options,
            settings: this.props.settings,
            activeIndex: this.state.activeIndex,
            customComponents: this.props.customComponents,
            galleryId: this.props.id,
            gotFirstScrollEvent: this.props.gotFirstScrollEvent,
            playingVideoIdx: this.props.playingVideoIdx,
            playing3DIdx: this.props.playing3DIdx,
            noFollowForSEO: this.props.noFollowForSEO,
            isPrerenderMode: this.props.isPrerenderMode,
            firstUserInteractionExecuted: this.props.firstUserInteractionExecuted,
            enableExperimentalFeatures: this.props.enableExperimentalFeatures,
            actions: {
                eventsListener: this.props.actions.eventsListener,
            },
        };
    }
    screenLogs() {
        return pro_gallery_lib_1.utils.shouldDebug('screenLogs') ? (react_1.default.createElement("div", { className: "screen-logs" },
            "URL width: ",
            pro_gallery_lib_1.utils.parseGetParam('width'),
            ", Container: ",
            JSON.stringify(this.props.container.galleryWidth),
            ", window.document.body.clientWidth ",
            document.body.clientWidth,
            ", window.innerWidth ",
            pro_gallery_lib_1.window.innerWidth,
            ", window.screen.width: ",
            pro_gallery_lib_1.window.screen.width)) : ('');
    }
    createShowMoreButton() {
        if (typeof this.props.customComponents.customLoadMoreRenderer === 'function') {
            return react_1.default.createElement("div", { onClick: this.showMoreItems }, this.props.customComponents.customLoadMoreRenderer(this.props));
        }
        const { options } = this.props;
        let showMoreButton = false;
        const buttonState = this.props.displayShowMore;
        const shouldShowButton = buttonState && this.props.galleryStructure.height > this.props.container.height;
        if (shouldShowButton) {
            const buttonText = options[pro_gallery_lib_1.optionsMap.behaviourParams.gallery.vertical.loadMore.text] || 'Load More';
            showMoreButton = (react_1.default.createElement("div", { className: 'show-more-container' + (pro_gallery_lib_1.utils.isMobile() ? ' pro-gallery-mobile-indicator' : '') },
                react_1.default.createElement("button", { tabIndex: pro_gallery_lib_1.utils.getTabIndex('loadMoreButton'), id: 'show-more-' + this.props.id, className: "show-more", onClick: this.showMoreItems, onMouseDown: (e) => e.preventDefault(), "data-hook": "show-more", "aria-label": buttonText, onKeyDown: this.onLoadMoreButtonKeyDown, onKeyUp: this.onLoadMoreButtonKeyUp }, buttonText)));
        }
        return showMoreButton;
    }
    //-----------------------------------------| RENDER |--------------------------------------------//
    render() {
        if (pro_gallery_lib_1.utils.isVerbose()) {
            console.count('galleryView render');
            console.time('Rendering Gallery took ');
            console.log('[DEBUG_RENDER] GalleryView options', this.props.options);
            console.log('[DEBUG_RENDER] GalleryView props changed', pro_gallery_lib_1.utils.printableObjectsDiff(this.lastProps || {}, this.props));
            this.lastProps = Object.assign({}, this.props);
            console.log('[DEBUG_RENDER] GalleryView state changed', pro_gallery_lib_1.utils.printableObjectsDiff(this.lastState || {}, this.state));
            this.lastState = Object.assign({}, this.state);
            this.renderCount = (this.renderCount || 0) + 1;
        }
        const showMore = this.createShowMoreButton();
        const gallery = this.createGallery(showMore);
        if (pro_gallery_lib_1.utils.isVerbose()) {
            console.timeEnd('Rendering Gallery took ');
        }
        const screenLogs = this.screenLogs();
        return (react_1.default.createElement("div", Object.assign({ className: 'pro-gallery-parent-container', key: `pro-gallery-${this.id}` }, pro_gallery_lib_1.utils.getAriaAttributes({
            proGalleryRole: this.props.proGalleryRole,
            proGalleryRegionLabel: this.props.proGalleryRegionLabel,
        })),
            screenLogs,
            gallery,
            showMore));
    }
}
exports.default = GalleryView;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=galleryView.js.map