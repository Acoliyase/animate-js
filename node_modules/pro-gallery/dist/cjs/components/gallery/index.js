"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const pro_gallery_lib_1 = require("pro-gallery-lib");
const pro_gallery_blueprints_1 = require("pro-gallery-blueprints");
const proGallery_js_1 = tslib_1.__importDefault(require("./proGallery/proGallery.js"));
const shouldValidate_js_1 = tslib_1.__importDefault(require("./typeValidator/shouldValidate.js"));
const viewModeWrapper_js_1 = require("./proGallery/viewModeWrapper.js");
class Gallery extends react_1.default.Component {
    constructor(props) {
        super(props);
        this.isUsingCustomInfoElements = this.isUsingCustomInfoElements.bind(this);
        this.blueprintsManager = new pro_gallery_blueprints_1.BlueprintsManager({ id: 'layoutingGallery' });
        this.blueprintsManager.init({
            deviceType: props.deviceType,
            api: {
                isUsingCustomInfoElements: this.isUsingCustomInfoElements,
                fetchMoreItems: (from) => {
                    typeof props.eventsListener === 'function' &&
                        props.eventsListener(pro_gallery_lib_1.GALLERY_CONSTS.events.NEED_MORE_ITEMS, from);
                },
                onBlueprintReady: ({ blueprint, blueprintChanged, initialBlueprint }) => {
                    if (blueprintChanged) {
                        this.setBlueprint(blueprint, initialBlueprint);
                    }
                    else {
                        if (pro_gallery_lib_1.utils.isVerbose()) {
                            console.count('>>> Blueprint not changed, not setting it');
                        }
                    }
                },
            },
        });
        this.onNewProps(props, true);
        this.state = {
            blueprint: this.blueprintsManager.createInitialBlueprint(props) || null,
        };
    }
    setBlueprint(blueprint, initialBlueprint) {
        if (initialBlueprint) {
            // the blueprint from the initial blueprint flow will be set in the constructor
        }
        else {
            this.setState({ blueprint });
        }
    }
    isUsingCustomInfoElements() {
        return (!!this.galleryProps.customComponents.customHoverRenderer ||
            !!this.galleryProps.customComponents.customInfoRenderer);
    }
    onNewProps(props, calledByConstructor) {
        const { eventsListener } = props, otherProps = tslib_1.__rest(props, ["eventsListener"]);
        const _eventsListener = (eventName, eventData, event) => {
            if (eventName === pro_gallery_lib_1.GALLERY_CONSTS.events.NEED_MORE_ITEMS) {
                this.blueprintsManager.getMoreItems(eventData);
            }
            else {
                typeof eventsListener === 'function' && eventsListener(eventName, eventData, event);
            }
        };
        this.galleryProps = Object.assign(Object.assign({}, otherProps), { eventsListener: _eventsListener, id: props.id || 'default-dom-id', customComponents: props.customComponents || {} });
        if (calledByConstructor) {
            // the blueprint will be initiated with the state
        }
        else {
            this.blueprintsManager.createBlueprint(this.galleryProps).catch((e) => {
                //TODOVER3 check totalItemsCount
                console.error('Could not create a blueprint from the new props', e);
            });
        }
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        this.onNewProps(newProps, false);
    }
    render() {
        const { blueprint, typeErrors } = this.state;
        if (typeErrors) {
            return typeErrors;
        }
        if (blueprint && Object.keys(blueprint).length > 0) {
            return react_1.default.createElement(proGallery_js_1.default, Object.assign({}, this.galleryProps, blueprint));
        }
        else {
            return null;
        }
    }
    async componentDidMount() {
        if ((0, shouldValidate_js_1.default)(this.props, pro_gallery_lib_1.utils.isSSR()) === false) {
            return;
        }
        const validateTypesModule = await Promise.resolve().then(() => tslib_1.__importStar(require(
        /* webpackChunkName: "proGallery_validateTypes" */ './typeValidator/validateTypes.js')));
        const { validate, typeErrorsUI } = validateTypesModule;
        const typeErrors = validate(this.state.blueprint.options);
        if (typeErrors.length > 0) {
            this.setState({ typeErrors: typeErrorsUI(typeErrors) });
        }
    }
}
exports.default = (0, viewModeWrapper_js_1.ViewModeWrapperHOC)(Gallery);
//# sourceMappingURL=index.js.map