"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNumber = exports.isEqual = exports.isFunction = exports.get = exports.debounce = exports.throttle = exports.pick = void 0;
const pick = (obj, keys) => {
    const res = {};
    Object.entries(obj || {}).forEach(([key, val]) => {
        if (keys.indexOf(key) >= 0) {
            res[key] = val;
        }
    });
    return res;
};
exports.pick = pick;
const throttle = (callback, limit) => {
    let wait = false;
    let callAfterWait = false;
    return (...args) => {
        if (!wait) {
            callAfterWait = false;
            callback.apply(this, args);
            wait = true;
            setTimeout(() => {
                callAfterWait && callback.apply(this, args);
                wait = false;
            }, limit);
        }
        else {
            callAfterWait = true;
        }
    };
};
exports.throttle = throttle;
const debounce = (callback, wait) => {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            callback.apply(this, args);
        }, wait);
    };
};
exports.debounce = debounce;
const get = (obj, path, defaultValue) => {
    const result = String.prototype.split
        .call(path, /[,[\].]+?/)
        .filter(Boolean)
        .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);
    return result === undefined || result === obj ? defaultValue : result;
};
exports.get = get;
const isFunction = (something) => typeof something === 'function';
exports.isFunction = isFunction;
const isEqual = (obj1, obj2) => {
    try {
        return JSON.stringify(obj1) === JSON.stringify(obj2);
    }
    catch (e) {
        return false;
    }
};
exports.isEqual = isEqual;
const isNumber = (n) => {
    return !isNaN(parseFloat(n)) && isFinite(n);
};
exports.isNumber = isNumber;
//# sourceMappingURL=lodash.js.map