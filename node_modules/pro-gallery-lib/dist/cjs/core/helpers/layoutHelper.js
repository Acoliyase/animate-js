"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeBordersIfNeeded = exports.processNumberOfImagesPerCol = exports.processGridStyle = exports.fixColumnsIfNeeded = exports.processNumberOfImagesPerRow = exports.calcTargetItemSize = void 0;
const tslib_1 = require("tslib");
/* eslint-disable prettier/prettier */
const index_js_1 = tslib_1.__importDefault(require("../../common/utils/index.js"));
const windowWrapper_js_1 = tslib_1.__importDefault(require("../../common/window/windowWrapper.js"));
const layoutParams_info_placement_js_1 = require("../../common/constants/layoutParams_info_placement.js");
const index_js_2 = tslib_1.__importDefault(require("../../common/constants/index.js"));
const textBoxDimensionsHelper_js_1 = tslib_1.__importDefault(require("./textBoxDimensionsHelper.js"));
const behaviourParams_gallery_horizontal_slideAnimation_js_1 = tslib_1.__importDefault(require("../../settings/options/behaviourParams_gallery_horizontal_slideAnimation.js"));
const layoutParams_navigationArrows_position_js_1 = tslib_1.__importDefault(require("../../settings/options/layoutParams_navigationArrows_position.js"));
const optionsMap_js_1 = tslib_1.__importDefault(require("./optionsMap.js"));
const calcTargetItemSize = (options, smartValue) => {
    if (options[optionsMap_js_1.default.layoutParams.targetItemSize.unit] === index_js_2.default[optionsMap_js_1.default.layoutParams.targetItemSize.unit].PIXEL &&
        options[optionsMap_js_1.default.layoutParams.targetItemSize.value] > 0) {
        return options[optionsMap_js_1.default.layoutParams.targetItemSize.value];
    }
    else if (options[optionsMap_js_1.default.layoutParams.targetItemSize.unit] === index_js_2.default[optionsMap_js_1.default.layoutParams.targetItemSize.unit].PERCENT &&
        options[optionsMap_js_1.default.layoutParams.targetItemSize.value] > 0) {
        return (((windowWrapper_js_1.default && windowWrapper_js_1.default.innerWidth) || 980) * (options[optionsMap_js_1.default.layoutParams.targetItemSize.value] / 100));
    }
    else if (smartValue > 0) {
        return smartValue;
    }
    else {
        return options[optionsMap_js_1.default.layoutParams.targetItemSize.value];
    }
};
exports.calcTargetItemSize = calcTargetItemSize;
const processNumberOfImagesPerRow = (options) => {
    //This will be used in the masonry and grid presets
    let res = Object.assign({}, options);
    res = (0, exports.fixColumnsIfNeeded)(res);
    if (res[optionsMap_js_1.default.layoutParams.structure.scrollDirection] ===
        index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].VERTICAL || //relevant for grid, in Masonry its fixed to !oneRow
        res[optionsMap_js_1.default.layoutParams.structure.layoutOrientation] ===
            index_js_2.default[optionsMap_js_1.default.layoutParams.structure.layoutOrientation].VERTICAL //relevant for masonry, in grid its fixed to vertical.
    ) {
        res[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes] = [
            index_js_2.default[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes]['1'],
        ];
        res[optionsMap_js_1.default.layoutParams.groups.groupSize] = 1;
        // res.collageAmount = 0; //doesnt really exist. I'll comment and then remove.
        res[optionsMap_js_1.default.layoutParams.groups.density] = 0;
    }
    return res;
};
exports.processNumberOfImagesPerRow = processNumberOfImagesPerRow;
const fixColumnsIfNeeded = (options) => {
    let res = Object.assign({}, options);
    res.fixedColumns = 0;
    if (res[optionsMap_js_1.default.layoutParams.structure.scrollDirection] ===
        index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].VERTICAL || //relevant for grid, in Masonry its fixed to !oneRow
        res[optionsMap_js_1.default.layoutParams.structure.layoutOrientation] ===
            index_js_2.default[optionsMap_js_1.default.layoutParams.structure.layoutOrientation].VERTICAL //relevant for masonry, in grid its fixed to vertical.
    ) {
        res.fixedColumns = // a layouter thing
            options[optionsMap_js_1.default.layoutParams.structure.responsiveMode] === index_js_2.default[optionsMap_js_1.default.layoutParams.structure.responsiveMode].SET_ITEMS_PER_ROW
                ? res[optionsMap_js_1.default.layoutParams.structure.numberOfColumns]
                : 0;
    }
    return res;
};
exports.fixColumnsIfNeeded = fixColumnsIfNeeded;
const processGridStyle = (options) => {
    let res = Object.assign({}, options);
    const isVerticalOrientation = res[optionsMap_js_1.default.layoutParams.structure.layoutOrientation] ===
        index_js_2.default[optionsMap_js_1.default.layoutParams.structure.layoutOrientation]
            .VERTICAL;
    res[optionsMap_js_1.default.layoutParams.structure.responsiveMode] =
        isVerticalOrientation ? options[optionsMap_js_1.default.layoutParams.structure.responsiveMode] : index_js_2.default[optionsMap_js_1.default.layoutParams.structure.responsiveMode].FIT_TO_SCREEN;
    return res;
};
exports.processGridStyle = processGridStyle;
const processNumberOfImagesPerCol = (options) => {
    //This will be used in the grid preset
    let res = Object.assign({}, options);
    if (!index_js_1.default.isUndefined(options[optionsMap_js_1.default.layoutParams.structure.numberOfGridRows]) &&
        options[optionsMap_js_1.default.layoutParams.structure.scrollDirection] ===
            index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].HORIZONTAL) {
        res[optionsMap_js_1.default.layoutParams.structure.numberOfColumns] = 0;
        switch (options[optionsMap_js_1.default.layoutParams.structure.numberOfGridRows]) {
            case 1:
            default:
                res[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes] = [
                    index_js_2.default[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes]['1'],
                ];
                res[optionsMap_js_1.default.layoutParams.groups.groupSize] = 1;
                // res.collageAmount = 0;
                res[optionsMap_js_1.default.layoutParams.groups.density] = 0;
                break;
            case 2:
                res[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes] = [
                    index_js_2.default[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes]['2v'],
                ];
                res[optionsMap_js_1.default.layoutParams.groups.groupSize] = 2;
                // res.collageAmount = 1;
                res[optionsMap_js_1.default.layoutParams.groups.density] = 1;
                break;
            case 3:
                res[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes] = [
                    index_js_2.default[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes]['3v'],
                ];
                res[optionsMap_js_1.default.layoutParams.groups.groupSize] = 3;
                // res.collageAmount = 1;
                res[optionsMap_js_1.default.layoutParams.groups.density] = 1;
                break;
        }
    }
    return res;
};
exports.processNumberOfImagesPerCol = processNumberOfImagesPerCol;
const forceInfoOnHoverWhenNeeded = (options) => {
    let _options = Object.assign({}, options);
    if (!index_js_2.default.isLayout('SLIDER')(_options) && //not slider
        !index_js_2.default.isLayout('COLUMN')(_options) && //not columns
        !index_js_2.default.isLayout('SLIDESHOW')(_options) //not columns
    ) {
        if ((_options[optionsMap_js_1.default.layoutParams.structure.layoutOrientation] === index_js_2.default[optionsMap_js_1.default.layoutParams.structure.layoutOrientation].HORIZONTAL || //layout orientation is horizontal
            _options[optionsMap_js_1.default.layoutParams.groups.groupSize] > 1) //groups are larger than one (items can be on top or right left of eachother)
        ) {
            // Dont allow info placement to be external
            _options[optionsMap_js_1.default.layoutParams.info.placement] = index_js_2.default[optionsMap_js_1.default.layoutParams.info.placement].OVERLAY;
        }
    }
    return _options;
};
const forceHoverToShowTextsIfNeeded = (options) => {
    let _options = Object.assign({}, options);
    if (options.EXPERIMENTALallowParallelInfos)
        return _options;
    if (!(0, layoutParams_info_placement_js_1.hasHoverPlacement)(_options[optionsMap_js_1.default.layoutParams.info.placement]) &&
        _options[optionsMap_js_1.default.behaviourParams.item.overlay.hoveringBehaviour] !== index_js_2.default[optionsMap_js_1.default.behaviourParams.item.overlay.hoveringBehaviour].NEVER_SHOW) {
        _options[optionsMap_js_1.default.behaviourParams.item.overlay.hoveringBehaviour] = index_js_2.default[optionsMap_js_1.default.behaviourParams.item.overlay.hoveringBehaviour].APPEARS;
    }
    return _options;
};
const blockScrollOnFadeOrDeckScrollAnimations = (options) => {
    let _options = Object.assign({}, options);
    if ((options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideAnimation] === index_js_2.default[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideAnimation].FADE ||
        options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideAnimation] === index_js_2.default[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideAnimation].DECK) && (behaviourParams_gallery_horizontal_slideAnimation_js_1.default.isRelevant(options))) {
        _options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.blockScroll] = true;
    }
    return _options;
};
const blockVideoControlsOnMouseCursorNavigation = (options) => {
    let _options = Object.assign({}, options);
    if ((options[optionsMap_js_1.default.layoutParams.navigationArrows.position] === index_js_2.default[optionsMap_js_1.default.layoutParams.navigationArrows.position].MOUSE_CURSOR) && (layoutParams_navigationArrows_position_js_1.default.isRelevant(options))) {
        _options[optionsMap_js_1.default.behaviourParams.item.video.enableControls] = false;
    }
    return _options;
};
const blockMouseCursorNavigationOnTouchDevice = (options) => {
    let _options = Object.assign({}, options);
    if (index_js_1.default.isTouch() && (options[optionsMap_js_1.default.layoutParams.navigationArrows.position] === index_js_2.default[optionsMap_js_1.default.layoutParams.navigationArrows.position].MOUSE_CURSOR) && (layoutParams_navigationArrows_position_js_1.default.isRelevant(options))) {
        _options[optionsMap_js_1.default.layoutParams.navigationArrows.enable] = false;
    }
    return _options;
};
const removeShadowOnHorizontalGalleries = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.stylingParams.itemEnableShadow] && _options[optionsMap_js_1.default.layoutParams.structure.scrollDirection] === index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].HORIZONTAL) {
        _options[optionsMap_js_1.default.stylingParams.itemEnableShadow] = false;
    }
    return _options;
};
const forceHorizontalOrientationInHorizontalGalleries = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.layoutParams.structure.scrollDirection] === index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].HORIZONTAL) {
        // in horizontal galleries allow only horizontal orientation
        _options[optionsMap_js_1.default.layoutParams.structure.layoutOrientation] = index_js_2.default[optionsMap_js_1.default.layoutParams.structure.layoutOrientation].HORIZONTAL;
    }
    return _options;
};
const removeLoopOnVerticalGalleries = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.layoutParams.structure.scrollDirection] === index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].VERTICAL) {
        _options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.loop] = false; // allow loop only for horizontal layouts
    }
    return _options;
};
const limitImageMargin = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.layoutParams.structure.itemSpacing] > 0) {
        _options[optionsMap_js_1.default.layoutParams.structure.itemSpacing] = Math.min(_options[optionsMap_js_1.default.layoutParams.structure.itemSpacing], 50); // limit mobile spacing to 50px (25 on each side)
    }
    return _options;
};
const forceScrollAnimationOnSingleImageInViewGalleries = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.layoutParams.structure.scrollDirection] === index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].VERTICAL ||
        _options[optionsMap_js_1.default.layoutParams.groups.groupSize] > 1 ||
        !_options[optionsMap_js_1.default.layoutParams.crop.enable]) {
        _options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideAnimation] = index_js_2.default[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideAnimation].SCROLL;
    }
    return _options;
};
const removeArrowPaddingIfOutsideTheGallery = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.layoutParams.navigationArrows.position] === index_js_2.default[optionsMap_js_1.default.layoutParams.navigationArrows.position].OUTSIDE_GALLERY) {
        _options[optionsMap_js_1.default.layoutParams.navigationArrows.padding] = 0;
    }
    return _options;
};
const processLoadMoreButtonFont = (options) => {
    let _options = Object.assign({}, options);
    if (_options.loadMoreButtonFont && index_js_1.default.isMobile()) {
        _options.loadMoreButtonFont.value =
            _options.loadMoreButtonFont.value.replace(/^font\s*:\s*/, '');
        _options.loadMoreButtonFont.value =
            _options.loadMoreButtonFont.value.replace(/;$/, '');
        if (_options.loadMoreButtonFont.value.indexOf('underline') > -1) {
            _options.loadMoreButtonFont.value =
                _options.loadMoreButtonFont.value.replace('underline', '');
            _options.textDecorationLoadMore = 'underline';
        }
        else {
            _options.textDecorationLoadMore = 'none';
        }
    }
    return _options;
};
const blockCounterByProduct = (options) => {
    let _options = Object.assign({}, options);
    if (!_options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideshowInfo.enableCounter]) {
        return _options;
    }
    if (_options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.autoSlide.behaviour] === index_js_2.default[optionsMap_js_1.default.behaviourParams.gallery.horizontal.autoSlide.behaviour].OFF) {
        _options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideshowInfo.enableCounter] = false;
    }
    if (index_js_2.default.isLayout('SLIDESHOW')(options) === false) {
        _options[optionsMap_js_1.default.behaviourParams.gallery.horizontal.slideshowInfo.enableCounter] = false;
    }
    return _options;
};
const addMarginsToSupportShadows = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.stylingParams.itemEnableShadow] && _options[optionsMap_js_1.default.layoutParams.structure.scrollDirection] === index_js_2.default[optionsMap_js_1.default.layoutParams.structure.scrollDirection].VERTICAL) {
        // add gallerySpacing to allow the shadow to be seen
        _options[optionsMap_js_1.default.layoutParams.structure.gallerySpacing] = Math.max(_options[optionsMap_js_1.default.layoutParams.structure.gallerySpacing], (_options[optionsMap_js_1.default.stylingParams.itemShadowSize] || 0) +
            (_options[optionsMap_js_1.default.stylingParams.itemShadowBlur] || 0));
    }
    return _options;
};
const centerArrowsWhenNeeded = (options) => {
    let _options = Object.assign({}, options);
    const isSingleVerticalItemRendered = _options[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes].length >= 1 ?
        _options[optionsMap_js_1.default.layoutParams.groups.allowedGroupTypes].join('') === '1' : false;
    const filteredPlacement = _options[optionsMap_js_1.default.layoutParams.info.placement] // filtering hover since it doesn't affect this product
        .split(',')
        .filter(placement => !(0, layoutParams_info_placement_js_1.isHoverPlacement)(placement))
        .join(',');
    if (!(0, layoutParams_info_placement_js_1.isConstantVerticalPlacement)(filteredPlacement) ||
        !isSingleVerticalItemRendered) {
        // if text (info) placement is not above/below placement or more then 1 images per col, arrows are gallery("item") centered
        _options[optionsMap_js_1.default.layoutParams.navigationArrows.verticalAlignment] = index_js_2.default[optionsMap_js_1.default.layoutParams.navigationArrows.verticalAlignment].ITEM_CENTER;
    }
    return _options;
};
const removeBordersIfNeeded = (options) => {
    //TODO this can go into the _optionspective 4 layouts.
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.layoutParams.crop.method] ===
        index_js_2.default[optionsMap_js_1.default.layoutParams.crop.method].FIT) {
        _options[optionsMap_js_1.default.stylingParams.itemBorderWidth] = 0;
        _options[optionsMap_js_1.default.stylingParams.itemBorderRadius] = 0;
        _options[optionsMap_js_1.default.stylingParams.itemEnableShadow] = false;
    }
    return _options;
};
exports.removeBordersIfNeeded = removeBordersIfNeeded;
const cropItemsWithCropOnlyFillParam = (options) => {
    let _options = Object.assign({}, options);
    if (_options[optionsMap_js_1.default.layoutParams.crop.cropOnlyFill]) {
        _options[optionsMap_js_1.default.layoutParams.crop.enable] =
            _options[optionsMap_js_1.default.layoutParams.crop.method] === index_js_2.default[optionsMap_js_1.default.layoutParams.crop.method].FILL;
    }
    return _options;
};
function processLayouts(options, customExternalInfoRendererExists) {
    let processedOptions = Object.assign({}, options);
    if (index_js_1.default.isMobile()) {
        processedOptions = limitImageMargin(processedOptions);
    }
    processedOptions = forceInfoOnHoverWhenNeeded(processedOptions);
    processedOptions = forceHoverToShowTextsIfNeeded(processedOptions);
    processedOptions = removeShadowOnHorizontalGalleries(processedOptions);
    processedOptions = addMarginsToSupportShadows(processedOptions);
    processedOptions = removeArrowPaddingIfOutsideTheGallery(processedOptions);
    processedOptions = forceHorizontalOrientationInHorizontalGalleries(processedOptions);
    processedOptions = removeLoopOnVerticalGalleries(processedOptions);
    processedOptions = forceScrollAnimationOnSingleImageInViewGalleries(processedOptions);
    processedOptions = processLoadMoreButtonFont(processedOptions); // NEW STYPEPARAMS METHOD - should be removed but currently supported//contains if isMobile, but also has an else.
    processedOptions = (0, textBoxDimensionsHelper_js_1.default)(processedOptions, customExternalInfoRendererExists);
    processedOptions = centerArrowsWhenNeeded(processedOptions);
    processedOptions = blockCounterByProduct(processedOptions);
    processedOptions = blockScrollOnFadeOrDeckScrollAnimations(processedOptions);
    processedOptions = blockVideoControlsOnMouseCursorNavigation(processedOptions);
    processedOptions = blockMouseCursorNavigationOnTouchDevice(processedOptions);
    processedOptions = cropItemsWithCropOnlyFillParam(processedOptions);
    return processedOptions;
}
exports.default = processLayouts;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=layoutHelper.js.map