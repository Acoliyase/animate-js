"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemsHelper = void 0;
const tslib_1 = require("tslib");
const galleryItem_js_1 = tslib_1.__importDefault(require("./galleryItem.js"));
const galleryGroup_js_1 = tslib_1.__importDefault(require("./galleryGroup.js"));
const pro_gallery_lib_1 = require("pro-gallery-lib");
class ItemsHelper {
    static convertDtoToLayoutItem(dto) {
        const isLayoutItem = !!(dto.id && dto.width > 0 && dto.height > 0);
        if (isLayoutItem) {
            return dto;
        }
        else {
            const dtoMetadata = dto.metadata || dto.metaData;
            const metadata = typeof dtoMetadata === 'object' ? dtoMetadata : pro_gallery_lib_1.utils.parseStringObject(dtoMetadata) || {};
            return Object.assign({ id: dto.itemId || dto.photoId, width: metadata.width, height: metadata.height }, dto);
        }
    }
    static convertToGalleryItems(galleryStructure, itemConfig = {}, existingItems = []) {
        galleryStructure.galleryItems = [];
        for (let c = 0; c < galleryStructure.columns.length; c++) {
            const column = galleryStructure.columns[c];
            column.galleryGroups = [];
            const groups = column.groups || column;
            for (let g = 0; g < groups.length; g++) {
                const group = groups[g];
                const groupItems = [];
                for (let i = 0; i < group.items.length; i++) {
                    const item = group.items[i];
                    const _itemConfig = Object.assign({ scheme: item, dto: item.dto }, itemConfig);
                    const existingItem = existingItems[item.idx];
                    let newItem;
                    if (existingItem && existingItem.id && existingItem.id === item.id) {
                        newItem = existingItem;
                        newItem.update(_itemConfig);
                    }
                    else {
                        newItem = new galleryItem_js_1.default(_itemConfig);
                    }
                    groupItems[i] = newItem;
                    galleryStructure.galleryItems[item.idx] = groupItems[i];
                }
                column.galleryGroups[g] = new galleryGroup_js_1.default({
                    scheme: group,
                    dto: group.dto,
                    items: groupItems,
                });
            }
        }
        return galleryStructure;
    }
    static convertExistingStructureToGalleryItems(existingStructure, galleryStructure, itemConfig = {}) {
        // console.log('convertToGalleryItems', existingStructure.galleryItems);
        // console.count('convertToGalleryItems');
        if (pro_gallery_lib_1.utils.isVerbose()) {
            console.time('convertToGalleryItems');
        }
        if (!existingStructure.galleryItems) {
            existingStructure.galleryItems = [];
        }
        // remove last group so it will be rebuilt in case of dummy item
        const lastColumn = existingStructure.columns.slice(-1)[0];
        const lastGroup = lastColumn.galleryGroups.pop();
        lastGroup && existingStructure.galleryItems.splice(-lastGroup.items.length);
        for (let c = 0; c < galleryStructure.columns.length; c++) {
            const column = galleryStructure.columns[c];
            const existingColumn = existingStructure.columns[c] || column;
            if (!existingColumn.galleryGroups) {
                existingColumn.galleryGroups = [];
            }
            const groups = column.groups || column;
            for (let g = 0; g < groups.length; g++) {
                const group = groups[g];
                const groupItems = [];
                for (let i = 0; i < group.items.length; i++) {
                    const item = group.items[i];
                    if (!existingStructure.galleryItems[item.idx]) {
                        // console.count(`convertToGalleryItems - item [${item.idx}]`);
                        groupItems[i] = new galleryItem_js_1.default(Object.assign({
                            scheme: item,
                            dto: item.dto,
                        }, itemConfig));
                        existingStructure.galleryItems[item.idx] = groupItems[i];
                    }
                    else {
                        existingStructure.galleryItems[item.idx].processScheme(item);
                    }
                }
                if (!existingColumn.galleryGroups[g]) {
                    // console.count(`convertToGalleryItems - group [${g}]`);
                    existingColumn.galleryGroups[g] = new galleryGroup_js_1.default({
                        scheme: group,
                        dto: group.dto,
                        items: groupItems,
                    });
                }
                else {
                    existingColumn.galleryGroups[g].processScheme(group);
                }
            }
            column.galleryGroups = existingColumn.galleryGroups;
        }
        galleryStructure.galleryItems = existingStructure.galleryItems;
        if (pro_gallery_lib_1.utils.isVerbose()) {
            console.timeEnd('convertToGalleryItems');
        }
        return galleryStructure;
    }
}
exports.ItemsHelper = ItemsHelper;
//# sourceMappingURL=itemsHelper.js.map