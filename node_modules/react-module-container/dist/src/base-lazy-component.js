"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports["default"] = void 0;
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _moduleRegistry = _interopRequireDefault(require("./module-registry"));
var _tagAppender = require("./tag-appender");
var _assign = _interopRequireDefault(require("lodash/assign"));
var _ReactModuleContainerErrors = require("./ReactModuleContainerErrors");
var _context = require("./context");
var BaseLazyComponent = exports["default"] = /*#__PURE__*/function (_React$Component) {
  (0, _inheritsLoose2["default"])(BaseLazyComponent, _React$Component);
  function BaseLazyComponent(props, manifest) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.manifest = manifest;
    _this.fileNodes = [];
    return _this;
  }
  var _proto = BaseLazyComponent.prototype;
  _proto.hasSuspensePayload = function hasSuspensePayload() {
    var _this$context;
    return !!((_this$context = this.context) != null && _this$context.suspensePayload);
  };
  _proto.setupSuspensePayload = function setupSuspensePayload() {
    var _this$context2,
      _this2 = this;
    if (!((_this$context2 = this.context) != null && _this$context2.suspense)) {
      return;
    }
    var suspensePayload = this.context.suspensePayload = {};
    suspensePayload.promise = this.resourceLoader.then(function () {
      // Store the resolvedData from the suspended instance to be reloaded in the new component instance
      suspensePayload.resolvedData = _this2.resolvedData;
    });
  };
  _proto.handleSuspenseRender = function handleSuspenseRender() {
    var _this$context3;
    if (!((_this$context3 = this.context) != null && _this$context3.suspense)) {
      return;
    }
    var suspensePayload = this.context.suspensePayload;
    var isResolved = !!suspensePayload.resolvedData;
    if (!isResolved) {
      throw suspensePayload.promise;
    }

    // Promise is resolved, restore the data from the suspended instance to the instance
    if (!this.resolvedData) {
      this.resolvedData = suspensePayload.resolvedData;
      this.resourceLoader = suspensePayload.promise;
    }
  };
  _proto.getSuspensePayload = function getSuspensePayload() {
    var _this$context4;
    return (_this$context4 = this.context) == null ? void 0 : _this$context4.suspensePayload;
  };
  _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
    var _this3 = this;
    if (this.hasSuspensePayload()) {
      // All of this already happened, we just wait for the previous promise to resolve and we'll restore the needed state.
      return;
    }
    _moduleRegistry["default"].notifyListeners('reactModuleContainer.componentStartLoading', this.manifest.component);
    var prepare = this.manifest.prepare ? function () {
      return _this3.manifest.prepare();
    } : function () {
      return undefined;
    };
    var filesAppenderPromise = (0, _tagAppender.filesAppender)(this.manifest.files, this.manifest.crossorigin).then(function (fileNodes) {
      return Promise.resolve(prepare()).then(function () {
        return fileNodes;
      });
    });
    var resolvePromise = this.manifest.resolve ? this.manifest.resolve() : Promise.resolve({});
    this.resourceLoader = Promise.all([resolvePromise, filesAppenderPromise]).then(function (_ref) {
      var resolvedData = _ref[0],
        fileNodes = _ref[1];
      _this3.fileNodes = fileNodes;
      _this3.resolvedData = resolvedData;
      _moduleRegistry["default"].notifyListeners('reactModuleContainer.componentReady', _this3.manifest.component);
    })["catch"](function (err) {
      _moduleRegistry["default"].notifyListeners('reactModuleContainer.error', new _ReactModuleContainerErrors.LazyComponentLoadingError(_this3.manifest.component, err));
      _this3.setState({
        error: err
      });
    });

    // This component instance will be thrown away and a new one created when the promise is resolved.
    // Store the promise and reference to the data from this instance
    this.setupSuspensePayload();
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.manifest.unloadStylesOnDestroy !== false && this.fileNodes) {
      (0, _tagAppender.unloadStyles)(this.fileNodes);
    }
    _moduleRegistry["default"].notifyListeners('reactModuleContainer.componentWillUnmount', this.manifest.component);
  };
  _proto.renderComponent = function renderComponent(Component) {
    if (Component === void 0) {
      Component = this.state.component;
    }
    this.handleSuspenseRender();

    // Make sure any context does not propagate to any children (otherwise this can enter an infinite loop since it's working on the same payload instance)
    return Component ? /*#__PURE__*/_react["default"].createElement(_context.ReactModuleContainerContext.Provider, {
      value: null
    }, /*#__PURE__*/_react["default"].createElement(Component, this.mergedProps)) : null;
  };
  (0, _createClass2["default"])(BaseLazyComponent, [{
    key: "mergedProps",
    get: function get() {
      return (0, _assign["default"])({}, this.props, this.resolvedData);
    }
  }]);
  return BaseLazyComponent;
}(_react["default"].Component);
(0, _defineProperty2["default"])(BaseLazyComponent, "contextType", _context.ReactModuleContainerContext);