import { NonNullablePaths } from '@wix/sdk-types';

/**
 * A Policy is a set of terms and conditions attached to a specific event and shown during RSVP or checkout.
 *
 * You can use Policies to communicate refund, cancellation, and ticket-transfer rules by defining a policy name and body that attendees acknowledge.
 */
interface Policy {
    /**
     * Policy ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the policy is updated. The existing revision must be used when updating a policy to prevent conflicting changes. You'll get an error if you try to use the previous revision.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time when the policy was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time of the policy's latest update in.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Policy name that is visible in the dashboard and checkout form.
     *
     * Min: 1 character
     *
     * Max: 40 characters
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /**
     * Policy body, usually containing various terms and conditions.
     *
     * Min: 1 character
     *
     * Max: 50000 characters.
     *
     * **Note**: You can format text using various HTML tags such as `<p>`, `<b>`, `<ul>`, etc.
     * @minLength 1
     * @maxLength 50000
     */
    body?: string;
    /**
     * ID of the event to which the policy belongs.
     * @format GUID
     * @immutable
     */
    eventId?: string;
}
interface CreatePolicyRequest {
    /** Policy info. */
    policy: Policy;
}
interface CreatePolicyResponse {
    /** Created policy. */
    policy?: Policy;
}
interface UpdatePolicyRequest {
    /** Policy to update. */
    policy: Policy;
}
interface UpdatePolicyResponse {
    /** The updated policy. */
    policy?: Policy;
}
interface UpdatePolicySortIndexRequest {
    /**
     * ID of the policy.
     * @format GUID
     */
    policyId?: string;
    /** The revision of the event policy. */
    revision?: string;
    /** The sort index of a policy to set. */
    sortIndex?: number;
}
interface UpdatePolicySortIndexResponse {
    /** The updated event policy. */
    policy?: Policy;
}
interface DeletePolicyRequest {
    /**
     * ID of the policy to delete.
     * @format GUID
     */
    policyId: string;
}
interface DeletePolicyResponse {
}
interface QueryPoliciesRequest {
    /** Query options. See [API Query Langauge](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
    query: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Pagination options. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1", "fieldName2":{"$operator":"value2"} }`. <br/> <br/> **Example:** <br/> `"filter" : { "id": "2224a9d1-79e6-4549-a5c5-bf7ce5aac1a5", "revision": {"$ne":"1"} }` <br/> <br/> See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/policy-v2/filter-and-sort) for more information. */
    filter?: Record<string, any> | null;
    /** Sort object in the following format: <br/> `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]` <br/> <br/> **Example:** <br/> `[{"fieldName":"createdDate","direction":"DESC"}]` <br/> <br/> See [supported fields](https://dev.wix.com/api/rest/wix-events/policy-v2/filter-and-sort) for more information. */
    sort?: Sorting[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Pagination options. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 100
     */
    fieldName?: string;
    /** Sort order (ASC/DESC). Defaults to ASC */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load per page. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Number of items to load per page.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryPoliciesResponse {
    /** Event policies. */
    policies?: Policy[];
    /** Query result's metadata. */
    metadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
interface ReorderEventPoliciesRequest extends ReorderEventPoliciesRequestReferencePolicyOneOf {
    /**
     * Move the given `policyId` before the specified policy.
     * @format GUID
     */
    beforePolicyId?: string;
    /**
     * Move the given `policyId` after the specified policy.
     * @format GUID
     */
    afterPolicyId?: string;
    /**
     * Event ID.
     * @format GUID
     */
    eventId: string;
    /**
     * Event policy ID.
     * @format GUID
     */
    policyId: string;
}
/** @oneof */
interface ReorderEventPoliciesRequestReferencePolicyOneOf {
    /**
     *
     * @format GUID
     */
    beforePolicyId?: string;
    /**
     * Move the given `policyId` after the specified policy.
     * @format GUID
     */
    afterPolicyId?: string;
}
interface ReorderEventPoliciesResponse {
    /** Ordered event policies. */
    policies?: Policy[];
}
interface GetPolicyRequest {
    /**
     * Policy ID.
     * @format GUID
     */
    policyId: string;
}
interface GetPolicyResponse {
    /** The requested policy. */
    policy?: Policy;
}
interface EventCopied {
    /** Event created timestamp in ISO UTC format. */
    timestamp?: Date | null;
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /** Event location. */
    location?: Location;
    /** Event schedule configuration. */
    scheduleConfig?: ScheduleConfig;
    /** Event title. */
    title?: string;
    /**
     * Event creator user ID.
     * @format GUID
     */
    userId?: string | null;
    /** Event status. */
    status?: EventStatusWithLiterals;
    /**
     * Instance ID. Indicates the original app instance which current event was derived from.
     * @format GUID
     */
    derivedFromInstanceId?: string | null;
    /**
     * Event ID. Indicates the original event which current event was derived from.
     * @format GUID
     */
    derivedFromEventId?: string | null;
    /**
     * Map of copied ticket definitions from original event.
     * Key represents ticket def id in the original event.
     * Value represents ticket def id in the newly created event.
     */
    ticketDefinitions?: Record<string, string>;
}
interface Location {
    /**
     * Location name.
     * @maxLength 50
     */
    name?: string | null;
    /** Location map coordinates. */
    coordinates?: MapCoordinates;
    /**
     * Single line address representation.
     * @maxLength 300
     */
    address?: string | null;
    /** Location type. */
    type?: LocationTypeWithLiterals;
    /**
     * Full address derived from formatted single line `address`.
     * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
     * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
     *
     * Migration notes:
     * - `full_address.formatted_address` is equivalent to `address`.
     * - `full_address.geocode` is equivalent to `coordinates`.
     */
    fullAddress?: Address;
    /**
     * Defines event location as TBD (To Be Determined).
     * When event location is not yet defined, `name` is displayed instead of location address.
     * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
     */
    tbd?: boolean | null;
}
interface MapCoordinates {
    /**
     * Latitude.
     * @min -90
     * @max 90
     */
    lat?: number;
    /**
     * Longitude.
     * @min -180
     * @max 180
     */
    lng?: number;
}
declare enum LocationType {
    VENUE = "VENUE",
    ONLINE = "ONLINE"
}
/** @enumType */
type LocationTypeWithLiterals = LocationType | 'VENUE' | 'ONLINE';
/** Physical address */
interface Address extends AddressStreetOneOf {
    /** a break down of the street to number and street name */
    streetAddress?: StreetAddress;
    /** Main address line (usually street and number) as free text */
    addressLine1?: string | null;
    /**
     * country code
     * @format COUNTRY
     */
    country?: string | null;
    /** subdivision (usually state or region) code according to ISO 3166-2 */
    subdivision?: string | null;
    /** city name */
    city?: string | null;
    /** zip/postal code */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
    addressLine2?: string | null;
    /** A string containing the human-readable address of this location */
    formatted?: string | null;
    /** Free text for human-to-human textual orientation aid purposes */
    hint?: string | null;
    /** coordinates of the physical address */
    location?: AddressLocation;
    /** country full-name */
    countryFullname?: string | null;
    /**
     * multi-level subdivisions from top to bottom
     * @maxSize 6
     */
    subdivisions?: Subdivision[];
}
/** @oneof */
interface AddressStreetOneOf {
    /** a break down of the street to number and street name */
    streetAddress?: StreetAddress;
    /** Main address line (usually street and number) as free text */
    addressLine?: string | null;
}
interface StreetAddress {
    /** street number */
    number?: string;
    /** street name */
    name?: string;
}
interface AddressLocation {
    /**
     * address latitude coordinates
     * @min -90
     * @max 90
     */
    latitude?: number | null;
    /**
     * address longitude coordinates
     * @min -180
     * @max 180
     */
    longitude?: number | null;
}
interface Subdivision {
    /** subdivision short code */
    code?: string;
    /** subdivision full-name */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
interface ScheduleConfig {
    /**
     * Defines event as TBD (To Be Determined) schedule.
     * When event time is not yet defined, TBD message is displayed instead of event start and end times.
     * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
     */
    scheduleTbd?: boolean;
    /**
     * TBD message.
     * @maxLength 100
     */
    scheduleTbdMessage?: string | null;
    /** Event start timestamp. */
    startDate?: Date | null;
    /** Event end timestamp. */
    endDate?: Date | null;
    /**
     * Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`.
     * @maxLength 100
     */
    timeZoneId?: string | null;
    /** Whether end date is hidden in the formatted schedule. */
    endDateHidden?: boolean;
    /** Whether time zone is displayed in formatted schedule. */
    showTimeZone?: boolean;
    /** Event recurrences. */
    recurrences?: Recurrences;
}
interface Recurrences {
    /**
     * Event occurrences.
     * @maxSize 1000
     */
    occurrences?: Occurrence[];
    /**
     * Recurring event category ID.
     * @readonly
     */
    categoryId?: string | null;
    /**
     * Recurrence status.
     * @readonly
     */
    status?: StatusWithLiterals;
}
interface Occurrence {
    /** Event start timestamp. */
    startDate?: Date | null;
    /** Event end timestamp. */
    endDate?: Date | null;
    /**
     * Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`.
     * @maxLength 100
     */
    timeZoneId?: string | null;
    /** Whether time zone is displayed in formatted schedule. */
    showTimeZone?: boolean;
}
declare enum Status {
    /** Event occurs only once. */
    ONE_TIME = "ONE_TIME",
    /** Event is recurring. */
    RECURRING = "RECURRING",
    /** Marks the next upcoming occurrence of the recurring event. */
    RECURRING_NEXT = "RECURRING_NEXT",
    /** Marks the most recent ended occurrence of the recurring event. */
    RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
    /** Marks the most recent canceled occurrence of the recurring event. */
    RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
}
/** @enumType */
type StatusWithLiterals = Status | 'ONE_TIME' | 'RECURRING' | 'RECURRING_NEXT' | 'RECURRING_LAST_ENDED' | 'RECURRING_LAST_CANCELED';
declare enum EventStatus {
    /** Event is public and scheduled to start */
    SCHEDULED = "SCHEDULED",
    /** Event has started */
    STARTED = "STARTED",
    /** Event has ended */
    ENDED = "ENDED",
    /** Event was canceled */
    CANCELED = "CANCELED"
}
/** @enumType */
type EventStatusWithLiterals = EventStatus | 'SCHEDULED' | 'STARTED' | 'ENDED' | 'CANCELED';
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type CreatePolicyApplicationErrors = {
    code?: 'POLICIES_LIMIT_REACHED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ReorderEventPoliciesApplicationErrors = {
    code?: 'INVALID_REORDER_INSTRUCTION';
    description?: string;
    data?: Record<string, any>;
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface PolicyCreatedEnvelope {
    entity: Policy;
    metadata: EventMetadata;
}
/**
 * Triggered when a policy is created.
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Policies
 * @permissionScopeId SCOPE.DC-EVENTS.READ-POLICIES
 * @permissionScope Manage Policies
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-POLICIES
 * @permissionId WIX_EVENTS.READ_POLICIES
 * @webhook
 * @eventType wix.events.v2.policy_created
 * @serviceIdentifier wix.events.v2.PolicyManagement
 * @slug created
 */
declare function onPolicyCreated(handler: (event: PolicyCreatedEnvelope) => void | Promise<void>): void;
interface PolicyDeletedEnvelope {
    entity: Policy;
    metadata: EventMetadata;
}
/**
 * Triggered when a policy is deleted.
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Policies
 * @permissionScopeId SCOPE.DC-EVENTS.READ-POLICIES
 * @permissionScope Manage Policies
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-POLICIES
 * @permissionId WIX_EVENTS.READ_POLICIES
 * @webhook
 * @eventType wix.events.v2.policy_deleted
 * @serviceIdentifier wix.events.v2.PolicyManagement
 * @slug deleted
 */
declare function onPolicyDeleted(handler: (event: PolicyDeletedEnvelope) => void | Promise<void>): void;
interface PolicyUpdatedEnvelope {
    entity: Policy;
    metadata: EventMetadata;
}
/**
 * Triggered when a policy is updated.
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Policies
 * @permissionScopeId SCOPE.DC-EVENTS.READ-POLICIES
 * @permissionScope Manage Policies
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-POLICIES
 * @permissionId WIX_EVENTS.READ_POLICIES
 * @webhook
 * @eventType wix.events.v2.policy_updated
 * @serviceIdentifier wix.events.v2.PolicyManagement
 * @slug updated
 */
declare function onPolicyUpdated(handler: (event: PolicyUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a policy.
 *
 *
 * <!--
 * >  Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 *
 * The `createPolicy()` function returns a Promise that resolves to the newly-created policy.
 *
 * You can create up to 3 policies per event. If you try to create more than 3, you'll get the "Maximum number of policies for the event has been reached" error.
 * @public
 * @requiredField policy
 * @requiredField policy.body
 * @requiredField policy.eventId
 * @requiredField policy.name
 * @param policy - Policy info.
 * @permissionId WIX_EVENTS.MANAGE_POLICIES
 * @applicableIdentity APP
 * @returns Created policy.
 * @fqn wix.events.v2.PolicyManagement.CreatePolicy
 */
declare function createPolicy(policy: NonNullablePaths<Policy, `body` | `eventId` | `name`, 2>): Promise<NonNullablePaths<Policy, `name` | `body` | `eventId`, 2> & {
    __applicationErrorsType?: CreatePolicyApplicationErrors;
}>;
/**
 * Updates a policy.
 *
 * <!--
 * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 *
 * The `updatePolicy()` function returns a Promise that resolves to the newly-updated policy.
 *
 * Each time the policy is updated, `revision` increments by 1. The existing `revision` must be included when updating the policy. This ensures you're working with the latest policy and prevents unintended overwrites.
 * @public
 * @requiredField _id
 * @requiredField policy
 * @requiredField policy.body
 * @requiredField policy.eventId
 * @requiredField policy.name
 * @requiredField policy.revision
 * @param policy - Policy to update.
 * @param _id - Policy ID.
 * @permissionId WIX_EVENTS.MANAGE_POLICIES
 * @applicableIdentity APP
 * @returns The updated policy.
 * @fqn wix.events.v2.PolicyManagement.UpdatePolicy
 */
declare function updatePolicy(_id: string, policy: NonNullablePaths<UpdatePolicy, `body` | `eventId` | `name` | `revision`, 2>): Promise<NonNullablePaths<Policy, `name` | `body` | `eventId`, 2>>;
interface UpdatePolicy {
    /**
     * Policy ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the policy is updated. The existing revision must be used when updating a policy to prevent conflicting changes. You'll get an error if you try to use the previous revision.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date policy was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time of the policy's latest update in `yyyy-mm-ddThh:mm:sssZ` format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Policy name that is visible in the dashboard and checkout form.
     *
     * Min: 1 character
     *
     * Max: 40 characters
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /**
     * Policy body. Here you can enter various terms and conditions.
     *
     * Min: 1 character
     *
     * Max: 50000 characters
     *
     * **Note**: You can format text using various HTML tags such as `<p>`, `<b>`, `<ul>`, etc.
     * @minLength 1
     * @maxLength 50000
     */
    body?: string;
    /**
     * ID of the event to which the policy belongs.
     * @format GUID
     * @immutable
     */
    eventId?: string;
}
/**
 * Permanently deletes a policy.
 *
 *
 * <!--
 * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 *
 * The `deletePolicy()` function returns a Promise that resolves when the specified policy is deleted.
 *
 * Deleted policies are not returned by the `getPolicy()` or `queryPolicies()` functions.
 * @public
 * @requiredField policyId
 * @param options - Options for Delete Policy function.
 * @param policyId - ID of the policy to delete.
 * @permissionId WIX_EVENTS.MANAGE_POLICIES
 * @applicableIdentity APP
 * @fqn wix.events.v2.PolicyManagement.DeletePolicy
 */
declare function deletePolicy(policyId: string): Promise<void>;
/**
 * Creates a query to retrieve a list of policies, given the provided paging and filter.
 *
 *
 * The `queryPolicies()` function builds a query to retrieve a list of policies and returns a [PoliciesQueryBuilder](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder) object.
 *
 * The returned object contains the query definition which is typically used to run the query using the [`find()`](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder/find) function.
 *
 * You can refine the query by chaining `PoliciesQueryBuilder` functions onto the query. `PoliciesQueryBuilder` functions enable you to sort, filter and control the results that `PoliciesQueryBuilder.find()` returns.
 *
 * The query runs with the following `PoliciesQueryBuilder` defaults that you can override:
 *
 * [`limit`](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder/limit): `50`
 * [`descending`](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder/descending): `_createdDate`
 *
 * The functions that are chained to `queryPolicies()` are applied in the order they are called. For example, if you sort on the `_createdDate` property in ascending order and then on the id property in descending order, the results are sorted by the created date and then, if there are multiple results with the same date, the items are sorted by the id.
 *
 * The table below shows which `PoliciesQueryBuilder` functions are supported for `queryPoliciesGuests()`. You can only use one filter function for each property. If a property is used in more than one filter, only the first filter will work.
 * @public
 * @permissionId WIX_EVENTS.READ_POLICIES
 * @applicableIdentity APP
 * @fqn wix.events.v2.PolicyManagement.QueryPolicies
 */
declare function queryPolicies(): PoliciesQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface PoliciesQueryResult extends QueryCursorResult {
    items: Policy[];
    query: PoliciesQueryBuilder;
    next: () => Promise<PoliciesQueryResult>;
    prev: () => Promise<PoliciesQueryResult>;
}
interface PoliciesQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
    in: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
    exists: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: boolean) => PoliciesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId'>) => PoliciesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId'>) => PoliciesQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => PoliciesQueryBuilder;
    /** @param cursor - A pointer to specific record */
    skipTo: (cursor: string) => PoliciesQueryBuilder;
    find: () => Promise<PoliciesQueryResult>;
}
/**
 * Changes policy order in an event dashboard and agreement checkbox on the checkout form.
 * For example, if we have 3 policies in the list, after using this function the 3rd policy will become the 1st, and other policies will move by 1 position. By default, the policies are arranged by the created date in descending order.
 *
 * >  **Note**: it is possible to use both `beforePolicyId` and `afterPolicyId` at the same time but only the last one defined will be executed.
 *
 * <!--
 * >  Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 *
 * The `reorderEventPolicies()` function returns a Promise that resolves to the newly-reordered policy.
 * @param policyId - Event policy ID.
 * @param eventId - Event ID.
 * @public
 * @requiredField eventId
 * @requiredField policyId
 * @param options - Options for Reorder Event Policies function.
 * @permissionId WIX_EVENTS.MANAGE_POLICIES
 * @applicableIdentity APP
 * @fqn wix.events.v2.PolicyManagement.ReorderEventPolicies
 */
declare function reorderEventPolicies(policyId: string, eventId: string, options?: ReorderEventPoliciesOptions): Promise<NonNullablePaths<ReorderEventPoliciesResponse, `policies` | `policies.${number}.name` | `policies.${number}.body` | `policies.${number}.eventId`, 4> & {
    __applicationErrorsType?: ReorderEventPoliciesApplicationErrors;
}>;
interface ReorderEventPoliciesOptions extends ReorderEventPoliciesOptionsReferencePolicyOneOf {
    /**
     * Move the given `policyId` before the specified policy.
     * @format GUID
     */
    beforePolicyId?: string;
    /**
     * Move the given `policyId` after the specified policy.
     * @format GUID
     */
    afterPolicyId?: string;
}
/** @oneof */
interface ReorderEventPoliciesOptionsReferencePolicyOneOf {
    /**
     *
     * @format GUID
     */
    beforePolicyId?: string;
    /**
     * Move the given `policyId` after the specified policy.
     * @format GUID
     */
    afterPolicyId?: string;
}
/**
 * Retrieves a policy by ID.
 *
 *
 * The `getPolicy()` function returns a Promise that resolves to a policy whose ID matches the given ID.
 * @public
 * @requiredField policyId
 * @param policyId - Policy ID.
 * @permissionId WIX_EVENTS.READ_POLICIES
 * @applicableIdentity APP
 * @returns The requested policy.
 * @fqn wix.events.v2.PolicyManagement.GetPolicy
 */
declare function getPolicy(policyId: string): Promise<NonNullablePaths<Policy, `name` | `body` | `eventId`, 2>>;

export { type ActionEvent, type Address, type AddressLocation, type AddressStreetOneOf, type BaseEventMetadata, type CreatePolicyApplicationErrors, type CreatePolicyRequest, type CreatePolicyResponse, type CursorPaging, type Cursors, type DeletePolicyRequest, type DeletePolicyResponse, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventCopied, type EventMetadata, EventStatus, type EventStatusWithLiterals, type GetPolicyRequest, type GetPolicyResponse, type IdentificationData, type IdentificationDataIdOneOf, type Location, LocationType, type LocationTypeWithLiterals, type MapCoordinates, type MessageEnvelope, type Occurrence, type Paging, type PagingMetadataV2, type PoliciesQueryBuilder, type PoliciesQueryResult, type Policy, type PolicyCreatedEnvelope, type PolicyDeletedEnvelope, type PolicyUpdatedEnvelope, type QueryPoliciesRequest, type QueryPoliciesResponse, type QueryV2, type QueryV2PagingMethodOneOf, type Recurrences, type ReorderEventPoliciesApplicationErrors, type ReorderEventPoliciesOptions, type ReorderEventPoliciesOptionsReferencePolicyOneOf, type ReorderEventPoliciesRequest, type ReorderEventPoliciesRequestReferencePolicyOneOf, type ReorderEventPoliciesResponse, type RestoreInfo, type ScheduleConfig, SortOrder, type SortOrderWithLiterals, type Sorting, Status, type StatusWithLiterals, type StreetAddress, type Subdivision, SubdivisionType, type SubdivisionTypeWithLiterals, type UpdatePolicy, type UpdatePolicyRequest, type UpdatePolicyResponse, type UpdatePolicySortIndexRequest, type UpdatePolicySortIndexResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, createPolicy, deletePolicy, getPolicy, onPolicyCreated, onPolicyDeleted, onPolicyUpdated, queryPolicies, reorderEventPolicies, updatePolicy };
