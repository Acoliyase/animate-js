import { CreatePolicyRequest as CreatePolicyRequest$1, CreatePolicyResponse as CreatePolicyResponse$1, UpdatePolicyRequest as UpdatePolicyRequest$1, UpdatePolicyResponse as UpdatePolicyResponse$1, DeletePolicyRequest as DeletePolicyRequest$1, DeletePolicyResponse as DeletePolicyResponse$1, QueryPoliciesRequest as QueryPoliciesRequest$1, QueryPoliciesResponse as QueryPoliciesResponse$1, ReorderEventPoliciesRequest as ReorderEventPoliciesRequest$1, ReorderEventPoliciesResponse as ReorderEventPoliciesResponse$1, GetPolicyRequest as GetPolicyRequest$1, GetPolicyResponse as GetPolicyResponse$1 } from './index.typings.mjs';
import '@wix/sdk-types';

/**
 * A Policy is a set of terms and conditions attached to a specific event and shown during RSVP or checkout.
 *
 * You can use Policies to communicate refund, cancellation, and ticket-transfer rules by defining a policy name and body that attendees acknowledge.
 */
interface Policy {
    /**
     * Policy ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the policy is updated.
     *
     * To prevent conflicting changes, the current revision must be used when updating a policy.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the policy was created in `yyyy-mm-ddThh:mm:sssZ` format.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the policy was updated in `yyyy-mm-ddThh:mm:sssZ` format.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Policy name that is visible in the dashboard and checkout form.
     *
     * Min: 1 character  <br/>
     * Max: 40 characters
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /**
     * Policy body. Usually contains various terms and conditions.
     *
     * Min: 1 character
     * Max: 50,000 characters
     *
     * <b>Note:</b> You can format text using various HTML tags such as `<p>`, `<b>`, `<ul>`, etc.
     * @minLength 1
     * @maxLength 50000
     */
    body?: string;
    /**
     * ID of the event to which the policy belongs.
     * @format GUID
     * @immutable
     */
    eventId?: string;
}
interface CreatePolicyRequest {
    /** Policy info. */
    policy: Policy;
}
interface CreatePolicyResponse {
    /** Created policy. */
    policy?: Policy;
}
interface UpdatePolicyRequest {
    /** Policy info to update. */
    policy: Policy;
}
interface UpdatePolicyResponse {
    /** Updated policy. */
    policy?: Policy;
}
interface UpdatePolicySortIndexRequest {
    /**
     * ID of the policy.
     * @format GUID
     */
    policyId?: string;
    /** Current revision number of the policy. */
    revision?: string;
    /** Index to sort of a policy. */
    sortIndex?: number;
}
interface UpdatePolicySortIndexResponse {
    /** Updated policy. */
    policy?: Policy;
}
interface DeletePolicyRequest {
    /**
     * ID of the policy to delete.
     * @format GUID
     */
    policyId: string;
}
interface DeletePolicyResponse {
}
interface QueryPoliciesRequest {
    /** Query options. See [API Query Langauge](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
    query: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Pagination options. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1", "fieldName2":{"$operator":"value2"} }`. <br/> <br/> **Example:** <br/> `"filter" : { "id": "2224a9d1-79e6-4549-a5c5-bf7ce5aac1a5", "revision": {"$ne":"1"} }` <br/> <br/> See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/policy-v2/filter-and-sort) for more information. */
    filter?: Record<string, any> | null;
    /** Sort object in the following format: <br/> `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]` <br/> <br/> **Example:** <br/> `[{"fieldName":"createdDate","direction":"DESC"}]` <br/> <br/> See [supported fields](https://dev.wix.com/api/rest/wix-events/policy-v2/filter-and-sort) for more information. */
    sort?: Sorting[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Pagination options. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 100
     */
    fieldName?: string;
    /** Sort order (ASC/DESC). Defaults to ASC */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load per page. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Number of items to load per page.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryPoliciesResponse {
    /** List of policies. */
    policies?: Policy[];
    /** Metadata for the paginated results. */
    metadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
interface ReorderEventPoliciesRequest extends ReorderEventPoliciesRequestReferencePolicyOneOf {
    /**
     * Move the given policy before this specified policy.
     * @format GUID
     */
    beforePolicyId?: string;
    /**
     * Move the given policy after this specified policy.
     * @format GUID
     */
    afterPolicyId?: string;
    /**
     * Event ID to which the policy belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * ID of the policy to reorder.
     * @format GUID
     */
    policyId: string;
}
/** @oneof */
interface ReorderEventPoliciesRequestReferencePolicyOneOf {
    /**
     * Move the given policy before this specified policy.
     * @format GUID
     */
    beforePolicyId?: string;
    /**
     * Move the given policy after this specified policy.
     * @format GUID
     */
    afterPolicyId?: string;
}
interface ReorderEventPoliciesResponse {
    /** Policies in the new order. */
    policies?: Policy[];
}
interface GetPolicyRequest {
    /**
     * ID of the policy to retrieve.
     * @format GUID
     */
    policyId: string;
}
interface GetPolicyResponse {
    /** Retrieved policy. */
    policy?: Policy;
}
interface EventCopied {
    /** Event created timestamp in ISO UTC format. */
    timestamp?: Date | null;
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /** Event location. */
    location?: Location;
    /** Event schedule configuration. */
    scheduleConfig?: ScheduleConfig;
    /** Event title. */
    title?: string;
    /**
     * Event creator user ID.
     * @format GUID
     */
    userId?: string | null;
    /** Event status. */
    status?: EventStatusWithLiterals;
    /**
     * Instance ID. Indicates the original app instance which current event was derived from.
     * @format GUID
     */
    derivedFromInstanceId?: string | null;
    /**
     * Event ID. Indicates the original event which current event was derived from.
     * @format GUID
     */
    derivedFromEventId?: string | null;
    /**
     * Map of copied ticket definitions from original event.
     * Key represents ticket def id in the original event.
     * Value represents ticket def id in the newly created event.
     */
    ticketDefinitions?: Record<string, string>;
}
interface Location {
    /**
     * Location name.
     * @maxLength 50
     */
    name?: string | null;
    /** Location map coordinates. */
    coordinates?: MapCoordinates;
    /**
     * Single line address representation.
     * @maxLength 300
     */
    address?: string | null;
    /** Location type. */
    type?: LocationTypeWithLiterals;
    /**
     * Full address derived from formatted single line `address`.
     * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
     * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
     *
     * Migration notes:
     * - `full_address.formatted_address` is equivalent to `address`.
     * - `full_address.geocode` is equivalent to `coordinates`.
     */
    fullAddress?: Address;
    /**
     * Defines event location as TBD (To Be Determined).
     * When event location is not yet defined, `name` is displayed instead of location address.
     * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
     */
    tbd?: boolean | null;
}
interface MapCoordinates {
    /**
     * Latitude.
     * @min -90
     * @max 90
     */
    lat?: number;
    /**
     * Longitude.
     * @min -180
     * @max 180
     */
    lng?: number;
}
declare enum LocationType {
    VENUE = "VENUE",
    ONLINE = "ONLINE"
}
/** @enumType */
type LocationTypeWithLiterals = LocationType | 'VENUE' | 'ONLINE';
/** Physical address */
interface Address extends AddressStreetOneOf {
    /** a break down of the street to number and street name */
    streetAddress?: StreetAddress;
    /** Main address line (usually street and number) as free text */
    addressLine?: string | null;
    /**
     * country code
     * @format COUNTRY
     */
    country?: string | null;
    /** subdivision (usually state or region) code according to ISO 3166-2 */
    subdivision?: string | null;
    /** city name */
    city?: string | null;
    /** zip/postal code */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
    addressLine2?: string | null;
    /** A string containing the human-readable address of this location */
    formattedAddress?: string | null;
    /** Free text for human-to-human textual orientation aid purposes */
    hint?: string | null;
    /** coordinates of the physical address */
    geocode?: AddressLocation;
    /** country full-name */
    countryFullname?: string | null;
    /**
     * multi-level subdivisions from top to bottom
     * @maxSize 6
     */
    subdivisions?: Subdivision[];
}
/** @oneof */
interface AddressStreetOneOf {
    /** a break down of the street to number and street name */
    streetAddress?: StreetAddress;
    /** Main address line (usually street and number) as free text */
    addressLine?: string | null;
}
interface StreetAddress {
    /** street number */
    number?: string;
    /** street name */
    name?: string;
}
interface AddressLocation {
    /**
     * address latitude coordinates
     * @min -90
     * @max 90
     */
    latitude?: number | null;
    /**
     * address longitude coordinates
     * @min -180
     * @max 180
     */
    longitude?: number | null;
}
interface Subdivision {
    /** subdivision short code */
    code?: string;
    /** subdivision full-name */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
interface ScheduleConfig {
    /**
     * Defines event as TBD (To Be Determined) schedule.
     * When event time is not yet defined, TBD message is displayed instead of event start and end times.
     * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
     */
    scheduleTbd?: boolean;
    /**
     * TBD message.
     * @maxLength 100
     */
    scheduleTbdMessage?: string | null;
    /** Event start timestamp. */
    startDate?: Date | null;
    /** Event end timestamp. */
    endDate?: Date | null;
    /**
     * Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`.
     * @maxLength 100
     */
    timeZoneId?: string | null;
    /** Whether end date is hidden in the formatted schedule. */
    endDateHidden?: boolean;
    /** Whether time zone is displayed in formatted schedule. */
    showTimeZone?: boolean;
    /** Event recurrences. */
    recurrences?: Recurrences;
}
interface Recurrences {
    /**
     * Event occurrences.
     * @maxSize 1000
     */
    occurrences?: Occurrence[];
    /**
     * Recurring event category ID.
     * @readonly
     */
    categoryId?: string | null;
    /**
     * Recurrence status.
     * @readonly
     */
    status?: StatusWithLiterals;
}
interface Occurrence {
    /** Event start timestamp. */
    startDate?: Date | null;
    /** Event end timestamp. */
    endDate?: Date | null;
    /**
     * Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`.
     * @maxLength 100
     */
    timeZoneId?: string | null;
    /** Whether time zone is displayed in formatted schedule. */
    showTimeZone?: boolean;
}
declare enum Status {
    /** Event occurs only once. */
    ONE_TIME = "ONE_TIME",
    /** Event is recurring. */
    RECURRING = "RECURRING",
    /** Marks the next upcoming occurrence of the recurring event. */
    RECURRING_NEXT = "RECURRING_NEXT",
    /** Marks the most recent ended occurrence of the recurring event. */
    RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
    /** Marks the most recent canceled occurrence of the recurring event. */
    RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
}
/** @enumType */
type StatusWithLiterals = Status | 'ONE_TIME' | 'RECURRING' | 'RECURRING_NEXT' | 'RECURRING_LAST_ENDED' | 'RECURRING_LAST_CANCELED';
declare enum EventStatus {
    /** Event is public and scheduled to start */
    SCHEDULED = "SCHEDULED",
    /** Event has started */
    STARTED = "STARTED",
    /** Event has ended */
    ENDED = "ENDED",
    /** Event was canceled */
    CANCELED = "CANCELED"
}
/** @enumType */
type EventStatusWithLiterals = EventStatus | 'SCHEDULED' | 'STARTED' | 'ENDED' | 'CANCELED';
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type CreatePolicyApplicationErrors = {
    code?: 'POLICIES_LIMIT_REACHED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ReorderEventPoliciesApplicationErrors = {
    code?: 'INVALID_REORDER_INSTRUCTION';
    description?: string;
    data?: Record<string, any>;
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createPolicy(): __PublicMethodMetaInfo<'POST', {}, CreatePolicyRequest$1, CreatePolicyRequest, CreatePolicyResponse$1, CreatePolicyResponse>;
declare function updatePolicy(): __PublicMethodMetaInfo<'PATCH', {
    policyId: string;
}, UpdatePolicyRequest$1, UpdatePolicyRequest, UpdatePolicyResponse$1, UpdatePolicyResponse>;
declare function deletePolicy(): __PublicMethodMetaInfo<'DELETE', {
    policyId: string;
}, DeletePolicyRequest$1, DeletePolicyRequest, DeletePolicyResponse$1, DeletePolicyResponse>;
declare function queryPolicies(): __PublicMethodMetaInfo<'POST', {}, QueryPoliciesRequest$1, QueryPoliciesRequest, QueryPoliciesResponse$1, QueryPoliciesResponse>;
declare function reorderEventPolicies(): __PublicMethodMetaInfo<'POST', {}, ReorderEventPoliciesRequest$1, ReorderEventPoliciesRequest, ReorderEventPoliciesResponse$1, ReorderEventPoliciesResponse>;
declare function getPolicy(): __PublicMethodMetaInfo<'GET', {
    policyId: string;
}, GetPolicyRequest$1, GetPolicyRequest, GetPolicyResponse$1, GetPolicyResponse>;

export { type ActionEvent as ActionEventOriginal, type AddressLocation as AddressLocationOriginal, type Address as AddressOriginal, type AddressStreetOneOf as AddressStreetOneOfOriginal, type CreatePolicyApplicationErrors as CreatePolicyApplicationErrorsOriginal, type CreatePolicyRequest as CreatePolicyRequestOriginal, type CreatePolicyResponse as CreatePolicyResponseOriginal, type CursorPaging as CursorPagingOriginal, type Cursors as CursorsOriginal, type DeletePolicyRequest as DeletePolicyRequestOriginal, type DeletePolicyResponse as DeletePolicyResponseOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type Empty as EmptyOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type EventCopied as EventCopiedOriginal, EventStatus as EventStatusOriginal, type EventStatusWithLiterals as EventStatusWithLiteralsOriginal, type GetPolicyRequest as GetPolicyRequestOriginal, type GetPolicyResponse as GetPolicyResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type Location as LocationOriginal, LocationType as LocationTypeOriginal, type LocationTypeWithLiterals as LocationTypeWithLiteralsOriginal, type MapCoordinates as MapCoordinatesOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type Occurrence as OccurrenceOriginal, type PagingMetadataV2 as PagingMetadataV2Original, type Paging as PagingOriginal, type Policy as PolicyOriginal, type QueryPoliciesRequest as QueryPoliciesRequestOriginal, type QueryPoliciesResponse as QueryPoliciesResponseOriginal, type QueryV2 as QueryV2Original, type QueryV2PagingMethodOneOf as QueryV2PagingMethodOneOfOriginal, type Recurrences as RecurrencesOriginal, type ReorderEventPoliciesApplicationErrors as ReorderEventPoliciesApplicationErrorsOriginal, type ReorderEventPoliciesRequest as ReorderEventPoliciesRequestOriginal, type ReorderEventPoliciesRequestReferencePolicyOneOf as ReorderEventPoliciesRequestReferencePolicyOneOfOriginal, type ReorderEventPoliciesResponse as ReorderEventPoliciesResponseOriginal, type RestoreInfo as RestoreInfoOriginal, type ScheduleConfig as ScheduleConfigOriginal, SortOrder as SortOrderOriginal, type SortOrderWithLiterals as SortOrderWithLiteralsOriginal, type Sorting as SortingOriginal, Status as StatusOriginal, type StatusWithLiterals as StatusWithLiteralsOriginal, type StreetAddress as StreetAddressOriginal, type Subdivision as SubdivisionOriginal, SubdivisionType as SubdivisionTypeOriginal, type SubdivisionTypeWithLiterals as SubdivisionTypeWithLiteralsOriginal, type UpdatePolicyRequest as UpdatePolicyRequestOriginal, type UpdatePolicyResponse as UpdatePolicyResponseOriginal, type UpdatePolicySortIndexRequest as UpdatePolicySortIndexRequestOriginal, type UpdatePolicySortIndexResponse as UpdatePolicySortIndexResponseOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, createPolicy, deletePolicy, getPolicy, queryPolicies, reorderEventPolicies, updatePolicy };
