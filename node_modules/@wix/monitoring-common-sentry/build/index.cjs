"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  createManualSpanRegistry: () => createManualSpanRegistry,
  generateRandomId: () => generateRandomId,
  isPromise: () => isPromise,
  runWithMaybeDelay: () => runWithMaybeDelay,
  runWithMaybePromise: () => runWithMaybePromise
});
module.exports = __toCommonJS(index_exports);

// src/utils.ts
var isPromise = (value) => typeof value?.then === "function";
var runWithMaybePromise = (value, cb) => {
  if (!cb) {
    return value;
  }
  if (isPromise(value)) {
    return value.then((res) => {
      cb(res, true);
      return res;
    });
  } else {
    cb(value, false);
    return value;
  }
};
var runWithMaybeDelay = (cb, maybeTimeCompensation) => {
  if (!cb) {
    return;
  }
  if (maybeTimeCompensation) {
    setTimeout(cb, maybeTimeCompensation);
  } else {
    cb();
  }
};
var generateRandomId = () => Date.now() + Math.random();

// src/manual-span.ts
var ManualSpanRegistryImpl = class {
  constructor(options) {
    this.options = options;
    this.spanMap = /* @__PURE__ */ new Map();
  }
  createSpan(spanOptions, sentryOptionsOrPromise) {
    let resolveSpan;
    let rejectSpan;
    let error;
    const startTime = Date.now();
    let maybeDurationCompensation;
    const maybePromise = runWithMaybePromise(
      sentryOptionsOrPromise,
      ({ sentrySDK, scope }, isPromise2) => {
        if (isPromise2) {
          maybeDurationCompensation = Date.now() - startTime;
        }
        const promise = sentrySDK.startSpan(
          {
            ...spanOptions,
            scope,
            forceTransaction: this.options.forceTransaction
          },
          () => new Promise((resolve, reject) => {
            resolveSpan = resolve;
            rejectSpan = reject;
          })
        );
        promise?.catch((e) => {
          if (e?.message !== error?.message) {
            throw e;
          }
        });
      }
    );
    const endSpan = (cb) => {
      this.spanMap.delete(spanOptions.name);
      runWithMaybePromise(maybePromise, () => {
        runWithMaybeDelay(cb, maybeDurationCompensation);
      });
    };
    const span = {
      end: () => {
        endSpan(() => resolveSpan?.());
      },
      fail: (_error) => {
        error = error ?? _error;
        endSpan(() => rejectSpan?.(_error));
      }
    };
    this.spanMap.set(spanOptions.name, span);
    return span;
  }
  getSpan(spanOptions) {
    return this.spanMap.get(spanOptions.name);
  }
};
var createManualSpanRegistry = (options) => new ManualSpanRegistryImpl(options);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createManualSpanRegistry,
  generateRandomId,
  isPromise,
  runWithMaybeDelay,
  runWithMaybePromise
});
