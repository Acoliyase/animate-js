import { RefObject } from 'react';
import { EventsListenerFunction } from '../lib';
import { NavigationModes } from './navigationModes';
export interface Measurements {
    width: number;
    height: number;
    top: number;
    left: number;
}
export interface ScrollPosition {
    x: number;
    y: number;
}
export interface Item {
    index: number;
    measurements: Measurements;
    ref: React.RefObject<HTMLDivElement>;
}
export type NavigationMode = NavigationModes.CENTER | NavigationModes.START | NavigationModes.END;
export interface ScrollSettings {
    duration?: number;
    slideTransition?: string;
    mode?: NavigationMode;
    loop?: boolean;
    isRTL?: boolean;
}
export interface FullyDefinedSettings {
    duration: number;
    slideTransition: string;
    mode: NavigationMode;
    loop: boolean;
    isRTL: boolean;
}
export type Direction = 'left' | 'right' | 'up' | 'down';
export interface NavigationAPI {
    navigateToIndex(index: number, settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<{
        x: number;
        y: number;
    }>;
    next(settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<{
        x: number;
        y: number;
    }>;
    previous(settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<{
        x: number;
        y: number;
    }>;
    currentIndex(): number | null;
    canNavigateToNext(settings?: ScrollSettings): Promise<boolean>;
    canNavigateToPrevious(settings?: ScrollSettings): Promise<boolean>;
    isScrollerRefScrollless(): boolean;
    getNextItemByDirection(currentIndex: number, direction: Direction): number | null;
}
export interface INavigator {
    setScrollerRef(scrollerRef: RefObject<HTMLDivElement>): void;
    setWrapperRef(wrapperRef?: RefObject<Window>): void;
    setContainerRef(containerRef: RefObject<HTMLDivElement>): void;
    removeScrollerRef(scrollerRef: RefObject<HTMLDivElement>): void;
    removeWrapperRef(wrapperRef?: RefObject<Window>): void;
    removeContainerRef(scrollerRef: RefObject<HTMLDivElement>): void;
    getActiveScrollingElement(): RefObject<HTMLDivElement> | RefObject<Window> | null;
    getActiveScrollingElementMeasurements(): Measurements | null;
    updateItemMeasurements(newMeasurements: Measurements, index: number, itemRef: React.RefObject<HTMLDivElement>): void;
    updateScrollerMeasurements(newMeasurements: Measurements): void;
    updateWrapperMeasurements(newMeasurements: Measurements): void;
    updateContainerMeasurements(newMeasurements: Measurements): void;
    computeNavigation(index: number, settings?: ScrollSettings): ScrollPosition;
    isAbleToNavigateToPrevious(settings?: ScrollSettings): Promise<boolean>;
    isAbleToNavigateToNext(settings?: ScrollSettings): Promise<boolean>;
    navigate(index: number, settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    defaultScrollingNavigation(index: number, scrollSettings: FullyDefinedSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    nativeScrollingNavigation(index: number, scrollSettings: FullyDefinedSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    scrolllessNavigation(index: number, scrollSettings: FullyDefinedSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    next(settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    previous(settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    getCenteredItemByBothAxes(): number | null;
    setCenteredItemByBothAxes(index: number): void;
    setCurrentItem(index: number): void;
    getCurrentIndex(): number | null;
    updateTotalItemsCount(count: number): void;
    fireEvent(...args: Parameters<EventsListenerFunction>): void;
    getNavigationApi(): NavigationAPI;
    isScrollerRefScrollless(): boolean;
    createNavigationBoundaries(): void;
    calculateNavigationBoundaries(): Measurements;
    focusOnFirstItem(): void;
    getNextItemByDirection(currentIndex: number, direction: Direction): number | null;
}
//# sourceMappingURL=types.d.ts.map