import { RefObject } from 'react';
import { Measurements, ScrollSettings, FullyDefinedSettings, NavigationAPI, ScrollPosition, INavigator, Direction } from './types';
import { EventsListenerFunction } from '../lib';
export declare class Navigator implements INavigator {
    private _items;
    private _scrollerMeasurement;
    private _wrapperMeasurement;
    private _containerMeasurement;
    private _navigationBoundaries;
    private _scrollerRef;
    private _wrapperRef;
    private _containerRef;
    private scrollPosition;
    private centeredItemByBothAxes;
    private currentItem;
    private currentScroll;
    private promiseToBeResolvedNextTimeAScrollEnds;
    private currentNavigation;
    private deferredGettingMoreItems;
    private baseSettings;
    private totalItemsCount;
    private eventsListener?;
    logger: (...args: any[]) => void;
    constructor({ initSettings, eventsListener, logger, }?: {
        initSettings?: ScrollSettings;
        eventsListener?: EventsListenerFunction;
        logger?: (...args: any[]) => void;
    });
    setScrollerRef(scrollerRef: RefObject<HTMLDivElement>): void;
    setWrapperRef(wrapperRef: RefObject<Window>): void;
    setContainerRef(containerRef: RefObject<HTMLDivElement>): void;
    removeScrollerRef(scrollerRef: RefObject<HTMLDivElement>): void;
    removeWrapperRef(wrapperRef: RefObject<Window>): void;
    removeContainerRef(scrollerRef: RefObject<HTMLDivElement>): void;
    getActiveScrollingElement(): RefObject<HTMLDivElement> | RefObject<Window> | null;
    getActiveScrollingElementMeasurements(): Measurements | null;
    private scrollEventHandler;
    private areMeasurementsDifferent;
    private debouncedFireLayoutChanged;
    private fireLayoutChangedEventIfLayoutChanged;
    updateItemMeasurements(newMeasurements: Measurements, index: number, itemRef: React.RefObject<HTMLDivElement>): void;
    updateScrollerMeasurements(newMeasurements: Measurements): void;
    updateWrapperMeasurements(newMeasurements: Measurements): void;
    updateContainerMeasurements(newMeasurements: Measurements): void;
    private mergeSettingsWithDefaults;
    private getScrollPositions;
    private limitScrollPosition;
    computeNavigation(index: number, settings?: ScrollSettings): ScrollPosition;
    isAbleToNavigateToPrevious(settings?: ScrollSettings): Promise<boolean>;
    isAbleToNavigateToNext(settings?: ScrollSettings): Promise<boolean>;
    navigate(index: number, settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    defaultScrollingNavigation(index: number, scrollSettings: FullyDefinedSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    nativeScrollingNavigation(index: number, scrollSettings: FullyDefinedSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    scrolllessNavigation(index: number, scrollSettings: FullyDefinedSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    next(settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    previous(settings?: ScrollSettings, staleNavigationFunction?: () => Promise<boolean>): Promise<ScrollPosition>;
    private navigateInDirection;
    private throttledGetMoreItemsIfNeeded;
    private throttledScrollTasks;
    private handleScrollEnd;
    private registerScrollStart;
    private registerScrollEnd;
    private debouncedHandleScrollEnd;
    private debouncedRegisterCenteredItems;
    private registerCenteredItems;
    private getMoreItemsIfNeededScrollBased;
    getCenteredItemByBothAxes(): number | null;
    setCenteredItemByBothAxes(index: number): void;
    fireEvent(...args: Parameters<EventsListenerFunction>): void;
    setCurrentItem(index: number): void;
    getCurrentIndex(): number | null;
    updateTotalItemsCount(count: number): void;
    private lastNavigationStatus;
    private checkAndFireNavigationStatus;
    private loopBack;
    fireNavigationApiReadyEvent(): void;
    getNavigationApi(): NavigationAPI;
    isScrollerRefScrollless(): boolean;
    debouncedCreateNavigationBoundaries: (...args: any[]) => void;
    createNavigationBoundaries(): void;
    calculateNavigationBoundaries(): Measurements;
    focusOnFirstItem(): void;
    getNextItemByDirection(currentIndex: number, direction: Direction): number | null;
}
//# sourceMappingURL=navigator.d.ts.map