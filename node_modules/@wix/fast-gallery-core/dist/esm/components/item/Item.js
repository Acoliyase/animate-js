import React, { useEffect, useRef, useState } from 'react';
import classNames from 'clsx';
import { useMeasure } from '../../navigator';
import ItemRenderer from './ItemRenderer';
import { GALLERY_EVENTS, GalleryUtils as utils, isEditMode, CLICK_ACTION, MediaTypes,
// OVERLAY_BEHAVIOR_ON_HOVER,
// SECONDARY_MEDIA_TRIGGER,
// PLAY_TRIGGER,
 } from '../../lib';
import { renderCustomOrDefaultComp } from '../utils';
import { hoverClasses } from '../generalConstants';
import s from './Item.module.scss';
const Item = (props) => {
    const { index, data, selectors, customRenderers, eventsListener, createResizedMediaUrl, onMeasure, activeIndex, isCurrentlyHovered, options, isAccessible, getItemCustomAttributes, registerItemRef, } = props;
    const itemRef = useRef(null);
    const [isActive, setIsActive] = useState(false);
    const [isInFocus, setIsInFocus] = useState(false);
    const itemClickAction = props?.options?.itemClickAction;
    useEffect(() => {
        setIsActive(index === activeIndex);
    }, [activeIndex, index]);
    useEffect(() => {
        if (registerItemRef) {
            registerItemRef(index, itemRef.current);
        }
    }, [registerItemRef, index]);
    useMeasure({
        callback: (measurements) => onMeasure(index, measurements, itemRef),
        index,
        ref: itemRef,
    });
    const handleRightClickContextMenu = (event) => {
        if (options?.disableContextMenu) {
            event.preventDefault();
        }
    };
    const applyItemHover = () => {
        eventsListener(GALLERY_EVENTS.HOVER_SET, { index });
        itemRef.current?.classList.add(hoverClasses.itemHover);
    };
    const clearItemHover = () => {
        itemRef.current?.classList.remove(hoverClasses.itemHover);
        eventsListener(GALLERY_EVENTS.HOVER_SET, { index: -1 });
    };
    const onMouseEnter = () => {
        // if (!utils.isMobile()) { //TODO: add this when isMobile is available
        // }
        applyItemHover();
    };
    const onMouseLeave = () => {
        // if (!utils.isMobile()) { //TODO: add this when isMobile is available
        // }
        clearItemHover();
    };
    const onFocus = () => {
        eventsListener(GALLERY_EVENTS.ITEM_FOCUSED, { index });
        applyItemHover();
        setIsInFocus(true);
    };
    const onBlur = (e) => {
        if (isAccessible && isCurrentlyHovered) {
            eventsListener(GALLERY_EVENTS.HOVER_SET, { index: -1 });
            clearItemHover();
        }
        else {
            eventsListener(GALLERY_EVENTS.ITEM_LOST_FOCUS, { index });
            e.currentTarget.blur();
            setIsInFocus(false);
        }
    };
    const onKeyDown = (e) => {
        if (e.key === 'Escape') {
            onBlur(e);
        }
    };
    const itemHasLink = () => {
        const { link } = data.metaData;
        const itemDoesntHaveLink = !link || !link.url || link.url === ''; // when itemClickAction is 'LINK' but no link was added to this specific item
        return !itemDoesntHaveLink;
    };
    const isItemClickable = () => {
        const itemDoesntHaveLink = !itemHasLink(); // when itemClickAction is 'LINK' but no link was added to this specific item
        return props?.options?.itemClickAction === CLICK_ACTION.NOTHING ||
            (props?.options?.itemClickAction === CLICK_ACTION.LINK &&
                itemDoesntHaveLink)
            ? false
            : true;
    };
    const onItemClick = (e, shouldPreventDefault = false) => {
        eventsListener(GALLERY_EVENTS.ON_ITEM_CLICKED, {
            index,
        });
        if (shouldUseDirectLink()) {
            return;
        }
        if (shouldPreventDefault) {
            e.preventDefault();
        }
        if (shouldShowHoverOnMobile()
        // || shouldShowSecondMediaOnMobile()
        ) {
            handleHoverClickOnMobile();
        }
        else if (shouldHoverWithoutOverlayAndClickOnMobile()) {
            eventsListener(GALLERY_EVENTS.HOVER_SET, { index });
        }
        else {
            handleGalleryItemAction();
        }
    };
    const handleGalleryItemAction = () => {
        if (itemClickAction === CLICK_ACTION.ACTION) {
            eventsListener(GALLERY_EVENTS.ITEM_ACTION_TRIGGERED, { index });
        }
    };
    const shouldUseDirectLink = () => {
        const { link } = data.metaData;
        const { url, target } = link || {};
        const useDirectLink = !!(url &&
            target &&
            itemClickAction === CLICK_ACTION.LINK);
        const isHoverEnabledOnMobile = shouldShowHoverOnMobile();
        const shouldUseDirectLinkOnMobile = isHoverEnabledOnMobile &&
            // isClickOnCurrentHoveredItem() &&
            useDirectLink;
        if (shouldUseDirectLinkOnMobile) {
            eventsListener(GALLERY_EVENTS.HOVER_SET, { index: -1 });
            return true;
        }
        if (useDirectLink && !isHoverEnabledOnMobile) {
            return true;
        }
        return false;
    };
    // const isClickOnCurrentHoveredItem = () =>
    //   isCurrentlyHovered
    // || // this single item was already hovered.
    // props.options?.hoveringBehavior ===
    //   OVERLAY_BEHAVIOR_ON_HOVER.ALWAYS_SHOW;
    const handleHoverClickOnMobile = () => {
        if (isCurrentlyHovered) {
            handleGalleryItemAction();
            eventsListener(GALLERY_EVENTS.HOVER_SET, { index: -1 });
        }
        else {
            eventsListener(GALLERY_EVENTS.HOVER_SET, { index });
        }
    };
    const shouldShowHoverOnMobile = () => {
        if (utils.isMobile()) {
            // const { hoveringBehavior, alwaysShowHover, previewHover } =
            // props.options?.behaviors?.item?.overlay || {};
            // if (hoveringBehavior === OVERLAY_BEHAVIOR_ON_HOVER.NEVER_SHOW) {
            //   return false;
            // }
            if (itemClickAction === CLICK_ACTION.NOTHING &&
                data.type !== MediaTypes.VIDEO) {
                return true;
            }
            // if (
            // this.props.customComponents.customHoverRenderer &&
            // GALLERY_CONSTS.hasHoverPlacement(
            //   this.props.options[optionsMap.layoutParams.info.placement]
            // ) &&
            // hoveringBehaviour !== OVERLAY_BEHAVIOR_ON_HOVER.NEVER_SHOW
            // ) {
            // return true;
            // }
            // TODO Notice this important case
            // if (isEditMode() && previewHover) {
            //   return true;
            // }
            if (isEditMode()) {
                return true;
            }
        }
        return false;
    };
    // const shouldShowSecondMediaOnMobile = () => {
    //   if (utils.isMobile()) {
    //     if (
    //       itemClickAction === CLICK_ACTION.NOTHING &&
    //       data.type !== 'video' &&
    //       data.type !== '3d'
    //     ) {
    //       return (
    //         props.options?.secondaryMedia?.trigger ===
    //         SECONDARY_MEDIA_TRIGGER.HOVER
    //       );
    //     } else {
    //       return false;
    //     }
    //   }
    //   return false;
    // };
    const shouldHoverWithoutOverlayAndClickOnMobile = () => {
        return (utils.isMobile() &&
            // props.options?.behaviors?.item?.video?.playTrigger ===
            //   PLAY_TRIGGER.HOVER &&
            itemClickAction === CLICK_ACTION.NOTHING);
    };
    const getItemAriaLabel = () => {
        const { type } = data;
        const { alt, description, title } = data.metaData;
        const label = alt || title || description.substring(0, 120);
        const defaultLabel = `Gallery item ${index + 1}`;
        const mapTypeToLabel = {
            [MediaTypes.VIDEO]: label || `${defaultLabel} (video)`,
            [MediaTypes.IMAGE]: label || defaultLabel,
        };
        return mapTypeToLabel[type];
    };
    // const getItemContainerTabIndex = () => {
    //   const tabIndex = this.isHighlight()
    //     ? utils.getTabIndex('currentThumbnail')
    //     : this.props.activeIndex === this.props.idx
    //     ? utils.getTabIndex('currentGalleryItem')
    //     : -1;
    //   return tabIndex;
    // }; //TODO: add this when getTabIndex is needed
    const generateResizedMediaUrl = () => {
        const resizeMediaConsts = {
            resizeMethod: 'fit',
            requiredWidth: 1000,
            requiredHeight: 1000,
            createMultiple: true,
        };
        const resizeMediaParams = {
            ...resizeMediaConsts,
            item: { item: data, dto: { imageToken: '' } },
            originalUrl: data.mediaUrl,
        };
        if (typeof createResizedMediaUrl === 'function') {
            return createResizedMediaUrl(resizeMediaParams);
        }
        else {
            return data.mediaUrl;
        }
    };
    const itemRendererProps = {
        data: { ...data, mediaUrl: generateResizedMediaUrl() },
        selectors,
        customRenderers,
        eventsListener,
        onItemClick,
        shouldUseDirectLink,
        options,
    };
    // Get custom attributes for the item element
    const itemCustomAttributes = getItemCustomAttributes
        ? getItemCustomAttributes(index)
        : {};
    return (React.createElement("div", { ref: itemRef, className: classNames(s.item, selectors?.item, isActive ? 'active' : '', isInFocus ? 'focus' : '', isItemClickable() ? s.clickable : '', isCurrentlyHovered ? 'item-hover' : '', isAccessible ? 'accessible' : ''), tabIndex: index === activeIndex ? 0 : -1, "data-index": index, role: "listitem", onContextMenu: (e) => {
            handleRightClickContextMenu(e);
        }, onClick: (e) => onItemClick(e, false), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onFocus: onFocus, onBlur: onBlur, onKeyDown: onKeyDown, "aria-label": getItemAriaLabel(), ...itemCustomAttributes }, renderCustomOrDefaultComp(customRenderers?.itemRenderer, ItemRenderer, itemRendererProps)));
};
export default Item;
//# sourceMappingURL=Item.js.map