import React, { useRef, useEffect, useState } from 'react';
import classNames from 'clsx';
import { useMeasure } from '../../navigator';
import Item from '../item/Item';
import { makeEventsListener, } from '../../lib';
import { defaultGallerySelectors, hoverClasses } from '../generalConstants';
import s from './Gallery.module.scss';
import { useArrowsNavigation } from '../hooks/useArrowNavigation';
const Gallery = ({ dataList, selectors: gallerySelectors, customRenderers, eventsListener = () => { }, createResizedMediaUrl, options = { disableContextMenu: true }, isAccessible = false, wrapperRef, getItemCustomAttributes, }) => {
    const [navigator, setNavigator] = useState(null);
    const scrollerRef = useRef(null);
    const defaultScrollerWrapperRef = useRef(null);
    const scrollerWrapperRef = wrapperRef
        ? wrapperRef
        : defaultScrollerWrapperRef;
    const containerRef = useRef(null);
    const [currentIndex, setCurrentIndex] = useState(0);
    const { handleKeyDown, registerItemRef } = useArrowsNavigation(navigator, isAccessible);
    const [isInHover, setIsInHover] = useState(false);
    const [currentHoveredIndex, setCurrentHoveredIndex] = useState(-1);
    const selectors = {
        ...defaultGallerySelectors,
        ...gallerySelectors,
    };
    const galleryEventsListener = makeEventsListener()
        .CURRENT_ITEM_CHANGED((eventData) => {
        setCurrentIndex(eventData.index);
    })
        .HOVER_SET((eventData) => {
        setCurrentHoveredIndex(eventData.index ?? -1);
    })
        .done(eventsListener);
    useEffect(() => {
        const loadNavigator = async () => {
            const { Navigator } = await import(
            /* webpackChunkName: "Navigator" */
            '../../navigator');
            setNavigator(new Navigator({
                initSettings: {},
                eventsListener: galleryEventsListener,
            }));
        };
        loadNavigator();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    useEffect(() => {
        if (navigator === null) {
            return;
        }
        navigator.setScrollerRef(scrollerRef);
        navigator.setWrapperRef(wrapperRef);
        navigator.setContainerRef(containerRef);
        navigator.updateTotalItemsCount(5);
        const scrollerElement = scrollerRef.current;
        if (scrollerElement) {
            scrollerElement.addEventListener('keydown', handleKeyDown);
        }
        return () => {
            if (navigator === null) {
                return;
            }
            navigator.removeScrollerRef(scrollerRef);
            navigator.removeWrapperRef(wrapperRef);
            navigator.removeContainerRef(containerRef);
            if (scrollerElement) {
                scrollerElement.removeEventListener('keydown', handleKeyDown);
            }
        };
    }, [navigator, scrollerRef, wrapperRef, handleKeyDown]);
    const handleScrollerMeasure = (newMeasurements) => {
        navigator?.updateScrollerMeasurements(newMeasurements);
    };
    const handleWrapperMeasure = (newMeasurements) => {
        navigator?.updateWrapperMeasurements(newMeasurements);
    };
    const handleContainerMeasure = (newMeasurements) => {
        navigator?.updateContainerMeasurements(newMeasurements);
    };
    const handleItemMeasure = (index, newMeasurements, itemRef) => {
        navigator?.updateItemMeasurements(newMeasurements, index, itemRef);
    };
    useMeasure({
        callback: (measurements) => handleScrollerMeasure(measurements),
        ref: scrollerRef,
    });
    useMeasure({
        callback: (measurements) => handleWrapperMeasure(measurements),
        ref: scrollerWrapperRef,
    });
    useMeasure({
        callback: (measurements) => handleContainerMeasure(measurements),
        ref: containerRef,
    });
    const onMouseEnter = () => {
        // the commented code is copied from pro-gallery and is not used in this component currently
        // if (
        //   this.currentScrollData?.isContinuousScrolling &&
        //   this.state.options[optionsMap.behaviourParams.gallery.horizontal.autoSlide.pauseOnHover]
        // ) {
        //   haltScroll(this.currentScrollData);
        // }
        setIsInHover(true);
        containerRef.current?.classList.add(hoverClasses.containerHover);
    };
    const onMouseLeave = () => {
        setIsInHover(false);
        containerRef.current?.classList.remove(hoverClasses.containerHover);
    };
    const onContainerFocus = () => {
        setIsInHover(true);
        containerRef.current?.classList.add(hoverClasses.containerHover);
    };
    const onContainerBlur = () => {
        setIsInHover(false);
        containerRef.current?.classList.remove(hoverClasses.containerHover);
    };
    return (React.createElement("div", { ref: scrollerRef, id: "scroller", className: classNames(s.scroller, 'scroller', selectors?.scroller, isInHover && s.hover), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave },
        React.createElement("div", { ref: containerRef, className: classNames(s.container, selectors?.container, isInHover ? 'container-hover' : ''), role: "list", onFocus: onContainerFocus, onBlur: onContainerBlur, tabIndex: isAccessible ? 0 : -1 }, dataList.map((data, index) => (React.createElement(Item, { getItemCustomAttributes: getItemCustomAttributes, key: data.id, index: index, data: data, selectors: selectors, customRenderers: customRenderers, eventsListener: galleryEventsListener, createResizedMediaUrl: createResizedMediaUrl, onMeasure: handleItemMeasure, activeIndex: currentIndex, isCurrentlyHovered: index === currentHoveredIndex, options: options, isAccessible: isAccessible, registerItemRef: registerItemRef }))))));
};
export default Gallery;
//# sourceMappingURL=Gallery.js.map