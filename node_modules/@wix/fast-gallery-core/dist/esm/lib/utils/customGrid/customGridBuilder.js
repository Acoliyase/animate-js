import { serializeStyles } from '@emotion/serialize';
import { CustomGridScrollDirection, GapUnits, } from '../../types';
import { lcmArray } from '../mathUtils';
import { cssStringToBuilderReturnType } from '../commonUtils';
// calculates the sum of all 'proportion' values in a row
const getRowProportions = (row) => row.cells.reduce((p, c) => p + Math.abs(c.proportion), 0);
const getPatternCellCount = (pattern) => pattern.rows.reduce((rp, rc) => rp + rc.cells.reduce((cp, cc) => cp + (cc.proportion > 0 ? 1 : 0), 0), 0);
const getVerticalParentCss = (oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns) => {
    return {
        display: 'grid',
        gridTemplateColumns: `repeat(${maxColumns}, 1fr)`,
        gridAutoFlow: 'row',
        gap: `${verticalGap + verticalGapUnit} ${horizontalGap + horizontalGapUnit}`,
        gridAutoRows: oppositePattern || 'auto',
    };
};
const getHorizontalParentCss = (oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns) => {
    return {
        display: 'grid',
        gridTemplateRows: `repeat(${maxColumns}, 1fr)`,
        gridAutoFlow: 'column',
        gap: `${verticalGap + verticalGapUnit} ${horizontalGap + horizontalGapUnit}`,
        gridAutoColumns: oppositePattern || 'auto',
    };
};
const getChildCss = (itemSelector, cellCount, cellIndex, mode, startColumn, endColumn) => {
    return {
        [`${itemSelector}:nth-child(${cellCount}n+${cellIndex})`]: mode === CustomGridScrollDirection.vertical
            ? {
                gridColumn: `${startColumn}/${endColumn}`,
            }
            : {
                gridRow: `${startColumn}/${endColumn}`,
            },
    };
};
export const buildCustomGridStyles = ({ selectors: { itemSelector, parentSelector }, pattern, oppositePattern = 'auto', flip = false, mode = CustomGridScrollDirection.vertical, horizontalGap = 0, horizontalGapUnit = GapUnits.px, verticalGap = 0, verticalGapUnit = GapUnits.px, }) => {
    const maxColumns = lcmArray(pattern.rows.map(getRowProportions));
    const flipValue = flip ? 2 : 1;
    const parentRule = {
        [parentSelector]: mode === CustomGridScrollDirection.vertical
            ? getVerticalParentCss(oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns)
            : getHorizontalParentCss(oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns),
    };
    const childRules = {};
    const patternCellCount = getPatternCellCount(pattern);
    const cellCount = patternCellCount * flipValue;
    let cellIndex = 1;
    for (let flipIndex = 0; flipIndex < flipValue; flipIndex++) {
        const isFlip = flipIndex > 0;
        for (const row of pattern.rows) {
            let cellPosition = 0;
            const cellWeight = maxColumns / getRowProportions(row);
            const cells = isFlip ? [...row.cells].reverse() : row.cells;
            for (const cell of cells) {
                if (cell.proportion > 0) {
                    const startColumn = cellPosition + 1;
                    const endColumn = startColumn + cellWeight * cell.proportion;
                    const childCss = getChildCss(itemSelector, cellCount, cellIndex, mode, startColumn, endColumn);
                    if (childCss) {
                        Object.assign(childRules, {
                            ...childCss,
                        });
                    }
                    cellIndex++;
                }
                cellPosition += Math.abs(cell.proportion) * cellWeight;
            }
        }
    }
    const customGridStylesheet = serializeStyles([{
            ...parentRule,
            ...childRules,
        }]).styles;
    return cssStringToBuilderReturnType(customGridStylesheet);
};
//# sourceMappingURL=customGridBuilder.js.map