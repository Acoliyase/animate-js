import WindowMock, { hydrateMockMap } from './window.mock';
class WindowWrapper {
    constructor() {
        this._shouldUseMock = true;
        this.initProxyWindow = this.initProxyWindow.bind(this);
        if (this.windowIsAvailable()) {
            // this will wrap the real window with partial mock for the dimensions
            // once the gallery is mounted we will switch from the mocked properties to the real values
            this.initProxyWindow();
        }
        else {
            this.initMockWindow();
        }
    }
    windowIsAvailable() {
        try {
            return typeof window !== 'undefined';
        }
        catch (e) {
            return false;
        }
    }
    initProxyWindow() {
        const handler = {
            get: (target, property) => {
                if (hydrateMockMap.has(property) && this.shouldUseMock) {
                    return hydrateMockMap.get(property);
                }
                return target[property];
            },
            set: (target, property, value) => {
                return Reflect.set(target, property, value);
            },
        };
        // eslint-disable-next-line no-undef
        const windowProxy = new Proxy(window, handler);
        // Initialize proGalleryCustomProps as a Set if it doesn't exist
        if (!windowProxy.proGalleryCustomProps) {
            windowProxy.proGalleryCustomProps = new Set();
        }
        const windowFuncHandler = {
            get: (property) => {
                const props = windowProxy.proGalleryCustomProps;
                if (!props.has(property) &&
                    typeof windowProxy[property] === 'function') {
                    return windowProxy[property].bind(window);
                }
                return windowProxy[property];
            },
            set: (property, value) => {
                const props = windowProxy.proGalleryCustomProps;
                if (typeof property === 'string') {
                    props.add(property);
                }
                return Reflect.set(windowProxy, property, value);
            },
        };
        // this second proxy that returns bound functions to avoid issues with non-configurable properties
        // eslint-disable-next-line no-undef
        this.window = new Proxy({}, windowFuncHandler);
    }
    initMockWindow() {
        this.window = WindowMock;
        this.window.mockInstanceId = Math.floor(Math.random() * 100000);
    }
    stopUsingMock() {
        this.shouldUseMock = false;
    }
    get shouldUseMock() {
        return this._shouldUseMock;
    }
    set shouldUseMock(shouldUseMock) {
        this._shouldUseMock = shouldUseMock;
    }
}
const windowWrapper = new WindowWrapper();
const _window = windowWrapper.window;
export default _window;
export { windowWrapper };
//# sourceMappingURL=windowWrapper.js.map