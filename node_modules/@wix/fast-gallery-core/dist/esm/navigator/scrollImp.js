import { Deferred } from './asyncUtils';
import { isHTMLElement } from './navigatorUtils';
function isWindow(obj) {
    return obj != null && obj === obj.window;
}
// this is a fallback for cases that the scroller cannot handle for now like flex box (classic slideshow)
// ideally we want to have on function for this scrolling. may require some refactor in the navigator
export function fallbackScrollIntoView(target, container, duration) {
    if (!container?.current || !target?.current)
        return;
    let startX;
    let startY;
    const isContainerWindow = isWindow(container.current);
    if (!isContainerWindow) {
        startX = container.current.scrollLeft;
        startY = container.current.scrollTop;
    }
    else {
        startX = container.current.scrollX;
        startY = container.current.scrollY;
    }
    const targetRect = target.current.getBoundingClientRect();
    const containerRect = isContainerWindow ? { top: 0, left: 0 } : container.current.getBoundingClientRect();
    const targetX = targetRect.left - containerRect.left + startX;
    const targetY = targetRect.top - containerRect.top + startY;
    const distanceX = targetX - startX;
    const distanceY = targetY - startY;
    const startTime = performance.now();
    function easeInOutQuad(t) {
        return t < 0.5
            ? 2 * t * t
            : -1 + (4 - 2 * t) * t;
    }
    if (!isContainerWindow) {
        container.current.style.scrollSnapType = "none";
    }
    function animateScroll(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const ease = easeInOutQuad(progress);
        const scrollToX = startX + distanceX * ease;
        const scrollToY = startY + distanceY * ease;
        if (isContainerWindow) {
            window.scrollTo({
                top: scrollToY,
                left: scrollToX,
            });
        }
        else {
            container?.current?.scrollTo({
                top: scrollToY,
                left: scrollToX,
            });
        }
        if (progress < 1) {
            requestAnimationFrame(animateScroll);
        }
        else {
            if (!isContainerWindow) {
                container?.current?.style.removeProperty('scroll-snap-type');
            }
        }
    }
    requestAnimationFrame(animateScroll);
}
export function cssScrollTo({ scroller, fromX, toX, fromY, toY, duration, 
// isRTL,
slideTransition, isContinuousScrolling, autoSlideshowContinuousSpeed, }) {
    const changeX = toX - fromX;
    const changeY = toY - fromY;
    if (changeX === 0 && changeY === 0) {
        return { scrollingPromise: Promise.resolve({ x: toX, y: toY }) };
    }
    if (isContinuousScrolling) {
        const maxChange = Math.max(Math.abs(changeX), Math.abs(changeY));
        duration = (maxChange / autoSlideshowContinuousSpeed) * 1000;
    }
    if (isHTMLElement(scroller)) {
        const scrollerInner = scroller.firstChild;
        scroller.setAttribute('data-scrolling', 'true');
        Object.assign(scroller.style, {
            'scroll-snap-type': 'none',
        });
        Object.assign(scrollerInner.style, {
            transition: `transform ${duration}ms ${slideTransition}`,
            '-webkit-transition': `transform ${duration}ms ${slideTransition}`,
        }, {
            transform: `translate(${-1 * changeX}px, ${-1 * changeY}px)`,
        });
    }
    else {
        // Handle Window case
        // Window scrolling doesn't need transform or transition styles
    }
    const intervals = 10;
    const scrollTransitionEvent = new CustomEvent('scrollTransition', {
        detail: { changeX: changeX / intervals, changeY: changeY / intervals },
    });
    const scrollTransitionInterval = setInterval(() => {
        if (isHTMLElement(scroller)) {
            scroller.dispatchEvent(scrollTransitionEvent);
        }
    }, Math.round(duration / intervals));
    const scrollingPromise = new Deferred();
    // const currentScrollEndTimeout =
    setTimeout(() => {
        clearInterval(scrollTransitionInterval);
        if (isHTMLElement(scroller)) {
            const scrollerInner = scroller.firstChild;
            Object.assign(scrollerInner.style, {
                transition: `none`,
                '-webkit-transition': `none`,
            }, {
                transform: `translate(0px, 0px)`,
            });
            scroller.style.removeProperty('scroll-snap-type');
            scroller.setAttribute('data-scrolling', '');
        }
        if (isHTMLElement(scroller)) {
            scroller.scrollLeft = toX;
            scroller.scrollTop = toY;
        }
        else {
            scroller.scrollTo(toX, toY);
        }
        scrollingPromise.resolve({ x: toX, y: toY });
    }, duration);
    return {
        scrollingPromise: scrollingPromise.promise,
    };
}
// import { optionsMap, utils, GALLERY_CONSTS } from 'pro-gallery-lib';
// export function scrollToItemImp(scrollParams) {
//   let to, from;
//   const {
//     scrollMarginCorrection = 0,
//     durationInMS,
//     horizontalElement,
//     scrollingElement,
//     isRTL,
//     scrollDirection,
//     galleryWidth,
//     galleryHeight,
//     totalWidth,
//     top,
//     items,
//     itemIdx,
//     fixedScroll,
//     slideTransition,
//     isContinuousScrolling,
//     autoSlideshowContinuousSpeed,
//     itemSpacing,
//   } = scrollParams;
//   const rtlFix = isRTL ? -1 : 1;
//   // default = scroll by half the container size
//   if (scrollDirection === 'horizontal') {
//     from = horizontalElement.scrollLeft * rtlFix;
//     to = from + (itemIdx * galleryWidth) / 2;
//   } else {
//     from = top;
//     to = top + (itemIdx * galleryHeight) / 2;
//   }
//   if (fixedScroll !== true) {
//     // scroll to specific item
//     // if (utils.isVerbose()) {
//     //   console.log('Scrolling to items #' + itemIdx);
//     // }
//     const item = items.find((itm) => itm.idx === itemIdx);
//     to =
//       scrollDirection === 'horizontal'
//         ? utils.get(item, 'offset.left')
//         : utils.get(item, 'offset.top');
//     if (utils.isVerbose()) {
//       console.log('Scrolling to position ' + to, item);
//     }
//     if (!(to >= 0)) {
//       utils.isVerbose() && console.warn('Position not found, not scrolling');
//       return new Promise((res) => res());
//     }
//     if (scrollDirection === 'horizontal') {
//       // set scroll to place the item in the middle of the component
//       const diff = (galleryWidth - item.width - itemSpacing) / 2;
//       to -= diff;
//       to = Math.max(0, to);
//       to = Math.min(to, totalWidth - galleryWidth + scrollMarginCorrection);
//       to *= rtlFix;
//       from *= rtlFix;
//       if (utils.isVerbose()) {
//         console.log('Scrolling to new position ' + to, this);
//       }
//     }
//   }
//   if (scrollDirection === 'horizontal') {
//     return horizontalCssScrollTo({
//       scroller: horizontalElement,
//       from: Math.round(from),
//       to: Math.round(to),
//       duration: durationInMS,
//       isRTL,
//       slideTransition,
//       isContinuousScrolling,
//       autoSlideshowContinuousSpeed,
//     });
//   } else {
//     return new Promise((resolve) => {
//       scrollingElement.vertical().scrollTo(0, to);
//       resolve(to);
//     });
//   }
// }
// export function scrollToGroupImp(scrollParams) {
//   let to, from;
//   const {
//     scrollMarginCorrection = 0,
//     durationInMS,
//     horizontalElement,
//     scrollingElement,
//     isRTL,
//     scrollDirection,
//     galleryWidth,
//     galleryHeight,
//     totalWidth,
//     top,
//     groups,
//     groupIdx,
//     fixedScroll,
//     slideTransition,
//     isContinuousScrolling,
//     autoSlideshowContinuousSpeed,
//     itemSpacing,
//   } = scrollParams;
//   const rtlFix = isRTL ? -1 : 1;
//   // default = scroll by half the container size
//   if (scrollDirection === 'horizontal') {
//     from = horizontalElement.scrollLeft;
//     to = from + (groupIdx * galleryWidth) / 2;
//     // console.log('[RTL SCROLL] scrollTogroupImp: ', from, to);
//   } else {
//     from = top;
//     to = top + (groupIdx * galleryHeight) / 2;
//   }
//   if (fixedScroll !== true) {
//     // scroll to specific group
//     if (utils.isVerbose()) {
//       console.log('Scrolling to groups #' + groupIdx);
//     }
//     const group = groups.find((grp) => grp.idx === groupIdx);
//     to =
//       scrollDirection === 'horizontal'
//         ? utils.get(group, 'left')
//         : utils.get(group, 'top');
//     if (utils.isVerbose()) {
//       console.log('Scrolling to position ' + to, group);
//     }
//     if (!(to >= 0)) {
//       utils.isVerbose() && console.warn('Position not found, not scrolling');
//       return new Promise((res) => res());
//     }
//     if (scrollDirection === 'horizontal') {
//       // set scroll to place the group in the middle of the component
//       const diff = (galleryWidth - group.width - itemSpacing) / 2;
//       to -= diff;
//       to = Math.max(0, to);
//       to = Math.min(to, totalWidth - galleryWidth + scrollMarginCorrection);
//       to *= rtlFix;
//       if (utils.isVerbose()) {
//         console.log('Scrolling to new position ' + to, this);
//       }
//     }
//   }
//   if (scrollDirection === 'horizontal') {
//     return horizontalCssScrollTo({
//       scroller: horizontalElement,
//       from: Math.round(from),
//       to: Math.round(to),
//       duration: durationInMS,
//       isRTL,
//       slideTransition,
//       isContinuousScrolling,
//       autoSlideshowContinuousSpeed,
//     });
//   } else {
//     return new Promise((resolve) => {
//       scrollingElement.vertical().scrollTo(0, to);
//       resolve(to);
//     });
//   }
// }
// ----- rendererd / visible ----- //
// export function horizontalCssScrollTo({
//   scroller,
//   from,
//   to,
//   duration,
//   isRTL,
//   slideTransition,
//   isContinuousScrolling,
//   autoSlideshowContinuousSpeed,
// }) {
//   const change = to - from;
//   if (change === 0) {
//     return new Promise((resolve) => resolve(to));
//   }
//   if (isContinuousScrolling) {
//     duration = (Math.abs(change) / autoSlideshowContinuousSpeed) * 1000;
//   }
//   const scrollerInner = scroller.firstChild;
//   scroller.setAttribute('data-scrolling', 'true');
//   Object.assign(scroller.style, {
//     'scroll-snap-type': 'none',
//   });
//   Object.assign(
//     scrollerInner.style,
//     {
//       transition: `transform ${duration}ms ${slideTransition}`,
//       '-webkit-transition': `transform ${duration}ms ${slideTransition}`,
//     },
//     {
//       transform: `translateX(${-1 * change}px)`,
//     },
//   );
//   const intervals = 10;
//   const scrollTransitionEvent = new CustomEvent('scrollTransition', {
//     detail: change / intervals,
//   });
//   const scrollTransitionInterval = setInterval(() => {
//     scroller.dispatchEvent(scrollTransitionEvent);
//   }, Math.round(duration / intervals));
//   const scrollDeffered = new Deferred();
//   const currentScrollEndTimeout = setTimeout(() => {
//     clearInterval(scrollTransitionInterval);
//     Object.assign(
//       scrollerInner.style,
//       {
//         transition: `none`,
//         '-webkit-transition': `none`,
//       },
//       {
//         transform: `translateX(0px)`,
//       },
//     );
//     scroller.style.removeProperty('scroll-snap-type');
//     scroller.scrollLeft = to;
//     scroller.setAttribute('data-scrolling', '');
//     scrollDeffered.resolve(to);
//   }, duration);
//   return {
//     scrollDeffered,
//     scroller,
//     from,
//     to,
//     duration,
//     isRTL,
//     slideTransition,
//     isContinuousScrolling,
//     autoSlideshowContinuousSpeed,
//     currentScrollEndTimeout,
//   };
// }
// function animateStopScroll({ scroller, at, isRTL }) {
//   Object.assign(scroller.style, {
//     'scroll-snap-type': 'none',
//   });
//   const scrollDeffered = new Deferred();
//   Object.assign(
//     scroller.firstChild.style,
//     {
//       transition: `none`,
//       '-webkit-transition': `none`,
//     },
//     {
//       transform: `translateX(0px)`,
//     },
//   );
//   scroller.scrollLeft = at;
//   scrollDeffered.resolve(at);
//   return {
//     scrollDeffered,
//     scroller,
//     isRTL,
//   };
// }
// export function haltScroll({
//   scroller,
//   from,
//   isRTL,
//   currentScrollEndTimeout,
//   scrollDeffered,
// }) {
//   clearTimeout(currentScrollEndTimeout);
//   const scrollerInner = scroller.firstChild;
//   const computedStyle = getComputedStyle(scrollerInner);
//   const transform = computedStyle.getPropertyValue('transform');
//   const matrix = new DOMMatrix(transform);
//   const margins = Math.round(parseInt(matrix.m41, 10));
//   from = from - margins;
//   animateStopScroll({
//     scroller,
//     at: from,
//     isRTL,
//   });
//   scrollDeffered.resolve(from);
// }
//# sourceMappingURL=scrollImp.js.map