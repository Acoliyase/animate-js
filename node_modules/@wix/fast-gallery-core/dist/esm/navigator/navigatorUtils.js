export const NeedMoreItemsPaddingSize = 1500;
export function canNavigateByScroller(scrollerRef, scrollerMeasurements, containerMeasurements) {
    const scrollerExists = !!scrollerRef?.current;
    const containerExists = !!containerMeasurements; // Need to see if this is enough, TODO - if I have the ref by the end of it - use it
    const differentDimensions = !areDimensionsEqual(scrollerMeasurements, containerMeasurements);
    return scrollerExists && containerExists && differentDimensions;
}
export function areDimensionsEqual(containerMeasurements, scrollerMeasurements) {
    if (!containerMeasurements || !scrollerMeasurements) {
        throw new Error('containerMeasurements and scrollerMeasurements must be defined');
    }
    const containerWidth = containerMeasurements.width;
    const containerHeight = containerMeasurements.height;
    const scrollerWidth = scrollerMeasurements.width;
    const scrollerHeight = scrollerMeasurements.height;
    const sameHeight = containerHeight === scrollerHeight;
    const sameWidth = containerWidth === scrollerWidth;
    return sameHeight && sameWidth;
}
export function isALargerThanB(a, b) {
    if (!a || !b) {
        throw new Error('two measurements must be defined');
    }
    const byHeight = a.height >= b.height;
    const byWidth = a.width >= b.width;
    return byHeight && byWidth;
}
export function isHTMLElement(element) {
    return element instanceof HTMLElement;
}
export function isWindowElement(element) {
    return element instanceof Window;
}
export function someItemsOutsideOfContainer(items, containerMeasurements) {
    if (!containerMeasurements) {
        throw new Error('containerMeasurements must be defined to check for items arrangement');
    }
    return items.some((item) => {
        return (item.measurements.left + item.measurements.width >
            containerMeasurements.width ||
            item.measurements.top + item.measurements.height >
                containerMeasurements.height);
    });
}
export function isCurrentlyNavigating(currentNavigation, currentScroll) {
    return ((currentNavigation && currentNavigation.state === 'pending') || // navigation promise is ongoing
        currentScroll // current scroll in process
    );
}
export function getScrollPositionFromMeasurements(measurements) {
    return {
        x: measurements.left,
        y: measurements.top,
    };
}
export function isAtEnd(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
    return isAtScrollEnd(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition);
}
export function isAtScrollEnd(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
    if (isRTL) {
        return (isAtScrollStartX(scrollPosition) &&
            isAtScrollEndY(scrollerMeasurements, navigationBoundries, scrollPosition));
    }
    else {
        return (isAtScrollEndX(scrollerMeasurements, navigationBoundries, scrollPosition) &&
            isAtScrollEndY(scrollerMeasurements, navigationBoundries, scrollPosition));
    }
}
export function isAtStart(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
    if (isRTL) {
        return (isAtScrollEndX(scrollerMeasurements, navigationBoundries, scrollPosition) && isAtScrollStartY(scrollPosition));
    }
    else {
        return isAtScrollStartX(scrollPosition) && isAtScrollStartY(scrollPosition);
    }
}
export function isAtScrollStartX(scrollPosition) {
    return scrollPosition.x === 0;
}
export function isAtScrollStartY(scrollPosition) {
    return scrollPosition.y === 0;
}
export function isAtScrollEndX(scrollerMeasurements, navigationBoundries, scrollPosition) {
    return (navigationBoundries.height != 0 && scrollPosition.x >= navigationBoundries.width - scrollerMeasurements.width);
}
export function isAtScrollEndY(scrollerMeasurements, navigationBoundries, scrollPosition) {
    return (scrollPosition.y >=
        navigationBoundries.height - scrollerMeasurements.height);
}
export function isAtScrollEndWithPadding(isRTL, scrollerMeasurements, navigationBoundaries, scrollPosition, padding) {
    const paddedScrollPosition = {
        x: scrollPosition.x + padding,
        y: scrollPosition.y + padding,
    };
    return isAtScrollEnd(isRTL, scrollerMeasurements, navigationBoundaries, paddedScrollPosition);
}
export function reachedToNeedMoreItems(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
    // should return true if the scroll in the gallery reached the threshold to load more items (considering the padding)
    return isAtScrollEndWithPadding(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition, NeedMoreItemsPaddingSize);
}
export function getScrollPositionFromEvent(event) {
    let target;
    if (event.target === document && event.bubbles) {
        //scrolling through window
        // @ts-ignore
        target = event.srcElement.scrollingElement;
    }
    else {
        // scrolling through a div
        target = event.target;
    }
    return { x: target.scrollLeft, y: target.scrollTop };
}
export function isItemCenteredX(itemMeasurements, centerX) {
    const itemLeft = itemMeasurements.left;
    const itemRight = itemMeasurements.left + itemMeasurements.width;
    return itemLeft < centerX && itemRight > centerX;
}
export function isItemCenteredY(itemMeasurements, centerY) {
    const itemTop = itemMeasurements.top;
    const itemBottom = itemMeasurements.top + itemMeasurements.height;
    return itemTop < centerY && itemBottom > centerY;
}
export function isItemCenteredBothAxes(itemMeasurements, centerX, centerY) {
    return (isItemCenteredX(itemMeasurements, centerX) &&
        isItemCenteredY(itemMeasurements, centerY));
}
//# sourceMappingURL=navigatorUtils.js.map