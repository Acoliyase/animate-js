import { useCallback, useEffect, useRef, useState } from 'react';
import { isHTMLElement, isWindowElement } from './navigatorUtils';
const measureImpUsingOffsets = (ref) => {
    try {
        if (ref.current) {
            const element = ref.current;
            if (isHTMLElement(element)) {
                const newMeasurements = {
                    width: Math.floor(element.offsetWidth),
                    height: Math.floor(element.offsetHeight),
                    top: Math.floor(element.offsetTop),
                    left: Math.floor(element.offsetLeft),
                };
                return newMeasurements;
            }
            if (isWindowElement(element)) {
                const newMeasurements = {
                    width: Math.floor(element.innerWidth),
                    height: Math.floor(element.innerHeight),
                    // todo - check if this is correct
                    top: 0,
                    left: 0, // Window doesn't have 'left' in the same way
                };
                return newMeasurements;
            }
            throw new Error('Ref is neither an HTMLElement nor a Window');
        }
        else {
            console.warn('ref.current is null', ref);
            return { width: 0, height: 0, top: 0, left: 0 };
        }
    }
    catch (e) {
        console.error('could not get measurements for ', ref, e);
        return { width: 0, height: 0, top: 0, left: 0 };
    }
};
export const useMeasure = ({ callback, index, ref, allowMeasuring = true, // Default value
 }) => {
    const [currentMeasurements, setCurrentMeasurements] = useState(null);
    const debounceTimeout = useRef(undefined);
    const measure = useCallback(() => {
        if (!allowMeasuring || !ref.current) {
            return;
        } // Check if measuring is allowed
        const newMeasurements = measureImpUsingOffsets(ref);
        if (!currentMeasurements ||
            newMeasurements.width !== currentMeasurements.width ||
            newMeasurements.height !== currentMeasurements.height ||
            newMeasurements.top !== currentMeasurements.top ||
            newMeasurements.left !== currentMeasurements.left) {
            setCurrentMeasurements(newMeasurements);
            callback(newMeasurements, index);
        }
    }, [allowMeasuring, callback, currentMeasurements, index, ref]);
    useEffect(() => {
        const handleEvents = () => {
            if (!allowMeasuring) {
                return;
            } // Check if measuring is allowed
            if (debounceTimeout.current) {
                clearTimeout(debounceTimeout.current);
            }
            debounceTimeout.current = window.setTimeout(() => {
                window.setTimeout(measure, 0);
            }, 50);
        };
        const resizeObserver = new ResizeObserver(handleEvents);
        const intersectionObserver = new IntersectionObserver(handleEvents);
        if (isWindowElement(ref.current)) {
            window.addEventListener('resize', handleEvents);
            handleEvents(); // Initial measurement on window resize
        }
        else if (ref.current) {
            resizeObserver.observe(ref.current);
            intersectionObserver.observe(ref.current);
        }
        return () => {
            if (debounceTimeout.current) {
                clearTimeout(debounceTimeout.current);
            }
            if (isHTMLElement(ref.current)) {
                resizeObserver.unobserve(ref.current);
                intersectionObserver.unobserve(ref.current);
            }
            if (isWindowElement(ref.current)) {
                window.removeEventListener('resize', handleEvents);
            }
        };
    }, [allowMeasuring, measure, ref]);
};
//# sourceMappingURL=useMeasure.js.map