/* eslint-disable @typescript-eslint/no-dynamic-delete */
import { NavigationModes } from './navigationModes';
import { cssScrollTo, fallbackScrollIntoView } from './scrollImp';
import { TrackablePromise, Deferred } from './asyncUtils';
import { NavigationErrors } from './navigationErrors';
import { isAtEnd, isAtStart, canNavigateByScroller, isALargerThanB, someItemsOutsideOfContainer, isCurrentlyNavigating, getScrollPositionFromMeasurements, getScrollPositionFromEvent, isItemCenteredBothAxes, reachedToNeedMoreItems, } from './navigatorUtils';
import { GALLERY_EVENTS, GalleryUtils, makeEventsListener, } from '../lib';
import { defaultSettings } from './defaultNavigationSettings';
const DEBOUNCE_TIMEOUT = 50;
const THROTTLING_TIMEOUT = 500;
const DEFERRED_MORE_ITEMS_TIMEOUT = 2000;
// utils debounce function
function debounce(func, timeout) {
    let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = window.setTimeout(() => {
            func(...args);
        }, timeout);
    };
}
export class Navigator {
    constructor({ initSettings, eventsListener, logger = (..._args) => {
        // console.log('NAVIGATOR:', ..._args);
    }, } = {}) {
        // private isScrolling = false;
        this._items = [];
        this._scrollerMeasurement = null;
        this._wrapperMeasurement = null;
        this._containerMeasurement = null;
        this._navigationBoundaries = null;
        this._scrollerRef = null;
        this._wrapperRef = null;
        this._containerRef = null;
        this.scrollPosition = { x: 0, y: 0 };
        this.centeredItemByBothAxes = null;
        this.currentItem = null;
        this.currentScroll = undefined;
        this.promiseToBeResolvedNextTimeAScrollEnds = undefined;
        this.currentNavigation = undefined;
        this.deferredGettingMoreItems = undefined;
        this.baseSettings = defaultSettings;
        this.totalItemsCount = Infinity;
        this.scrollEventHandler = (e) => {
            this.registerScrollStart(e);
            this.throttledScrollTasks(e);
            this.debouncedHandleScrollEnd(e);
        };
        this.debouncedFireLayoutChanged = debounce(() => {
            this.fireEvent(GALLERY_EVENTS.LAYOUT_CHANGED, {});
        }, DEBOUNCE_TIMEOUT);
        this.fireLayoutChangedEventIfLayoutChanged = (prevMeasurements, newMeasurements) => {
            if (this.areMeasurementsDifferent(prevMeasurements, newMeasurements)) {
                this.debouncedFireLayoutChanged();
            }
        };
        this.throttledGetMoreItemsIfNeeded = GalleryUtils.throttle(this.getMoreItemsIfNeededScrollBased.bind(this), THROTTLING_TIMEOUT);
        this.debouncedHandleScrollEnd = debounce(this.handleScrollEnd.bind(this), DEBOUNCE_TIMEOUT);
        this.debouncedRegisterCenteredItems = debounce(this.registerCenteredItems.bind(this), DEBOUNCE_TIMEOUT);
        this.lastNavigationStatus = {
            canNavigateToNext: null,
            canNavigateToPrevious: null,
        };
        this.debouncedCreateNavigationBoundaries = debounce(this.createNavigationBoundaries.bind(this), DEBOUNCE_TIMEOUT);
        this.baseSettings = { ...defaultSettings, ...initSettings };
        this.logger = logger;
        this.handleScrollEnd = this.handleScrollEnd.bind(this);
        this.debouncedHandleScrollEnd = this.debouncedHandleScrollEnd.bind(this);
        this.debouncedRegisterCenteredItems =
            this.debouncedRegisterCenteredItems.bind(this);
        this.registerCenteredItems = this.registerCenteredItems.bind(this);
        this.isScrollerRefScrollless = this.isScrollerRefScrollless.bind(this);
        this.throttledGetMoreItemsIfNeeded =
            this.throttledGetMoreItemsIfNeeded.bind(this);
        this.eventsListener = makeEventsListener()
            .CURRENT_ITEM_CHANGED(() => this.checkAndFireNavigationStatus())
            .LAYOUT_CHANGED(() => this.checkAndFireNavigationStatus())
            .done(eventsListener);
    }
    setScrollerRef(scrollerRef) {
        if (this._scrollerRef) {
            this.removeScrollerRef(this._scrollerRef);
        }
        this._scrollerRef = scrollerRef;
        if (scrollerRef?.current) {
            scrollerRef.current.addEventListener('scroll', this.scrollEventHandler);
        }
        this.fireNavigationApiReadyEvent();
    }
    setWrapperRef(wrapperRef) {
        if (this._wrapperRef) {
            this.removeWrapperRef(this._wrapperRef);
        }
        this._wrapperRef = wrapperRef;
        if (wrapperRef?.current) {
            wrapperRef.current.addEventListener('scroll', this.scrollEventHandler);
        }
        this.fireNavigationApiReadyEvent();
    }
    setContainerRef(containerRef) {
        if (this._containerRef) {
            this.removeScrollerRef(this._containerRef);
        }
        this._containerRef = containerRef;
        if (containerRef?.current) {
            containerRef.current.addEventListener('scroll', this.scrollEventHandler);
        }
        this.fireNavigationApiReadyEvent();
    }
    removeScrollerRef(scrollerRef) {
        if (scrollerRef?.current) {
            scrollerRef.current.removeEventListener('scroll', this.scrollEventHandler);
        }
    }
    removeWrapperRef(wrapperRef) {
        if (wrapperRef?.current) {
            wrapperRef.current.removeEventListener('scroll', this.scrollEventHandler);
        }
    }
    removeContainerRef(scrollerRef) {
        if (scrollerRef?.current) {
            scrollerRef.current.removeEventListener('scroll', this.scrollEventHandler);
        }
    }
    getActiveScrollingElement() {
        if (this.isScrollerRefScrollless()) {
            return this._wrapperRef;
        }
        else {
            return this._scrollerRef;
        }
    }
    getActiveScrollingElementMeasurements() {
        if (this.isScrollerRefScrollless()) {
            return this._wrapperMeasurement;
        }
        else {
            return this._scrollerMeasurement;
        }
    }
    areMeasurementsDifferent(prev, next) {
        if (!prev) {
            return true;
        }
        const { width, height, top, left } = prev;
        return (width !== next.width ||
            height !== next.height ||
            top !== next.top ||
            left !== next.left);
    }
    updateItemMeasurements(newMeasurements, index, itemRef) {
        const prevMeasurements = this._items[index]?.measurements || null;
        const newItem = {
            index,
            measurements: newMeasurements,
            ref: itemRef,
        };
        this._items[index] = newItem;
        this.logger(`Measurements registered for index ${index}: ${JSON.stringify(newMeasurements)}`);
        this.debouncedCreateNavigationBoundaries();
        this.debouncedRegisterCenteredItems();
        this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
    }
    updateScrollerMeasurements(newMeasurements) {
        const prevMeasurements = this._scrollerMeasurement;
        this._scrollerMeasurement = newMeasurements;
        this.logger(`Scroller measurements updated: ${JSON.stringify(newMeasurements)}`);
        this.debouncedRegisterCenteredItems();
        this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
    }
    updateWrapperMeasurements(newMeasurements) {
        const prevMeasurements = this._wrapperMeasurement;
        this._wrapperMeasurement = newMeasurements;
        this.logger(`Wrapper measurements updated: ${JSON.stringify(newMeasurements)}`);
        this.debouncedRegisterCenteredItems();
        this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
    }
    updateContainerMeasurements(newMeasurements) {
        const prevMeasurements = this._containerMeasurement;
        this._containerMeasurement = newMeasurements;
        this.logger(`Container measurements updated: ${JSON.stringify(newMeasurements)}`);
        this.debouncedCreateNavigationBoundaries();
        this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
    }
    mergeSettingsWithDefaults(functionSettings) {
        return {
            ...this.baseSettings,
            ...functionSettings,
        };
    }
    getScrollPositions(itemMeasurements, scrollSettings) {
        let x = 0;
        let y = 0;
        const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
        switch (scrollSettings.mode) {
            case NavigationModes.CENTER:
                x =
                    itemMeasurements.left +
                        itemMeasurements.width / 2 -
                        activeScrollerMeasurement.width / 2;
                y =
                    itemMeasurements.top +
                        itemMeasurements.height / 2 -
                        activeScrollerMeasurement.height / 2;
                break;
            case NavigationModes.START:
                x = itemMeasurements.left;
                y = itemMeasurements.top;
                break;
            case NavigationModes.END:
                x =
                    itemMeasurements.left +
                        itemMeasurements.width -
                        activeScrollerMeasurement.width;
                y =
                    itemMeasurements.top +
                        itemMeasurements.height -
                        activeScrollerMeasurement.height;
                break;
            default:
                throw new Error(NavigationErrors.INVALID_NAVIGATION_MODE);
        }
        return { x, y };
    }
    limitScrollPosition(x, y) {
        const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
        x = Math.min(x, this._containerMeasurement.width - activeScrollerMeasurement.width);
        x = Math.max(0, x);
        y = Math.min(y, this._containerMeasurement.height - activeScrollerMeasurement.height);
        y = Math.max(0, y);
        return { x: Math.round(x), y: Math.round(y) };
    }
    computeNavigation(index, settings) {
        const scrollSettings = this.mergeSettingsWithDefaults(settings);
        const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
        if (!activeScrollerMeasurement) {
            throw new Error(NavigationErrors.NO_SCROLLER_MEASUREMENTS);
        }
        const item = this._items[index];
        if (!item) {
            throw new Error(NavigationErrors.NO_ITEM_MEASUREMENTS);
        }
        const { x, y } = this.getScrollPositions(item.measurements, scrollSettings);
        return this.limitScrollPosition(x, y);
    }
    async isAbleToNavigateToPrevious(settings) {
        try {
            await this.previous(settings, () => Promise.resolve(true));
            return true;
        }
        catch {
            return false;
        }
    }
    async isAbleToNavigateToNext(settings) {
        try {
            await this.next(settings, () => Promise.resolve(true));
            return true;
        }
        catch {
            return false;
        }
    }
    async navigate(index, settings, staleNavigationFunction) {
        const scrollSettings = this.mergeSettingsWithDefaults(settings);
        if (isCurrentlyNavigating(this.currentNavigation, this.currentScroll)) {
            throw new Error(NavigationErrors.INVALID_NAVIGATION_IN_PROGRESS);
        }
        const activeScrollerRef = this.getActiveScrollingElement();
        const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
        if (this.isScrollerRefScrollless()) {
            // for scrollless galleries, we cant navigate by scrolling. we can only change the current item
            return this.scrolllessNavigation(index, scrollSettings, staleNavigationFunction);
        }
        else if (!canNavigateByScroller(activeScrollerRef, activeScrollerMeasurement, this._containerMeasurement)) {
            // navigate by native browser scrollIntoView
            this.logger('Cannot navigate by scroller, navigating by item.scrollIntoView');
            return this.nativeScrollingNavigation(index, scrollSettings, staleNavigationFunction);
        }
        else {
            // navigate by calculating and css implementation
            return this.defaultScrollingNavigation(index, scrollSettings, staleNavigationFunction);
        }
    }
    async defaultScrollingNavigation(index, scrollSettings, staleNavigationFunction) {
        const activeScrollerRef = this.getActiveScrollingElement();
        try {
            const navigationPromise = new Promise(async (resolve, reject) => {
                try {
                    const scrollPosition = this.computeNavigation(index, scrollSettings);
                    if (activeScrollerRef && activeScrollerRef.current) {
                        let currentScrollPositionX = 0;
                        let currentScrollPositionY = 0;
                        if (activeScrollerRef === this._scrollerRef) {
                            currentScrollPositionX = activeScrollerRef.current.scrollLeft;
                            currentScrollPositionY = activeScrollerRef.current.scrollTop;
                        }
                        else if (activeScrollerRef === this._wrapperRef) {
                            currentScrollPositionX = activeScrollerRef.current.scrollX;
                            currentScrollPositionY = activeScrollerRef.current.scrollY;
                        }
                        if (scrollPosition.x === currentScrollPositionX &&
                            scrollPosition.y === currentScrollPositionY) {
                            return reject(new Error(NavigationErrors.NO_CHANGE_IN_SCROLL_POSITION));
                        }
                        else if (staleNavigationFunction) {
                            return staleNavigationFunction()
                                .then(() => resolve(scrollPosition))
                                .catch(reject);
                        }
                        else {
                            const scrollParams = {
                                scroller: activeScrollerRef.current,
                                fromX: currentScrollPositionX,
                                toX: scrollPosition.x,
                                fromY: currentScrollPositionY,
                                toY: scrollPosition.y,
                                duration: scrollSettings.duration,
                                isRTL: false,
                                slideTransition: scrollSettings.slideTransition,
                                isContinuousScrolling: false,
                                autoSlideshowContinuousSpeed: 100,
                            };
                            this.currentNavigation = new TrackablePromise(cssScrollTo(scrollParams).scrollingPromise);
                            await this.currentNavigation;
                            resolve(scrollPosition);
                        }
                    }
                    else {
                        return reject(new Error(NavigationErrors.SCROLLER_REF_NOT_SET));
                    }
                }
                catch (error) {
                    return reject(error);
                }
            });
            const result = await navigationPromise;
            // Check if we need to loop back after navigation
            if (scrollSettings.loop && index >= 1.5 * this.totalItemsCount) {
                await this.loopBack(scrollSettings);
            }
            return result;
        }
        catch (error) {
            throw error;
        }
        finally {
            this.currentNavigation = undefined;
        }
    }
    async nativeScrollingNavigation(index, scrollSettings, staleNavigationFunction) {
        this.promiseToBeResolvedNextTimeAScrollEnds = new Deferred();
        const currentScrollPosition = { ...this.scrollPosition };
        this.promiseToBeResolvedNextTimeAScrollEnds.promise.then((scrollPosition) => {
            if (scrollPosition.x === currentScrollPosition.x &&
                scrollPosition.y === currentScrollPosition.y) {
                throw new Error(NavigationErrors.NO_CHANGE_IN_SCROLL_POSITION);
            }
        });
        const navigationPromise = new Promise(async (resolve, reject) => {
            try {
                if (staleNavigationFunction) {
                    return staleNavigationFunction()
                        .then(() => resolve(getScrollPositionFromMeasurements(this._items[index].measurements)))
                        .catch(reject);
                }
                const scrollerRef = this.getActiveScrollingElement();
                fallbackScrollIntoView(this._items[index].ref, scrollerRef, scrollSettings.duration);
                this.logger('Item scrolled into view:', index);
            }
            catch (error) {
                return reject(error);
            }
            finally {
                this.promiseToBeResolvedNextTimeAScrollEnds?.promise.then((scrollPosition) => {
                    this.logger('Scroll position AT THE END OF THE NATIVE SCROLL:', scrollPosition);
                    resolve(scrollPosition);
                    this.promiseToBeResolvedNextTimeAScrollEnds = undefined;
                });
            }
        });
        const result = await navigationPromise;
        // Check if we need to loop back after navigation
        if (scrollSettings.loop && index >= 1.5 * this.totalItemsCount) {
            await this.loopBack(scrollSettings);
        }
        return result;
    }
    async scrolllessNavigation(index, scrollSettings, staleNavigationFunction) {
        staleNavigationFunction
            ? staleNavigationFunction()
            : this.setCurrentItem(index);
        if (scrollSettings.loop && index >= 1.5 * this.totalItemsCount) {
            // TODO this happens on every navigation implementation and can be refactored
            await this.loopBack(scrollSettings);
        }
        return Promise.resolve(this.scrollPosition);
    }
    async next(settings, staleNavigationFunction) {
        // If we are already at the ending position, we cannot navigate further forward
        const definedSettings = this.mergeSettingsWithDefaults(settings);
        const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
        if (!this.isScrollerRefScrollless() &&
            isAtEnd(definedSettings.isRTL, activeScrollerMeasurement, this._navigationBoundaries, this.scrollPosition)) {
            return Promise.reject(new Error(NavigationErrors.CANNOT_NAVIGATE_TO_NEXT));
        }
        return this.navigateInDirection(1, settings, staleNavigationFunction);
    }
    async previous(settings, staleNavigationFunction) {
        // If we are already at the starting position, we cannot navigate further back
        const definedSettings = this.mergeSettingsWithDefaults(settings);
        const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
        if (!this.isScrollerRefScrollless() &&
            isAtStart(definedSettings.isRTL, activeScrollerMeasurement, this._navigationBoundaries, this.scrollPosition)) {
            return Promise.reject(new Error(NavigationErrors.CANNOT_NAVIGATE_TO_PREVIOUS));
        }
        return this.navigateInDirection(-1, settings, staleNavigationFunction);
    }
    async navigateInDirection(direction, settings, staleNavigationFunction, retries = 0) {
        // if current item is null, we cannot navigate
        if (this.currentItem === null) {
            return Promise.reject(new Error(NavigationErrors.NO_CENTERED_ITEM));
        }
        // calculate the next item recursively
        const newIndex = this.currentItem + direction + retries * direction;
        // make sure the new index is within the bounds of the items
        if (newIndex >= 0 && newIndex < this._items.length) {
            return this.navigate(newIndex, settings, staleNavigationFunction).catch((error) => {
                if (error.message === NavigationErrors.NO_CHANGE_IN_SCROLL_POSITION) {
                    this.logger('No change in scroll position, retrying navigation');
                    return this.navigateInDirection(direction, settings, staleNavigationFunction, retries + 1);
                }
                else {
                    return Promise.reject(error);
                }
            });
        }
        else {
            return Promise.reject(new Error(direction === 1
                ? NavigationErrors.CANNOT_NAVIGATE_TO_NEXT
                : NavigationErrors.CANNOT_NAVIGATE_TO_PREVIOUS));
        }
    }
    throttledScrollTasks(event) {
        this.throttledGetMoreItemsIfNeeded(event);
    }
    handleScrollEnd(event) {
        const activeScrollingElement = this.getActiveScrollingElement();
        let target;
        if (activeScrollingElement === this._wrapperRef) {
            // @ts-expect-error
            target = event.target.scrollingElement;
        }
        else if (activeScrollingElement === this._scrollerRef) {
            target = event.target;
        }
        this.scrollPosition = {
            y: target.scrollTop,
            x: target.scrollLeft,
        };
        this.registerScrollEnd(event);
        this.logger('Scroll position:', this.scrollPosition);
        this.registerCenteredItems(); // no double debouce
    }
    registerScrollStart(event) {
        if (this.currentScroll) {
            return;
        }
        else {
            this.currentScroll = new Deferred();
            if (this.promiseToBeResolvedNextTimeAScrollEnds) {
                this.currentScroll.promise.then((scrollPosition) => {
                    this.promiseToBeResolvedNextTimeAScrollEnds?.resolve(scrollPosition);
                });
            }
            this.logger('Scroll start:', event);
        }
    }
    registerScrollEnd(event) {
        this.logger('Scroll end:', event);
        this.currentScroll?.resolve(getScrollPositionFromEvent(event));
        this.currentScroll = undefined;
    }
    registerCenteredItems() {
        const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
        if (!activeScrollerMeasurement) {
            console.warn(NavigationErrors.NO_SCROLLER_MEASUREMENTS);
            return;
        }
        const scrollerCenterX = this.scrollPosition.x + activeScrollerMeasurement.width / 2;
        const scrollerCenterY = this.scrollPosition.y + activeScrollerMeasurement.height / 2;
        let closestIndex = null;
        let smallestDistance = Infinity;
        this._items.forEach((item) => {
            const measurements = item.measurements;
            const itemCenterX = measurements.left + measurements.width / 2;
            const itemCenterY = measurements.top + measurements.height / 2;
            const diffX = Math.abs(itemCenterX - scrollerCenterX);
            const diffY = Math.abs(itemCenterY - scrollerCenterY);
            const distance = Math.sqrt(diffX * diffX + diffY * diffY);
            if (isItemCenteredBothAxes(measurements, scrollerCenterX, scrollerCenterY)) {
                this.setCenteredItemByBothAxes(item.index);
                closestIndex = item.index;
                smallestDistance = 0;
            }
            else if (distance < smallestDistance) {
                closestIndex = item.index;
                smallestDistance = distance;
            }
        });
        if (closestIndex !== null) {
            this.setCenteredItemByBothAxes(closestIndex);
            this.logger(`Centered item in both axes: ${this.centeredItemByBothAxes}`);
        }
    }
    async getMoreItemsIfNeededScrollBased(event) {
        if (this.deferredGettingMoreItems?.isPending) {
            this.logger('getting more items is in progress, do nothing');
        }
        else {
            this.deferredGettingMoreItems = new Deferred();
            const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
            const invalidMeasurements = !activeScrollerMeasurement ||
                !this._containerMeasurement ||
                !this._navigationBoundaries;
            if (invalidMeasurements) {
                this.deferredGettingMoreItems.reject(NavigationErrors.NO_SCROLLER_MEASUREMENTS);
            }
            else {
                const needMoreItems = reachedToNeedMoreItems(this.baseSettings.isRTL, activeScrollerMeasurement, this._navigationBoundaries, this.scrollPosition);
                if (needMoreItems) {
                    this.fireEvent(GALLERY_EVENTS.NEED_MORE_ITEMS, {
                        event,
                    });
                    setTimeout(() => {
                        this.deferredGettingMoreItems?.resolve(event);
                    }, DEFERRED_MORE_ITEMS_TIMEOUT);
                }
                else {
                    this.deferredGettingMoreItems.resolve(event);
                }
            }
        }
        return this.deferredGettingMoreItems.promise.catch((e) => console.error('failed in get more items through scrolling', e));
    }
    getCenteredItemByBothAxes() {
        return this.centeredItemByBothAxes;
    }
    setCenteredItemByBothAxes(index) {
        if (index === this.centeredItemByBothAxes) {
            return; // unchanged
        }
        if (typeof index !== 'number') {
            return;
        }
        this.centeredItemByBothAxes = index;
        if (!this.isScrollerRefScrollless()) {
            // dont set by scroll in a scrollless gallery
            this.setCurrentItem(index);
        }
    }
    fireEvent(...args) {
        this.logger('Firing Event:', ...args);
        if (typeof this.eventsListener === 'function') {
            this.eventsListener(...args);
        }
    }
    setCurrentItem(index) {
        if (this.currentItem !== index) {
            this.fireEvent(GALLERY_EVENTS.CURRENT_ITEM_CHANGED, { index });
            this.currentItem = index;
        }
    }
    getCurrentIndex() {
        return this.currentItem;
    }
    updateTotalItemsCount(count) {
        this.totalItemsCount = count;
    }
    async checkAndFireNavigationStatus() {
        const newStatus = {
            canNavigateToNext: await this.isAbleToNavigateToNext(),
            canNavigateToPrevious: await this.isAbleToNavigateToPrevious(),
        };
        if (newStatus.canNavigateToNext !==
            this.lastNavigationStatus.canNavigateToNext ||
            newStatus.canNavigateToPrevious !==
                this.lastNavigationStatus.canNavigateToPrevious) {
            this.lastNavigationStatus = newStatus;
            this.fireEvent(GALLERY_EVENTS.NAVIGATION_STATUS_CHANGED, newStatus);
        }
    }
    async loopBack(settings) {
        if (this.totalItemsCount === Infinity) {
            return Promise.reject(new Error(NavigationErrors.CANNOT_LOOP_WITHOUT_TOTAL_ITEMS_COUNT));
        }
        const middleIndex = Math.ceil(this.totalItemsCount / 2);
        // Use navigate to perform the scroll
        return this.navigate(middleIndex, { ...settings, duration: 0 });
    }
    fireNavigationApiReadyEvent() {
        this.fireEvent(GALLERY_EVENTS.NAVIGATION_API_READY, this.getNavigationApi());
    }
    getNavigationApi() {
        return {
            navigateToIndex: this.navigate.bind(this),
            next: this.next.bind(this),
            previous: this.previous.bind(this),
            currentIndex: this.getCurrentIndex.bind(this),
            canNavigateToNext: this.isAbleToNavigateToNext.bind(this),
            canNavigateToPrevious: this.isAbleToNavigateToPrevious.bind(this),
            isScrollerRefScrollless: this.isScrollerRefScrollless.bind(this),
            getNextItemByDirection: this.getNextItemByDirection.bind(this),
        };
    }
    isScrollerRefScrollless() {
        // Scrolless is the case of a stack of items where all the items are contained in the container boundries and a <= is size. this means there is no scroll (not even fake flex scroll)
        this.logger(isALargerThanB(this._scrollerMeasurement, this._containerMeasurement), someItemsOutsideOfContainer(this._items, this._containerMeasurement));
        return (isALargerThanB(this._scrollerMeasurement, this._containerMeasurement) &&
            !someItemsOutsideOfContainer(this._items, this._containerMeasurement));
    }
    createNavigationBoundaries() {
        this._navigationBoundaries = this.calculateNavigationBoundaries();
    }
    calculateNavigationBoundaries() {
        // this is the maximum value in each axis combining both the containerMeasurements and each one of the item measurements to create the max boundries of the possible navigation
        const maxX = Math.max(this._containerMeasurement.width, ...this._items.map(
        // TODO, im sure this can be optimized, but any optimization in the length of the tested array will create edge cases. maybe for now a reduce could be more relevant
        (item) => item.measurements.left + item.measurements.width));
        const maxY = Math.max(this._containerMeasurement.height, ...this._items.map(
        // TODO, im sure this can be optimized, but any optimization in the length of the tested array will create edge cases. maybe for now a reduce could be more relevant
        (item) => item.measurements.top + item.measurements.height));
        this.logger('Navigation boundaries:', { maxX, maxY });
        return {
            width: maxX,
            height: maxY,
            top: 0,
            left: 0,
        };
    }
    focusOnFirstItem() {
        if (this._items.length > 0) {
            this.setCenteredItemByBothAxes(0);
            this.setCurrentItem(0);
            this.logger(`Initial focus set to first item: 0`);
        }
    }
    getNextItemByDirection(currentIndex, direction) {
        if (this._items.length === 0) {
            return null;
        }
        const directionMap = {
            left: (index, length) => (index === 0 ? length - 1 : index - 1),
            right: (index, length) => (index === length - 1 ? 0 : index + 1),
            // Vertical navigation not implemented yet - return current index
            up: (index, _length) => index,
            down: (index, _length) => index,
        };
        return directionMap[direction](currentIndex, this._items.length);
    }
}
//# sourceMappingURL=navigator.js.map