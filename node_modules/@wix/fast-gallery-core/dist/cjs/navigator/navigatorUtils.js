"use strict";

exports.__esModule = true;
exports.NeedMoreItemsPaddingSize = void 0;
exports.areDimensionsEqual = areDimensionsEqual;
exports.canNavigateByScroller = canNavigateByScroller;
exports.getScrollPositionFromEvent = getScrollPositionFromEvent;
exports.getScrollPositionFromMeasurements = getScrollPositionFromMeasurements;
exports.isALargerThanB = isALargerThanB;
exports.isAtEnd = isAtEnd;
exports.isAtScrollEnd = isAtScrollEnd;
exports.isAtScrollEndWithPadding = isAtScrollEndWithPadding;
exports.isAtScrollEndX = isAtScrollEndX;
exports.isAtScrollEndY = isAtScrollEndY;
exports.isAtScrollStartX = isAtScrollStartX;
exports.isAtScrollStartY = isAtScrollStartY;
exports.isAtStart = isAtStart;
exports.isCurrentlyNavigating = isCurrentlyNavigating;
exports.isHTMLElement = isHTMLElement;
exports.isItemCenteredBothAxes = isItemCenteredBothAxes;
exports.isItemCenteredX = isItemCenteredX;
exports.isItemCenteredY = isItemCenteredY;
exports.isWindowElement = isWindowElement;
exports.reachedToNeedMoreItems = reachedToNeedMoreItems;
exports.someItemsOutsideOfContainer = someItemsOutsideOfContainer;
const NeedMoreItemsPaddingSize = exports.NeedMoreItemsPaddingSize = 1500;
function canNavigateByScroller(scrollerRef, scrollerMeasurements, containerMeasurements) {
  const scrollerExists = !!(scrollerRef != null && scrollerRef.current);
  const containerExists = !!containerMeasurements; // Need to see if this is enough, TODO - if I have the ref by the end of it - use it
  const differentDimensions = !areDimensionsEqual(scrollerMeasurements, containerMeasurements);
  return scrollerExists && containerExists && differentDimensions;
}
function areDimensionsEqual(containerMeasurements, scrollerMeasurements) {
  if (!containerMeasurements || !scrollerMeasurements) {
    throw new Error('containerMeasurements and scrollerMeasurements must be defined');
  }
  const containerWidth = containerMeasurements.width;
  const containerHeight = containerMeasurements.height;
  const scrollerWidth = scrollerMeasurements.width;
  const scrollerHeight = scrollerMeasurements.height;
  const sameHeight = containerHeight === scrollerHeight;
  const sameWidth = containerWidth === scrollerWidth;
  return sameHeight && sameWidth;
}
function isALargerThanB(a, b) {
  if (!a || !b) {
    throw new Error('two measurements must be defined');
  }
  const byHeight = a.height >= b.height;
  const byWidth = a.width >= b.width;
  return byHeight && byWidth;
}
function isHTMLElement(element) {
  return element instanceof HTMLElement;
}
function isWindowElement(element) {
  return element instanceof Window;
}
function someItemsOutsideOfContainer(items, containerMeasurements) {
  if (!containerMeasurements) {
    throw new Error('containerMeasurements must be defined to check for items arrangement');
  }
  return items.some(item => {
    return item.measurements.left + item.measurements.width > containerMeasurements.width || item.measurements.top + item.measurements.height > containerMeasurements.height;
  });
}
function isCurrentlyNavigating(currentNavigation, currentScroll) {
  return currentNavigation && currentNavigation.state === 'pending' ||
  // navigation promise is ongoing
  currentScroll // current scroll in process
  ;
}
function getScrollPositionFromMeasurements(measurements) {
  return {
    x: measurements.left,
    y: measurements.top
  };
}
function isAtEnd(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
  return isAtScrollEnd(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition);
}
function isAtScrollEnd(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
  if (isRTL) {
    return isAtScrollStartX(scrollPosition) && isAtScrollEndY(scrollerMeasurements, navigationBoundries, scrollPosition);
  } else {
    return isAtScrollEndX(scrollerMeasurements, navigationBoundries, scrollPosition) && isAtScrollEndY(scrollerMeasurements, navigationBoundries, scrollPosition);
  }
}
function isAtStart(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
  if (isRTL) {
    return isAtScrollEndX(scrollerMeasurements, navigationBoundries, scrollPosition) && isAtScrollStartY(scrollPosition);
  } else {
    return isAtScrollStartX(scrollPosition) && isAtScrollStartY(scrollPosition);
  }
}
function isAtScrollStartX(scrollPosition) {
  return scrollPosition.x === 0;
}
function isAtScrollStartY(scrollPosition) {
  return scrollPosition.y === 0;
}
function isAtScrollEndX(scrollerMeasurements, navigationBoundries, scrollPosition) {
  return navigationBoundries.height != 0 && scrollPosition.x >= navigationBoundries.width - scrollerMeasurements.width;
}
function isAtScrollEndY(scrollerMeasurements, navigationBoundries, scrollPosition) {
  return scrollPosition.y >= navigationBoundries.height - scrollerMeasurements.height;
}
function isAtScrollEndWithPadding(isRTL, scrollerMeasurements, navigationBoundaries, scrollPosition, padding) {
  const paddedScrollPosition = {
    x: scrollPosition.x + padding,
    y: scrollPosition.y + padding
  };
  return isAtScrollEnd(isRTL, scrollerMeasurements, navigationBoundaries, paddedScrollPosition);
}
function reachedToNeedMoreItems(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition) {
  // should return true if the scroll in the gallery reached the threshold to load more items (considering the padding)
  return isAtScrollEndWithPadding(isRTL, scrollerMeasurements, navigationBoundries, scrollPosition, NeedMoreItemsPaddingSize);
}
function getScrollPositionFromEvent(event) {
  let target;
  if (event.target === document && event.bubbles) {
    //scrolling through window
    // @ts-ignore
    target = event.srcElement.scrollingElement;
  } else {
    // scrolling through a div
    target = event.target;
  }
  return {
    x: target.scrollLeft,
    y: target.scrollTop
  };
}
function isItemCenteredX(itemMeasurements, centerX) {
  const itemLeft = itemMeasurements.left;
  const itemRight = itemMeasurements.left + itemMeasurements.width;
  return itemLeft < centerX && itemRight > centerX;
}
function isItemCenteredY(itemMeasurements, centerY) {
  const itemTop = itemMeasurements.top;
  const itemBottom = itemMeasurements.top + itemMeasurements.height;
  return itemTop < centerY && itemBottom > centerY;
}
function isItemCenteredBothAxes(itemMeasurements, centerX, centerY) {
  return isItemCenteredX(itemMeasurements, centerX) && isItemCenteredY(itemMeasurements, centerY);
}
//# sourceMappingURL=navigatorUtils.js.map