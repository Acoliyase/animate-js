"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.Navigator = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _navigationModes = require("./navigationModes");
var _scrollImp = require("./scrollImp");
var _asyncUtils = require("./asyncUtils");
var _navigationErrors = require("./navigationErrors");
var _navigatorUtils = require("./navigatorUtils");
var _lib = require("../lib");
var _defaultNavigationSettings = require("./defaultNavigationSettings");
/* eslint-disable @typescript-eslint/no-dynamic-delete */

// import all types from types.ts

const DEBOUNCE_TIMEOUT = 50;
const THROTTLING_TIMEOUT = 500;
const DEFERRED_MORE_ITEMS_TIMEOUT = 2000;

// utils debounce function
function debounce(func, timeout) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = window.setTimeout(() => {
      func(...args);
    }, timeout);
  };
}
class Navigator {
  constructor({
    initSettings,
    eventsListener,
    logger = (..._args) => {
      // console.log('NAVIGATOR:', ..._args);
    }
  } = {}) {
    // private isScrolling = false;
    (0, _defineProperty2.default)(this, "_items", []);
    (0, _defineProperty2.default)(this, "_scrollerMeasurement", null);
    (0, _defineProperty2.default)(this, "_wrapperMeasurement", null);
    (0, _defineProperty2.default)(this, "_containerMeasurement", null);
    (0, _defineProperty2.default)(this, "_navigationBoundaries", null);
    (0, _defineProperty2.default)(this, "_scrollerRef", null);
    (0, _defineProperty2.default)(this, "_wrapperRef", null);
    (0, _defineProperty2.default)(this, "_containerRef", null);
    (0, _defineProperty2.default)(this, "scrollPosition", {
      x: 0,
      y: 0
    });
    (0, _defineProperty2.default)(this, "centeredItemByBothAxes", null);
    (0, _defineProperty2.default)(this, "currentItem", null);
    (0, _defineProperty2.default)(this, "currentScroll", undefined);
    (0, _defineProperty2.default)(this, "promiseToBeResolvedNextTimeAScrollEnds", undefined);
    (0, _defineProperty2.default)(this, "currentNavigation", undefined);
    (0, _defineProperty2.default)(this, "deferredGettingMoreItems", undefined);
    (0, _defineProperty2.default)(this, "baseSettings", _defaultNavigationSettings.defaultSettings);
    (0, _defineProperty2.default)(this, "totalItemsCount", Infinity);
    (0, _defineProperty2.default)(this, "eventsListener", void 0);
    (0, _defineProperty2.default)(this, "logger", void 0);
    (0, _defineProperty2.default)(this, "scrollEventHandler", e => {
      this.registerScrollStart(e);
      this.throttledScrollTasks(e);
      this.debouncedHandleScrollEnd(e);
    });
    (0, _defineProperty2.default)(this, "debouncedFireLayoutChanged", debounce(() => {
      this.fireEvent(_lib.GALLERY_EVENTS.LAYOUT_CHANGED, {});
    }, DEBOUNCE_TIMEOUT));
    (0, _defineProperty2.default)(this, "fireLayoutChangedEventIfLayoutChanged", (prevMeasurements, newMeasurements) => {
      if (this.areMeasurementsDifferent(prevMeasurements, newMeasurements)) {
        this.debouncedFireLayoutChanged();
      }
    });
    (0, _defineProperty2.default)(this, "throttledGetMoreItemsIfNeeded", _lib.GalleryUtils.throttle(this.getMoreItemsIfNeededScrollBased.bind(this), THROTTLING_TIMEOUT));
    (0, _defineProperty2.default)(this, "debouncedHandleScrollEnd", debounce(this.handleScrollEnd.bind(this), DEBOUNCE_TIMEOUT));
    (0, _defineProperty2.default)(this, "debouncedRegisterCenteredItems", debounce(this.registerCenteredItems.bind(this), DEBOUNCE_TIMEOUT));
    (0, _defineProperty2.default)(this, "lastNavigationStatus", {
      canNavigateToNext: null,
      canNavigateToPrevious: null
    });
    (0, _defineProperty2.default)(this, "debouncedCreateNavigationBoundaries", debounce(this.createNavigationBoundaries.bind(this), DEBOUNCE_TIMEOUT));
    this.baseSettings = {
      ..._defaultNavigationSettings.defaultSettings,
      ...initSettings
    };
    this.logger = logger;
    this.handleScrollEnd = this.handleScrollEnd.bind(this);
    this.debouncedHandleScrollEnd = this.debouncedHandleScrollEnd.bind(this);
    this.debouncedRegisterCenteredItems = this.debouncedRegisterCenteredItems.bind(this);
    this.registerCenteredItems = this.registerCenteredItems.bind(this);
    this.isScrollerRefScrollless = this.isScrollerRefScrollless.bind(this);
    this.throttledGetMoreItemsIfNeeded = this.throttledGetMoreItemsIfNeeded.bind(this);
    this.eventsListener = (0, _lib.makeEventsListener)().CURRENT_ITEM_CHANGED(() => this.checkAndFireNavigationStatus()).LAYOUT_CHANGED(() => this.checkAndFireNavigationStatus()).done(eventsListener);
  }
  setScrollerRef(scrollerRef) {
    if (this._scrollerRef) {
      this.removeScrollerRef(this._scrollerRef);
    }
    this._scrollerRef = scrollerRef;
    if (scrollerRef != null && scrollerRef.current) {
      scrollerRef.current.addEventListener('scroll', this.scrollEventHandler);
    }
    this.fireNavigationApiReadyEvent();
  }
  setWrapperRef(wrapperRef) {
    if (this._wrapperRef) {
      this.removeWrapperRef(this._wrapperRef);
    }
    this._wrapperRef = wrapperRef;
    if (wrapperRef != null && wrapperRef.current) {
      wrapperRef.current.addEventListener('scroll', this.scrollEventHandler);
    }
    this.fireNavigationApiReadyEvent();
  }
  setContainerRef(containerRef) {
    if (this._containerRef) {
      this.removeScrollerRef(this._containerRef);
    }
    this._containerRef = containerRef;
    if (containerRef != null && containerRef.current) {
      containerRef.current.addEventListener('scroll', this.scrollEventHandler);
    }
    this.fireNavigationApiReadyEvent();
  }
  removeScrollerRef(scrollerRef) {
    if (scrollerRef != null && scrollerRef.current) {
      scrollerRef.current.removeEventListener('scroll', this.scrollEventHandler);
    }
  }
  removeWrapperRef(wrapperRef) {
    if (wrapperRef != null && wrapperRef.current) {
      wrapperRef.current.removeEventListener('scroll', this.scrollEventHandler);
    }
  }
  removeContainerRef(scrollerRef) {
    if (scrollerRef != null && scrollerRef.current) {
      scrollerRef.current.removeEventListener('scroll', this.scrollEventHandler);
    }
  }
  getActiveScrollingElement() {
    if (this.isScrollerRefScrollless()) {
      return this._wrapperRef;
    } else {
      return this._scrollerRef;
    }
  }
  getActiveScrollingElementMeasurements() {
    if (this.isScrollerRefScrollless()) {
      return this._wrapperMeasurement;
    } else {
      return this._scrollerMeasurement;
    }
  }
  areMeasurementsDifferent(prev, next) {
    if (!prev) {
      return true;
    }
    const {
      width,
      height,
      top,
      left
    } = prev;
    return width !== next.width || height !== next.height || top !== next.top || left !== next.left;
  }
  updateItemMeasurements(newMeasurements, index, itemRef) {
    var _this$_items$index;
    const prevMeasurements = ((_this$_items$index = this._items[index]) == null ? void 0 : _this$_items$index.measurements) || null;
    const newItem = {
      index,
      measurements: newMeasurements,
      ref: itemRef
    };
    this._items[index] = newItem;
    this.logger(`Measurements registered for index ${index}: ${JSON.stringify(newMeasurements)}`);
    this.debouncedCreateNavigationBoundaries();
    this.debouncedRegisterCenteredItems();
    this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
  }
  updateScrollerMeasurements(newMeasurements) {
    const prevMeasurements = this._scrollerMeasurement;
    this._scrollerMeasurement = newMeasurements;
    this.logger(`Scroller measurements updated: ${JSON.stringify(newMeasurements)}`);
    this.debouncedRegisterCenteredItems();
    this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
  }
  updateWrapperMeasurements(newMeasurements) {
    const prevMeasurements = this._wrapperMeasurement;
    this._wrapperMeasurement = newMeasurements;
    this.logger(`Wrapper measurements updated: ${JSON.stringify(newMeasurements)}`);
    this.debouncedRegisterCenteredItems();
    this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
  }
  updateContainerMeasurements(newMeasurements) {
    const prevMeasurements = this._containerMeasurement;
    this._containerMeasurement = newMeasurements;
    this.logger(`Container measurements updated: ${JSON.stringify(newMeasurements)}`);
    this.debouncedCreateNavigationBoundaries();
    this.fireLayoutChangedEventIfLayoutChanged(prevMeasurements, newMeasurements);
  }
  mergeSettingsWithDefaults(functionSettings) {
    return {
      ...this.baseSettings,
      ...functionSettings
    };
  }
  getScrollPositions(itemMeasurements, scrollSettings) {
    let x = 0;
    let y = 0;
    const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
    switch (scrollSettings.mode) {
      case _navigationModes.NavigationModes.CENTER:
        x = itemMeasurements.left + itemMeasurements.width / 2 - activeScrollerMeasurement.width / 2;
        y = itemMeasurements.top + itemMeasurements.height / 2 - activeScrollerMeasurement.height / 2;
        break;
      case _navigationModes.NavigationModes.START:
        x = itemMeasurements.left;
        y = itemMeasurements.top;
        break;
      case _navigationModes.NavigationModes.END:
        x = itemMeasurements.left + itemMeasurements.width - activeScrollerMeasurement.width;
        y = itemMeasurements.top + itemMeasurements.height - activeScrollerMeasurement.height;
        break;
      default:
        throw new Error(_navigationErrors.NavigationErrors.INVALID_NAVIGATION_MODE);
    }
    return {
      x,
      y
    };
  }
  limitScrollPosition(x, y) {
    const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
    x = Math.min(x, this._containerMeasurement.width - activeScrollerMeasurement.width);
    x = Math.max(0, x);
    y = Math.min(y, this._containerMeasurement.height - activeScrollerMeasurement.height);
    y = Math.max(0, y);
    return {
      x: Math.round(x),
      y: Math.round(y)
    };
  }
  computeNavigation(index, settings) {
    const scrollSettings = this.mergeSettingsWithDefaults(settings);
    const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
    if (!activeScrollerMeasurement) {
      throw new Error(_navigationErrors.NavigationErrors.NO_SCROLLER_MEASUREMENTS);
    }
    const item = this._items[index];
    if (!item) {
      throw new Error(_navigationErrors.NavigationErrors.NO_ITEM_MEASUREMENTS);
    }
    const {
      x,
      y
    } = this.getScrollPositions(item.measurements, scrollSettings);
    return this.limitScrollPosition(x, y);
  }
  async isAbleToNavigateToPrevious(settings) {
    try {
      await this.previous(settings, () => Promise.resolve(true));
      return true;
    } catch {
      return false;
    }
  }
  async isAbleToNavigateToNext(settings) {
    try {
      await this.next(settings, () => Promise.resolve(true));
      return true;
    } catch {
      return false;
    }
  }
  async navigate(index, settings, staleNavigationFunction) {
    const scrollSettings = this.mergeSettingsWithDefaults(settings);
    if ((0, _navigatorUtils.isCurrentlyNavigating)(this.currentNavigation, this.currentScroll)) {
      throw new Error(_navigationErrors.NavigationErrors.INVALID_NAVIGATION_IN_PROGRESS);
    }
    const activeScrollerRef = this.getActiveScrollingElement();
    const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
    if (this.isScrollerRefScrollless()) {
      // for scrollless galleries, we cant navigate by scrolling. we can only change the current item
      return this.scrolllessNavigation(index, scrollSettings, staleNavigationFunction);
    } else if (!(0, _navigatorUtils.canNavigateByScroller)(activeScrollerRef, activeScrollerMeasurement, this._containerMeasurement)) {
      // navigate by native browser scrollIntoView
      this.logger('Cannot navigate by scroller, navigating by item.scrollIntoView');
      return this.nativeScrollingNavigation(index, scrollSettings, staleNavigationFunction);
    } else {
      // navigate by calculating and css implementation
      return this.defaultScrollingNavigation(index, scrollSettings, staleNavigationFunction);
    }
  }
  async defaultScrollingNavigation(index, scrollSettings, staleNavigationFunction) {
    const activeScrollerRef = this.getActiveScrollingElement();
    try {
      const navigationPromise = new Promise(async (resolve, reject) => {
        try {
          const scrollPosition = this.computeNavigation(index, scrollSettings);
          if (activeScrollerRef && activeScrollerRef.current) {
            let currentScrollPositionX = 0;
            let currentScrollPositionY = 0;
            if (activeScrollerRef === this._scrollerRef) {
              currentScrollPositionX = activeScrollerRef.current.scrollLeft;
              currentScrollPositionY = activeScrollerRef.current.scrollTop;
            } else if (activeScrollerRef === this._wrapperRef) {
              currentScrollPositionX = activeScrollerRef.current.scrollX;
              currentScrollPositionY = activeScrollerRef.current.scrollY;
            }
            if (scrollPosition.x === currentScrollPositionX && scrollPosition.y === currentScrollPositionY) {
              return reject(new Error(_navigationErrors.NavigationErrors.NO_CHANGE_IN_SCROLL_POSITION));
            } else if (staleNavigationFunction) {
              return staleNavigationFunction().then(() => resolve(scrollPosition)).catch(reject);
            } else {
              const scrollParams = {
                scroller: activeScrollerRef.current,
                fromX: currentScrollPositionX,
                toX: scrollPosition.x,
                fromY: currentScrollPositionY,
                toY: scrollPosition.y,
                duration: scrollSettings.duration,
                isRTL: false,
                slideTransition: scrollSettings.slideTransition,
                isContinuousScrolling: false,
                autoSlideshowContinuousSpeed: 100
              };
              this.currentNavigation = new _asyncUtils.TrackablePromise((0, _scrollImp.cssScrollTo)(scrollParams).scrollingPromise);
              await this.currentNavigation;
              resolve(scrollPosition);
            }
          } else {
            return reject(new Error(_navigationErrors.NavigationErrors.SCROLLER_REF_NOT_SET));
          }
        } catch (error) {
          return reject(error);
        }
      });
      const result = await navigationPromise;

      // Check if we need to loop back after navigation
      if (scrollSettings.loop && index >= 1.5 * this.totalItemsCount) {
        await this.loopBack(scrollSettings);
      }
      return result;
    } catch (error) {
      throw error;
    } finally {
      this.currentNavigation = undefined;
    }
  }
  async nativeScrollingNavigation(index, scrollSettings, staleNavigationFunction) {
    this.promiseToBeResolvedNextTimeAScrollEnds = new _asyncUtils.Deferred();
    const currentScrollPosition = {
      ...this.scrollPosition
    };
    this.promiseToBeResolvedNextTimeAScrollEnds.promise.then(scrollPosition => {
      if (scrollPosition.x === currentScrollPosition.x && scrollPosition.y === currentScrollPosition.y) {
        throw new Error(_navigationErrors.NavigationErrors.NO_CHANGE_IN_SCROLL_POSITION);
      }
    });
    const navigationPromise = new Promise(async (resolve, reject) => {
      try {
        if (staleNavigationFunction) {
          return staleNavigationFunction().then(() => resolve((0, _navigatorUtils.getScrollPositionFromMeasurements)(this._items[index].measurements))).catch(reject);
        }
        const scrollerRef = this.getActiveScrollingElement();
        (0, _scrollImp.fallbackScrollIntoView)(this._items[index].ref, scrollerRef, scrollSettings.duration);
        this.logger('Item scrolled into view:', index);
      } catch (error) {
        return reject(error);
      } finally {
        var _this$promiseToBeReso;
        (_this$promiseToBeReso = this.promiseToBeResolvedNextTimeAScrollEnds) == null || _this$promiseToBeReso.promise.then(scrollPosition => {
          this.logger('Scroll position AT THE END OF THE NATIVE SCROLL:', scrollPosition);
          resolve(scrollPosition);
          this.promiseToBeResolvedNextTimeAScrollEnds = undefined;
        });
      }
    });
    const result = await navigationPromise;

    // Check if we need to loop back after navigation
    if (scrollSettings.loop && index >= 1.5 * this.totalItemsCount) {
      await this.loopBack(scrollSettings);
    }
    return result;
  }
  async scrolllessNavigation(index, scrollSettings, staleNavigationFunction) {
    staleNavigationFunction ? staleNavigationFunction() : this.setCurrentItem(index);
    if (scrollSettings.loop && index >= 1.5 * this.totalItemsCount) {
      // TODO this happens on every navigation implementation and can be refactored
      await this.loopBack(scrollSettings);
    }
    return Promise.resolve(this.scrollPosition);
  }
  async next(settings, staleNavigationFunction) {
    // If we are already at the ending position, we cannot navigate further forward
    const definedSettings = this.mergeSettingsWithDefaults(settings);
    const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
    if (!this.isScrollerRefScrollless() && (0, _navigatorUtils.isAtEnd)(definedSettings.isRTL, activeScrollerMeasurement, this._navigationBoundaries, this.scrollPosition)) {
      return Promise.reject(new Error(_navigationErrors.NavigationErrors.CANNOT_NAVIGATE_TO_NEXT));
    }
    return this.navigateInDirection(1, settings, staleNavigationFunction);
  }
  async previous(settings, staleNavigationFunction) {
    // If we are already at the starting position, we cannot navigate further back
    const definedSettings = this.mergeSettingsWithDefaults(settings);
    const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
    if (!this.isScrollerRefScrollless() && (0, _navigatorUtils.isAtStart)(definedSettings.isRTL, activeScrollerMeasurement, this._navigationBoundaries, this.scrollPosition)) {
      return Promise.reject(new Error(_navigationErrors.NavigationErrors.CANNOT_NAVIGATE_TO_PREVIOUS));
    }
    return this.navigateInDirection(-1, settings, staleNavigationFunction);
  }
  async navigateInDirection(direction, settings, staleNavigationFunction, retries = 0) {
    // if current item is null, we cannot navigate
    if (this.currentItem === null) {
      return Promise.reject(new Error(_navigationErrors.NavigationErrors.NO_CENTERED_ITEM));
    }
    // calculate the next item recursively
    const newIndex = this.currentItem + direction + retries * direction;
    // make sure the new index is within the bounds of the items
    if (newIndex >= 0 && newIndex < this._items.length) {
      return this.navigate(newIndex, settings, staleNavigationFunction).catch(error => {
        if (error.message === _navigationErrors.NavigationErrors.NO_CHANGE_IN_SCROLL_POSITION) {
          this.logger('No change in scroll position, retrying navigation');
          return this.navigateInDirection(direction, settings, staleNavigationFunction, retries + 1);
        } else {
          return Promise.reject(error);
        }
      });
    } else {
      return Promise.reject(new Error(direction === 1 ? _navigationErrors.NavigationErrors.CANNOT_NAVIGATE_TO_NEXT : _navigationErrors.NavigationErrors.CANNOT_NAVIGATE_TO_PREVIOUS));
    }
  }
  throttledScrollTasks(event) {
    this.throttledGetMoreItemsIfNeeded(event);
  }
  handleScrollEnd(event) {
    const activeScrollingElement = this.getActiveScrollingElement();
    let target;
    if (activeScrollingElement === this._wrapperRef) {
      // @ts-expect-error
      target = event.target.scrollingElement;
    } else if (activeScrollingElement === this._scrollerRef) {
      target = event.target;
    }
    this.scrollPosition = {
      y: target.scrollTop,
      x: target.scrollLeft
    };
    this.registerScrollEnd(event);
    this.logger('Scroll position:', this.scrollPosition);
    this.registerCenteredItems(); // no double debouce
  }
  registerScrollStart(event) {
    if (this.currentScroll) {
      return;
    } else {
      this.currentScroll = new _asyncUtils.Deferred();
      if (this.promiseToBeResolvedNextTimeAScrollEnds) {
        this.currentScroll.promise.then(scrollPosition => {
          var _this$promiseToBeReso2;
          (_this$promiseToBeReso2 = this.promiseToBeResolvedNextTimeAScrollEnds) == null || _this$promiseToBeReso2.resolve(scrollPosition);
        });
      }
      this.logger('Scroll start:', event);
    }
  }
  registerScrollEnd(event) {
    var _this$currentScroll;
    this.logger('Scroll end:', event);
    (_this$currentScroll = this.currentScroll) == null || _this$currentScroll.resolve((0, _navigatorUtils.getScrollPositionFromEvent)(event));
    this.currentScroll = undefined;
  }
  registerCenteredItems() {
    const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
    if (!activeScrollerMeasurement) {
      console.warn(_navigationErrors.NavigationErrors.NO_SCROLLER_MEASUREMENTS);
      return;
    }
    const scrollerCenterX = this.scrollPosition.x + activeScrollerMeasurement.width / 2;
    const scrollerCenterY = this.scrollPosition.y + activeScrollerMeasurement.height / 2;
    let closestIndex = null;
    let smallestDistance = Infinity;
    this._items.forEach(item => {
      const measurements = item.measurements;
      const itemCenterX = measurements.left + measurements.width / 2;
      const itemCenterY = measurements.top + measurements.height / 2;
      const diffX = Math.abs(itemCenterX - scrollerCenterX);
      const diffY = Math.abs(itemCenterY - scrollerCenterY);
      const distance = Math.sqrt(diffX * diffX + diffY * diffY);
      if ((0, _navigatorUtils.isItemCenteredBothAxes)(measurements, scrollerCenterX, scrollerCenterY)) {
        this.setCenteredItemByBothAxes(item.index);
        closestIndex = item.index;
        smallestDistance = 0;
      } else if (distance < smallestDistance) {
        closestIndex = item.index;
        smallestDistance = distance;
      }
    });
    if (closestIndex !== null) {
      this.setCenteredItemByBothAxes(closestIndex);
      this.logger(`Centered item in both axes: ${this.centeredItemByBothAxes}`);
    }
  }
  async getMoreItemsIfNeededScrollBased(event) {
    var _this$deferredGetting;
    if ((_this$deferredGetting = this.deferredGettingMoreItems) != null && _this$deferredGetting.isPending) {
      this.logger('getting more items is in progress, do nothing');
    } else {
      this.deferredGettingMoreItems = new _asyncUtils.Deferred();
      const activeScrollerMeasurement = this.getActiveScrollingElementMeasurements();
      const invalidMeasurements = !activeScrollerMeasurement || !this._containerMeasurement || !this._navigationBoundaries;
      if (invalidMeasurements) {
        this.deferredGettingMoreItems.reject(_navigationErrors.NavigationErrors.NO_SCROLLER_MEASUREMENTS);
      } else {
        const needMoreItems = (0, _navigatorUtils.reachedToNeedMoreItems)(this.baseSettings.isRTL, activeScrollerMeasurement, this._navigationBoundaries, this.scrollPosition);
        if (needMoreItems) {
          this.fireEvent(_lib.GALLERY_EVENTS.NEED_MORE_ITEMS, {
            event
          });
          setTimeout(() => {
            var _this$deferredGetting2;
            (_this$deferredGetting2 = this.deferredGettingMoreItems) == null || _this$deferredGetting2.resolve(event);
          }, DEFERRED_MORE_ITEMS_TIMEOUT);
        } else {
          this.deferredGettingMoreItems.resolve(event);
        }
      }
    }
    return this.deferredGettingMoreItems.promise.catch(e => console.error('failed in get more items through scrolling', e));
  }
  getCenteredItemByBothAxes() {
    return this.centeredItemByBothAxes;
  }
  setCenteredItemByBothAxes(index) {
    if (index === this.centeredItemByBothAxes) {
      return; // unchanged
    }
    if (typeof index !== 'number') {
      return;
    }
    this.centeredItemByBothAxes = index;
    if (!this.isScrollerRefScrollless()) {
      // dont set by scroll in a scrollless gallery
      this.setCurrentItem(index);
    }
  }
  fireEvent(...args) {
    this.logger('Firing Event:', ...args);
    if (typeof this.eventsListener === 'function') {
      this.eventsListener(...args);
    }
  }
  setCurrentItem(index) {
    if (this.currentItem !== index) {
      this.fireEvent(_lib.GALLERY_EVENTS.CURRENT_ITEM_CHANGED, {
        index
      });
      this.currentItem = index;
    }
  }
  getCurrentIndex() {
    return this.currentItem;
  }
  updateTotalItemsCount(count) {
    this.totalItemsCount = count;
  }
  async checkAndFireNavigationStatus() {
    const newStatus = {
      canNavigateToNext: await this.isAbleToNavigateToNext(),
      canNavigateToPrevious: await this.isAbleToNavigateToPrevious()
    };
    if (newStatus.canNavigateToNext !== this.lastNavigationStatus.canNavigateToNext || newStatus.canNavigateToPrevious !== this.lastNavigationStatus.canNavigateToPrevious) {
      this.lastNavigationStatus = newStatus;
      this.fireEvent(_lib.GALLERY_EVENTS.NAVIGATION_STATUS_CHANGED, newStatus);
    }
  }
  async loopBack(settings) {
    if (this.totalItemsCount === Infinity) {
      return Promise.reject(new Error(_navigationErrors.NavigationErrors.CANNOT_LOOP_WITHOUT_TOTAL_ITEMS_COUNT));
    }
    const middleIndex = Math.ceil(this.totalItemsCount / 2);

    // Use navigate to perform the scroll
    return this.navigate(middleIndex, {
      ...settings,
      duration: 0
    });
  }
  fireNavigationApiReadyEvent() {
    this.fireEvent(_lib.GALLERY_EVENTS.NAVIGATION_API_READY, this.getNavigationApi());
  }
  getNavigationApi() {
    return {
      navigateToIndex: this.navigate.bind(this),
      next: this.next.bind(this),
      previous: this.previous.bind(this),
      currentIndex: this.getCurrentIndex.bind(this),
      canNavigateToNext: this.isAbleToNavigateToNext.bind(this),
      canNavigateToPrevious: this.isAbleToNavigateToPrevious.bind(this),
      isScrollerRefScrollless: this.isScrollerRefScrollless.bind(this),
      getNextItemByDirection: this.getNextItemByDirection.bind(this)
    };
  }
  isScrollerRefScrollless() {
    // Scrolless is the case of a stack of items where all the items are contained in the container boundries and a <= is size. this means there is no scroll (not even fake flex scroll)
    this.logger((0, _navigatorUtils.isALargerThanB)(this._scrollerMeasurement, this._containerMeasurement), (0, _navigatorUtils.someItemsOutsideOfContainer)(this._items, this._containerMeasurement));
    return (0, _navigatorUtils.isALargerThanB)(this._scrollerMeasurement, this._containerMeasurement) && !(0, _navigatorUtils.someItemsOutsideOfContainer)(this._items, this._containerMeasurement);
  }
  createNavigationBoundaries() {
    this._navigationBoundaries = this.calculateNavigationBoundaries();
  }
  calculateNavigationBoundaries() {
    // this is the maximum value in each axis combining both the containerMeasurements and each one of the item measurements to create the max boundries of the possible navigation
    const maxX = Math.max(this._containerMeasurement.width, ...this._items.map(
    // TODO, im sure this can be optimized, but any optimization in the length of the tested array will create edge cases. maybe for now a reduce could be more relevant
    item => item.measurements.left + item.measurements.width));
    const maxY = Math.max(this._containerMeasurement.height, ...this._items.map(
    // TODO, im sure this can be optimized, but any optimization in the length of the tested array will create edge cases. maybe for now a reduce could be more relevant
    item => item.measurements.top + item.measurements.height));
    this.logger('Navigation boundaries:', {
      maxX,
      maxY
    });
    return {
      width: maxX,
      height: maxY,
      top: 0,
      left: 0
    };
  }
  focusOnFirstItem() {
    if (this._items.length > 0) {
      this.setCenteredItemByBothAxes(0);
      this.setCurrentItem(0);
      this.logger(`Initial focus set to first item: 0`);
    }
  }
  getNextItemByDirection(currentIndex, direction) {
    if (this._items.length === 0) {
      return null;
    }
    const directionMap = {
      left: (index, length) => index === 0 ? length - 1 : index - 1,
      right: (index, length) => index === length - 1 ? 0 : index + 1,
      // Vertical navigation not implemented yet - return current index
      up: (index, _length) => index,
      down: (index, _length) => index
    };
    return directionMap[direction](currentIndex, this._items.length);
  }
}
exports.Navigator = Navigator;
//# sourceMappingURL=navigator.js.map