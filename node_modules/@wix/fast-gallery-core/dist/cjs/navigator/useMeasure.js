"use strict";

exports.__esModule = true;
exports.useMeasure = void 0;
var _react = require("react");
var _navigatorUtils = require("./navigatorUtils");
const measureImpUsingOffsets = ref => {
  try {
    if (ref.current) {
      const element = ref.current;
      if ((0, _navigatorUtils.isHTMLElement)(element)) {
        const newMeasurements = {
          width: Math.floor(element.offsetWidth),
          height: Math.floor(element.offsetHeight),
          top: Math.floor(element.offsetTop),
          left: Math.floor(element.offsetLeft)
        };
        return newMeasurements;
      }
      if ((0, _navigatorUtils.isWindowElement)(element)) {
        const newMeasurements = {
          width: Math.floor(element.innerWidth),
          height: Math.floor(element.innerHeight),
          // todo - check if this is correct
          top: 0,
          // Window doesn't have 'top' in the same way
          left: 0 // Window doesn't have 'left' in the same way
        };
        return newMeasurements;
      }
      throw new Error('Ref is neither an HTMLElement nor a Window');
    } else {
      console.warn('ref.current is null', ref);
      return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
      };
    }
  } catch (e) {
    console.error('could not get measurements for ', ref, e);
    return {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};
const useMeasure = ({
  callback,
  index,
  ref,
  allowMeasuring = true // Default value
}) => {
  const [currentMeasurements, setCurrentMeasurements] = (0, _react.useState)(null);
  const debounceTimeout = (0, _react.useRef)(undefined);
  const measure = (0, _react.useCallback)(() => {
    if (!allowMeasuring || !ref.current) {
      return;
    } // Check if measuring is allowed

    const newMeasurements = measureImpUsingOffsets(ref);
    if (!currentMeasurements || newMeasurements.width !== currentMeasurements.width || newMeasurements.height !== currentMeasurements.height || newMeasurements.top !== currentMeasurements.top || newMeasurements.left !== currentMeasurements.left) {
      setCurrentMeasurements(newMeasurements);
      callback(newMeasurements, index);
    }
  }, [allowMeasuring, callback, currentMeasurements, index, ref]);
  (0, _react.useEffect)(() => {
    const handleEvents = () => {
      if (!allowMeasuring) {
        return;
      } // Check if measuring is allowed

      if (debounceTimeout.current) {
        clearTimeout(debounceTimeout.current);
      }
      debounceTimeout.current = window.setTimeout(() => {
        window.setTimeout(measure, 0);
      }, 50);
    };
    const resizeObserver = new ResizeObserver(handleEvents);
    const intersectionObserver = new IntersectionObserver(handleEvents);
    if ((0, _navigatorUtils.isWindowElement)(ref.current)) {
      window.addEventListener('resize', handleEvents);
      handleEvents(); // Initial measurement on window resize
    } else if (ref.current) {
      resizeObserver.observe(ref.current);
      intersectionObserver.observe(ref.current);
    }
    return () => {
      if (debounceTimeout.current) {
        clearTimeout(debounceTimeout.current);
      }
      if ((0, _navigatorUtils.isHTMLElement)(ref.current)) {
        resizeObserver.unobserve(ref.current);
        intersectionObserver.unobserve(ref.current);
      }
      if ((0, _navigatorUtils.isWindowElement)(ref.current)) {
        window.removeEventListener('resize', handleEvents);
      }
    };
  }, [allowMeasuring, measure, ref]);
};
exports.useMeasure = useMeasure;
//# sourceMappingURL=useMeasure.js.map