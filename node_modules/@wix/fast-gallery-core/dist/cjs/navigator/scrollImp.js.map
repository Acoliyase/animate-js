{"version":3,"names":["_asyncUtils","require","_navigatorUtils","isWindow","obj","window","fallbackScrollIntoView","target","container","duration","current","startX","startY","isContainerWindow","scrollLeft","scrollTop","scrollX","scrollY","targetRect","getBoundingClientRect","containerRect","top","left","targetX","targetY","distanceX","distanceY","startTime","performance","now","easeInOutQuad","t","style","scrollSnapType","animateScroll","currentTime","elapsed","progress","Math","min","ease","scrollToX","scrollToY","scrollTo","_container$current","requestAnimationFrame","_container$current2","removeProperty","cssScrollTo","scroller","fromX","toX","fromY","toY","slideTransition","isContinuousScrolling","autoSlideshowContinuousSpeed","changeX","changeY","scrollingPromise","Promise","resolve","x","y","maxChange","max","abs","isHTMLElement","scrollerInner","firstChild","setAttribute","Object","assign","transition","transform","intervals","scrollTransitionEvent","CustomEvent","detail","scrollTransitionInterval","setInterval","dispatchEvent","round","Deferred","setTimeout","clearInterval","promise"],"sources":["../../../src/navigator/scrollImp.ts"],"sourcesContent":["import { Deferred } from './asyncUtils';\nimport { isHTMLElement } from './navigatorUtils';\n\ninterface ScrollToParams {\n  scroller: HTMLElement | Window;\n  fromX: number;\n  toX: number;\n  fromY: number;\n  toY: number;\n  duration: number;\n  isRTL: boolean;\n  slideTransition: string;\n  isContinuousScrolling: boolean;\n  autoSlideshowContinuousSpeed: number;\n}\n\nfunction isWindow(obj: any): obj is Window {\n  return obj != null && obj === obj.window;\n}\n\n// this is a fallback for cases that the scroller cannot handle for now like flex box (classic slideshow)\n// ideally we want to have on function for this scrolling. may require some refactor in the navigator\nexport function fallbackScrollIntoView(\n  target: React.RefObject<HTMLElement>,\n  container: React.RefObject<HTMLElement> | React.RefObject<Window> | null,\n  duration: number,\n  ) {\n  if (!container?.current || !target?.current) return;\n\n  let startX: number;\n  let startY: number;\n  const isContainerWindow = isWindow(container.current)\n  if (!isContainerWindow) {\n    startX = container.current.scrollLeft;\n    startY = container.current.scrollTop;\n  } else {\n    startX = container.current.scrollX;\n    startY = container.current.scrollY;\n  }\n\n  const targetRect = target.current.getBoundingClientRect();\n  const containerRect = isContainerWindow ? {top: 0, left: 0} : container.current.getBoundingClientRect();\n\n  const targetX = targetRect.left - containerRect.left + startX;\n  const targetY = targetRect.top - containerRect.top + startY;\n\n  const distanceX = targetX - startX;\n  const distanceY = targetY - startY;\n\n  const startTime = performance.now();\n\n  function easeInOutQuad(t: number) {\n    return t < 0.5\n      ? 2 * t * t\n      : -1 + (4 - 2 * t) * t;\n  }\n  if (!isContainerWindow) {\n    container.current.style.scrollSnapType = \"none\";\n  }\n\n  function animateScroll(currentTime: number) {\n    const elapsed = currentTime - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const ease = easeInOutQuad(progress);\n\n    const scrollToX = startX + distanceX * ease;\n    const scrollToY = startY + distanceY * ease;\n\n    if (isContainerWindow) {\n      window.scrollTo({\n        top: scrollToY,\n        left: scrollToX,\n      });\n    } else {\n      container?.current?.scrollTo({\n        top: scrollToY,\n        left: scrollToX,\n      });\n    }\n\n    if (progress < 1) {\n      requestAnimationFrame(animateScroll);\n    } else {\n      if (!isContainerWindow) {\n        container?.current?.style.removeProperty('scroll-snap-type');\n      }\n    }\n  }\n  requestAnimationFrame(animateScroll);\n}\n\nexport function cssScrollTo({\n  scroller,\n  fromX,\n  toX,\n  fromY,\n  toY,\n  duration,\n  // isRTL,\n  slideTransition,\n  isContinuousScrolling,\n  autoSlideshowContinuousSpeed,\n}: ScrollToParams): { scrollingPromise: Promise<{ x: number; y: number }> } {\n  const changeX = toX - fromX;\n  const changeY = toY - fromY;\n\n  if (changeX === 0 && changeY === 0) {\n    return { scrollingPromise: Promise.resolve({ x: toX, y: toY }) };\n  }\n\n  if (isContinuousScrolling) {\n    const maxChange = Math.max(Math.abs(changeX), Math.abs(changeY));\n    duration = (maxChange / autoSlideshowContinuousSpeed) * 1000;\n  }\n\n  if (isHTMLElement(scroller)) {\n    const scrollerInner = scroller.firstChild as HTMLElement;\n\n    scroller.setAttribute('data-scrolling', 'true');\n    Object.assign(scroller.style, {\n      'scroll-snap-type': 'none',\n    });\n    Object.assign(\n      scrollerInner.style,\n      {\n        transition: `transform ${duration}ms ${slideTransition}`,\n        '-webkit-transition': `transform ${duration}ms ${slideTransition}`,\n      },\n      {\n        transform: `translate(${-1 * changeX}px, ${-1 * changeY}px)`,\n      }\n    );\n  } else {\n    // Handle Window case\n    // Window scrolling doesn't need transform or transition styles\n  }\n\n  const intervals = 10;\n  const scrollTransitionEvent = new CustomEvent('scrollTransition', {\n    detail: { changeX: changeX / intervals, changeY: changeY / intervals },\n  });\n  const scrollTransitionInterval = setInterval(() => {\n    if (isHTMLElement(scroller)) {\n      scroller.dispatchEvent(scrollTransitionEvent);\n    }\n  }, Math.round(duration / intervals));\n\n  const scrollingPromise = new Deferred<{ x: number; y: number }>();\n\n  // const currentScrollEndTimeout =\n  setTimeout(() => {\n    clearInterval(scrollTransitionInterval);\n    if (isHTMLElement(scroller)) {\n      const scrollerInner = scroller.firstChild as HTMLElement;\n      Object.assign(\n        scrollerInner.style,\n        {\n          transition: `none`,\n          '-webkit-transition': `none`,\n        },\n        {\n          transform: `translate(0px, 0px)`,\n        }\n      );\n      scroller.style.removeProperty('scroll-snap-type');\n      scroller.setAttribute('data-scrolling', '');\n    }\n    if (isHTMLElement(scroller)) {\n      scroller.scrollLeft = toX;\n      scroller.scrollTop = toY;\n    } else {\n      scroller.scrollTo(toX, toY);\n    }\n    scrollingPromise.resolve({ x: toX, y: toY });\n  }, duration);\n\n  return {\n    scrollingPromise: scrollingPromise.promise,\n  };\n}\n\n// import { optionsMap, utils, GALLERY_CONSTS } from 'pro-gallery-lib';\n\n// export function scrollToItemImp(scrollParams) {\n//   let to, from;\n//   const {\n//     scrollMarginCorrection = 0,\n//     durationInMS,\n//     horizontalElement,\n//     scrollingElement,\n//     isRTL,\n//     scrollDirection,\n//     galleryWidth,\n//     galleryHeight,\n//     totalWidth,\n//     top,\n//     items,\n//     itemIdx,\n//     fixedScroll,\n//     slideTransition,\n//     isContinuousScrolling,\n//     autoSlideshowContinuousSpeed,\n//     itemSpacing,\n//   } = scrollParams;\n\n//   const rtlFix = isRTL ? -1 : 1;\n//   // default = scroll by half the container size\n//   if (scrollDirection === 'horizontal') {\n//     from = horizontalElement.scrollLeft * rtlFix;\n//     to = from + (itemIdx * galleryWidth) / 2;\n//   } else {\n//     from = top;\n//     to = top + (itemIdx * galleryHeight) / 2;\n//   }\n\n//   if (fixedScroll !== true) {\n//     // scroll to specific item\n//     // if (utils.isVerbose()) {\n//     //   console.log('Scrolling to items #' + itemIdx);\n//     // }\n\n//     const item = items.find((itm) => itm.idx === itemIdx);\n//     to =\n//       scrollDirection === 'horizontal'\n//         ? utils.get(item, 'offset.left')\n//         : utils.get(item, 'offset.top');\n\n//     if (utils.isVerbose()) {\n//       console.log('Scrolling to position ' + to, item);\n//     }\n\n//     if (!(to >= 0)) {\n//       utils.isVerbose() && console.warn('Position not found, not scrolling');\n//       return new Promise((res) => res());\n//     }\n\n//     if (scrollDirection === 'horizontal') {\n//       // set scroll to place the item in the middle of the component\n//       const diff = (galleryWidth - item.width - itemSpacing) / 2;\n//       to -= diff;\n//       to = Math.max(0, to);\n//       to = Math.min(to, totalWidth - galleryWidth + scrollMarginCorrection);\n//       to *= rtlFix;\n//       from *= rtlFix;\n//       if (utils.isVerbose()) {\n//         console.log('Scrolling to new position ' + to, this);\n//       }\n//     }\n//   }\n//   if (scrollDirection === 'horizontal') {\n//     return horizontalCssScrollTo({\n//       scroller: horizontalElement,\n//       from: Math.round(from),\n//       to: Math.round(to),\n//       duration: durationInMS,\n//       isRTL,\n//       slideTransition,\n//       isContinuousScrolling,\n//       autoSlideshowContinuousSpeed,\n//     });\n//   } else {\n//     return new Promise((resolve) => {\n//       scrollingElement.vertical().scrollTo(0, to);\n//       resolve(to);\n//     });\n//   }\n// }\n// export function scrollToGroupImp(scrollParams) {\n//   let to, from;\n//   const {\n//     scrollMarginCorrection = 0,\n//     durationInMS,\n//     horizontalElement,\n//     scrollingElement,\n//     isRTL,\n//     scrollDirection,\n//     galleryWidth,\n//     galleryHeight,\n//     totalWidth,\n//     top,\n//     groups,\n//     groupIdx,\n//     fixedScroll,\n//     slideTransition,\n//     isContinuousScrolling,\n//     autoSlideshowContinuousSpeed,\n//     itemSpacing,\n//   } = scrollParams;\n\n//   const rtlFix = isRTL ? -1 : 1;\n//   // default = scroll by half the container size\n//   if (scrollDirection === 'horizontal') {\n//     from = horizontalElement.scrollLeft;\n//     to = from + (groupIdx * galleryWidth) / 2;\n//     // console.log('[RTL SCROLL] scrollTogroupImp: ', from, to);\n//   } else {\n//     from = top;\n//     to = top + (groupIdx * galleryHeight) / 2;\n//   }\n\n//   if (fixedScroll !== true) {\n//     // scroll to specific group\n//     if (utils.isVerbose()) {\n//       console.log('Scrolling to groups #' + groupIdx);\n//     }\n\n//     const group = groups.find((grp) => grp.idx === groupIdx);\n//     to =\n//       scrollDirection === 'horizontal'\n//         ? utils.get(group, 'left')\n//         : utils.get(group, 'top');\n\n//     if (utils.isVerbose()) {\n//       console.log('Scrolling to position ' + to, group);\n//     }\n\n//     if (!(to >= 0)) {\n//       utils.isVerbose() && console.warn('Position not found, not scrolling');\n//       return new Promise((res) => res());\n//     }\n\n//     if (scrollDirection === 'horizontal') {\n//       // set scroll to place the group in the middle of the component\n//       const diff = (galleryWidth - group.width - itemSpacing) / 2;\n//       to -= diff;\n//       to = Math.max(0, to);\n//       to = Math.min(to, totalWidth - galleryWidth + scrollMarginCorrection);\n//       to *= rtlFix;\n//       if (utils.isVerbose()) {\n//         console.log('Scrolling to new position ' + to, this);\n//       }\n//     }\n//   }\n//   if (scrollDirection === 'horizontal') {\n//     return horizontalCssScrollTo({\n//       scroller: horizontalElement,\n//       from: Math.round(from),\n//       to: Math.round(to),\n//       duration: durationInMS,\n//       isRTL,\n//       slideTransition,\n//       isContinuousScrolling,\n//       autoSlideshowContinuousSpeed,\n//     });\n//   } else {\n//     return new Promise((resolve) => {\n//       scrollingElement.vertical().scrollTo(0, to);\n//       resolve(to);\n//     });\n//   }\n// }\n\n// ----- rendererd / visible ----- //\n// export function horizontalCssScrollTo({\n//   scroller,\n//   from,\n//   to,\n//   duration,\n//   isRTL,\n//   slideTransition,\n//   isContinuousScrolling,\n//   autoSlideshowContinuousSpeed,\n// }) {\n//   const change = to - from;\n\n//   if (change === 0) {\n//     return new Promise((resolve) => resolve(to));\n//   }\n\n//   if (isContinuousScrolling) {\n//     duration = (Math.abs(change) / autoSlideshowContinuousSpeed) * 1000;\n//   }\n\n//   const scrollerInner = scroller.firstChild;\n\n//   scroller.setAttribute('data-scrolling', 'true');\n//   Object.assign(scroller.style, {\n//     'scroll-snap-type': 'none',\n//   });\n//   Object.assign(\n//     scrollerInner.style,\n//     {\n//       transition: `transform ${duration}ms ${slideTransition}`,\n//       '-webkit-transition': `transform ${duration}ms ${slideTransition}`,\n//     },\n//     {\n//       transform: `translateX(${-1 * change}px)`,\n//     },\n//   );\n\n//   const intervals = 10;\n//   const scrollTransitionEvent = new CustomEvent('scrollTransition', {\n//     detail: change / intervals,\n//   });\n//   const scrollTransitionInterval = setInterval(() => {\n//     scroller.dispatchEvent(scrollTransitionEvent);\n//   }, Math.round(duration / intervals));\n//   const scrollDeffered = new Deferred();\n//   const currentScrollEndTimeout = setTimeout(() => {\n//     clearInterval(scrollTransitionInterval);\n//     Object.assign(\n//       scrollerInner.style,\n//       {\n//         transition: `none`,\n//         '-webkit-transition': `none`,\n//       },\n//       {\n//         transform: `translateX(0px)`,\n//       },\n//     );\n//     scroller.style.removeProperty('scroll-snap-type');\n//     scroller.scrollLeft = to;\n//     scroller.setAttribute('data-scrolling', '');\n//     scrollDeffered.resolve(to);\n//   }, duration);\n\n//   return {\n//     scrollDeffered,\n//     scroller,\n//     from,\n//     to,\n//     duration,\n//     isRTL,\n//     slideTransition,\n//     isContinuousScrolling,\n//     autoSlideshowContinuousSpeed,\n//     currentScrollEndTimeout,\n//   };\n// }\n\n// function animateStopScroll({ scroller, at, isRTL }) {\n//   Object.assign(scroller.style, {\n//     'scroll-snap-type': 'none',\n//   });\n//   const scrollDeffered = new Deferred();\n//   Object.assign(\n//     scroller.firstChild.style,\n//     {\n//       transition: `none`,\n//       '-webkit-transition': `none`,\n//     },\n//     {\n//       transform: `translateX(0px)`,\n//     },\n//   );\n//   scroller.scrollLeft = at;\n//   scrollDeffered.resolve(at);\n\n//   return {\n//     scrollDeffered,\n//     scroller,\n//     isRTL,\n//   };\n// }\n\n// export function haltScroll({\n//   scroller,\n//   from,\n//   isRTL,\n//   currentScrollEndTimeout,\n//   scrollDeffered,\n// }) {\n//   clearTimeout(currentScrollEndTimeout);\n//   const scrollerInner = scroller.firstChild;\n//   const computedStyle = getComputedStyle(scrollerInner);\n//   const transform = computedStyle.getPropertyValue('transform');\n//   const matrix = new DOMMatrix(transform);\n\n//   const margins = Math.round(parseInt(matrix.m41, 10));\n//   from = from - margins;\n\n//   animateStopScroll({\n//     scroller,\n//     at: from,\n//     isRTL,\n//   });\n//   scrollDeffered.resolve(from);\n// }\n"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]}