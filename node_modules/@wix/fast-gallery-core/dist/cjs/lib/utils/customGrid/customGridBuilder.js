"use strict";

exports.__esModule = true;
exports.buildCustomGridStyles = void 0;
var _serialize = require("@emotion/serialize");
var _types = require("../../types");
var _mathUtils = require("../mathUtils");
var _commonUtils = require("../commonUtils");
// calculates the sum of all 'proportion' values in a row
const getRowProportions = row => row.cells.reduce((p, c) => p + Math.abs(c.proportion), 0);
const getPatternCellCount = pattern => pattern.rows.reduce((rp, rc) => rp + rc.cells.reduce((cp, cc) => cp + (cc.proportion > 0 ? 1 : 0), 0), 0);
const getVerticalParentCss = (oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns) => {
  return {
    display: 'grid',
    gridTemplateColumns: `repeat(${maxColumns}, 1fr)`,
    gridAutoFlow: 'row',
    gap: `${verticalGap + verticalGapUnit} ${horizontalGap + horizontalGapUnit}`,
    gridAutoRows: oppositePattern || 'auto'
  };
};
const getHorizontalParentCss = (oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns) => {
  return {
    display: 'grid',
    gridTemplateRows: `repeat(${maxColumns}, 1fr)`,
    gridAutoFlow: 'column',
    gap: `${verticalGap + verticalGapUnit} ${horizontalGap + horizontalGapUnit}`,
    gridAutoColumns: oppositePattern || 'auto'
  };
};
const getChildCss = (itemSelector, cellCount, cellIndex, mode, startColumn, endColumn) => {
  return {
    [`${itemSelector}:nth-child(${cellCount}n+${cellIndex})`]: mode === _types.CustomGridScrollDirection.vertical ? {
      gridColumn: `${startColumn}/${endColumn}`
    } : {
      gridRow: `${startColumn}/${endColumn}`
    }
  };
};
const buildCustomGridStyles = ({
  selectors: {
    itemSelector,
    parentSelector
  },
  pattern,
  oppositePattern = 'auto',
  flip = false,
  mode = _types.CustomGridScrollDirection.vertical,
  horizontalGap = 0,
  horizontalGapUnit = _types.GapUnits.px,
  verticalGap = 0,
  verticalGapUnit = _types.GapUnits.px
}) => {
  const maxColumns = (0, _mathUtils.lcmArray)(pattern.rows.map(getRowProportions));
  const flipValue = flip ? 2 : 1;
  const parentRule = {
    [parentSelector]: mode === _types.CustomGridScrollDirection.vertical ? getVerticalParentCss(oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns) : getHorizontalParentCss(oppositePattern, verticalGap, verticalGapUnit, horizontalGap, horizontalGapUnit, maxColumns)
  };
  const childRules = {};
  const patternCellCount = getPatternCellCount(pattern);
  const cellCount = patternCellCount * flipValue;
  let cellIndex = 1;
  for (let flipIndex = 0; flipIndex < flipValue; flipIndex++) {
    const isFlip = flipIndex > 0;
    for (const row of pattern.rows) {
      let cellPosition = 0;
      const cellWeight = maxColumns / getRowProportions(row);
      const cells = isFlip ? [...row.cells].reverse() : row.cells;
      for (const cell of cells) {
        if (cell.proportion > 0) {
          const startColumn = cellPosition + 1;
          const endColumn = startColumn + cellWeight * cell.proportion;
          const childCss = getChildCss(itemSelector, cellCount, cellIndex, mode, startColumn, endColumn);
          if (childCss) {
            Object.assign(childRules, {
              ...childCss
            });
          }
          cellIndex++;
        }
        cellPosition += Math.abs(cell.proportion) * cellWeight;
      }
    }
  }
  const customGridStylesheet = (0, _serialize.serializeStyles)([{
    ...parentRule,
    ...childRules
  }]).styles;
  return (0, _commonUtils.cssStringToBuilderReturnType)(customGridStylesheet);
};
exports.buildCustomGridStyles = buildCustomGridStyles;
//# sourceMappingURL=customGridBuilder.js.map