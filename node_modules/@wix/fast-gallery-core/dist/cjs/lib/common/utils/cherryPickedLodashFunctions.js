"use strict";

exports.__esModule = true;
exports.throttle = exports.pick = exports.isNumber = exports.isFunction = exports.isEqual = exports.get = exports.debounce = void 0;
const pick = (obj, keys) => {
  const res = {};
  Object.entries(obj || {}).forEach(([key, val]) => {
    if (keys.includes(key)) {
      res[key] = val;
    }
  });
  return res;
};
exports.pick = pick;
const throttle = (callback, limit) => {
  let wait = false;
  let callAfterWait = false;
  return (...args) => {
    if (!wait) {
      callAfterWait = false;
      callback.apply(void 0, args);
      wait = true;
      setTimeout(() => {
        callAfterWait && callback.apply(void 0, args);
        wait = false;
      }, limit);
    } else {
      callAfterWait = true;
    }
  };
};
exports.throttle = throttle;
const debounce = (callback, wait) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      callback.apply(void 0, args);
    }, wait);
  };
};
exports.debounce = debounce;
const get = (obj, path, defaultValue) => {
  const result = String.prototype.split.call(path, /[,[\].]+?/).filter(Boolean).reduce((res, key) => res !== null && res !== undefined ? res[key] : res, obj // Add an index signature to allow using string as an index
  );
  return result === undefined || result === obj ? defaultValue : result;
};
exports.get = get;
const isFunction = something => typeof something === 'function';
exports.isFunction = isFunction;
const isEqual = (obj1, obj2) => {
  try {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  } catch (e) {
    return false;
  }
};
exports.isEqual = isEqual;
const isNumber = n => {
  return !isNaN(parseFloat(n)) && isFinite(n);
};
exports.isNumber = isNumber;
//# sourceMappingURL=cherryPickedLodashFunctions.js.map