"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.windowWrapper = exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _window2 = _interopRequireWildcard(require("./window.mock"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
class WindowWrapper {
  // Using 'any' here for simplicity; you can define a more specific type if needed

  constructor() {
    (0, _defineProperty2.default)(this, "_shouldUseMock", void 0);
    (0, _defineProperty2.default)(this, "window", void 0);
    this._shouldUseMock = true;
    this.initProxyWindow = this.initProxyWindow.bind(this);
    if (this.windowIsAvailable()) {
      // this will wrap the real window with partial mock for the dimensions
      // once the gallery is mounted we will switch from the mocked properties to the real values
      this.initProxyWindow();
    } else {
      this.initMockWindow();
    }
  }
  windowIsAvailable() {
    try {
      return typeof window !== 'undefined';
    } catch (e) {
      return false;
    }
  }
  initProxyWindow() {
    const handler = {
      get: (target, property) => {
        if (_window2.hydrateMockMap.has(property) && this.shouldUseMock) {
          return _window2.hydrateMockMap.get(property);
        }
        return target[property];
      },
      set: (target, property, value) => {
        return Reflect.set(target, property, value);
      }
    };

    // eslint-disable-next-line no-undef
    const windowProxy = new Proxy(window, handler);

    // Initialize proGalleryCustomProps as a Set if it doesn't exist
    if (!windowProxy.proGalleryCustomProps) {
      windowProxy.proGalleryCustomProps = new Set();
    }
    const windowFuncHandler = {
      get: property => {
        const props = windowProxy.proGalleryCustomProps;
        if (!props.has(property) && typeof windowProxy[property] === 'function') {
          return windowProxy[property].bind(window);
        }
        return windowProxy[property];
      },
      set: (property, value) => {
        const props = windowProxy.proGalleryCustomProps;
        if (typeof property === 'string') {
          props.add(property);
        }
        return Reflect.set(windowProxy, property, value);
      }
    };

    // this second proxy that returns bound functions to avoid issues with non-configurable properties
    // eslint-disable-next-line no-undef
    this.window = new Proxy({}, windowFuncHandler);
  }
  initMockWindow() {
    this.window = _window2.default;
    this.window.mockInstanceId = Math.floor(Math.random() * 100000);
  }
  stopUsingMock() {
    this.shouldUseMock = false;
  }
  get shouldUseMock() {
    return this._shouldUseMock;
  }
  set shouldUseMock(shouldUseMock) {
    this._shouldUseMock = shouldUseMock;
  }
}
const windowWrapper = exports.windowWrapper = new WindowWrapper();
const _window = windowWrapper.window;
var _default = exports.default = _window;
//# sourceMappingURL=windowWrapper.js.map