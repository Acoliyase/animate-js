(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("WixDashboardSDK", [], factory);
	else if(typeof exports === 'object')
		exports["WixDashboardSDK"] = factory();
	else
		root["WixDashboardSDK"] = factory();
})((typeof self !== 'undefined' ? self : this), () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 801:
/*!********************************************!*\
  !*** ./dashboardHostModule.ts + 5 modules ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ createDashboardModule)
});

// EXTERNAL MODULE: ../../../node_modules/@wix/sdk-context/build/browser/index.mjs
var browser = __webpack_require__(748);
;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk-runtime/build/context.js

function context_resolveContext() {
    const oldContext = typeof $wixContext !== 'undefined' && $wixContext.initWixModules
        ? $wixContext.initWixModules
        : typeof globalThis.__wix_context__ !== 'undefined' &&
            globalThis.__wix_context__.initWixModules
            ? globalThis.__wix_context__.initWixModules
            : undefined;
    if (oldContext) {
        return {
            // @ts-expect-error
            initWixModules(modules, elevated) {
                return runWithoutContext(() => oldContext(modules, elevated));
            },
            fetchWithAuth() {
                throw new Error('fetchWithAuth is not available in this context');
            },
            graphql() {
                throw new Error('graphql is not available in this context');
            },
        };
    }
    const contextualClient = typeof $wixContext !== 'undefined'
        ? $wixContext.client
        : typeof browser/* wixContext */.X.client !== 'undefined'
            ? browser/* wixContext */.X.client
            : typeof globalThis.__wix_context__ !== 'undefined'
                ? globalThis.__wix_context__.client
                : undefined;
    const elevatedClient = typeof $wixContext !== 'undefined'
        ? $wixContext.elevatedClient
        : typeof browser/* wixContext */.X.elevatedClient !== 'undefined'
            ? browser/* wixContext */.X.elevatedClient
            : typeof globalThis.__wix_context__ !== 'undefined'
                ? globalThis.__wix_context__.elevatedClient
                : undefined;
    if (!contextualClient && !elevatedClient) {
        return;
    }
    return {
        initWixModules(wixModules, elevated) {
            if (elevated) {
                if (!elevatedClient) {
                    throw new Error('An elevated client is required to use elevated modules. Make sure to initialize the Wix context with an elevated client before using elevated SDK modules');
                }
                return runWithoutContext(() => elevatedClient.use(wixModules));
            }
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return runWithoutContext(() => contextualClient.use(wixModules));
        },
        fetchWithAuth: (urlOrRequest, requestInit) => {
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return contextualClient.fetchWithAuth(urlOrRequest, requestInit);
        },
        async graphql(query, variables, opts) {
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return contextualClient.graphql(query, variables, opts);
        },
    };
}
function contextualizeHostModule(hostModule, prop) {
    return (...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(hostModule)[prop].apply(undefined, args);
    };
}
function contextualizeRESTModule(restModule, expectedArgsLength) {
    return ((...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context
            .initWixModules(restModule, args[expectedArgsLength]?.suppressAuth ? true : false)
            .apply(undefined, args);
    });
}
function contextualizeEventDefinitionModule(eventDefinition) {
    return ((...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(eventDefinition).apply(undefined, args);
    });
}
function contextualizeSerivcePluginModule(servicePlugin) {
    return ((...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(servicePlugin).apply(undefined, args);
    });
}

function runWithoutContext(fn) {
    const globalContext = globalThis.__wix_context__;
    const moduleContext = {
        client: browser/* wixContext */.X.client,
        elevatedClient: browser/* wixContext */.X.elevatedClient,
    };
    let closureContext;
    globalThis.__wix_context__ = undefined;
    browser/* wixContext */.X.client = undefined;
    browser/* wixContext */.X.elevatedClient = undefined;
    if (typeof $wixContext !== 'undefined') {
        closureContext = {
            client: $wixContext?.client,
            elevatedClient: $wixContext?.elevatedClient,
        };
        delete $wixContext.client;
        delete $wixContext.elevatedClient;
    }
    try {
        return fn();
    }
    finally {
        globalThis.__wix_context__ = globalContext;
        browser/* wixContext */.X.client = moduleContext.client;
        browser/* wixContext */.X.elevatedClient = moduleContext.elevatedClient;
        if (typeof $wixContext !== 'undefined') {
            $wixContext.client = closureContext.client;
            $wixContext.elevatedClient = closureContext.elevatedClient;
        }
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk-runtime/build/context-v2.js



function contextualizeHostModuleV2(hostModule, props) {
    return {
        ...hostModule,
        ...Object.fromEntries(props.map((prop) => [
            prop,
            (...args) => {
                const context = context_resolveContext();
                if (!context) {
                    throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
                }
                return context
                    .initWixModules(hostModule)[prop].apply(undefined, args);
            },
        ])),
    };
}
function contextualizeRESTModuleV2(restModule, elevated) {
    return ((...args) => {
        const context = resolveContext();
        if (!context) {
            // @ts-expect-error - if there is no context, we want to behave like the original module
            return restModule.apply(undefined, args);
        }
        return (context
            .initWixModules(restModule, elevated)
            // @ts-expect-error - we know the args here are meant to be passed to the initalized module
            .apply(undefined, args));
    });
}
function contextualizeEventDefinitionModuleV2(eventDefinition) {
    const contextualMethod = ((...args) => {
        const context = resolveContext();
        if (!context) {
            // this line should throw, but this would be a breaking change for older SDK versions
            // this is because in wixClient there's code that calls any function it detects and checks
            // if it's an ambassador module (see isAmbassadorModule)
            return () => { };
        }
        return context.initWixModules(eventDefinition).apply(undefined, args);
    });
    contextualMethod.__type = eventDefinition.__type;
    contextualMethod.type = eventDefinition.type;
    contextualMethod.isDomainEvent = eventDefinition.isDomainEvent;
    contextualMethod.transformations = eventDefinition.transformations;
    return contextualMethod;
}
function contextualizeSerivcePluginModuleV2(servicePlugin) {
    const contextualMethod = ((...args) => {
        const context = resolveContext();
        if (!context) {
            // this line should throw, but this would be a breaking change for older SDK versions
            // this is because in wixClient there's code that calls any function it detects and checks
            // if it's an ambassador module (see isAmbassadorModule)
            return () => { };
        }
        return context.initWixModules(servicePlugin).apply(undefined, args);
    });
    contextualMethod.__type = servicePlugin.__type;
    contextualMethod.componentType = servicePlugin.componentType;
    contextualMethod.methods = servicePlugin.methods;
    return contextualMethod;
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk-runtime/build/host-modules.js

function createHostModule(hostModuleAPI) {
    return contextualizeHostModuleV2({
        __type: 'host',
        create: (host) => Object.entries(hostModuleAPI).reduce((acc, [key, fn]) => ({
            ...acc,
            [key]: fn(host),
        }), {}),
    }, Object.keys(hostModuleAPI));
}

// EXTERNAL MODULE: ../../../node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(213);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);
;// CONCATENATED MODULE: ./types/addSitePlugin.ts
class AddSitePluginModalError extends Error{constructor(_ref){let{message,code}=_ref;super(message);defineProperty_default()(this,"code",void 0);this.message=message;this.code=code;}}
;// CONCATENATED MODULE: ./sdk.ts
const createSDKBuilders=()=>{const showToast=_ref=>{let{channel}=_ref;return function(){const handle=channel.showToast(...arguments);const remove=()=>Promise.resolve(handle).then(h=>h.remove());return{remove};};};const observeState=_ref2=>{let{channel}=_ref2;return function(){const handle=channel.observeState(...arguments);// this temporary casting is needed because it seems that typescript can't handle this by itself.
const disconnect=()=>Promise.resolve(handle).then(h=>h.disconnect());return{disconnect};};};const navigate=_ref3=>{let{channel}=_ref3;return function(){return channel.navigate(...arguments);};};const navigateBack=_ref4=>{let{channel}=_ref4;return()=>{return channel.navigateBack();};};const openModal=_ref5=>{let{channel}=_ref5;return(modalInfo,modalParams)=>{const[modalId,params]=typeof modalInfo==='string'?[modalInfo,modalParams]:[modalInfo.modalId,modalInfo.params];const handle=channel.openModal(modalId,params);return{modalClosed:Promise.resolve(handle).then(h=>h.modalClosed)};};};const closeModal=_ref6=>{let{channel}=_ref6;return closeData=>{if(closeData===undefined){return channel.closeModal();}const filteredArg=JSON.parse(JSON.stringify(closeData));return channel.closeModal(filteredArg);};};const getAccessToken=_ref7=>{let{channel}=_ref7;return()=>{return channel.getAccessToken();};};const getPageUrl=_ref8=>{let{channel}=_ref8;return function(){return channel.getPageUrl(...arguments);};};const openMediaManager=_ref9=>{let{channel}=_ref9;return function(){return channel.openMediaManager(...arguments);};};const addSitePlugin=_ref10=>{let{channel}=_ref10;return(pluginId,options)=>{const PLUGINS_DASHBOARD_MODAL_ID='802c76e4-b381-4bb3-9152-96acabbf3194';const additionalParams=(options==null?void 0:options.placement)||{};const handle=channel.openModal(PLUGINS_DASHBOARD_MODAL_ID,{...additionalParams,pluginId,action:'populate'});return Promise.resolve(handle).then(h=>h.modalClosed).then(resp=>{if((resp==null?void 0:resp.type)===undefined){throw new AddSitePluginModalError({message:'Aborted by user',code:3006});}if((resp==null?void 0:resp.type)==='ERROR'){throw new AddSitePluginModalError(resp.data.error);}});};};const onBeforeUnload=_ref11=>{let{channel}=_ref11;return function(){return channel.onBeforeUnload(...arguments);};};const setPageTitle=_ref12=>{let{channel}=_ref12;return pageTitle=>{return channel.setPageTitle(pageTitle);};};const getLanguage=host=>{let language=null;return async()=>{var _observeStateResult;if(language){return language;}let observeStateResult=null;language=await new Promise(resolve=>{observeStateResult=observeState(host)((_,envState)=>{resolve(envState.language);});});(_observeStateResult=observeStateResult)==null||_observeStateResult.disconnect();return language;};};const requestFeedback=_ref13=>{let{channel}=_ref13;return function(){return channel.requestFeedback(...arguments);};};const onLayerStateChange=_ref14=>{let{channel}=_ref14;return function(){const resultOrPromise=channel.onLayerStateChange(...arguments);const remove=()=>Promise.resolve(resultOrPromise).then(h=>h.remove());return{remove};};};const installApp=_ref15=>{let{channel}=_ref15;return channel.installApp;};const getWidget=_ref16=>{let{channel}=_ref16;return function(){if('getWidget'in channel){return channel.getWidget(...arguments);}else{throw new Error('Unsupported');}};};const getDashboardPlugins=_ref17=>{let{channel}=_ref17;return function(){if('getDashboardPlugins'in channel){return channel.getDashboardPlugins(...arguments);}else{throw new Error('Unsupported');}};};const getDashboardMenuPlugins=_ref18=>{let{channel}=_ref18;return function(){if('getDashboardMenuPlugins'in channel){return channel.getDashboardMenuPlugins(...arguments);}else{throw new Error('Unsupported');}};};const getSiteInfo=_ref19=>{let{channel}=_ref19;return channel.getSiteInfo;};return{showToast,observeState,navigate,navigateBack,openModal,closeModal,getAccessToken,getPageUrl,openMediaManager,addSitePlugin,onBeforeUnload,setPageTitle,getLanguage,requestFeedback,onLayerStateChange,installApp,getSiteInfo,getWidget,getDashboardPlugins,getDashboardMenuPlugins};};
;// CONCATENATED MODULE: ./dashboardHostModule.ts
const createDashboardModule=_ref=>{let{createHost}=_ref;const dashboardSDKBuilders=createSDKBuilders();return{...createHostModule(dashboardSDKBuilders),host:createHost,auth:()=>{return{getAuthHeaders:async host=>{const getAccessToken=dashboardSDKBuilders.getAccessToken(host);return{headers:{Authorization:await getAccessToken()}};}};}};};

/***/ }),

/***/ 202:
/*!**************************************!*\
  !*** ./hostPlatform.ts + 12 modules ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  L: () => (/* binding */ createHost)
});

;// CONCATENATED MODULE: ../../../node_modules/comlink/dist/esm/comlink.mjs
/**
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
/**
 * Internal transfer handle to handle objects marked to proxy.
 */
const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
        const { port1, port2 } = new MessageChannel();
        comlink_expose(obj, port1);
        return [port2, [port2]];
    },
    deserialize(port) {
        port.start();
        return wrap(port);
    },
};
/**
 * Internal transfer handler to handle thrown exceptions.
 */
const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack,
                },
            };
        }
        else {
            serialized = { isError: false, value };
        }
        return [serialized, []];
    },
    deserialize(serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    },
};
/**
 * Allows customizing the serialization of certain values.
 */
const transferHandlers = new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler],
]);
function comlink_expose(obj, ep = self) {
    ep.addEventListener("message", function callback(ev) {
        if (!ev || !ev.data) {
            return;
        }
        const { id, type, path } = Object.assign({ path: [] }, ev.data);
        const argumentList = (ev.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
            const rawValue = path.reduce((obj, prop) => obj[prop], obj);
            switch (type) {
                case 0 /* GET */:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case 1 /* SET */:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;
                case 2 /* APPLY */:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case 3 /* CONSTRUCT */:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case 4 /* ENDPOINT */:
                    {
                        const { port1, port2 } = new MessageChannel();
                        comlink_expose(obj, port2);
                        returnValue = transfer(port1, [port1]);
                    }
                    break;
                case 5 /* RELEASE */:
                    {
                        returnValue = undefined;
                    }
                    break;
            }
        }
        catch (value) {
            returnValue = { value, [throwMarker]: 0 };
        }
        Promise.resolve(returnValue)
            .catch((value) => {
            return { value, [throwMarker]: 0 };
        })
            .then((returnValue) => {
            const [wireValue, transferables] = toWireValue(returnValue);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === 5 /* RELEASE */) {
                // detach and deactive after sending release response above.
                ep.removeEventListener("message", callback);
                closeEndPoint(ep);
            }
        });
    });
    if (ep.start) {
        ep.start();
    }
}
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
        endpoint.close();
}
function wrap(ep, target) {
    return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function createProxy(ep, path = [], target = function () { }) {
    let isProxyReleased = false;
    const proxy = new Proxy(target, {
        get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return () => {
                    return requestResponseMessage(ep, {
                        type: 5 /* RELEASE */,
                        path: path.map((p) => p.toString()),
                    }).then(() => {
                        closeEndPoint(ep);
                        isProxyReleased = true;
                    });
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return { then: () => proxy };
                }
                const r = requestResponseMessage(ep, {
                    type: 0 /* GET */,
                    path: path.map((p) => p.toString()),
                }).then(fromWireValue);
                return r.then.bind(r);
            }
            return createProxy(ep, [...path, prop]);
        },
        set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
            // boolean. To show good will, we return true asynchronously ¯\_(ツ)_/¯
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, {
                type: 1 /* SET */,
                path: [...path, prop].map((p) => p.toString()),
                value,
            }, transferables).then(fromWireValue);
        },
        apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep, {
                    type: 4 /* ENDPOINT */,
                }).then(fromWireValue);
            }
            // We just pretend that `bind()` didn’t happen.
            if (last === "bind") {
                return createProxy(ep, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: 2 /* APPLY */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
        construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: 3 /* CONSTRUCT */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
    });
    return proxy;
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
}
function windowEndpoint(w, context = self, targetOrigin = "*") {
    return {
        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
        addEventListener: context.addEventListener.bind(context),
        removeEventListener: context.removeEventListener.bind(context),
    };
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: 3 /* HANDLER */,
                    name,
                    value: serializedValue,
                },
                transferables,
            ];
        }
    }
    return [
        {
            type: 0 /* RAW */,
            value,
        },
        transferCache.get(value) || [],
    ];
}
function fromWireValue(value) {
    switch (value.type) {
        case 3 /* HANDLER */:
            return transferHandlers.get(value.name).deserialize(value.value);
        case 0 /* RAW */:
            return value.value;
    }
}
function requestResponseMessage(ep, msg, transfers) {
    return new Promise((resolve) => {
        const id = generateUUID();
        ep.addEventListener("message", function l(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
                return;
            }
            ep.removeEventListener("message", l);
            resolve(ev.data);
        });
        if (ep.start) {
            ep.start();
        }
        ep.postMessage(Object.assign({ id }, msg), transfers);
    });
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join("-");
}


//# sourceMappingURL=comlink.mjs.map

;// CONCATENATED MODULE: ../../../communication-channel/dist/esm/serialization.js

const proxyCallbackMarker = '__proxyCallbackId__wixSDK__';
const proxyPromiseMarker = '__proxyPromiseId__wixSDK__';
const serializeAllMethodsIn = sdk => {
  return wrapMethodsWithProxy(sdk, originalMethod => {
    return async function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const [proxies, argsNoProxies] = extractProxies(args);
      const originalResult = await originalMethod(proxy(proxies), argsNoProxies);
      return deserializeReturnValue(originalResult);
    };
  });
};
const serialization_deserializeAllMethodsIn = api => {
  return wrapMethodsWithProxy(api, originalMethod => {
    return (proxies, args) => {
      const argsWithProxies = insertProxies(proxies, args);
      const originalRun = originalMethod(...argsWithProxies);
      return serializeReturnValue(originalRun);
    };
  });
};
const serializeReturnValue = async value => {
  const [proxies, clonables] = extractProxies(await value);
  return proxy({
    proxies,
    clonables
  });
};
const deserializeReturnValue = async value => {
  return insertProxies(value == null ? void 0 : value.proxies, await (value == null ? void 0 : value.clonables));
};
const extractProxies = data => {
  const walker = (proxies, val) => {
    if (isPromise(val)) {
      const proxyId = uniqueId();
      proxies.promises[proxyId] = val;
      return {
        [proxyPromiseMarker]: proxyId
      };
    }
    if (isFunction(val)) {
      const proxyId = uniqueId();
      proxies.callbacks[proxyId] = (innerProxies, argsAsArray) => {
        const argsWithProxies = insertProxies(innerProxies, argsAsArray);
        const exec = val(...argsWithProxies);
        return serializeReturnValue(exec);
      };
      return {
        [proxyCallbackMarker]: proxyId
      };
    }
    if (Array.isArray(val)) {
      return val.map(i => walker(proxies, i));
    }
    if (serialization_isObject(val)) {
      return mapObjectValues(val, i => walker(proxies, i));
    }
    return val;
  };
  const proxies = {
    promises: {},
    callbacks: {}
  };
  const dataWithoutProxies = walker(proxies, data);
  return [proxies, dataWithoutProxies];
};
const insertProxies = (proxies, data) => {
  if (Array.isArray(data)) {
    return data.map(i => insertProxies(proxies, i));
  }
  if (serialization_isObject(data) && data.hasOwnProperty(proxyPromiseMarker)) {
    const promiseId = data[proxyPromiseMarker];
    return proxies.promises[promiseId];
  }
  if (serialization_isObject(data) && data.hasOwnProperty(proxyCallbackMarker)) {
    const callbackId = data[proxyCallbackMarker];
    // passing args in spread syntax to comlink proxy generates problem when transpiling to old JS version
    // so pass it as array and handle it on the deserialization level:
    return async function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      const [innerProxies, argsNoProxies] = extractProxies(args);
      const exec = await proxies.callbacks[callbackId](proxy(innerProxies), argsNoProxies);
      return deserializeReturnValue(exec);
    };
  }
  if (serialization_isObject(data)) {
    return mapObjectValues(data, i => insertProxies(proxies, i));
  }
  return data;
};
const wrapMethodsWithProxy = (obj, callback) => {
  return new Proxy(obj, {
    get(target, prop) {
      if (!target[prop]) {
        return () => {
          throw new Error(`Serialization error occurred while accessing ${prop} property of ${target}`);
        };
      }
      return callback(target[prop]);
    }
  });
};
const isPromise = val => val instanceof Promise;
const serialization_isObject = val => val && typeof val === 'object' && !isPromise(val);
const isFunction = val => typeof val === 'function';
const mapObjectValues = (obj, callback) => {
  const mapEntries = _ref => {
    let [key, value] = _ref;
    return [key, callback(value)];
  };
  return Object.fromEntries(Object.entries(obj).map(mapEntries));
};
const uniqueId = (() => {
  let counter = 0;
  return () => ++counter;
})();
//# sourceMappingURL=serialization.js.map
;// CONCATENATED MODULE: ../../../communication-channel/dist/esm/index.js


const handshakeCode = 'wix-sdk-bo-hello-handshake';
/**
 * Initializes a new channel with a target.
 * @param postMessage - Target's function to receive messages.
 * @param origin - Target's origin.
 */
const esm_open = _ref => {
  let {
    postMessage,
    origin
  } = _ref;
  const {
    port1: widgetPort,
    port2: hostPort
  } = new MessageChannel();
  const protocolVersion = '1.0.0';
  const message = {
    code: handshakeCode,
    version: protocolVersion,
    port: hostPort
  };
  postMessage(message, origin, [hostPort]);
  const channel = serializeAllMethodsIn(wrap(widgetPort));
  return {
    channel,
    close: () => channel[releaseProxy]()
  };
};

/**
 * Serves api as a response over the communication channel to given port.
 * @param api - The api object that has the methods inside it.
 * @param port - The port on which the channel was initiated and needs to receive the api.
 */
const serve = _ref2 => {
  let {
    api,
    port
  } = _ref2;
  expose(deserializeAllMethodsIn(api), port);
};
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring/build/index.js
// src/context/context-utils.ts
var validValue = (value) => value !== void 0 && value !== null && value !== "";
var pickByValidValues = (obj) => pickBy(obj, validValue);
function pickBy(object, predicate = (value) => !!value) {
  if (!object) {
    return {};
  }
  const result = {};
  for (const key in object) {
    if (predicate(object[key], key)) {
      result[key] = object[key];
    }
  }
  return result;
}
var generateTagsAndContext = (context) => {
  const tags = pickByValidValues({
    "app.id": context.appId,
    "app.version": context.appVersion,
    "app.instanceId": context.appInstanceId,
    "extension.id": context.extensionId,
    "extension.name": context.extensionName,
    "extension.type": context.extensionType,
    platform: context.platform
  });
  const contexts = pickBy(
    {
      "extension.data": pickByValidValues({
        ...context.extensionData
      }),
      site: pickByValidValues({
        url: context.siteUrl,
        id: context.tenantType === "SITE" ? context.tenantId : void 0
      }),
      account: pickByValidValues({
        id: context.tenantType === "ACCOUNT" ? context.tenantId : void 0
      })
    },
    (value) => !!value && Object.keys(value).length > 0
  );
  return {
    tags,
    contexts
  };
};

// src/fallback-client.ts
var FallbackMonitoringClient = class {
  constructor(message) {
    this.message = message;
    this.captureException = () => {
      console.error(this.message);
    };
    this.captureMessage = () => {
      console.error(this.message);
    };
    this.startSpan = (spanOptions, callback) => {
      console.error(this.message);
      return callback(void 0);
    };
    this.startSpanManual = () => {
      console.error(this.message);
      return {
        end: () => {
        },
        fail: () => {
        }
      };
    };
    this.endSpanManual = () => {
      console.error(this.message);
    };
    this.addBreadcrumb = () => {
      console.error(this.message);
    };
  }
};
var createFallbackMonitoringClient = (message) => {
  return new FallbackMonitoringClient(message);
};


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-common-sentry/build/index.js
// src/utils.ts
var build_isPromise = (value) => typeof value?.then === "function";
var runWithMaybePromise = (value, cb) => {
  if (!cb) {
    return value;
  }
  if (build_isPromise(value)) {
    return value.then((res) => {
      cb(res, true);
      return res;
    });
  } else {
    cb(value, false);
    return value;
  }
};
var runWithMaybeDelay = (cb, maybeTimeCompensation) => {
  if (!cb) {
    return;
  }
  if (maybeTimeCompensation) {
    setTimeout(cb, maybeTimeCompensation);
  } else {
    cb();
  }
};
var generateRandomId = () => Date.now() + Math.random();

// src/manual-span.ts
var ManualSpanRegistryImpl = class {
  constructor(options) {
    this.options = options;
    this.spanMap = /* @__PURE__ */ new Map();
  }
  createSpan(spanOptions, sentryOptionsOrPromise) {
    let resolveSpan;
    let rejectSpan;
    let error;
    const startTime = Date.now();
    let maybeDurationCompensation;
    const maybePromise = runWithMaybePromise(
      sentryOptionsOrPromise,
      ({ sentrySDK, scope }, isPromise2) => {
        if (isPromise2) {
          maybeDurationCompensation = Date.now() - startTime;
        }
        const promise = sentrySDK.startSpan(
          {
            ...spanOptions,
            scope,
            forceTransaction: this.options.forceTransaction
          },
          () => new Promise((resolve, reject) => {
            resolveSpan = resolve;
            rejectSpan = reject;
          })
        );
        promise?.catch((e) => {
          if (e?.message !== error?.message) {
            throw e;
          }
        });
      }
    );
    const endSpan = (cb) => {
      this.spanMap.delete(spanOptions.name);
      runWithMaybePromise(maybePromise, () => {
        runWithMaybeDelay(cb, maybeDurationCompensation);
      });
    };
    const span = {
      end: () => {
        endSpan(() => resolveSpan?.());
      },
      fail: (_error) => {
        error = error ?? _error;
        endSpan(() => rejectSpan?.(_error));
      }
    };
    this.spanMap.set(spanOptions.name, span);
    return span;
  }
  getSpan(spanOptions) {
    return this.spanMap.get(spanOptions.name);
  }
};
var createManualSpanRegistry = (options) => new ManualSpanRegistryImpl(options);


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-browser-sentry/build/index.js
// src/factory.ts


// src/browser/client.ts


// src/abstract-browser-client.ts


// src/context-utils.ts

var setTagsAndContextsOnScope = (scope, { tags, contexts }) => {
  if (tags) {
    scope.setTags(tags);
  }
  if (contexts) {
    Object.entries(contexts).forEach(
      ([key, value]) => typeof value !== "undefined" && scope.setContext(key, value)
    );
  }
};
var setHostContextOnScope = (scope, hostContext) => {
  if (!hostContext) {
    return;
  }
  const { tags, contexts } = generateTagsAndContext(hostContext);
  setTagsAndContextsOnScope(scope, { tags, contexts });
};

// src/abstract-browser-client.ts
var MandatorySDKMethods = ["onLoad", "forceLoad"];
var manualSpanRegistryMap = /* @__PURE__ */ new Map();
var AbstractSentryBrowserClient = class {
  constructor(options) {
    this.options = options;
    this.resolvedState = null;
    this.validateOptions = (options) => {
      const missingSDKMethods = MandatorySDKMethods.filter(
        (method) => typeof options.sentrySDK?.[method] !== "function"
      );
      if (missingSDKMethods.length > 0) {
        throw new Error(
          `Missing the following options.sentrySDK methods: ${missingSDKMethods.join(", ")}`
        );
      }
    };
    this.validateOptions(options);
    let manualSpanRegistry = manualSpanRegistryMap.get(options.dsn);
    if (!manualSpanRegistry) {
      manualSpanRegistry = createManualSpanRegistry({
        // Force spans to be reported as individual transactions (one http request per one span)
        forceTransaction: true
      });
      manualSpanRegistryMap.set(options.dsn, manualSpanRegistry);
    }
    this.manualSpanRegistry = manualSpanRegistry;
  }
  isFullSDK() {
    return typeof this.options.sentrySDK.BrowserClient === "function";
  }
  init() {
    if (this.resolvedState) {
      return this.resolvedState;
    }
    const {
      sentrySDK,
      transport,
      hostContext,
      dsn,
      release,
      environment,
      tracesSampleRate = 1,
      debug = false
    } = this.options;
    const scope = new sentrySDK.Scope();
    const sentryClient = new sentrySDK.BrowserClient({
      dsn,
      transport: transport ?? sentrySDK.makeFetchTransport,
      integrations: sentrySDK.getDefaultIntegrations({}),
      stackParser: sentrySDK.defaultStackParser,
      tracesSampleRate: tracesSampleRate || 1,
      debug,
      environment,
      release
    });
    setHostContextOnScope(scope, hostContext);
    scope.setClient(sentryClient);
    sentryClient.init();
    this.resolvedState = {
      sentrySDK,
      scope,
      sentryClient
    };
    return this.resolvedState;
  }
  loadFullSDK(handler) {
    if (this.isFullSDK()) {
      handler?.(this.init());
      return;
    }
    if (this.promise) {
      this.promise.then(handler);
      return;
    }
    this.promise = new Promise((resolve) => {
      this.options.sentrySDK.onLoad(() => {
        if (this.resolvedState) {
          return;
        }
        const resolvedState = this.init();
        resolve(resolvedState);
        handler?.(resolvedState);
      });
    });
    this.options.sentrySDK.forceLoad();
  }
};

// src/browser/client.ts
var SentryBrowserClient = class extends AbstractSentryBrowserClient {
  constructor() {
    super(...arguments);
    /**
     * Records a new breadcrumb which will be attached to future events.
     * Breadcrumbs will be added to subsequent events to provide more context on user's actions prior to an error or crash.
     * @param breadcrumb The breadcrumb to record.
     */
    this.addBreadcrumb = (breadcrumb) => {
      const filteredBreadcrumb = {
        type: breadcrumb.type,
        category: breadcrumb.category,
        message: breadcrumb.message,
        level: breadcrumb.level,
        data: breadcrumb.data
      };
      this.loadFullSDK(({ scope }) => {
        scope.addBreadcrumb(filteredBreadcrumb);
      });
    };
    /**
     * Captures an exception event and sends it to Sentry.
     * @param error The error to capture
     * @param captureContext Optional additional data to attach to the Sentry event.
     */
    this.captureException = (error, captureContext) => {
      this.loadFullSDK(({ sentryClient, scope }) => {
        sentryClient.captureException(
          error,
          {
            captureContext: {
              level: captureContext?.level ?? "error",
              tags: captureContext?.tags,
              contexts: captureContext?.contexts
            }
          },
          scope
        );
      });
    };
    /**
     * Captures a message event and sends it to Sentry.
     * @param message The message to capture
     * @param captureContext Define the level of the message or pass in additional data to attach to the message.
     */
    this.captureMessage = (message, captureContext) => {
      this.loadFullSDK(({ sentryClient, scope }) => {
        sentryClient.captureMessage(
          message,
          captureContext?.level ?? "error",
          {
            captureContext: {
              level: captureContext?.level ?? "error",
              tags: captureContext?.tags,
              contexts: captureContext?.contexts
            }
          },
          scope
        );
      });
    };
    /**
     * Wraps a function with a span and finishes the span after the function is done. The created span is the active span and will be used as parent by other spans created inside the function, as long as the function is executed while the scope is active.
     * @param spanOptions The options for the span
     * @param callback The function to wrap with a span
     * @returns The return value of the callback
     */
    this.startSpan = (spanOptions, callback) => {
      if (this.isFullSDK()) {
        const { sentrySDK, scope } = this.init();
        return sentrySDK.startSpan({ ...spanOptions, scope }, callback);
      }
      this.loadFullSDK();
      const simulateAndReportSuccessfulSpan = (callbackResult2, startTime2) => {
        const spanDuration = Date.now() - startTime2;
        const simulatedCallback = () => {
          return new Promise(
            (resolve) => setTimeout(() => resolve(callbackResult2), spanDuration)
          );
        };
        this.loadFullSDK(async ({ sentrySDK, scope }) => {
          return sentrySDK.startSpan(
            { ...spanOptions, scope },
            simulatedCallback
          );
        });
      };
      const simulateAndReportFailedSpan = async (error2, startTime2) => {
        const spanDuration = Date.now() - startTime2;
        const simulatedCallback = () => {
          return new Promise(
            (_, reject) => setTimeout(() => reject(error2), spanDuration)
          );
        };
        this.loadFullSDK(async ({ sentrySDK, scope }) => {
          try {
            await sentrySDK.startSpan(
              { ...spanOptions, scope },
              simulatedCallback
            );
          } catch (e) {
            if (e?.message !== error2?.message) {
              throw e;
            }
          }
        });
      };
      const startTime = Date.now();
      let callbackResult;
      let error;
      try {
        callbackResult = callback();
      } catch (e) {
        error = e;
      }
      if (error) {
        simulateAndReportFailedSpan(error, startTime);
        throw error;
      } else {
        if (build_isPromise(callbackResult)) {
          callbackResult.then((res) => simulateAndReportSuccessfulSpan(res, startTime)).catch((e) => simulateAndReportFailedSpan(e, startTime));
        } else {
          simulateAndReportSuccessfulSpan(callbackResult, startTime);
        }
        return callbackResult;
      }
    };
    this.startSpanManual = (spanOptions) => {
      const resolvedStateOrPromise = this.isFullSDK() ? this.init() : new Promise((resolve) => this.loadFullSDK(resolve));
      const span = this.manualSpanRegistry.createSpan(
        spanOptions,
        resolvedStateOrPromise
      );
      return span;
    };
    this.endSpanManual = (spanOptions) => {
      const span = this.manualSpanRegistry.getSpan(spanOptions);
      span?.end();
    };
  }
};

// src/factory.ts
var unsupportedEnvironmentMessage = (version) => `Sentry SDK version "${version}" is not supported. Please make sure to use monitoring SDK only in supported environments.`;
var major = (version) => {
  try {
    return parseInt(version.split(".")[0], 10);
  } catch {
    console.warn("Failed to parse Sentry SDK version");
    return void 0;
  }
};
var createSentryBrowserClient = ({
  sentrySDK,
  dsn,
  ...options
}) => {
  if (!sentrySDK) {
    return createFallbackMonitoringClient(
      "Unsupported environment - Sentry SDK is not loaded into the environment. Please make sure to use monitoring SDK only in supported environments."
    );
  }
  if (!dsn) {
    return createFallbackMonitoringClient(
      "Missing Sentry DSN in the app's monitoring configuration. Please make sure to set it."
    );
  }
  try {
    const sentrySdkMajorVersion = sentrySDK.SDK_VERSION && major(sentrySDK.SDK_VERSION);
    if (sentrySdkMajorVersion && sentrySdkMajorVersion < 7) {
      return createFallbackMonitoringClient(
        unsupportedEnvironmentMessage(sentrySDK.SDK_VERSION)
      );
    }
    return new SentryBrowserClient({ ...options, dsn, sentrySDK });
  } catch (e) {
    return createFallbackMonitoringClient(
      `Failed to initialize monitoring client: ${e.message}`
    );
  }
};


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-browser-panorama/build/index.js
// src/client.ts

var PanoramaBrowserClient = class {
  constructor(options) {
    this.options = options;
    this.captureException = (error, captureContext) => {
      const { panoramaClient } = this.options;
      if (!(error instanceof Error)) {
        error = new Error(error);
      }
      panoramaClient.errorMonitor().reportError(error, this.contextToData(captureContext));
    };
    this.captureMessage = (message, captureContext) => {
      const { panoramaClient } = this.options;
      const logger = panoramaClient.logger();
      let loggerByLevel;
      switch (captureContext?.level) {
        case "error":
          loggerByLevel = logger.error;
          break;
        case "warning":
          loggerByLevel = logger.warn;
          break;
        default:
          loggerByLevel = logger.info;
      }
      loggerByLevel(message, this.contextToData(captureContext));
    };
    this.startSpan = (spanOptions, callback) => {
      const { panoramaClient } = this.options;
      const { name } = spanOptions;
      let res;
      const transaction = panoramaClient.transaction(name, {
        id: generateRandomId()
      });
      const data = this.contextToData(spanOptions);
      transaction.start(data);
      try {
        res = callback();
        if (build_isPromise(res)) {
          res = res.then((_res) => {
            transaction.finish(data);
            return _res;
          }).catch((e) => {
            this.reportErrorInContextOfSpan(e, spanOptions);
            throw e;
          });
        } else {
          transaction.finish(data);
        }
      } catch (e) {
        this.reportErrorInContextOfSpan(e, spanOptions);
        throw e;
      }
      return res;
    };
    this.addBreadcrumb = (breadcrumb) => {
      const { panoramaClient } = this.options;
      panoramaClient.errorMonitor().addBreadcrumb(breadcrumb);
    };
  }
  contextToData(captureContext) {
    return captureContext && {
      ...captureContext?.tags && { tags: captureContext.tags },
      ...captureContext?.contexts && { context: captureContext.contexts },
      ...captureContext?.level && {
        severity: captureContext.level
      }
    };
  }
  reportErrorInContextOfSpan(error, spanOptions) {
    const { panoramaClient } = this.options;
    const { name } = spanOptions;
    const data = this.contextToData({
      ...spanOptions,
      contexts: { transaction: { name } }
    });
    panoramaClient.errorMonitor().reportError(error, data);
  }
  startSpanManual(spanOptions) {
    const { panoramaClient } = this.options;
    const { name } = spanOptions;
    const transaction = panoramaClient.transaction(name, {
      id: generateRandomId()
    });
    const data = this.contextToData(spanOptions);
    transaction.start(data);
    let reported = false;
    const reportOnce = (cb) => {
      if (reported) {
        return;
      }
      reported = true;
      cb();
    };
    return {
      end: () => {
        reportOnce(() => transaction.finish(data));
      },
      fail: (error) => {
        reportOnce(() => this.reportErrorInContextOfSpan(error, spanOptions));
      }
    };
  }
  endSpanManual(spanOptions) {
    const { panoramaClient } = this.options;
    const { name } = spanOptions;
    panoramaClient.transaction(name).finish();
  }
};

// src/factory.ts

var createPanoramaBrowserClient = (options) => {
  const { panoramaClient } = options;
  if (!panoramaClient) {
    return createFallbackMonitoringClient("Missing Panorama client");
  }
  return new PanoramaBrowserClient(options);
};


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-browser-sdk-host/build/index.js
// src/monitoring-client.ts



var isSentryConfig = (monitoringConfig) => monitoringConfig?.type === "SENTRY";
var isPanoramaConfig = (monitoringConfig) => monitoringConfig?.type === "PANORAMA";
var getMonitoringClientFunction = ({
  sentrySDK,
  sentryTransport,
  panoramaClient,
  monitoringConfig,
  hostContext
}) => {
  if (isSentryConfig(monitoringConfig)) {
    const { sentryOptions } = monitoringConfig;
    return () => createSentryBrowserClient({
      dsn: sentryOptions?.dsn,
      hostContext,
      sentrySDK,
      transport: sentryTransport
    });
  } else if (isPanoramaConfig(monitoringConfig)) {
    return () => createPanoramaBrowserClient({ panoramaClient });
  }
  return () => createFallbackMonitoringClient(
    "Invalid monitoring configuration. Please check the monitoring setup of your application."
  );
};


;// CONCATENATED MODULE: ./helpers/registerHeightReporter.ts
const registerHeightReporter=(bridge,container)=>{const update=()=>bridge.updateHeight(container.offsetHeight);const resizeObserver=new ResizeObserver(update);resizeObserver.observe(container);return()=>resizeObserver.disconnect();};
;// CONCATENATED MODULE: ./helpers/isWixOrigin.ts
const origins=['https://manage.wix.com','https://manage.editorx.com'];const allowedOrigins=new Set(origins);const isWixOrigin=origin=>allowedOrigins.has(origin);
;// CONCATENATED MODULE: ./helpers/registerOnBeforeUnload.ts
const registerBeforeUnloadHandler=channel=>{const eventTarget=new EventTarget();const isInWorker=typeof window==='undefined';const onIframeBeforeUnload=event=>{const shouldUnloadWithoutConfirmation=eventTarget.dispatchEvent(new CustomEvent('beforeunload',{cancelable:true}));if(!shouldUnloadWithoutConfirmation){event.preventDefault();event.returnValue=true;// Chrome requires returnValue to be set
}};const onBeforeUnloadHandle=channel.onBeforeUnload(onIframeBeforeUnload);const clearBeforeUnloadHandler=()=>{if(!isInWorker){window.removeEventListener('beforeunload',onIframeBeforeUnload);}onBeforeUnloadHandle.then(_ref=>{let{remove}=_ref;return remove();});};if(!isInWorker){window.addEventListener('beforeunload',onIframeBeforeUnload);window.addEventListener('unload',clearBeforeUnloadHandler);}const onBeforeUnload=callback=>{eventTarget.addEventListener('beforeunload',callback);const remove=()=>{eventTarget.removeEventListener('beforeunload',callback);};return{remove};};return{onBeforeUnload,clearBeforeUnloadHandler};};
;// CONCATENATED MODULE: ./helpers/essentials.ts
function safeParseEssentials(essentials){if(!essentials){return undefined;}try{return JSON.parse(decodeURIComponent(essentials));}catch(e){console.warn('Failed to parse "essentials" query parameter. Make sure to run the code inside a supported Wix App extension.',e);return undefined;}}function getEssentialsFromQueryParams(queryParams){return queryParams.has('essentials')?safeParseEssentials(queryParams.get('essentials')):undefined;}
;// CONCATENATED MODULE: ./hostPlatform.ts
const createHost=function(config){if(config===void 0){config={};}// when full url is provided (worker case) use it and ignore own location search
const searchString=config.fullUrl&&new URL(config.fullUrl).search||typeof window!=='undefined'&&window.location.search||'';const queryParams=new URLSearchParams(searchString);const origin=config.origin||queryParams.get('origin')||'';const postMessage=config.postMessage||window.parent.postMessage.bind(window.parent);if(!isWixOrigin(origin)){throw new Error(`Wix Dashboard SDK: Unable to establish a connection with the Wix dashboard. Please ensure that you are running your app within the Wix dashboard.`);}const{channel,close}=esm_open({postMessage,origin});const closeMethods=[close];if(config.autoHeightUpdate===undefined||config.autoHeightUpdate){const element=config.autoHeightElement||document.documentElement;const clearHeightReport=registerHeightReporter(channel,element);closeMethods.push(()=>clearHeightReport());}const{onBeforeUnload,clearBeforeUnloadHandler}=registerBeforeUnloadHandler(channel);closeMethods.push(clearBeforeUnloadHandler);const siteInfo=parseSiteInfo(queryParams.get('siteInfo')||'');const getSiteInfoSync=()=>siteInfo;const channelProxy=new Proxy(channel,{get(target,prop,receiver){if(prop==='onBeforeUnload'){return onBeforeUnload;}if(prop==='getSiteInfo'){return getSiteInfoSync;}return Reflect.get(target,prop,receiver);}});const{monitoring,...essentials}=getEssentialsFromQueryParams(queryParams)||{};const getMonitoringClient=getMonitoringClientFunction({hostContext:monitoring==null?void 0:monitoring.context,monitoringConfig:monitoring==null?void 0:monitoring.config,sentrySDK:typeof window!=='undefined'?window.Sentry:undefined});return{channel:channelProxy,close:()=>closeMethods.forEach(method=>method()),getMonitoringClient,essentials};};const parseSiteInfo=siteInfo=>{try{return JSON.parse(decodeURIComponent(siteInfo));}catch(e){console.warn('Failed to parse "siteInfo" query parameter. Make sure to run the code inside a supported Wix App extension.',e);return{};}};

/***/ }),

/***/ 408:
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dashboard: () => (/* binding */ dashboard)
/* harmony export */ });
/* harmony import */ var _dashboardHostModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dashboardHostModule */ 801);
/* harmony import */ var _hostPlatform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hostPlatform */ 202);
const dashboard=(0,_dashboardHostModule__WEBPACK_IMPORTED_MODULE_0__/* .createDashboardModule */ .f)({createHost: _hostPlatform__WEBPACK_IMPORTED_MODULE_1__/* .createHost */ .L});

/***/ }),

/***/ 516:
/*!****************************************************!*\
  !*** ../../../node_modules/object-assign/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 447:
/*!***************************************************************!*\
  !*** ../../../node_modules/react/cjs/react.production.min.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v16.14.0
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var l=__webpack_require__(/*! object-assign */ 516),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}var I=H.prototype=new G;I.constructor=H;l(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return{$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
function N(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return{result:a,keyPrefix:b,func:c,context:e,count:0}}
function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}
function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++)}
function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a))}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b)}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}
var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:l};exports.Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};
exports.Component=F;exports.Fragment=r;exports.Profiler=u;exports.PureComponent=H;exports.StrictMode=t;exports.Suspense=y;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
exports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f}return{$$typeof:p,type:a.type,
key:d,ref:g,props:e,_owner:k}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:x,render:a}};exports.isValidElement=O;
exports.lazy=function(a){return{$$typeof:A,_ctor:a,_status:-1,_result:null}};exports.memo=function(a,b){return{$$typeof:z,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return Z().useCallback(a,b)};exports.useContext=function(a,b){return Z().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return Z().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
exports.useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return Z().useMemo(a,b)};exports.useReducer=function(a,b,c){return Z().useReducer(a,b,c)};exports.useRef=function(a){return Z().useRef(a)};exports.useState=function(a){return Z().useState(a)};exports.version="16.14.0";


/***/ }),

/***/ 735:
/*!********************************************!*\
  !*** ../../../node_modules/react/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(/*! ./cjs/react.production.min.js */ 447);
} else {}


/***/ }),

/***/ 213:
/*!**********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ 174);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 448:
/*!***************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/extends.js ***!
  \***************************************************************/
/***/ ((module) => {

function _extends() {
  return module.exports = _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends.apply(null, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 662:
/*!*******************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 114)["default"]);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 174:
/*!*********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 114)["default"]);
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ 662);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 114:
/*!**************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/typeof.js ***!
  \**************************************************************/
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 748:
/*!**********************************************************************!*\
  !*** ../../../node_modules/@wix/sdk-context/build/browser/index.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ wixContext)
/* harmony export */ });
// src/index.ts
var wixContext = {};



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***********************************!*\
  !*** ./internal.tsx + 13 modules ***!
  \***********************************/
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  withContextualWixClient: () => (/* binding */ withContextualWixClient)
});

// EXTERNAL MODULE: ../../../node_modules/@babel/runtime/helpers/extends.js
var helpers_extends = __webpack_require__(448);
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);
// EXTERNAL MODULE: ../../../node_modules/react/index.js
var react = __webpack_require__(735);
// EXTERNAL MODULE: ../../../node_modules/@wix/sdk-context/build/browser/index.mjs
var browser = __webpack_require__(748);
;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk-types/build/browser/index.mjs
// src/event-handlers-modules.ts
function EventDefinition(type, isDomainEvent = false, transformations = (x) => x) {
  return () => ({
    __type: "event-definition",
    type,
    isDomainEvent,
    transformations
  });
}

// src/service-plugins.ts
function ServicePluginDefinition(componentType, methods) {
  return {
    __type: "service-plugin-definition",
    componentType,
    methods
  };
}
var SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";


;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/ambassador-modules.js
const parseMethod = (method) => {
    switch (method) {
        case 'get':
        case 'GET':
            return 'GET';
        case 'post':
        case 'POST':
            return 'POST';
        case 'put':
        case 'PUT':
            return 'PUT';
        case 'delete':
        case 'DELETE':
            return 'DELETE';
        case 'patch':
        case 'PATCH':
            return 'PATCH';
        case 'head':
        case 'HEAD':
            return 'HEAD';
        case 'options':
        case 'OPTIONS':
            return 'OPTIONS';
        default:
            throw new Error(`Unknown method: ${method}`);
    }
};
const toHTTPModule = (factory) => (httpClient) => async (payload) => {
    let requestOptions;
    const HTTPFactory = (context) => {
        requestOptions = factory(payload)(context);
        if (requestOptions.url === undefined) {
            throw new Error('Url was not successfully created for this request, please reach out to support channels for assistance.');
        }
        const { method, url, params } = requestOptions;
        return {
            ...requestOptions,
            method: parseMethod(method),
            url,
            data: requestOptions.data,
            params,
        };
    };
    try {
        const response = await httpClient.request(HTTPFactory);
        if (requestOptions === undefined) {
            throw new Error('Request options were not created for this request, please reach out to support channels for assistance.');
        }
        const transformations = Array.isArray(requestOptions.transformResponse)
            ? requestOptions.transformResponse
            : [requestOptions.transformResponse];
        /**
         * Based on Axios implementation:
         * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/lib/core/transformData.js#L22
         */
        let data = response.data;
        transformations.forEach((transform) => {
            if (transform) {
                data = transform(response.data, response.headers);
            }
        });
        return data;
    }
    catch (e) {
        if (typeof e === 'object' &&
            e !== null &&
            'response' in e &&
            typeof e.response === 'object' &&
            e.response !== null &&
            'data' in e.response) {
            throw e.response.data;
        }
        throw e;
    }
};
/*
 * Because of issues with tree-shaking, we cant really put static parameter on module.
 * We still have check for __isAmbassador for backward compatibility
 */
const isAmbassadorModule = (module) => {
    if (module.__isAmbassador) {
        return true;
    }
    const fn = module();
    return Boolean(fn.__isAmbassador);
};

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/common.js
const PUBLIC_METADATA_KEY = '__metadata';
const DEFAULT_API_URL = 'www.wixapis.com';
const DEFAULT_EDGE_API_URL = 'edge.wixapis.com';
const FORCE_WRITE_API_URLS = (/* unused pure expression or super */ null && (['/ecom/v1/carts/current']));

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/fetch-error.js
class FetchErrorResponse extends Error {
    message;
    response;
    constructor(message, response) {
        super(message);
        this.message = message;
        this.response = response;
    }
    async details() {
        const dataError = await this.response.json();
        return errorBuilder(this.response.status, dataError?.message, dataError?.details, {
            requestId: this.response.headers.get('X-Wix-Request-Id'),
            details: dataError,
        });
    }
}
const errorBuilder = (code, description, details, data) => {
    return {
        details: {
            ...(!details?.validationError && {
                applicationError: {
                    description,
                    code,
                    data,
                },
            }),
            ...details,
        },
        message: description,
        requestId: data?.requestId,
    };
};

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/helpers.js
// we follow a simplified version of the axios convention
// https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/defaults/index.js#L65
const getDefaultContentHeader = (options) => {
    if (options?.method &&
        ['post', 'put', 'patch'].includes(options.method.toLocaleLowerCase()) &&
        options.body) {
        return { 'Content-Type': 'application/json' };
    }
    return {};
};
const isObject = (val) => val && typeof val === 'object' && !Array.isArray(val);
function parsePublicKeyIfEncoded(publicKey) {
    if (publicKey.includes('\n') || publicKey.includes('\r')) {
        // publicKey is multi-line string, can be used as is
        return publicKey.trim();
    }
    else {
        // publicKey is base64 encoded
        return typeof atob !== 'undefined'
            ? atob(publicKey)
            : Buffer.from(publicKey, 'base64').toString('utf-8');
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/host-modules.js
const isHostModule = (val) => val.__type === 'host';
function buildHostModule(val, host) {
    return val.create(host);
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/bi/biHeaderGenerator.js
const WixBIHeaderName = 'x-wix-bi-gateway';
function biHeaderGenerator(apiMetadata, publicMetadata, environment) {
    return {
        [WixBIHeaderName]: objectToKeyValue({
            environment: `js-sdk${environment ? `-${environment}` : ``}`,
            'package-name': apiMetadata.packageName ?? publicMetadata?.PACKAGE_NAME,
            'method-fqn': apiMetadata.methodFqn,
            entity: apiMetadata.entityFqdn,
        }),
    };
}
function objectToKeyValue(input) {
    return Object.entries(input)
        .filter(([_, value]) => Boolean(value))
        .map(([key, value]) => `${key}=${value}`)
        .join(',');
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/node_modules/@wix/sdk-runtime/build/context.js

function resolveContext() {
    const oldContext = typeof $wixContext !== 'undefined' && $wixContext.initWixModules
        ? $wixContext.initWixModules
        : typeof globalThis.__wix_context__ !== 'undefined' &&
            globalThis.__wix_context__.initWixModules
            ? globalThis.__wix_context__.initWixModules
            : undefined;
    if (oldContext) {
        return {
            // @ts-expect-error
            initWixModules(modules, elevated) {
                return runWithoutContext(() => oldContext(modules, elevated));
            },
            fetchWithAuth() {
                throw new Error('fetchWithAuth is not available in this context');
            },
            graphql() {
                throw new Error('graphql is not available in this context');
            },
        };
    }
    const contextualClient = typeof $wixContext !== 'undefined'
        ? $wixContext.client
        : typeof wixContext.client !== 'undefined'
            ? wixContext.client
            : typeof globalThis.__wix_context__ !== 'undefined'
                ? globalThis.__wix_context__.client
                : undefined;
    const elevatedClient = typeof $wixContext !== 'undefined'
        ? $wixContext.elevatedClient
        : typeof wixContext.elevatedClient !== 'undefined'
            ? wixContext.elevatedClient
            : typeof globalThis.__wix_context__ !== 'undefined'
                ? globalThis.__wix_context__.elevatedClient
                : undefined;
    if (!contextualClient && !elevatedClient) {
        return;
    }
    return {
        initWixModules(wixModules, elevated) {
            if (elevated) {
                if (!elevatedClient) {
                    throw new Error('An elevated client is required to use elevated modules. Make sure to initialize the Wix context with an elevated client before using elevated SDK modules');
                }
                return runWithoutContext(() => elevatedClient.use(wixModules));
            }
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return runWithoutContext(() => contextualClient.use(wixModules));
        },
        fetchWithAuth: (urlOrRequest, requestInit) => {
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return contextualClient.fetchWithAuth(urlOrRequest, requestInit);
        },
        async graphql(query, variables, opts) {
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return contextualClient.graphql(query, variables, opts);
        },
    };
}
function contextualizeHostModule(hostModule, prop) {
    return (...args) => {
        const context = resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(hostModule)[prop].apply(undefined, args);
    };
}
function contextualizeRESTModule(restModule, expectedArgsLength) {
    return ((...args) => {
        const context = resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context
            .initWixModules(restModule, args[expectedArgsLength]?.suppressAuth ? true : false)
            .apply(undefined, args);
    });
}
function contextualizeEventDefinitionModule(eventDefinition) {
    return ((...args) => {
        const context = resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(eventDefinition).apply(undefined, args);
    });
}
function contextualizeSerivcePluginModule(servicePlugin) {
    return ((...args) => {
        const context = resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(servicePlugin).apply(undefined, args);
    });
}

function runWithoutContext(fn) {
    const globalContext = globalThis.__wix_context__;
    const moduleContext = {
        client: browser/* wixContext */.X.client,
        elevatedClient: browser/* wixContext */.X.elevatedClient,
    };
    let closureContext;
    globalThis.__wix_context__ = undefined;
    browser/* wixContext */.X.client = undefined;
    browser/* wixContext */.X.elevatedClient = undefined;
    if (typeof $wixContext !== 'undefined') {
        closureContext = {
            client: $wixContext?.client,
            elevatedClient: $wixContext?.elevatedClient,
        };
        delete $wixContext.client;
        delete $wixContext.elevatedClient;
    }
    try {
        return fn();
    }
    finally {
        globalThis.__wix_context__ = globalContext;
        browser/* wixContext */.X.client = moduleContext.client;
        browser/* wixContext */.X.elevatedClient = moduleContext.elevatedClient;
        if (typeof $wixContext !== 'undefined') {
            $wixContext.client = closureContext.client;
            $wixContext.elevatedClient = closureContext.elevatedClient;
        }
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/rest-modules.js



function buildRESTDescriptor(origFunc, publicMetadata, boundFetch, wixAPIFetch, getActiveToken, options, hostName, useCDN) {
    return runWithoutContext(() => origFunc({
        request: async (factory) => {
            const requestOptions = factory({
                host: options?.HTTPHost || DEFAULT_API_URL,
            });
            let request = requestOptions;
            if (request.method === 'GET' &&
                request.fallback?.length &&
                request.params.toString().length > 4000) {
                request = requestOptions.fallback[0];
            }
            const domain = options?.HTTPHost ?? DEFAULT_API_URL;
            let url = `https://${useCDN ? DEFAULT_EDGE_API_URL : domain}${request.url}`;
            if (request.params && request.params.toString()) {
                url += `?${request.params.toString()}`;
            }
            try {
                const biHeader = biHeaderGenerator(requestOptions, publicMetadata, hostName);
                const res = await boundFetch(url, {
                    method: request.method,
                    ...(request.data && {
                        body: JSON.stringify(request.data),
                    }),
                    headers: {
                        ...biHeader,
                    },
                });
                if (res.status !== 200) {
                    let dataError = null;
                    try {
                        dataError = await res.json();
                    }
                    catch (e) {
                        //
                    }
                    throw rest_modules_errorBuilder(res.status, dataError?.message, dataError?.details, {
                        requestId: res.headers.get('X-Wix-Request-Id'),
                        details: dataError,
                    });
                }
                const data = await res.json();
                return {
                    data,
                    headers: res.headers,
                    status: res.status,
                    statusText: res.statusText,
                };
            }
            catch (e) {
                if (e.message?.includes('fetch is not defined')) {
                    console.error('Node.js v18+ is required');
                }
                throw e;
            }
        },
        fetchWithAuth: boundFetch,
        wixAPIFetch,
        getActiveToken,
    }));
}
const rest_modules_errorBuilder = (code, description, details, data) => {
    return {
        response: {
            data: {
                details: {
                    ...(!details?.validationError && {
                        applicationError: {
                            description,
                            code,
                            data,
                        },
                    }),
                    ...details,
                },
                message: description,
            },
            status: code,
        },
        requestId: data?.requestId,
    };
};

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/nanoevents.js
// Inlined from https://github.com/ai/nanoevents/blob/main/index.js
/**
 * Create event emitter.
 *
 * ```js
 * import { createNanoEvents } from 'nanoevents'
 *
 * class Ticker {
 * constructor() {
 * this.emitter = createNanoEvents()
 * }
 * on(...args) {
 * return this.emitter.on(...args)
 * }
 * tick() {
 * this.emitter.emit('tick')
 * }
 * }
 * ```
 * @returns Event emitter.
 */
function createNanoEvents() {
    return {
        emit(event, ...args) {
            for (let i = 0, callbacks = this.events[event] || [], length = callbacks.length; i < length; i++) {
                callbacks[i](...args);
            }
        },
        events: {},
        on(event, cb) {
            (this.events[event] ||= []).push(cb);
            return () => {
                this.events[event] = this.events[event]?.filter((i) => cb !== i);
            };
        },
    };
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/event-handlers-modules.js


const isEventHandlerModule = (val) => val.__type === 'event-definition';
function buildEventDefinition(eventDefinition, registerHandler) {
    return (handler) => {
        registerHandler(eventDefinition, handler);
    };
}
function runHandler(eventDefinition, handler, payload, baseEventMetadata) {
    let envelope;
    if (eventDefinition.isDomainEvent) {
        const domainEventPayload = payload;
        const { deletedEvent, actionEvent, createdEvent, updatedEvent, ...domainEventMetadata } = domainEventPayload;
        const metadata = {
            ...baseEventMetadata,
            ...domainEventMetadata,
        };
        if (deletedEvent) {
            if (deletedEvent?.deletedEntity) {
                envelope = {
                    entity: deletedEvent?.deletedEntity,
                    metadata,
                };
            }
            else {
                envelope = { metadata };
            }
        }
        else if (actionEvent) {
            envelope = {
                data: actionEvent.body,
                metadata,
            };
        }
        else {
            envelope = {
                entity: createdEvent?.entity ?? updatedEvent?.currentEntity,
                metadata,
            };
        }
    }
    else {
        envelope = {
            data: payload,
            metadata: baseEventMetadata,
        };
    }
    const transformFromRESTFn = eventDefinition.transformations ?? ((x) => x);
    return handler(transformFromRESTFn(envelope));
}
function eventHandlersModules(authStrategy) {
    const eventHandlers = new Map();
    const webhooksEmitter = createNanoEvents();
    const client = {
        ...webhooksEmitter,
        getRegisteredEvents: () => eventHandlers,
        async process(jwt, opts = {
            expectedEvents: [],
        }) {
            const { eventType, identity, instanceId, payload } = await this.parseJWT(jwt);
            const allExpectedEvents = [
                ...opts.expectedEvents,
                ...Array.from(eventHandlers.keys()).map((type) => ({ type })),
            ];
            if (allExpectedEvents.length > 0 &&
                !allExpectedEvents.some(({ type }) => type === eventType)) {
                throw new Error(`Unexpected event type: ${eventType}. Expected one of: ${allExpectedEvents
                    .map((x) => x.type)
                    .join(', ')}`);
            }
            const handlers = eventHandlers.get(eventType) ?? [];
            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, payload, {
                instanceId,
                identity,
            })));
            return {
                instanceId,
                eventType,
                payload,
                identity,
            };
        },
        async processRequest(request, opts) {
            const body = await request.text();
            return this.process(body, opts);
        },
        async parseJWT(jwt) {
            if (!authStrategy.decodeJWT) {
                throw new Error('decodeJWT is not supported by the authentication strategy');
            }
            const { decoded, valid } = await authStrategy.decodeJWT(jwt);
            if (!valid) {
                throw new Error('JWT is not valid');
            }
            if (typeof decoded.data !== 'string') {
                throw new Error(`Unexpected type of JWT data: expected string, got ${typeof decoded.data}`);
            }
            const parsedDecoded = JSON.parse(decoded.data);
            const eventType = parsedDecoded.eventType;
            const instanceId = parsedDecoded.instanceId;
            const identity = parsedDecoded.identity
                ? JSON.parse(parsedDecoded.identity)
                : undefined;
            const payload = JSON.parse(parsedDecoded.data);
            return {
                instanceId,
                eventType,
                payload,
                identity,
            };
        },
        async parseRequest(request) {
            const jwt = await request.text();
            return this.parseJWT(jwt);
        },
        async executeHandlers(event) {
            const allExpectedEvents = Array.from(eventHandlers.keys()).map((type) => ({ type }));
            if (allExpectedEvents.length > 0 &&
                !allExpectedEvents.some(({ type }) => type === event.eventType)) {
                throw new Error(`Unexpected event type: ${event.eventType}. Expected one of: ${allExpectedEvents
                    .map((x) => x.type)
                    .join(', ')}`);
            }
            const handlers = eventHandlers.get(event.eventType) ?? [];
            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, event.payload, {
                instanceId: event.instanceId,
                identity: event.identity,
            })));
        },
        apps: {
            AppInstalled: EventDefinition('AppInstalled')(),
            AppRemoved: EventDefinition('AppRemoved')(),
        },
    };
    return {
        initModule(eventDefinition) {
            return (handler) => {
                const handlers = eventHandlers.get(eventDefinition.type) ?? [];
                handlers.push({ eventDefinition, handler });
                eventHandlers.set(eventDefinition.type, handlers);
                webhooksEmitter.emit('registered', eventDefinition);
            };
        },
        client,
    };
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/service-plugin-modules.js

const isServicePluginModule = (val) => val.__type === 'service-plugin-definition';
function servicePluginsModules(authStrategy) {
    const servicePluginsImplementations = new Map();
    const servicePluginsEmitter = createNanoEvents();
    const client = {
        ...servicePluginsEmitter,
        getRegisteredServicePlugins: () => servicePluginsImplementations,
        async parseJWT(jwt) {
            if (!authStrategy.decodeJWT) {
                throw new Error('decodeJWT is not supported by the authentication strategy');
            }
            const { decoded, valid } = await authStrategy.decodeJWT(jwt, true);
            if (!valid) {
                throw new Error('JWT is not valid');
            }
            if (typeof decoded.data !== 'object' ||
                decoded.data === null ||
                !('metadata' in decoded.data) ||
                typeof decoded.data.metadata !== 'object' ||
                decoded.data.metadata === null ||
                !('appExtensionType' in decoded.data.metadata) ||
                typeof decoded.data.metadata.appExtensionType !== 'string') {
                throw new Error('Unexpected JWT data: expected object with metadata.appExtensionType string');
            }
            return decoded.data;
        },
        async process(request) {
            const servicePluginRequest = await this.parseJWT(request.body);
            return this.executeHandler(servicePluginRequest, request.url);
        },
        async parseRequest(request) {
            const body = await request.text();
            return this.parseJWT(body);
        },
        async processRequest(request) {
            const url = request.url;
            const body = await request.text();
            try {
                const implMethodResult = await this.process({ url, body });
                return Response.json(implMethodResult);
            }
            catch (err) {
                if (err.errorType === 'SPI' && err.applicationCode && err.httpCode) {
                    return Response.json({ applicationError: { code: err.applicationCode, data: err.data } }, { status: err.httpCode });
                }
                throw err;
            }
        },
        async executeHandler(servicePluginRequest, url) {
            const componentType = servicePluginRequest.metadata.appExtensionType.toLowerCase();
            const implementations = servicePluginsImplementations.get(componentType) ?? [];
            if (implementations.length === 0) {
                throw new Error(`No service plugin implementations found for component type ${componentType}`);
            }
            else if (implementations.length > 1) {
                throw new Error(`Multiple service plugin implementations found for component type ${componentType}. This is currently not supported`);
            }
            const { implementation: impl, servicePluginDefinition } = implementations[0];
            const method = servicePluginDefinition.methods.find((m) => url.endsWith(m.primaryHttpMappingPath));
            if (!method) {
                throw new Error('Unexpect request: request url did not match any method: ' + url);
            }
            const implMethod = impl[method.name];
            if (!implMethod) {
                throw new Error(`Got request for service plugin method ${method.name} but no implementation was provided. Available methods: ${Object.keys(impl).join(', ')}`);
            }
            return method.transformations.toREST(await implMethod(method.transformations.fromREST(servicePluginRequest)));
        },
    };
    return {
        initModule(servicePluginDefinition) {
            return (implementation) => {
                const implementations = servicePluginsImplementations.get(servicePluginDefinition.componentType.toLowerCase()) ?? [];
                implementations.push({ servicePluginDefinition, implementation });
                servicePluginsImplementations.set(servicePluginDefinition.componentType.toLowerCase(), implementations);
                servicePluginsEmitter.emit('registered', servicePluginDefinition);
            };
        },
        client,
    };
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk/build/wixClient.js











const X_WIX_CONSISTENT_HEADER = 'X-Wix-Consistent';
function createClient(config) {
    const _headers = config.headers || { Authorization: '' };
    const authStrategy = config.auth ||
        {
            getAuthHeaders: (_) => Promise.resolve({ headers: {} }),
        };
    const boundGetAuthHeaders = authStrategy.getAuthHeaders.bind(undefined, config.host);
    authStrategy.getAuthHeaders = boundGetAuthHeaders;
    const fetchWithAuth = async (urlOrRequest, requestInit) => {
        const authHeaders = await boundGetAuthHeaders();
        const headers = {
            ...(requestInit?.headers ?? {}),
            ...authHeaders.headers,
            ...(_headers[X_WIX_CONSISTENT_HEADER]
                ? { [X_WIX_CONSISTENT_HEADER]: _headers[X_WIX_CONSISTENT_HEADER] }
                : {}),
        };
        if (typeof urlOrRequest === 'string' || urlOrRequest instanceof URL) {
            const response = await fetch(urlOrRequest, {
                ...requestInit,
                headers,
            });
            const consistentHeader = findConsistentHeader(response);
            if (consistentHeader) {
                _headers[X_WIX_CONSISTENT_HEADER] = consistentHeader;
            }
            return response;
        }
        else {
            for (const [k, v] of Object.entries(headers)) {
                if (typeof v === 'string') {
                    urlOrRequest.headers.set(k, v);
                }
            }
            const response = await fetch(urlOrRequest, requestInit);
            const consistentHeader = findConsistentHeader(response);
            if (consistentHeader) {
                _headers[X_WIX_CONSISTENT_HEADER] = consistentHeader;
            }
            return response;
        }
    };
    const { client: servicePluginsClient, initModule: initServicePluginModule } = servicePluginsModules(authStrategy);
    const { client: eventHandlersClient, initModule: initEventHandlerModule } = eventHandlersModules(authStrategy);
    const boundFetch = async (url, options) => {
        const authHeaders = await boundGetAuthHeaders();
        const defaultContentTypeHeader = getDefaultContentHeader(options);
        const response = await fetch(url, {
            ...options,
            headers: {
                ...defaultContentTypeHeader,
                ..._headers,
                ...authHeaders?.headers,
                ...options?.headers,
                ...config.host?.essentials?.passThroughHeaders,
            },
        });
        const consistentHeader = findConsistentHeader(response);
        if (consistentHeader) {
            _headers[X_WIX_CONSISTENT_HEADER] = consistentHeader;
        }
        return response;
    };
    // This is typed as `any` because when trying to properly type it as defined
    // on the WixClient, typescript starts failing with `Type instantiation is
    // excessively deep and possibly infinite.`
    const use = (modules, metadata) => {
        if (isEventHandlerModule(modules)) {
            return initEventHandlerModule(modules);
        }
        else if (isServicePluginModule(modules)) {
            return initServicePluginModule(modules);
        }
        else if (isHostModule(modules) && config.host) {
            return buildHostModule(modules, config.host);
        }
        else if (typeof modules === 'function') {
            // The generated namespaces all have the error classes on them and
            // a class is also a function, so we need to explicitly ignore these
            // error classes using a static field that exists on them.
            if ('__type' in modules && modules.__type === SERVICE_PLUGIN_ERROR_TYPE) {
                return modules;
            }
            const apiBaseUrl = config.host?.apiBaseUrl ?? DEFAULT_API_URL;
            const shouldUseCDN = config.useCDN === undefined ? config.auth?.shouldUseCDN : config.useCDN;
            return buildRESTDescriptor(runWithoutContext(() => isAmbassadorModule(modules))
                ? toHTTPModule(modules)
                : modules, metadata ?? {}, boundFetch, (relativeUrl, fetchOptions) => {
                const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);
                finalUrl.host = apiBaseUrl;
                finalUrl.protocol = 'https';
                return boundFetch(finalUrl.toString(), fetchOptions);
            }, authStrategy.getActiveToken, { HTTPHost: apiBaseUrl }, config.host?.name, shouldUseCDN);
        }
        else if (isObject(modules)) {
            return Object.fromEntries(Object.entries(modules).map(([key, value]) => {
                return [key, use(value, modules[PUBLIC_METADATA_KEY])];
            }));
        }
        else {
            return modules;
        }
    };
    const setHeaders = (headers) => {
        for (const k in headers) {
            _headers[k] = headers[k];
        }
    };
    const wrappedModules = config.modules
        ? use(config.modules)
        : {};
    return {
        ...wrappedModules,
        auth: authStrategy,
        setHeaders,
        use,
        enableContext(contextType, opts = { elevated: false }) {
            if (contextType === 'global') {
                if (globalThis.__wix_context__ != null) {
                    if (opts.elevated) {
                        globalThis.__wix_context__.elevatedClient = this;
                    }
                    else {
                        globalThis.__wix_context__.client = this;
                    }
                }
                else {
                    if (opts.elevated) {
                        globalThis.__wix_context__ = { elevatedClient: this };
                    }
                    else {
                        globalThis.__wix_context__ = { client: this };
                    }
                }
            }
            else {
                if (opts.elevated) {
                    browser/* wixContext */.X.elevatedClient = this;
                }
                else {
                    browser/* wixContext */.X.client = this;
                }
            }
        },
        /**
         * @param relativeUrl The URL to fetch relative to the API base URL
         * @param options The fetch options
         * @returns The fetch Response object
         * @deprecated Use `fetchWithAuth` instead
         */
        fetch: (relativeUrl, options) => {
            const apiBaseUrl = config.host?.apiBaseUrl ?? DEFAULT_API_URL;
            const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);
            finalUrl.host = apiBaseUrl;
            finalUrl.protocol = 'https';
            return boundFetch(finalUrl.toString(), options);
        },
        fetchWithAuth,
        async graphql(query, variables, opts = {
            apiVersion: 'alpha',
        }) {
            const apiBaseUrl = config?.host?.apiBaseUrl ?? DEFAULT_API_URL;
            const res = await boundFetch(`https://${apiBaseUrl}/graphql/${opts.apiVersion}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query, variables }),
            });
            if (res.status !== 200) {
                throw new FetchErrorResponse(`GraphQL request failed with status ${res.status}`, res);
            }
            const { data, errors } = await res.json();
            return { data: data ?? {}, errors };
        },
        webhooks: eventHandlersClient,
        servicePlugins: servicePluginsClient,
    };
}
function findConsistentHeader(response) {
    return (response.headers?.get(X_WIX_CONSISTENT_HEADER) ??
        response.headers?.get(X_WIX_CONSISTENT_HEADER.toLowerCase()));
}

// EXTERNAL MODULE: ./index.ts
var index = __webpack_require__(408);
;// CONCATENATED MODULE: ./internal.tsx
// eslint-disable-next-line import/no-extraneous-dependencies
// eslint-disable-next-line import/no-extraneous-dependencies
const useBeforeRenderEffect=(effect,effectCondition)=>{const[lastEffectResult,setState]=(0,react.useState)(()=>effect());if(effectCondition(lastEffectResult)){setState(effect());}return lastEffectResult;};const withContextualWixClient=Component=>{return ownPropsWithHost=>{const{host,compProps}=useHostAndProps(ownPropsWithHost);useBeforeRenderEffect(()=>{createClient({auth:index.dashboard.auth(),host}).enableContext('module');return host;},lastHost=>lastHost!==host);return compProps?/*#__PURE__*/react.createElement(Component,extends_default()({host:host},compProps)):null;};};const useHostAndProps=ownPropsWithHost=>{const{host:maybeLocalHost,...ownProps}=ownPropsWithHost;const{host,hostType}=useBeforeRenderEffect(()=>maybeLocalHost?{host:maybeLocalHost,hostType:'local'}:{host:index.dashboard.host(),hostType:'remote'},lastResult=>!!maybeLocalHost&&maybeLocalHost!==lastResult.host);const[hostProps,setHostProps]=(0,react.useState)(undefined);(0,react.useEffect)(()=>{if(hostType==='local'){return;}const observeResult=host.channel.observeState(newPropsFromHost=>{setHostProps(newPropsFromHost||{});});const cleanup=async()=>{(await observeResult).disconnect();host.close();};return()=>{cleanup();};},[host,hostType]);return hostType==='local'?{host,compProps:ownProps}:{host,compProps:hostProps?{...hostProps,...ownProps}:undefined};};
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=internal.umd.js.map