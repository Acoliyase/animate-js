(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("WixDashboardSDK", [], factory);
	else if(typeof exports === 'object')
		exports["WixDashboardSDK"] = factory();
	else
		root["WixDashboardSDK"] = factory();
})((typeof self !== 'undefined' ? self : this), () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 801:
/*!********************************************!*\
  !*** ./dashboardHostModule.ts + 5 modules ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ createDashboardModule)
});

// EXTERNAL MODULE: ../../../node_modules/@wix/sdk-context/build/browser/index.mjs
var browser = __webpack_require__(748);
;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk-runtime/build/context.js

function context_resolveContext() {
    const oldContext = typeof $wixContext !== 'undefined' && $wixContext.initWixModules
        ? $wixContext.initWixModules
        : typeof globalThis.__wix_context__ !== 'undefined' &&
            globalThis.__wix_context__.initWixModules
            ? globalThis.__wix_context__.initWixModules
            : undefined;
    if (oldContext) {
        return {
            // @ts-expect-error
            initWixModules(modules, elevated) {
                return runWithoutContext(() => oldContext(modules, elevated));
            },
            fetchWithAuth() {
                throw new Error('fetchWithAuth is not available in this context');
            },
            graphql() {
                throw new Error('graphql is not available in this context');
            },
        };
    }
    const contextualClient = typeof $wixContext !== 'undefined'
        ? $wixContext.client
        : typeof browser/* wixContext */.X.client !== 'undefined'
            ? browser/* wixContext */.X.client
            : typeof globalThis.__wix_context__ !== 'undefined'
                ? globalThis.__wix_context__.client
                : undefined;
    const elevatedClient = typeof $wixContext !== 'undefined'
        ? $wixContext.elevatedClient
        : typeof browser/* wixContext */.X.elevatedClient !== 'undefined'
            ? browser/* wixContext */.X.elevatedClient
            : typeof globalThis.__wix_context__ !== 'undefined'
                ? globalThis.__wix_context__.elevatedClient
                : undefined;
    if (!contextualClient && !elevatedClient) {
        return;
    }
    return {
        initWixModules(wixModules, elevated) {
            if (elevated) {
                if (!elevatedClient) {
                    throw new Error('An elevated client is required to use elevated modules. Make sure to initialize the Wix context with an elevated client before using elevated SDK modules');
                }
                return runWithoutContext(() => elevatedClient.use(wixModules));
            }
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return runWithoutContext(() => contextualClient.use(wixModules));
        },
        fetchWithAuth: (urlOrRequest, requestInit) => {
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return contextualClient.fetchWithAuth(urlOrRequest, requestInit);
        },
        async graphql(query, variables, opts) {
            if (!contextualClient) {
                throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
            }
            return contextualClient.graphql(query, variables, opts);
        },
    };
}
function contextualizeHostModule(hostModule, prop) {
    return (...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(hostModule)[prop].apply(undefined, args);
    };
}
function contextualizeRESTModule(restModule, expectedArgsLength) {
    return ((...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context
            .initWixModules(restModule, args[expectedArgsLength]?.suppressAuth ? true : false)
            .apply(undefined, args);
    });
}
function contextualizeEventDefinitionModule(eventDefinition) {
    return ((...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(eventDefinition).apply(undefined, args);
    });
}
function contextualizeSerivcePluginModule(servicePlugin) {
    return ((...args) => {
        const context = context_resolveContext();
        if (!context) {
            throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
        }
        return context.initWixModules(servicePlugin).apply(undefined, args);
    });
}

function runWithoutContext(fn) {
    const globalContext = globalThis.__wix_context__;
    const moduleContext = {
        client: browser/* wixContext */.X.client,
        elevatedClient: browser/* wixContext */.X.elevatedClient,
    };
    let closureContext;
    globalThis.__wix_context__ = undefined;
    browser/* wixContext */.X.client = undefined;
    browser/* wixContext */.X.elevatedClient = undefined;
    if (typeof $wixContext !== 'undefined') {
        closureContext = {
            client: $wixContext?.client,
            elevatedClient: $wixContext?.elevatedClient,
        };
        delete $wixContext.client;
        delete $wixContext.elevatedClient;
    }
    try {
        return fn();
    }
    finally {
        globalThis.__wix_context__ = globalContext;
        browser/* wixContext */.X.client = moduleContext.client;
        browser/* wixContext */.X.elevatedClient = moduleContext.elevatedClient;
        if (typeof $wixContext !== 'undefined') {
            $wixContext.client = closureContext.client;
            $wixContext.elevatedClient = closureContext.elevatedClient;
        }
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk-runtime/build/context-v2.js



function contextualizeHostModuleV2(hostModule, props) {
    return {
        ...hostModule,
        ...Object.fromEntries(props.map((prop) => [
            prop,
            (...args) => {
                const context = context_resolveContext();
                if (!context) {
                    throw new Error('Wix context is not available. Make sure to initialize the Wix context before using SDK modules');
                }
                return context
                    .initWixModules(hostModule)[prop].apply(undefined, args);
            },
        ])),
    };
}
function contextualizeRESTModuleV2(restModule, elevated) {
    return ((...args) => {
        const context = resolveContext();
        if (!context) {
            // @ts-expect-error - if there is no context, we want to behave like the original module
            return restModule.apply(undefined, args);
        }
        return (context
            .initWixModules(restModule, elevated)
            // @ts-expect-error - we know the args here are meant to be passed to the initalized module
            .apply(undefined, args));
    });
}
function contextualizeEventDefinitionModuleV2(eventDefinition) {
    const contextualMethod = ((...args) => {
        const context = resolveContext();
        if (!context) {
            // this line should throw, but this would be a breaking change for older SDK versions
            // this is because in wixClient there's code that calls any function it detects and checks
            // if it's an ambassador module (see isAmbassadorModule)
            return () => { };
        }
        return context.initWixModules(eventDefinition).apply(undefined, args);
    });
    contextualMethod.__type = eventDefinition.__type;
    contextualMethod.type = eventDefinition.type;
    contextualMethod.isDomainEvent = eventDefinition.isDomainEvent;
    contextualMethod.transformations = eventDefinition.transformations;
    return contextualMethod;
}
function contextualizeSerivcePluginModuleV2(servicePlugin) {
    const contextualMethod = ((...args) => {
        const context = resolveContext();
        if (!context) {
            // this line should throw, but this would be a breaking change for older SDK versions
            // this is because in wixClient there's code that calls any function it detects and checks
            // if it's an ambassador module (see isAmbassadorModule)
            return () => { };
        }
        return context.initWixModules(servicePlugin).apply(undefined, args);
    });
    contextualMethod.__type = servicePlugin.__type;
    contextualMethod.componentType = servicePlugin.componentType;
    contextualMethod.methods = servicePlugin.methods;
    return contextualMethod;
}

;// CONCATENATED MODULE: ../../../node_modules/@wix/sdk-runtime/build/host-modules.js

function createHostModule(hostModuleAPI) {
    return contextualizeHostModuleV2({
        __type: 'host',
        create: (host) => Object.entries(hostModuleAPI).reduce((acc, [key, fn]) => ({
            ...acc,
            [key]: fn(host),
        }), {}),
    }, Object.keys(hostModuleAPI));
}

// EXTERNAL MODULE: ../../../node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(213);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);
;// CONCATENATED MODULE: ./types/addSitePlugin.ts
class AddSitePluginModalError extends Error{constructor(_ref){let{message,code}=_ref;super(message);defineProperty_default()(this,"code",void 0);this.message=message;this.code=code;}}
;// CONCATENATED MODULE: ./sdk.ts
const createSDKBuilders=()=>{const showToast=_ref=>{let{channel}=_ref;return function(){const handle=channel.showToast(...arguments);const remove=()=>Promise.resolve(handle).then(h=>h.remove());return{remove};};};const observeState=_ref2=>{let{channel}=_ref2;return function(){const handle=channel.observeState(...arguments);// this temporary casting is needed because it seems that typescript can't handle this by itself.
const disconnect=()=>Promise.resolve(handle).then(h=>h.disconnect());return{disconnect};};};const navigate=_ref3=>{let{channel}=_ref3;return function(){return channel.navigate(...arguments);};};const navigateBack=_ref4=>{let{channel}=_ref4;return()=>{return channel.navigateBack();};};const openModal=_ref5=>{let{channel}=_ref5;return(modalInfo,modalParams)=>{const[modalId,params]=typeof modalInfo==='string'?[modalInfo,modalParams]:[modalInfo.modalId,modalInfo.params];const handle=channel.openModal(modalId,params);return{modalClosed:Promise.resolve(handle).then(h=>h.modalClosed)};};};const closeModal=_ref6=>{let{channel}=_ref6;return closeData=>{if(closeData===undefined){return channel.closeModal();}const filteredArg=JSON.parse(JSON.stringify(closeData));return channel.closeModal(filteredArg);};};const getAccessToken=_ref7=>{let{channel}=_ref7;return()=>{return channel.getAccessToken();};};const getPageUrl=_ref8=>{let{channel}=_ref8;return function(){return channel.getPageUrl(...arguments);};};const openMediaManager=_ref9=>{let{channel}=_ref9;return function(){return channel.openMediaManager(...arguments);};};const addSitePlugin=_ref10=>{let{channel}=_ref10;return(pluginId,options)=>{const PLUGINS_DASHBOARD_MODAL_ID='802c76e4-b381-4bb3-9152-96acabbf3194';const additionalParams=(options==null?void 0:options.placement)||{};const handle=channel.openModal(PLUGINS_DASHBOARD_MODAL_ID,{...additionalParams,pluginId,action:'populate'});return Promise.resolve(handle).then(h=>h.modalClosed).then(resp=>{if((resp==null?void 0:resp.type)===undefined){throw new AddSitePluginModalError({message:'Aborted by user',code:3006});}if((resp==null?void 0:resp.type)==='ERROR'){throw new AddSitePluginModalError(resp.data.error);}});};};const onBeforeUnload=_ref11=>{let{channel}=_ref11;return function(){return channel.onBeforeUnload(...arguments);};};const setPageTitle=_ref12=>{let{channel}=_ref12;return pageTitle=>{return channel.setPageTitle(pageTitle);};};const getLanguage=host=>{let language=null;return async()=>{var _observeStateResult;if(language){return language;}let observeStateResult=null;language=await new Promise(resolve=>{observeStateResult=observeState(host)((_,envState)=>{resolve(envState.language);});});(_observeStateResult=observeStateResult)==null||_observeStateResult.disconnect();return language;};};const requestFeedback=_ref13=>{let{channel}=_ref13;return function(){return channel.requestFeedback(...arguments);};};const onLayerStateChange=_ref14=>{let{channel}=_ref14;return function(){const resultOrPromise=channel.onLayerStateChange(...arguments);const remove=()=>Promise.resolve(resultOrPromise).then(h=>h.remove());return{remove};};};const installApp=_ref15=>{let{channel}=_ref15;return channel.installApp;};const getWidget=_ref16=>{let{channel}=_ref16;return function(){if('getWidget'in channel){return channel.getWidget(...arguments);}else{throw new Error('Unsupported');}};};const getDashboardPlugins=_ref17=>{let{channel}=_ref17;return function(){if('getDashboardPlugins'in channel){return channel.getDashboardPlugins(...arguments);}else{throw new Error('Unsupported');}};};const getDashboardMenuPlugins=_ref18=>{let{channel}=_ref18;return function(){if('getDashboardMenuPlugins'in channel){return channel.getDashboardMenuPlugins(...arguments);}else{throw new Error('Unsupported');}};};const getSiteInfo=_ref19=>{let{channel}=_ref19;return channel.getSiteInfo;};return{showToast,observeState,navigate,navigateBack,openModal,closeModal,getAccessToken,getPageUrl,openMediaManager,addSitePlugin,onBeforeUnload,setPageTitle,getLanguage,requestFeedback,onLayerStateChange,installApp,getSiteInfo,getWidget,getDashboardPlugins,getDashboardMenuPlugins};};
;// CONCATENATED MODULE: ./dashboardHostModule.ts
const createDashboardModule=_ref=>{let{createHost}=_ref;const dashboardSDKBuilders=createSDKBuilders();return{...createHostModule(dashboardSDKBuilders),host:createHost,auth:()=>{return{getAuthHeaders:async host=>{const getAccessToken=dashboardSDKBuilders.getAccessToken(host);return{headers:{Authorization:await getAccessToken()}};}};}};};

/***/ }),

/***/ 202:
/*!**************************************!*\
  !*** ./hostPlatform.ts + 12 modules ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  L: () => (/* binding */ createHost)
});

;// CONCATENATED MODULE: ../../../node_modules/comlink/dist/esm/comlink.mjs
/**
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
/**
 * Internal transfer handle to handle objects marked to proxy.
 */
const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
        const { port1, port2 } = new MessageChannel();
        comlink_expose(obj, port1);
        return [port2, [port2]];
    },
    deserialize(port) {
        port.start();
        return wrap(port);
    },
};
/**
 * Internal transfer handler to handle thrown exceptions.
 */
const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack,
                },
            };
        }
        else {
            serialized = { isError: false, value };
        }
        return [serialized, []];
    },
    deserialize(serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    },
};
/**
 * Allows customizing the serialization of certain values.
 */
const transferHandlers = new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler],
]);
function comlink_expose(obj, ep = self) {
    ep.addEventListener("message", function callback(ev) {
        if (!ev || !ev.data) {
            return;
        }
        const { id, type, path } = Object.assign({ path: [] }, ev.data);
        const argumentList = (ev.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
            const rawValue = path.reduce((obj, prop) => obj[prop], obj);
            switch (type) {
                case 0 /* GET */:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case 1 /* SET */:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;
                case 2 /* APPLY */:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case 3 /* CONSTRUCT */:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case 4 /* ENDPOINT */:
                    {
                        const { port1, port2 } = new MessageChannel();
                        comlink_expose(obj, port2);
                        returnValue = transfer(port1, [port1]);
                    }
                    break;
                case 5 /* RELEASE */:
                    {
                        returnValue = undefined;
                    }
                    break;
            }
        }
        catch (value) {
            returnValue = { value, [throwMarker]: 0 };
        }
        Promise.resolve(returnValue)
            .catch((value) => {
            return { value, [throwMarker]: 0 };
        })
            .then((returnValue) => {
            const [wireValue, transferables] = toWireValue(returnValue);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === 5 /* RELEASE */) {
                // detach and deactive after sending release response above.
                ep.removeEventListener("message", callback);
                closeEndPoint(ep);
            }
        });
    });
    if (ep.start) {
        ep.start();
    }
}
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
        endpoint.close();
}
function wrap(ep, target) {
    return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function createProxy(ep, path = [], target = function () { }) {
    let isProxyReleased = false;
    const proxy = new Proxy(target, {
        get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return () => {
                    return requestResponseMessage(ep, {
                        type: 5 /* RELEASE */,
                        path: path.map((p) => p.toString()),
                    }).then(() => {
                        closeEndPoint(ep);
                        isProxyReleased = true;
                    });
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return { then: () => proxy };
                }
                const r = requestResponseMessage(ep, {
                    type: 0 /* GET */,
                    path: path.map((p) => p.toString()),
                }).then(fromWireValue);
                return r.then.bind(r);
            }
            return createProxy(ep, [...path, prop]);
        },
        set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
            // boolean. To show good will, we return true asynchronously ¯\_(ツ)_/¯
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, {
                type: 1 /* SET */,
                path: [...path, prop].map((p) => p.toString()),
                value,
            }, transferables).then(fromWireValue);
        },
        apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep, {
                    type: 4 /* ENDPOINT */,
                }).then(fromWireValue);
            }
            // We just pretend that `bind()` didn’t happen.
            if (last === "bind") {
                return createProxy(ep, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: 2 /* APPLY */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
        construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: 3 /* CONSTRUCT */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
    });
    return proxy;
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
}
function windowEndpoint(w, context = self, targetOrigin = "*") {
    return {
        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
        addEventListener: context.addEventListener.bind(context),
        removeEventListener: context.removeEventListener.bind(context),
    };
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: 3 /* HANDLER */,
                    name,
                    value: serializedValue,
                },
                transferables,
            ];
        }
    }
    return [
        {
            type: 0 /* RAW */,
            value,
        },
        transferCache.get(value) || [],
    ];
}
function fromWireValue(value) {
    switch (value.type) {
        case 3 /* HANDLER */:
            return transferHandlers.get(value.name).deserialize(value.value);
        case 0 /* RAW */:
            return value.value;
    }
}
function requestResponseMessage(ep, msg, transfers) {
    return new Promise((resolve) => {
        const id = generateUUID();
        ep.addEventListener("message", function l(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
                return;
            }
            ep.removeEventListener("message", l);
            resolve(ev.data);
        });
        if (ep.start) {
            ep.start();
        }
        ep.postMessage(Object.assign({ id }, msg), transfers);
    });
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join("-");
}


//# sourceMappingURL=comlink.mjs.map

;// CONCATENATED MODULE: ../../../communication-channel/dist/esm/serialization.js

const proxyCallbackMarker = '__proxyCallbackId__wixSDK__';
const proxyPromiseMarker = '__proxyPromiseId__wixSDK__';
const serializeAllMethodsIn = sdk => {
  return wrapMethodsWithProxy(sdk, originalMethod => {
    return async function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const [proxies, argsNoProxies] = extractProxies(args);
      const originalResult = await originalMethod(proxy(proxies), argsNoProxies);
      return deserializeReturnValue(originalResult);
    };
  });
};
const serialization_deserializeAllMethodsIn = api => {
  return wrapMethodsWithProxy(api, originalMethod => {
    return (proxies, args) => {
      const argsWithProxies = insertProxies(proxies, args);
      const originalRun = originalMethod(...argsWithProxies);
      return serializeReturnValue(originalRun);
    };
  });
};
const serializeReturnValue = async value => {
  const [proxies, clonables] = extractProxies(await value);
  return proxy({
    proxies,
    clonables
  });
};
const deserializeReturnValue = async value => {
  return insertProxies(value == null ? void 0 : value.proxies, await (value == null ? void 0 : value.clonables));
};
const extractProxies = data => {
  const walker = (proxies, val) => {
    if (isPromise(val)) {
      const proxyId = uniqueId();
      proxies.promises[proxyId] = val;
      return {
        [proxyPromiseMarker]: proxyId
      };
    }
    if (isFunction(val)) {
      const proxyId = uniqueId();
      proxies.callbacks[proxyId] = (innerProxies, argsAsArray) => {
        const argsWithProxies = insertProxies(innerProxies, argsAsArray);
        const exec = val(...argsWithProxies);
        return serializeReturnValue(exec);
      };
      return {
        [proxyCallbackMarker]: proxyId
      };
    }
    if (Array.isArray(val)) {
      return val.map(i => walker(proxies, i));
    }
    if (serialization_isObject(val)) {
      return mapObjectValues(val, i => walker(proxies, i));
    }
    return val;
  };
  const proxies = {
    promises: {},
    callbacks: {}
  };
  const dataWithoutProxies = walker(proxies, data);
  return [proxies, dataWithoutProxies];
};
const insertProxies = (proxies, data) => {
  if (Array.isArray(data)) {
    return data.map(i => insertProxies(proxies, i));
  }
  if (serialization_isObject(data) && data.hasOwnProperty(proxyPromiseMarker)) {
    const promiseId = data[proxyPromiseMarker];
    return proxies.promises[promiseId];
  }
  if (serialization_isObject(data) && data.hasOwnProperty(proxyCallbackMarker)) {
    const callbackId = data[proxyCallbackMarker];
    // passing args in spread syntax to comlink proxy generates problem when transpiling to old JS version
    // so pass it as array and handle it on the deserialization level:
    return async function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      const [innerProxies, argsNoProxies] = extractProxies(args);
      const exec = await proxies.callbacks[callbackId](proxy(innerProxies), argsNoProxies);
      return deserializeReturnValue(exec);
    };
  }
  if (serialization_isObject(data)) {
    return mapObjectValues(data, i => insertProxies(proxies, i));
  }
  return data;
};
const wrapMethodsWithProxy = (obj, callback) => {
  return new Proxy(obj, {
    get(target, prop) {
      if (!target[prop]) {
        return () => {
          throw new Error(`Serialization error occurred while accessing ${prop} property of ${target}`);
        };
      }
      return callback(target[prop]);
    }
  });
};
const isPromise = val => val instanceof Promise;
const serialization_isObject = val => val && typeof val === 'object' && !isPromise(val);
const isFunction = val => typeof val === 'function';
const mapObjectValues = (obj, callback) => {
  const mapEntries = _ref => {
    let [key, value] = _ref;
    return [key, callback(value)];
  };
  return Object.fromEntries(Object.entries(obj).map(mapEntries));
};
const uniqueId = (() => {
  let counter = 0;
  return () => ++counter;
})();
//# sourceMappingURL=serialization.js.map
;// CONCATENATED MODULE: ../../../communication-channel/dist/esm/index.js


const handshakeCode = 'wix-sdk-bo-hello-handshake';
/**
 * Initializes a new channel with a target.
 * @param postMessage - Target's function to receive messages.
 * @param origin - Target's origin.
 */
const esm_open = _ref => {
  let {
    postMessage,
    origin
  } = _ref;
  const {
    port1: widgetPort,
    port2: hostPort
  } = new MessageChannel();
  const protocolVersion = '1.0.0';
  const message = {
    code: handshakeCode,
    version: protocolVersion,
    port: hostPort
  };
  postMessage(message, origin, [hostPort]);
  const channel = serializeAllMethodsIn(wrap(widgetPort));
  return {
    channel,
    close: () => channel[releaseProxy]()
  };
};

/**
 * Serves api as a response over the communication channel to given port.
 * @param api - The api object that has the methods inside it.
 * @param port - The port on which the channel was initiated and needs to receive the api.
 */
const serve = _ref2 => {
  let {
    api,
    port
  } = _ref2;
  expose(deserializeAllMethodsIn(api), port);
};
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring/build/index.js
// src/context/context-utils.ts
var validValue = (value) => value !== void 0 && value !== null && value !== "";
var pickByValidValues = (obj) => pickBy(obj, validValue);
function pickBy(object, predicate = (value) => !!value) {
  if (!object) {
    return {};
  }
  const result = {};
  for (const key in object) {
    if (predicate(object[key], key)) {
      result[key] = object[key];
    }
  }
  return result;
}
var generateTagsAndContext = (context) => {
  const tags = pickByValidValues({
    "app.id": context.appId,
    "app.version": context.appVersion,
    "app.instanceId": context.appInstanceId,
    "extension.id": context.extensionId,
    "extension.name": context.extensionName,
    "extension.type": context.extensionType,
    platform: context.platform
  });
  const contexts = pickBy(
    {
      "extension.data": pickByValidValues({
        ...context.extensionData
      }),
      site: pickByValidValues({
        url: context.siteUrl,
        id: context.tenantType === "SITE" ? context.tenantId : void 0
      }),
      account: pickByValidValues({
        id: context.tenantType === "ACCOUNT" ? context.tenantId : void 0
      })
    },
    (value) => !!value && Object.keys(value).length > 0
  );
  return {
    tags,
    contexts
  };
};

// src/fallback-client.ts
var FallbackMonitoringClient = class {
  constructor(message) {
    this.message = message;
    this.captureException = () => {
      console.error(this.message);
    };
    this.captureMessage = () => {
      console.error(this.message);
    };
    this.startSpan = (spanOptions, callback) => {
      console.error(this.message);
      return callback(void 0);
    };
    this.startSpanManual = () => {
      console.error(this.message);
      return {
        end: () => {
        },
        fail: () => {
        }
      };
    };
    this.endSpanManual = () => {
      console.error(this.message);
    };
    this.addBreadcrumb = () => {
      console.error(this.message);
    };
  }
};
var createFallbackMonitoringClient = (message) => {
  return new FallbackMonitoringClient(message);
};


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-common-sentry/build/index.js
// src/utils.ts
var build_isPromise = (value) => typeof value?.then === "function";
var runWithMaybePromise = (value, cb) => {
  if (!cb) {
    return value;
  }
  if (build_isPromise(value)) {
    return value.then((res) => {
      cb(res, true);
      return res;
    });
  } else {
    cb(value, false);
    return value;
  }
};
var runWithMaybeDelay = (cb, maybeTimeCompensation) => {
  if (!cb) {
    return;
  }
  if (maybeTimeCompensation) {
    setTimeout(cb, maybeTimeCompensation);
  } else {
    cb();
  }
};
var generateRandomId = () => Date.now() + Math.random();

// src/manual-span.ts
var ManualSpanRegistryImpl = class {
  constructor(options) {
    this.options = options;
    this.spanMap = /* @__PURE__ */ new Map();
  }
  createSpan(spanOptions, sentryOptionsOrPromise) {
    let resolveSpan;
    let rejectSpan;
    let error;
    const startTime = Date.now();
    let maybeDurationCompensation;
    const maybePromise = runWithMaybePromise(
      sentryOptionsOrPromise,
      ({ sentrySDK, scope }, isPromise2) => {
        if (isPromise2) {
          maybeDurationCompensation = Date.now() - startTime;
        }
        const promise = sentrySDK.startSpan(
          {
            ...spanOptions,
            scope,
            forceTransaction: this.options.forceTransaction
          },
          () => new Promise((resolve, reject) => {
            resolveSpan = resolve;
            rejectSpan = reject;
          })
        );
        promise?.catch((e) => {
          if (e?.message !== error?.message) {
            throw e;
          }
        });
      }
    );
    const endSpan = (cb) => {
      this.spanMap.delete(spanOptions.name);
      runWithMaybePromise(maybePromise, () => {
        runWithMaybeDelay(cb, maybeDurationCompensation);
      });
    };
    const span = {
      end: () => {
        endSpan(() => resolveSpan?.());
      },
      fail: (_error) => {
        error = error ?? _error;
        endSpan(() => rejectSpan?.(_error));
      }
    };
    this.spanMap.set(spanOptions.name, span);
    return span;
  }
  getSpan(spanOptions) {
    return this.spanMap.get(spanOptions.name);
  }
};
var createManualSpanRegistry = (options) => new ManualSpanRegistryImpl(options);


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-browser-sentry/build/index.js
// src/factory.ts


// src/browser/client.ts


// src/abstract-browser-client.ts


// src/context-utils.ts

var setTagsAndContextsOnScope = (scope, { tags, contexts }) => {
  if (tags) {
    scope.setTags(tags);
  }
  if (contexts) {
    Object.entries(contexts).forEach(
      ([key, value]) => typeof value !== "undefined" && scope.setContext(key, value)
    );
  }
};
var setHostContextOnScope = (scope, hostContext) => {
  if (!hostContext) {
    return;
  }
  const { tags, contexts } = generateTagsAndContext(hostContext);
  setTagsAndContextsOnScope(scope, { tags, contexts });
};

// src/abstract-browser-client.ts
var MandatorySDKMethods = ["onLoad", "forceLoad"];
var manualSpanRegistryMap = /* @__PURE__ */ new Map();
var AbstractSentryBrowserClient = class {
  constructor(options) {
    this.options = options;
    this.resolvedState = null;
    this.validateOptions = (options) => {
      const missingSDKMethods = MandatorySDKMethods.filter(
        (method) => typeof options.sentrySDK?.[method] !== "function"
      );
      if (missingSDKMethods.length > 0) {
        throw new Error(
          `Missing the following options.sentrySDK methods: ${missingSDKMethods.join(", ")}`
        );
      }
    };
    this.validateOptions(options);
    let manualSpanRegistry = manualSpanRegistryMap.get(options.dsn);
    if (!manualSpanRegistry) {
      manualSpanRegistry = createManualSpanRegistry({
        // Force spans to be reported as individual transactions (one http request per one span)
        forceTransaction: true
      });
      manualSpanRegistryMap.set(options.dsn, manualSpanRegistry);
    }
    this.manualSpanRegistry = manualSpanRegistry;
  }
  isFullSDK() {
    return typeof this.options.sentrySDK.BrowserClient === "function";
  }
  init() {
    if (this.resolvedState) {
      return this.resolvedState;
    }
    const {
      sentrySDK,
      transport,
      hostContext,
      dsn,
      release,
      environment,
      tracesSampleRate = 1,
      debug = false
    } = this.options;
    const scope = new sentrySDK.Scope();
    const sentryClient = new sentrySDK.BrowserClient({
      dsn,
      transport: transport ?? sentrySDK.makeFetchTransport,
      integrations: sentrySDK.getDefaultIntegrations({}),
      stackParser: sentrySDK.defaultStackParser,
      tracesSampleRate: tracesSampleRate || 1,
      debug,
      environment,
      release
    });
    setHostContextOnScope(scope, hostContext);
    scope.setClient(sentryClient);
    sentryClient.init();
    this.resolvedState = {
      sentrySDK,
      scope,
      sentryClient
    };
    return this.resolvedState;
  }
  loadFullSDK(handler) {
    if (this.isFullSDK()) {
      handler?.(this.init());
      return;
    }
    if (this.promise) {
      this.promise.then(handler);
      return;
    }
    this.promise = new Promise((resolve) => {
      this.options.sentrySDK.onLoad(() => {
        if (this.resolvedState) {
          return;
        }
        const resolvedState = this.init();
        resolve(resolvedState);
        handler?.(resolvedState);
      });
    });
    this.options.sentrySDK.forceLoad();
  }
};

// src/browser/client.ts
var SentryBrowserClient = class extends AbstractSentryBrowserClient {
  constructor() {
    super(...arguments);
    /**
     * Records a new breadcrumb which will be attached to future events.
     * Breadcrumbs will be added to subsequent events to provide more context on user's actions prior to an error or crash.
     * @param breadcrumb The breadcrumb to record.
     */
    this.addBreadcrumb = (breadcrumb) => {
      const filteredBreadcrumb = {
        type: breadcrumb.type,
        category: breadcrumb.category,
        message: breadcrumb.message,
        level: breadcrumb.level,
        data: breadcrumb.data
      };
      this.loadFullSDK(({ scope }) => {
        scope.addBreadcrumb(filteredBreadcrumb);
      });
    };
    /**
     * Captures an exception event and sends it to Sentry.
     * @param error The error to capture
     * @param captureContext Optional additional data to attach to the Sentry event.
     */
    this.captureException = (error, captureContext) => {
      this.loadFullSDK(({ sentryClient, scope }) => {
        sentryClient.captureException(
          error,
          {
            captureContext: {
              level: captureContext?.level ?? "error",
              tags: captureContext?.tags,
              contexts: captureContext?.contexts
            }
          },
          scope
        );
      });
    };
    /**
     * Captures a message event and sends it to Sentry.
     * @param message The message to capture
     * @param captureContext Define the level of the message or pass in additional data to attach to the message.
     */
    this.captureMessage = (message, captureContext) => {
      this.loadFullSDK(({ sentryClient, scope }) => {
        sentryClient.captureMessage(
          message,
          captureContext?.level ?? "error",
          {
            captureContext: {
              level: captureContext?.level ?? "error",
              tags: captureContext?.tags,
              contexts: captureContext?.contexts
            }
          },
          scope
        );
      });
    };
    /**
     * Wraps a function with a span and finishes the span after the function is done. The created span is the active span and will be used as parent by other spans created inside the function, as long as the function is executed while the scope is active.
     * @param spanOptions The options for the span
     * @param callback The function to wrap with a span
     * @returns The return value of the callback
     */
    this.startSpan = (spanOptions, callback) => {
      if (this.isFullSDK()) {
        const { sentrySDK, scope } = this.init();
        return sentrySDK.startSpan({ ...spanOptions, scope }, callback);
      }
      this.loadFullSDK();
      const simulateAndReportSuccessfulSpan = (callbackResult2, startTime2) => {
        const spanDuration = Date.now() - startTime2;
        const simulatedCallback = () => {
          return new Promise(
            (resolve) => setTimeout(() => resolve(callbackResult2), spanDuration)
          );
        };
        this.loadFullSDK(async ({ sentrySDK, scope }) => {
          return sentrySDK.startSpan(
            { ...spanOptions, scope },
            simulatedCallback
          );
        });
      };
      const simulateAndReportFailedSpan = async (error2, startTime2) => {
        const spanDuration = Date.now() - startTime2;
        const simulatedCallback = () => {
          return new Promise(
            (_, reject) => setTimeout(() => reject(error2), spanDuration)
          );
        };
        this.loadFullSDK(async ({ sentrySDK, scope }) => {
          try {
            await sentrySDK.startSpan(
              { ...spanOptions, scope },
              simulatedCallback
            );
          } catch (e) {
            if (e?.message !== error2?.message) {
              throw e;
            }
          }
        });
      };
      const startTime = Date.now();
      let callbackResult;
      let error;
      try {
        callbackResult = callback();
      } catch (e) {
        error = e;
      }
      if (error) {
        simulateAndReportFailedSpan(error, startTime);
        throw error;
      } else {
        if (build_isPromise(callbackResult)) {
          callbackResult.then((res) => simulateAndReportSuccessfulSpan(res, startTime)).catch((e) => simulateAndReportFailedSpan(e, startTime));
        } else {
          simulateAndReportSuccessfulSpan(callbackResult, startTime);
        }
        return callbackResult;
      }
    };
    this.startSpanManual = (spanOptions) => {
      const resolvedStateOrPromise = this.isFullSDK() ? this.init() : new Promise((resolve) => this.loadFullSDK(resolve));
      const span = this.manualSpanRegistry.createSpan(
        spanOptions,
        resolvedStateOrPromise
      );
      return span;
    };
    this.endSpanManual = (spanOptions) => {
      const span = this.manualSpanRegistry.getSpan(spanOptions);
      span?.end();
    };
  }
};

// src/factory.ts
var unsupportedEnvironmentMessage = (version) => `Sentry SDK version "${version}" is not supported. Please make sure to use monitoring SDK only in supported environments.`;
var major = (version) => {
  try {
    return parseInt(version.split(".")[0], 10);
  } catch {
    console.warn("Failed to parse Sentry SDK version");
    return void 0;
  }
};
var createSentryBrowserClient = ({
  sentrySDK,
  dsn,
  ...options
}) => {
  if (!sentrySDK) {
    return createFallbackMonitoringClient(
      "Unsupported environment - Sentry SDK is not loaded into the environment. Please make sure to use monitoring SDK only in supported environments."
    );
  }
  if (!dsn) {
    return createFallbackMonitoringClient(
      "Missing Sentry DSN in the app's monitoring configuration. Please make sure to set it."
    );
  }
  try {
    const sentrySdkMajorVersion = sentrySDK.SDK_VERSION && major(sentrySDK.SDK_VERSION);
    if (sentrySdkMajorVersion && sentrySdkMajorVersion < 7) {
      return createFallbackMonitoringClient(
        unsupportedEnvironmentMessage(sentrySDK.SDK_VERSION)
      );
    }
    return new SentryBrowserClient({ ...options, dsn, sentrySDK });
  } catch (e) {
    return createFallbackMonitoringClient(
      `Failed to initialize monitoring client: ${e.message}`
    );
  }
};


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-browser-panorama/build/index.js
// src/client.ts

var PanoramaBrowserClient = class {
  constructor(options) {
    this.options = options;
    this.captureException = (error, captureContext) => {
      const { panoramaClient } = this.options;
      if (!(error instanceof Error)) {
        error = new Error(error);
      }
      panoramaClient.errorMonitor().reportError(error, this.contextToData(captureContext));
    };
    this.captureMessage = (message, captureContext) => {
      const { panoramaClient } = this.options;
      const logger = panoramaClient.logger();
      let loggerByLevel;
      switch (captureContext?.level) {
        case "error":
          loggerByLevel = logger.error;
          break;
        case "warning":
          loggerByLevel = logger.warn;
          break;
        default:
          loggerByLevel = logger.info;
      }
      loggerByLevel(message, this.contextToData(captureContext));
    };
    this.startSpan = (spanOptions, callback) => {
      const { panoramaClient } = this.options;
      const { name } = spanOptions;
      let res;
      const transaction = panoramaClient.transaction(name, {
        id: generateRandomId()
      });
      const data = this.contextToData(spanOptions);
      transaction.start(data);
      try {
        res = callback();
        if (build_isPromise(res)) {
          res = res.then((_res) => {
            transaction.finish(data);
            return _res;
          }).catch((e) => {
            this.reportErrorInContextOfSpan(e, spanOptions);
            throw e;
          });
        } else {
          transaction.finish(data);
        }
      } catch (e) {
        this.reportErrorInContextOfSpan(e, spanOptions);
        throw e;
      }
      return res;
    };
    this.addBreadcrumb = (breadcrumb) => {
      const { panoramaClient } = this.options;
      panoramaClient.errorMonitor().addBreadcrumb(breadcrumb);
    };
  }
  contextToData(captureContext) {
    return captureContext && {
      ...captureContext?.tags && { tags: captureContext.tags },
      ...captureContext?.contexts && { context: captureContext.contexts },
      ...captureContext?.level && {
        severity: captureContext.level
      }
    };
  }
  reportErrorInContextOfSpan(error, spanOptions) {
    const { panoramaClient } = this.options;
    const { name } = spanOptions;
    const data = this.contextToData({
      ...spanOptions,
      contexts: { transaction: { name } }
    });
    panoramaClient.errorMonitor().reportError(error, data);
  }
  startSpanManual(spanOptions) {
    const { panoramaClient } = this.options;
    const { name } = spanOptions;
    const transaction = panoramaClient.transaction(name, {
      id: generateRandomId()
    });
    const data = this.contextToData(spanOptions);
    transaction.start(data);
    let reported = false;
    const reportOnce = (cb) => {
      if (reported) {
        return;
      }
      reported = true;
      cb();
    };
    return {
      end: () => {
        reportOnce(() => transaction.finish(data));
      },
      fail: (error) => {
        reportOnce(() => this.reportErrorInContextOfSpan(error, spanOptions));
      }
    };
  }
  endSpanManual(spanOptions) {
    const { panoramaClient } = this.options;
    const { name } = spanOptions;
    panoramaClient.transaction(name).finish();
  }
};

// src/factory.ts

var createPanoramaBrowserClient = (options) => {
  const { panoramaClient } = options;
  if (!panoramaClient) {
    return createFallbackMonitoringClient("Missing Panorama client");
  }
  return new PanoramaBrowserClient(options);
};


;// CONCATENATED MODULE: ../../../node_modules/@wix/monitoring-browser-sdk-host/build/index.js
// src/monitoring-client.ts



var isSentryConfig = (monitoringConfig) => monitoringConfig?.type === "SENTRY";
var isPanoramaConfig = (monitoringConfig) => monitoringConfig?.type === "PANORAMA";
var getMonitoringClientFunction = ({
  sentrySDK,
  sentryTransport,
  panoramaClient,
  monitoringConfig,
  hostContext
}) => {
  if (isSentryConfig(monitoringConfig)) {
    const { sentryOptions } = monitoringConfig;
    return () => createSentryBrowserClient({
      dsn: sentryOptions?.dsn,
      hostContext,
      sentrySDK,
      transport: sentryTransport
    });
  } else if (isPanoramaConfig(monitoringConfig)) {
    return () => createPanoramaBrowserClient({ panoramaClient });
  }
  return () => createFallbackMonitoringClient(
    "Invalid monitoring configuration. Please check the monitoring setup of your application."
  );
};


;// CONCATENATED MODULE: ./helpers/registerHeightReporter.ts
const registerHeightReporter=(bridge,container)=>{const update=()=>bridge.updateHeight(container.offsetHeight);const resizeObserver=new ResizeObserver(update);resizeObserver.observe(container);return()=>resizeObserver.disconnect();};
;// CONCATENATED MODULE: ./helpers/isWixOrigin.ts
const origins=['https://manage.wix.com','https://manage.editorx.com'];const allowedOrigins=new Set(origins);const isWixOrigin=origin=>allowedOrigins.has(origin);
;// CONCATENATED MODULE: ./helpers/registerOnBeforeUnload.ts
const registerBeforeUnloadHandler=channel=>{const eventTarget=new EventTarget();const isInWorker=typeof window==='undefined';const onIframeBeforeUnload=event=>{const shouldUnloadWithoutConfirmation=eventTarget.dispatchEvent(new CustomEvent('beforeunload',{cancelable:true}));if(!shouldUnloadWithoutConfirmation){event.preventDefault();event.returnValue=true;// Chrome requires returnValue to be set
}};const onBeforeUnloadHandle=channel.onBeforeUnload(onIframeBeforeUnload);const clearBeforeUnloadHandler=()=>{if(!isInWorker){window.removeEventListener('beforeunload',onIframeBeforeUnload);}onBeforeUnloadHandle.then(_ref=>{let{remove}=_ref;return remove();});};if(!isInWorker){window.addEventListener('beforeunload',onIframeBeforeUnload);window.addEventListener('unload',clearBeforeUnloadHandler);}const onBeforeUnload=callback=>{eventTarget.addEventListener('beforeunload',callback);const remove=()=>{eventTarget.removeEventListener('beforeunload',callback);};return{remove};};return{onBeforeUnload,clearBeforeUnloadHandler};};
;// CONCATENATED MODULE: ./helpers/essentials.ts
function safeParseEssentials(essentials){if(!essentials){return undefined;}try{return JSON.parse(decodeURIComponent(essentials));}catch(e){console.warn('Failed to parse "essentials" query parameter. Make sure to run the code inside a supported Wix App extension.',e);return undefined;}}function getEssentialsFromQueryParams(queryParams){return queryParams.has('essentials')?safeParseEssentials(queryParams.get('essentials')):undefined;}
;// CONCATENATED MODULE: ./hostPlatform.ts
const createHost=function(config){if(config===void 0){config={};}// when full url is provided (worker case) use it and ignore own location search
const searchString=config.fullUrl&&new URL(config.fullUrl).search||typeof window!=='undefined'&&window.location.search||'';const queryParams=new URLSearchParams(searchString);const origin=config.origin||queryParams.get('origin')||'';const postMessage=config.postMessage||window.parent.postMessage.bind(window.parent);if(!isWixOrigin(origin)){throw new Error(`Wix Dashboard SDK: Unable to establish a connection with the Wix dashboard. Please ensure that you are running your app within the Wix dashboard.`);}const{channel,close}=esm_open({postMessage,origin});const closeMethods=[close];if(config.autoHeightUpdate===undefined||config.autoHeightUpdate){const element=config.autoHeightElement||document.documentElement;const clearHeightReport=registerHeightReporter(channel,element);closeMethods.push(()=>clearHeightReport());}const{onBeforeUnload,clearBeforeUnloadHandler}=registerBeforeUnloadHandler(channel);closeMethods.push(clearBeforeUnloadHandler);const siteInfo=parseSiteInfo(queryParams.get('siteInfo')||'');const getSiteInfoSync=()=>siteInfo;const channelProxy=new Proxy(channel,{get(target,prop,receiver){if(prop==='onBeforeUnload'){return onBeforeUnload;}if(prop==='getSiteInfo'){return getSiteInfoSync;}return Reflect.get(target,prop,receiver);}});const{monitoring,...essentials}=getEssentialsFromQueryParams(queryParams)||{};const getMonitoringClient=getMonitoringClientFunction({hostContext:monitoring==null?void 0:monitoring.context,monitoringConfig:monitoring==null?void 0:monitoring.config,sentrySDK:typeof window!=='undefined'?window.Sentry:undefined});return{channel:channelProxy,close:()=>closeMethods.forEach(method=>method()),getMonitoringClient,essentials};};const parseSiteInfo=siteInfo=>{try{return JSON.parse(decodeURIComponent(siteInfo));}catch(e){console.warn('Failed to parse "siteInfo" query parameter. Make sure to run the code inside a supported Wix App extension.',e);return{};}};

/***/ }),

/***/ 324:
/*!***********************!*\
  !*** ./types/auth.ts ***!
  \***********************/
/***/ (() => {



/***/ }),

/***/ 568:
/*!******************************!*\
  !*** ./types/getSiteInfo.ts ***!
  \******************************/
/***/ (() => {



/***/ }),

/***/ 814:
/*!************************!*\
  !*** ./types/index.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth */ 324);
/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_auth__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _auth__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _auth__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _mediaManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mediaManager */ 495);
/* harmony import */ var _mediaManager__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mediaManager__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _mediaManager__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _mediaManager__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _navigate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./navigate */ 944);
/* harmony import */ var _navigate__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_navigate__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _navigate__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _navigate__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _onBeforeUnload__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onBeforeUnload */ 72);
/* harmony import */ var _onBeforeUnload__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_onBeforeUnload__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _onBeforeUnload__WEBPACK_IMPORTED_MODULE_3__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _onBeforeUnload__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _serializable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./serializable */ 169);
/* harmony import */ var _serializable__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_serializable__WEBPACK_IMPORTED_MODULE_4__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _serializable__WEBPACK_IMPORTED_MODULE_4__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _serializable__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _toast__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toast */ 639);
/* harmony import */ var _toast__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_toast__WEBPACK_IMPORTED_MODULE_5__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _toast__WEBPACK_IMPORTED_MODULE_5__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _toast__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _requestFeedback__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./requestFeedback */ 270);
/* harmony import */ var _requestFeedback__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_requestFeedback__WEBPACK_IMPORTED_MODULE_6__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _requestFeedback__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _requestFeedback__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _onLayerStateChange__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./onLayerStateChange */ 710);
/* harmony import */ var _onLayerStateChange__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_onLayerStateChange__WEBPACK_IMPORTED_MODULE_7__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _onLayerStateChange__WEBPACK_IMPORTED_MODULE_7__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _onLayerStateChange__WEBPACK_IMPORTED_MODULE_7__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _installApp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./installApp */ 459);
/* harmony import */ var _installApp__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_installApp__WEBPACK_IMPORTED_MODULE_8__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _installApp__WEBPACK_IMPORTED_MODULE_8__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _installApp__WEBPACK_IMPORTED_MODULE_8__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _getSiteInfo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getSiteInfo */ 568);
/* harmony import */ var _getSiteInfo__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_getSiteInfo__WEBPACK_IMPORTED_MODULE_9__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _getSiteInfo__WEBPACK_IMPORTED_MODULE_9__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _getSiteInfo__WEBPACK_IMPORTED_MODULE_9__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ 459:
/*!*****************************!*\
  !*** ./types/installApp.ts ***!
  \*****************************/
/***/ (() => {



/***/ }),

/***/ 495:
/*!*******************************!*\
  !*** ./types/mediaManager.ts ***!
  \*******************************/
/***/ (() => {



/***/ }),

/***/ 944:
/*!***************************!*\
  !*** ./types/navigate.ts ***!
  \***************************/
/***/ (() => {



/***/ }),

/***/ 72:
/*!*********************************!*\
  !*** ./types/onBeforeUnload.ts ***!
  \*********************************/
/***/ (() => {



/***/ }),

/***/ 710:
/*!*************************************!*\
  !*** ./types/onLayerStateChange.ts ***!
  \*************************************/
/***/ (() => {



/***/ }),

/***/ 270:
/*!**********************************!*\
  !*** ./types/requestFeedback.ts ***!
  \**********************************/
/***/ (() => {



/***/ }),

/***/ 169:
/*!*******************************!*\
  !*** ./types/serializable.ts ***!
  \*******************************/
/***/ (() => {



/***/ }),

/***/ 639:
/*!************************!*\
  !*** ./types/toast.ts ***!
  \************************/
/***/ (() => {



/***/ }),

/***/ 213:
/*!**********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ 174);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 662:
/*!*******************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 114)["default"]);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 174:
/*!*********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 114)["default"]);
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ 662);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 114:
/*!**************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/typeof.js ***!
  \**************************************************************/
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 748:
/*!**********************************************************************!*\
  !*** ../../../node_modules/@wix/sdk-context/build/browser/index.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ wixContext)
/* harmony export */ });
// src/index.ts
var wixContext = {};



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dashboard: () => (/* binding */ dashboard)
/* harmony export */ });
/* harmony import */ var _dashboardHostModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dashboardHostModule */ 801);
/* harmony import */ var _hostPlatform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hostPlatform */ 202);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ 814);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_2__) if(["default","dashboard"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
const dashboard=(0,_dashboardHostModule__WEBPACK_IMPORTED_MODULE_0__/* .createDashboardModule */ .f)({createHost: _hostPlatform__WEBPACK_IMPORTED_MODULE_1__/* .createHost */ .L});
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=sdk.umd.js.map