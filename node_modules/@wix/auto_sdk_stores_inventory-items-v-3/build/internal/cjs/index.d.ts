import { HttpClient, NonNullablePaths, EventDefinition, MaybeContext, BuildRESTFunction, BuildEventDefinition } from '@wix/sdk-types';
import { I as InventoryItem, C as CreateInventoryItemApplicationErrors, a as CreateInventoryItemValidationErrors, B as BulkCreateInventoryItemsOptions, b as BulkCreateInventoryItemsResponse, c as BulkCreateInventoryItemsApplicationErrors, d as BulkCreateInventoryItemsValidationErrors, U as UpdateInventoryItem, e as UpdateInventoryItemOptions, f as UpdateInventoryItemApplicationErrors, M as MaskedInventoryItem, g as BulkUpdateInventoryItemsOptions, h as BulkUpdateInventoryItemsResponse, i as BulkUpdateInventoryItemsApplicationErrors, j as BulkUpdateInventoryItemsByFilterOptions, k as BulkUpdateInventoryItemsByFilterResponse, l as BulkUpdateInventoryItemsByFilterApplicationErrors, m as BulkDeleteInventoryItemsResponse, n as InventoryItemSearch, S as SearchInventoryItemsResponse, D as DecrementDataById, o as BulkDecrementInventoryItemsOptions, p as BulkDecrementInventoryItemsResponse, q as BulkDecrementInventoryItemsApplicationErrors, r as IncrementDataById, s as BulkIncrementInventoryItemsOptions, t as BulkIncrementInventoryItemsResponse, u as BulkIncrementInventoryItemsApplicationErrors, v as DecrementDataByVariantAndLocation, w as BulkDecrementInventoryItemsByVariantAndLocationOptions, x as BulkDecrementInventoryItemsByVariantAndLocationResponse, y as BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors, z as IncrementDataByVariantAndLocation, A as BulkIncrementInventoryItemsByVariantAndLocationOptions, E as BulkIncrementInventoryItemsByVariantAndLocationResponse, F as BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors, G as BulkSetOrAdjustInventoryItemsByFilterOptions, H as BulkSetOrAdjustInventoryItemsByFilterResponse, J as BulkSetOrAdjustInventoryItemsByFilterApplicationErrors, K as InventoryItemCreatedEnvelope, L as InventoryItemDeletedEnvelope, N as InventoryItemStockStatusUpdatedEnvelope, O as InventoryItemUpdatedEnvelope, P as InventoryItemUpdatedWithReasonEnvelope, Q as InventoryItemsQueryBuilder, R as QueryV2, T as typedQueryInventoryItems } from './stores-catalog-v3-inventory-item-inventory-items-v-3.universal-BSETn2mY.js';
export { bB as ActionEvent, bE as AdjustInventoryAction, bF as AdjustInventoryActionActionOneOf, aN as Aggregation, b1 as AggregationData, aO as AggregationKindOneOf, bk as AggregationResults, bl as AggregationResultsResultOneOf, b8 as AggregationResultsScalarResult, a4 as AggregationType, bY as AggregationTypeWithLiterals, ac as App, an as ApplicationError, V as AvailabilityStatus, bN as AvailabilityStatusWithLiterals, bJ as BaseEventMetadata, ao as BulkActionMetadata, ak as BulkCreateInventoryItemsRequest, bt as BulkDecrementInventoryItemsByVariantAndLocationRequest, br as BulkDecrementInventoryItemsRequest, aA as BulkDeleteInventoryItemsRequest, bu as BulkIncrementInventoryItemsByVariantAndLocationRequest, bs as BulkIncrementInventoryItemsRequest, ah as BulkInventoryItemAction, aB as BulkInventoryItemResult, bD as BulkSetOrAdjustInventoryItemsByFilterRequest, aw as BulkUpdateInventoryItemsByFilterRequest, av as BulkUpdateInventoryItemsRequest, aJ as CommonCursors, b_ as CommonSearchWithEntityContext, ai as CreateInventoryItemRequest, aj as CreateInventoryItemResponse, aG as CursorPaging, a$ as CursorPagingMetadata, aL as CursorSearch, aM as CursorSearchPagingMethodOneOf, b0 as Cursors, ag as CustomTag, aV as DateHistogramAggregation, bg as DateHistogramResult, bi as DateHistogramResults, ay as DeleteInventoryItemRequest, az as DeleteInventoryItemResponse, bv as DomainEvent, bw as DomainEventBodyOneOf, bC as Empty, bx as EntityCreatedEvent, bA as EntityDeletedEvent, bz as EntityUpdatedEvent, bK as EventMetadata, W as EventType, bO as EventTypeWithLiterals, a9 as ExtendedFields, af as File, ap as GetInventoryItemRequest, aq as GetInventoryItemResponse, aZ as GroupByAggregation, a_ as GroupByAggregationKindOneOf, bh as GroupByValueResults, bH as IdentificationData, bI as IdentificationDataIdOneOf, aQ as IncludeMissingValuesOptions, a3 as Interval, bX as IntervalWithLiterals, aa as InvalidateCache, ab as InvalidateCacheGetByOneOf, bM as InventoryItemSearchSpec, at as InventoryItemStockStatusUpdatedEvent, a6 as InventoryItemTrackingMethodOneOf, au as InventoryItemUpdatedWithReason, bL as InventoryItemsQueryResult, am as ItemMetadata, bG as MessageEnvelope, a0 as MissingValues, bU as MissingValuesWithLiterals, Y as Mode, bQ as ModeWithLiterals, aY as NestedAggregation, aW as NestedAggregationItem, aX as NestedAggregationItemKindOneOf, b4 as NestedAggregationResults, b5 as NestedAggregationResultsResultOneOf, a2 as NestedAggregationType, bW as NestedAggregationTypeWithLiterals, bd as NestedResultValue, be as NestedResultValueResultOneOf, bj as NestedResults, b9 as NestedValueAggregationResult, bn as OffsetSearch, bo as OffsetSearchPagingMethodOneOf, ad as Page, aF as Paging, bq as PagingMetadata, aI as PlatformPagingMetadataV2, a7 as PreorderInfo, a8 as Product, aC as QueryInventoryItemsRequest, aH as QueryInventoryItemsResponse, aD as QueryV2PagingMethodOneOf, aT as RangeAggregation, b3 as RangeAggregationResult, aP as RangeBucket, bb as RangeResult, b7 as RangeResults, X as ReasonType, bP as ReasonTypeWithLiterals, by as RestoreInfo, bf as Results, aU as ScalarAggregation, bc as ScalarResult, a1 as ScalarType, bV as ScalarTypeWithLiterals, ax as SearchDetails, aK as SearchInventoryItemsRequest, bm as SearchInventoryItemsWithOffsetRequest, bp as SearchInventoryItemsWithOffsetResponse, $ as SortDirection, bT as SortDirectionWithLiterals, Z as SortOrder, bR as SortOrderWithLiterals, _ as SortType, bS as SortTypeWithLiterals, aE as Sorting, ae as URI, ar as UpdateInventoryItemRequest, as as UpdateInventoryItemResponse, al as V3BulkInventoryItemResult, aR as ValueAggregation, aS as ValueAggregationOptionsOneOf, b2 as ValueAggregationResult, ba as ValueResult, b6 as ValueResults, a5 as WebhookIdentityType, bZ as WebhookIdentityTypeWithLiterals } from './stores-catalog-v3-inventory-item-inventory-items-v-3.universal-BSETn2mY.js';

declare function createInventoryItem$1(httpClient: HttpClient): CreateInventoryItemSignature;
interface CreateInventoryItemSignature {
    /**
     * Creates an inventory item.
     * The combination of `variantId` and `locationId` is unique.
     * @param - Inventory item to create.
     * @returns Created inventory item.
     */
    (inventoryItem: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
        __applicationErrorsType?: CreateInventoryItemApplicationErrors;
        __validationErrorsType?: CreateInventoryItemValidationErrors;
    }>;
}
declare function bulkCreateInventoryItems$1(httpClient: HttpClient): BulkCreateInventoryItemsSignature;
interface BulkCreateInventoryItemsSignature {
    /**
     * Creates multiple inventory items.
     * @param - Inventory items to create.
     */
    (inventoryItems: NonNullablePaths<InventoryItem, `productId` | `variantId`, 2>[], options?: BulkCreateInventoryItemsOptions): Promise<NonNullablePaths<BulkCreateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkCreateInventoryItemsApplicationErrors;
        __validationErrorsType?: BulkCreateInventoryItemsValidationErrors;
    }>;
}
declare function getInventoryItem$1(httpClient: HttpClient): GetInventoryItemSignature;
interface GetInventoryItemSignature {
    /**
     * Retrieves an inventory item.
     * @param - Inventory item ID.
     * @returns Inventory item.
     */
    (inventoryItemId: string): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3>>;
}
declare function updateInventoryItem$1(httpClient: HttpClient): UpdateInventoryItemSignature;
interface UpdateInventoryItemSignature {
    /**
     * Updates an inventory item.
     *
     *
     * Each time the inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating the inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory item ID.
     * @returns Updated inventory item.
     */
    (_id: string, inventoryItem: NonNullablePaths<UpdateInventoryItem, `revision`, 2>, options?: UpdateInventoryItemOptions): Promise<NonNullablePaths<InventoryItem, `inStock` | `quantity` | `variantId` | `productId` | `trackQuantity` | `availabilityStatus` | `product.directCategoryIds`, 3> & {
        __applicationErrorsType?: UpdateInventoryItemApplicationErrors;
    }>;
}
declare function bulkUpdateInventoryItems$1(httpClient: HttpClient): BulkUpdateInventoryItemsSignature;
interface BulkUpdateInventoryItemsSignature {
    /**
     * Updates multiple inventory items.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory items to update.
     */
    (inventoryItems: NonNullablePaths<MaskedInventoryItem, `inventoryItem._id` | `inventoryItem.revision`, 3>[], options?: BulkUpdateInventoryItemsOptions): Promise<NonNullablePaths<BulkUpdateInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkUpdateInventoryItemsApplicationErrors;
    }>;
}
declare function bulkUpdateInventoryItemsByFilter$1(httpClient: HttpClient): BulkUpdateInventoryItemsByFilterSignature;
interface BulkUpdateInventoryItemsByFilterSignature {
    /**
     * Updates multiple inventory items, given the provided filter.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Filter object.
     */
    (filter: Record<string, any>, options?: NonNullablePaths<BulkUpdateInventoryItemsByFilterOptions, `inventoryItem`, 2>): Promise<NonNullablePaths<BulkUpdateInventoryItemsByFilterResponse, `jobId`, 2> & {
        __applicationErrorsType?: BulkUpdateInventoryItemsByFilterApplicationErrors;
    }>;
}
declare function deleteInventoryItem$1(httpClient: HttpClient): DeleteInventoryItemSignature;
interface DeleteInventoryItemSignature {
    /**
     * Deletes an inventory item.
     * @param - Inventory item ID.
     */
    (inventoryItemId: string): Promise<void>;
}
declare function bulkDeleteInventoryItems$1(httpClient: HttpClient): BulkDeleteInventoryItemsSignature;
interface BulkDeleteInventoryItemsSignature {
    /**
     * Deletes multiple inventory items.
     * @param - IDs of inventory items to delete.
     */
    (inventoryItemIds: string[]): Promise<NonNullablePaths<BulkDeleteInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
}
declare function searchInventoryItems$1(httpClient: HttpClient): SearchInventoryItemsSignature;
interface SearchInventoryItemsSignature {
    /**
     * Retrieves a list of inventory items, given the provided filtering, sorting, and cursor paging.
     *
     *
     * Search Inventory Items runs with these defaults, which you can override:
     *
     * - `createdDate` is sorted in `DESC` order
     * - `cursorPaging.limit` is `100`
     *
     * For field support for filters and sorting,
     * see [Inventory Items: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/inventory-items-v3/supported-filters-and-sorting).
     *
     * To learn about working with _Search_ endpoints, see
     * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
     * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     * @param - Search options.
     */
    (search: InventoryItemSearch): Promise<NonNullablePaths<SearchInventoryItemsResponse, `inventoryItems` | `inventoryItems.${number}.inStock` | `inventoryItems.${number}.quantity` | `inventoryItems.${number}.variantId` | `inventoryItems.${number}.productId` | `inventoryItems.${number}.trackQuantity` | `inventoryItems.${number}.availabilityStatus` | `aggregationData.results` | `aggregationData.results.${number}.scalar.type` | `aggregationData.results.${number}.scalar.value` | `aggregationData.results.${number}.name` | `aggregationData.results.${number}.type` | `aggregationData.results.${number}.fieldPath`, 6>>;
}
declare function bulkDecrementInventoryItems$1(httpClient: HttpClient): BulkDecrementInventoryItemsSignature;
interface BulkDecrementInventoryItemsSignature {
    /**
     * Decrements quantities of multiple inventory items.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Inventory item IDs and decrement data.
     */
    (decrementData: NonNullablePaths<DecrementDataById, `decrementBy` | `inventoryItemId`, 2>[], options?: BulkDecrementInventoryItemsOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkDecrementInventoryItemsApplicationErrors;
    }>;
}
declare function bulkIncrementInventoryItems$1(httpClient: HttpClient): BulkIncrementInventoryItemsSignature;
interface BulkIncrementInventoryItemsSignature {
    /**
     * Increments quantities of multiple inventory items.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Inventory item IDs and increment data.
     */
    (incrementData: NonNullablePaths<IncrementDataById, `incrementBy` | `inventoryItemId`, 2>[], options?: BulkIncrementInventoryItemsOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkIncrementInventoryItemsApplicationErrors;
    }>;
}
declare function bulkDecrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkDecrementInventoryItemsByVariantAndLocationSignature;
interface BulkDecrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Decrements quantities of multiple inventory items by variant and location.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Variant and location IDs, as well as decrement data.
     */
    (decrementData: NonNullablePaths<DecrementDataByVariantAndLocation, `decrementBy` | `variantId`, 2>[], options?: BulkDecrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkDecrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors;
    }>;
}
declare function bulkIncrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkIncrementInventoryItemsByVariantAndLocationSignature;
interface BulkIncrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Increments quantities of multiple inventory items by variant and location.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Variant and location IDs, as well as increment data.
     */
    (incrementData: NonNullablePaths<IncrementDataByVariantAndLocation, `incrementBy` | `variantId`, 2>[], options?: BulkIncrementInventoryItemsByVariantAndLocationOptions): Promise<NonNullablePaths<BulkIncrementInventoryItemsByVariantAndLocationResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.inStock` | `results.${number}.item.quantity` | `results.${number}.item.variantId` | `results.${number}.item.productId` | `results.${number}.item.trackQuantity` | `results.${number}.item.availabilityStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors;
    }>;
}
/** @internal */
declare function bulkSetOrAdjustInventoryItemsByFilter$1(httpClient: HttpClient): BulkSetOrAdjustInventoryItemsByFilterSignature;
interface BulkSetOrAdjustInventoryItemsByFilterSignature {
    /**
     * Set or Adjust inventory items which satisfy the provided filter.
     * If item track quantity, adjust it's quantity,
     * In case non-tracking, updates it to track and sets quantity to `incrementBy` or `decrementBy`.
     * @param - Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    (filter: Record<string, any>, options?: NonNullablePaths<BulkSetOrAdjustInventoryItemsByFilterOptions, `adjustedInventoryAction`, 2>): Promise<NonNullablePaths<BulkSetOrAdjustInventoryItemsByFilterResponse, `jobId`, 2> & {
        __applicationErrorsType?: BulkSetOrAdjustInventoryItemsByFilterApplicationErrors;
    }>;
}
declare const onInventoryItemCreated$1: EventDefinition<InventoryItemCreatedEnvelope, "wix.stores.catalog.v3.inventory_item_created">;
declare const onInventoryItemDeleted$1: EventDefinition<InventoryItemDeletedEnvelope, "wix.stores.catalog.v3.inventory_item_deleted">;
declare const onInventoryItemStockStatusUpdated$1: EventDefinition<InventoryItemStockStatusUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_stock_status_updated">;
declare const onInventoryItemUpdated$1: EventDefinition<InventoryItemUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_updated">;
declare const onInventoryItemUpdatedWithReason$1: EventDefinition<InventoryItemUpdatedWithReasonEnvelope, "wix.stores.catalog.v3.inventory_item_updated_with_reason">;

declare function customQueryInventoryItems(httpClient: HttpClient): {
    (): InventoryItemsQueryBuilder;
    (query: QueryV2): ReturnType<typeof typedQueryInventoryItems>;
};
declare const createInventoryItem: MaybeContext<BuildRESTFunction<typeof createInventoryItem$1> & typeof createInventoryItem$1>;
declare const bulkCreateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkCreateInventoryItems$1> & typeof bulkCreateInventoryItems$1>;
declare const getInventoryItem: MaybeContext<BuildRESTFunction<typeof getInventoryItem$1> & typeof getInventoryItem$1>;
declare const updateInventoryItem: MaybeContext<BuildRESTFunction<typeof updateInventoryItem$1> & typeof updateInventoryItem$1>;
declare const bulkUpdateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItems$1> & typeof bulkUpdateInventoryItems$1>;
declare const bulkUpdateInventoryItemsByFilter: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItemsByFilter$1> & typeof bulkUpdateInventoryItemsByFilter$1>;
declare const deleteInventoryItem: MaybeContext<BuildRESTFunction<typeof deleteInventoryItem$1> & typeof deleteInventoryItem$1>;
declare const bulkDeleteInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDeleteInventoryItems$1> & typeof bulkDeleteInventoryItems$1>;
declare const searchInventoryItems: MaybeContext<BuildRESTFunction<typeof searchInventoryItems$1> & typeof searchInventoryItems$1>;
declare const bulkDecrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItems$1> & typeof bulkDecrementInventoryItems$1>;
declare const bulkIncrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItems$1> & typeof bulkIncrementInventoryItems$1>;
declare const bulkDecrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItemsByVariantAndLocation$1> & typeof bulkDecrementInventoryItemsByVariantAndLocation$1>;
declare const bulkIncrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItemsByVariantAndLocation$1> & typeof bulkIncrementInventoryItemsByVariantAndLocation$1>;
/** @internal */
declare const bulkSetOrAdjustInventoryItemsByFilter: MaybeContext<BuildRESTFunction<typeof bulkSetOrAdjustInventoryItemsByFilter$1> & typeof bulkSetOrAdjustInventoryItemsByFilter$1>;
declare const queryInventoryItems: MaybeContext<BuildRESTFunction<typeof customQueryInventoryItems> & typeof customQueryInventoryItems>;
/**
 * Triggered when an inventory item is created.
 */
declare const onInventoryItemCreated: BuildEventDefinition<typeof onInventoryItemCreated$1> & typeof onInventoryItemCreated$1;
/**
 * Triggered when an inventory item is deleted.
 */
declare const onInventoryItemDeleted: BuildEventDefinition<typeof onInventoryItemDeleted$1> & typeof onInventoryItemDeleted$1;
/**
 * Triggered when an inventory item's stock is updated.
 */
declare const onInventoryItemStockStatusUpdated: BuildEventDefinition<typeof onInventoryItemStockStatusUpdated$1> & typeof onInventoryItemStockStatusUpdated$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdated: BuildEventDefinition<typeof onInventoryItemUpdated$1> & typeof onInventoryItemUpdated$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdatedWithReason: BuildEventDefinition<typeof onInventoryItemUpdatedWithReason$1> & typeof onInventoryItemUpdatedWithReason$1;

export { BulkCreateInventoryItemsApplicationErrors, BulkCreateInventoryItemsOptions, BulkCreateInventoryItemsResponse, BulkCreateInventoryItemsValidationErrors, BulkDecrementInventoryItemsApplicationErrors, BulkDecrementInventoryItemsByVariantAndLocationApplicationErrors, BulkDecrementInventoryItemsByVariantAndLocationOptions, BulkDecrementInventoryItemsByVariantAndLocationResponse, BulkDecrementInventoryItemsOptions, BulkDecrementInventoryItemsResponse, BulkDeleteInventoryItemsResponse, BulkIncrementInventoryItemsApplicationErrors, BulkIncrementInventoryItemsByVariantAndLocationApplicationErrors, BulkIncrementInventoryItemsByVariantAndLocationOptions, BulkIncrementInventoryItemsByVariantAndLocationResponse, BulkIncrementInventoryItemsOptions, BulkIncrementInventoryItemsResponse, BulkSetOrAdjustInventoryItemsByFilterApplicationErrors, BulkSetOrAdjustInventoryItemsByFilterOptions, BulkSetOrAdjustInventoryItemsByFilterResponse, BulkUpdateInventoryItemsApplicationErrors, BulkUpdateInventoryItemsByFilterApplicationErrors, BulkUpdateInventoryItemsByFilterOptions, BulkUpdateInventoryItemsByFilterResponse, BulkUpdateInventoryItemsOptions, BulkUpdateInventoryItemsResponse, CreateInventoryItemApplicationErrors, CreateInventoryItemValidationErrors, DecrementDataById, DecrementDataByVariantAndLocation, IncrementDataById, IncrementDataByVariantAndLocation, InventoryItem, InventoryItemCreatedEnvelope, InventoryItemDeletedEnvelope, InventoryItemSearch, InventoryItemStockStatusUpdatedEnvelope, InventoryItemUpdatedEnvelope, InventoryItemUpdatedWithReasonEnvelope, InventoryItemsQueryBuilder, MaskedInventoryItem, QueryV2, SearchInventoryItemsResponse, UpdateInventoryItem, UpdateInventoryItemApplicationErrors, UpdateInventoryItemOptions, bulkCreateInventoryItems, bulkDecrementInventoryItems, bulkDecrementInventoryItemsByVariantAndLocation, bulkDeleteInventoryItems, bulkIncrementInventoryItems, bulkIncrementInventoryItemsByVariantAndLocation, bulkSetOrAdjustInventoryItemsByFilter, bulkUpdateInventoryItems, bulkUpdateInventoryItemsByFilter, createInventoryItem, deleteInventoryItem, getInventoryItem, onInventoryItemCreated, onInventoryItemDeleted, onInventoryItemStockStatusUpdated, onInventoryItemUpdated, onInventoryItemUpdatedWithReason, queryInventoryItems, searchInventoryItems, updateInventoryItem };
