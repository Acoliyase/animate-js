"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSelectorTestSuite = void 0;
const itemCreator_1 = require("../../itemCreator");
const runTest_1 = require("../utils/runTest");
const errors_1 = require("../../../UniDriverBase/errors");
const delay_1 = require("../../../utils/delay");
const runSelectorTestSuite = (params) => {
    const { isStorybook, setup } = params;
    describe('$', () => {
        describe('text()', () => {
            it('returns text of a element', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-item' } : { items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' })] }, async ({ driver }) => {
                    expect(await driver.$('.label').text()).toBe('Bob');
                    expect(await driver.$('.count').text()).toBe('1');
                });
            });
            it('returns text of a element with nested selector', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-item' } : { items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' })] }, async ({ driver }) => {
                    expect(await driver.$('[data-hook="todo-item"]').$('.label').text()).toBe('Bob');
                });
            });
            it('is lazy', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base' } : { items: [] }, async ({ driver }) => {
                    const item = driver.$('[data-hook="todo-item"]').$('.label');
                    await driver.$('header input').enterValue('Some value');
                    await driver.$('.add').click();
                    expect(await item.text()).toBe('Some value');
                });
            });
        });
        describe('hasClass()', () => {
            it('has full class name', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-item' } : { items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' })] }, async ({ driver }) => {
                    expect(await driver.$('.label').hasClass('label')).toBe(true);
                });
            });
            it('returns true when there are multiple class names', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook
                    ? { story: 'with-two-items' }
                    : {
                        items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' }), (0, itemCreator_1.itemCreator)({ label: 'David' })],
                    }, async ({ driver }) => {
                    const bd = driver.$$('[data-hook="todo-item"]').get(1);
                    await bd.hover();
                    expect(await bd.hasClass('todo-item')).toBe(true);
                });
            });
            it('returns false for partial class name', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-item' } : { items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' })] }, async ({ driver }) => {
                    expect(await driver.$('.label').hasClass('lab')).toBe(false);
                });
            });
            it('returns false when element has no class attribute', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-item' } : { items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' })] }, async ({ driver }) => {
                    expect(await driver.$('footer').hasClass('whatever')).toBe(false);
                });
            });
        });
        describe('value()', () => {
            it('returns value of given input', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-initial-text' } : { initialText: 'hello', items: [] }, async ({ driver }) => {
                    expect(await driver.$('header input').value()).toBe('hello');
                });
            });
            it('returns string in case no or numeric value', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-initial-text' } : { initialText: 'hello', items: [] }, async ({ driver }) => {
                    expect(await driver.$('meter').value()).toBe('0');
                    expect(await driver.$('header').value()).toBe('');
                });
            });
        });
        describe('enterValue()/enterText()', () => {
            const runInputTests = (fnName) => {
                it('should work with empty value', async ({ mount }) => {
                    await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-initial-text' } : { initialText: 'hello', items: [] }, async ({ driver }) => {
                        await driver.$('header input')[fnName]('');
                        expect(await driver.$('header input').value()).toBe('');
                    });
                });
                it('should override the input', async ({ mount }) => {
                    await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-initial-text' } : { initialText: 'hello', items: [] }, async ({ driver }) => {
                        await driver.$('header input')[fnName]('hey there');
                        expect(await driver.$('header input').value()).toBe('hey there');
                    });
                });
                it('should not clear the input if {shouldClear/clear: false}', async ({ mount }) => {
                    await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-initial-text' } : { initialText: 'hello', items: [] }, async ({ driver }) => {
                        if (fnName === 'enterText') {
                            await driver.$('header input').enterText(' hey there', { clear: false });
                        }
                        else {
                            await driver.$('header input').enterValue(' hey there', { shouldClear: false });
                        }
                        expect(await driver.$('header input').value()).toBe('hello hey there');
                    });
                });
                it('should do nothing when input is disabled', async ({ mount }) => {
                    await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'disabled-input' } : { initialText: 'other text', inputDisabled: true, items: [] }, async ({ driver }) => {
                        await driver.$('header input')[fnName]('hey there');
                        expect(await driver.$('header input').value()).toBe('other text');
                    });
                });
                it('should do nothing when input is readOnly', async ({ mount }) => {
                    await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'readonly-input' } : { initialText: 'other text', inputReadOnly: true, items: [] }, async ({ driver }) => {
                        await driver.$('header input')[fnName]('hey there');
                        expect(await driver.$('header input').value()).toBe('other text');
                    });
                });
                it('shout wait between key presses when delay option is passed', async ({ mount }) => {
                    await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                        const sleepPromise = (0, delay_1.delay)(500).then(async () => {
                            const value = await driver.$('header input').value();
                            // Wrote some of the input in 500 milliseconds but not all of it
                            expect(value.length).toBeGreaterThan(0);
                            expect(value.length).toBeLessThan('hey there'.length);
                        });
                        const inputPromise = driver.$('header input')[fnName]('hey there', { delay: 200 });
                        await sleepPromise;
                        await inputPromise;
                        expect(await driver.$('header input').value()).toBe('hey there');
                    });
                });
            };
            describe('enterText', () => {
                runInputTests('enterText');
            });
            describe('enterValue', () => {
                runInputTests('enterValue');
            });
        });
        describe('click()', () => {
            it('works', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    await driver.$('.todo-app header input').enterValue('bob');
                    await driver.$('.add').click();
                    expect(await driver.$('.count').text()).toBe('1');
                    expect(await driver.$('.label').text()).toBe('bob');
                });
            });
            it('includes the selector in the message if throws', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    const error = await driver
                        .$('.non-existing-element')
                        .click()
                        .catch((e) => e);
                    expect(error?.message).toContain('.non-existing-element');
                });
            });
        });
        describe('hover()', () => {
            it('works', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook
                    ? { story: 'with-two-items' }
                    : {
                        items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' }), (0, itemCreator_1.itemCreator)({ label: 'David' })],
                    }, async ({ driver }) => {
                    const bd = driver.$$('[data-hook="todo-item"]').get(1);
                    await bd.hover();
                    expect(await bd.attr('data-active')).toBe('true');
                });
            });
        });
        describe('exists()', () => {
            it('returns true when an element exists', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base' } : { items: [] }, async ({ driver }) => {
                    expect(await driver.$('.count').exists()).toBe(true);
                    expect(await driver.$('.add').exists()).toBe(true);
                });
            });
            it('returns false when an element does not exist', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base' } : { items: [] }, async ({ driver }) => {
                    expect(await driver.$('.tootim').exists()).toBe(false);
                    expect(await driver.$('#arnold-schwarzenegger').exists()).toBe(false);
                });
            });
            it('rejects the promise with an error when more than 1 element exists', async ({ mount }) => {
                const items = [(0, itemCreator_1.itemCreator)({ label: 'Bob' }), (0, itemCreator_1.itemCreator)({ label: 'David' })];
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-two-items' } : { items }, async ({ driver }) => {
                    const error = await driver
                        .$('[data-hook="todo-item"]')
                        .exists()
                        .catch((e) => e);
                    expect((0, errors_1.isMultipleElementsWithSelectorError)(error)).toBe(true);
                });
            });
        });
        describe('getNative()', () => {
            it('returns a native element for advanced usages', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base' } : { items: [] }, async ({ driver }) => {
                    const native = await driver.getNative();
                    expect(native).toBeDefined();
                });
            });
        });
        describe('pressKey()', () => {
            it('single key works', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    await driver.$('.todo-app header input').enterValue('bob');
                    await driver.$('.add').pressKey('Enter');
                    expect(await driver.$('.count').text()).toBe('1');
                    expect(await driver.$('.label').text()).toBe('bob');
                });
            });
        });
        describe('enterText', () => {
            it(`enters the text`, async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    await driver.$('.todo-app header input').enterText('bob');
                    await driver.$('.add').pressKey('Enter');
                    expect(await driver.$('.count').text()).toBe('1');
                    expect(await driver.$('.label').text()).toBe('bob');
                });
            });
        });
        describe('attr()', () => {
            it('returns null if attr does not exist', async ({ mount }) => {
                const items = [(0, itemCreator_1.itemCreator)({ label: 'Bob' })];
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-item' } : { items }, async ({ driver }) => {
                    expect(await driver.$('[data-hook="todo-item"]').attr('data-value')).toBe(null);
                });
            });
            it('returns attribute value', async ({ mount }) => {
                const itemsToShow = [
                    (0, itemCreator_1.itemCreator)({ completed: false, id: 'bob', label: 'Bob' }),
                    (0, itemCreator_1.itemCreator)({ completed: false, id: 'alice', label: 'Alice' }),
                ];
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'items-with-ids' } : { items: itemsToShow }, async ({ driver }) => {
                    const items = driver.$$('[data-hook="todo-item"]');
                    expect(await items.get(0).attr('data-value')).toBe('bob');
                    expect(await items.get(1).attr('data-value')).toBe('alice');
                });
            });
            it('returns empty string', async ({ mount }) => {
                const items = [(0, itemCreator_1.itemCreator)({ completed: false, id: '', label: 'Bob' })];
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'item-with-empty-id' } : { items }, async ({ driver }) => {
                    expect(await driver.$('[data-hook="todo-item"]').attr('data-value')).toBe('');
                });
            });
            it('gets correct attribute [when] $ is deep nested', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-item' } : { items: [(0, itemCreator_1.itemCreator)({ label: 'Bob' })] }, async ({ driver }) => {
                    const item = driver.$('[data-hook="todo-item"]');
                    expect(await item.$('button').attr('class')).toBe('toggle');
                });
            });
        });
        describe('prop()', () => {
            it('should return placeholder value', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    expect(await driver.$('header input').prop('placeholder')).toBe('this is a placeholder');
                });
            });
            it('should return undefined for undefined prop', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    expect(await driver.$('header input').prop('dummyProp')).toBe(undefined);
                });
            });
            it('returns the correct prop for items in list', async ({ mount }) => {
                const items = [(0, itemCreator_1.itemCreator)({ completed: false, label: 'Bob' }), (0, itemCreator_1.itemCreator)({ completed: true, label: 'David' })];
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-two-items' } : { items }, async ({ driver }) => {
                    const checkboxes = driver.$$('[data-hook="todo-item"] input');
                    expect(await checkboxes.get(0).prop('checked')).toBe(false);
                    expect(await checkboxes.get(1).prop('checked')).toBe(true);
                });
            });
        });
        describe('_prop()', () => {
            it('should return placeholder value', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    expect(await driver.$('header input')._prop('placeholder')).toBe('this is a placeholder');
                });
            });
            it('should return undefined for undefined prop', async ({ mount }) => {
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base-empty-initial-text' } : { initialText: '', items: [] }, async ({ driver }) => {
                    expect(await driver.$('header input')._prop('dummyProp')).toBe(undefined);
                });
            });
            it('returns the correct prop for items in list', async ({ mount }) => {
                const items = [(0, itemCreator_1.itemCreator)({ completed: false, label: 'Bob' }), (0, itemCreator_1.itemCreator)({ completed: true, label: 'David' })];
                await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-two-items' } : { items }, async ({ driver }) => {
                    const checkboxes = driver.$$('[data-hook="todo-item"] input');
                    expect(await checkboxes.get(0)._prop('checked')).toBe(false);
                    expect(await checkboxes.get(1)._prop('checked')).toBe(true);
                });
            });
        });
        it('rejects with the right error on action when an element does not exist given selector', async ({ mount }) => {
            await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'base' } : { items: [] }, async ({ driver }) => {
                const err = await driver
                    .$('.non_existing_element')
                    .text()
                    .catch((e) => e);
                expect((0, errors_1.isNoElementWithSelectorError)(err)).toBe(true);
            });
        });
        it('rejects with the right error on action when an more than 1 element exist given selector', async ({ mount }) => {
            const items = [(0, itemCreator_1.itemCreator)({ completed: false, label: 'Bob' }), (0, itemCreator_1.itemCreator)({ completed: true, label: 'David' })];
            await (0, runTest_1.runTest)(setup, { mount }, isStorybook ? { story: 'with-two-items' } : { items }, async ({ driver }) => {
                const err = await driver
                    .$('[data-hook="todo-item"]')
                    .text()
                    .catch((e) => e);
                expect((0, errors_1.isMultipleElementsWithSelectorError)(err)).toBe(true);
            });
        });
    });
};
exports.runSelectorTestSuite = runSelectorTestSuite;
//# sourceMappingURL=runSelectorTestSuite.js.map