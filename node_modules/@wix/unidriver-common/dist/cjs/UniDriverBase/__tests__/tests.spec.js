"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const react_1 = require("@testing-library/react");
const react_2 = tslib_1.__importDefault(require("react"));
const testUniDriver_1 = require("../../__tests__/TestUniDriver/testUniDriver");
const exports_testing_1 = require("../../exports-testing");
const delay_1 = require("../../utils/delay");
const vitest_1 = require("vitest");
(0, vitest_1.describe)('Common Test Suite', () => {
    (0, exports_testing_1.runAllSuites)({
        setup: (props) => {
            const { container } = (0, react_1.render)(react_2.default.createElement(exports_testing_1.TestApp, { ...props }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const tearDown = () => {
                (0, react_1.cleanup)();
            };
            return { driver, tearDown };
        },
    });
});
(0, vitest_1.describe)('Adapter Specific', () => {
    afterEach(() => {
        (0, react_1.cleanup)();
    });
    (0, vitest_1.describe)('type tests', () => {
        it('should return proper getNative type', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const native = await driver.getNative();
            (0, vitest_1.assertType)(native);
            expect(native).toBeDefined();
        });
        it('should return proper unwrap type', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const native = await driver.unwrap();
            (0, vitest_1.assertType)(native);
            const nativeAsserted = await driver.unwrap();
            (0, vitest_1.assertType)(nativeAsserted);
            expect(native).toBeDefined();
        });
    });
    (0, vitest_1.describe)('constructor params', () => {
        (0, vitest_1.describe)('base element', () => {
            it('should work with base element as non Promise', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null)));
                const driver = (0, testUniDriver_1.testUniDriver)(container);
                expect(await driver.$('section').exists()).toBe(true);
            });
            it('should work with base element as a Promise', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null)));
                const driver = (0, testUniDriver_1.testUniDriver)(Promise.resolve(container));
                expect(await driver.$('section').exists()).toBe(true);
            });
        });
        (0, vitest_1.describe)('should work with {selector, root}', () => {
            it('should work when selector is non Promise', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null, "test")));
                const driver = (0, testUniDriver_1.testUniDriver)({
                    selector: 'section',
                    root: container,
                });
                expect(await driver.text()).toBe('test');
            });
            it('should work when selector is a Promise', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null, "test")));
                const driver = (0, testUniDriver_1.testUniDriver)({
                    selector: 'section',
                    root: Promise.resolve(container),
                });
                expect(await driver.text()).toBe('test');
            });
        });
        (0, vitest_1.describe)('function', () => {
            it('should work with {selector, root}', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null, "test")));
                const driver = (0, testUniDriver_1.testUniDriver)(() => ({
                    selector: 'section',
                    root: container,
                }));
                expect(await driver.text()).toBe('test');
            });
            it('should work with base element', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null)));
                const driver = (0, testUniDriver_1.testUniDriver)(() => container);
                expect(await driver.$('section').exists()).toBe(true);
            });
            it('should work with base element which is delayed', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement(exports_testing_1.AsyncChildrenApp, { timeout: 30 },
                    react_2.default.createElement("div", { "data-testid": "delayed-element" })));
                const driver = (0, testUniDriver_1.testUniDriver)(() => {
                    return container.querySelector('[data-testid="delayed-element"]');
                });
                expect(await driver.exists()).toBe(false);
                await (0, react_1.waitFor)(async () => {
                    expect(await driver.exists()).toBe(true);
                });
            });
        });
        (0, vitest_1.describe)('async function', () => {
            it('should work with base element', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null)));
                const driver = (0, testUniDriver_1.testUniDriver)(async () => container);
                expect(await driver.$('section').exists()).toBe(true);
            });
        });
    });
    (0, vitest_1.describe)('click', () => {
        // TODO: check order of fired events
        it('should trigger button events when clicked', async () => {
            const onMouseUp = vi.fn();
            const onClick = vi.fn();
            const onMouseDown = vi.fn();
            const onFocus = vi.fn();
            const { container } = (0, react_1.render)(react_2.default.createElement("button", { onClick: onClick, onFocus: onFocus, onMouseDown: onMouseDown, onMouseUp: onMouseUp }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('button').click();
            expect(onClick).toHaveBeenCalledTimes(1);
            expect(onMouseUp).toHaveBeenCalledTimes(1);
            expect(onMouseDown).toHaveBeenCalledTimes(1);
            expect(onFocus).toHaveBeenCalledTimes(1);
        });
        it(`should trigger double click if {type: 'double'} is passed`, async () => {
            const onDoubleClick = vi.fn();
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { onDoubleClick: onDoubleClick, type: "checkbox" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('input').click({ type: 'double' });
            expect(onDoubleClick).toHaveBeenCalledTimes(1);
        });
        it('should trigger input events in order', async () => {
            const onMouseUp = vi.fn();
            const onClick = vi.fn();
            const onMouseDown = vi.fn();
            const onFocus = vi.fn();
            const onInput = vi.fn();
            const onChange = vi.fn();
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { onChange: onChange, onClick: onClick, onFocus: onFocus, onInput: onInput, onMouseDown: onMouseDown, onMouseUp: onMouseUp, type: "checkbox" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('input').click();
            expect(onClick).toHaveBeenCalledTimes(1);
            expect(onMouseUp).toHaveBeenCalledTimes(1);
            expect(onMouseDown).toHaveBeenCalledTimes(1);
            expect(onFocus).toHaveBeenCalledTimes(1);
            expect(onInput).toHaveBeenCalledTimes(1);
            expect(onChange).toHaveBeenCalledTimes(1);
        });
        it('should trigger focus and blur in order when clicking two buttons', async () => {
            const onFocusA = vi.fn();
            const onBlurA = vi.fn();
            const onFocusB = vi.fn();
            const { container } = (0, react_1.render)(react_2.default.createElement(react_2.default.Fragment, null,
                react_2.default.createElement("button", { id: "A", onBlur: onBlurA, onFocus: onFocusA }, "button A"),
                react_2.default.createElement("button", { id: "B", onFocus: onFocusB }, "button B")));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('#A').click();
            expect(onFocusA).toHaveBeenCalledTimes(1);
            expect(onBlurA).toHaveBeenCalledTimes(0);
            expect(onFocusB).toHaveBeenCalledTimes(0);
            await driver.$('#B').click();
            expect(onBlurA).toHaveBeenCalledTimes(1);
            expect(onFocusB).toHaveBeenCalledTimes(1);
        });
        it('should not call onFocus when given disabled button', async () => {
            const onFocusA = vi.fn();
            const { container } = (0, react_1.render)(react_2.default.createElement("button", { disabled: true, id: "A", onFocus: onFocusA }, "button B"));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('button#A').click();
            expect(onFocusA).toHaveBeenCalledTimes(0);
        });
        it('should work with fake timers', async () => {
            vi.useFakeTimers();
            const { container } = (0, react_1.render)(react_2.default.createElement("button", null, "button"));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('button').click();
            expect(true).toBe(true);
        });
        it('should work with pointer-events: none', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("button", { style: { pointerEvents: 'none' } }, "button"));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
            expect(await driver.$('button').click()).toBe(undefined);
        });
    });
    (0, vitest_1.describe)('enterText', () => {
        it('should change input value when entering', async () => {
            const onChange = vi.fn();
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { name: "search", onChange: (event) => {
                    onChange(event.target.value);
                }, type: "text" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('input').enterText('some keywords');
            const firstLetter = onChange.mock.calls.at(0)?.[0];
            const value = onChange.mock.calls.at(-1)?.[0];
            expect(firstLetter).toBe('s');
            expect(value).toBe('some keywords');
        });
        it('should change input value when given uncontrolled input', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { name: "search", type: "text" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const input = driver.$('input');
            await input.enterText('some keywords');
            expect(await input.value()).toBe('some keywords');
        });
        it('should type with a delay if delay prop provided', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { name: "search", type: "text" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const input = driver.$('input');
            const inputPromise = input.enterText('some keywords', { delay: 100 });
            const assertionPromise = (0, delay_1.delay)(300).then(async () => {
                const value = await driver.$('input').value();
                expect(value.length).toBeGreaterThan(0);
                expect(value.length).toBeLessThan('some keywords'.length);
            });
            await inputPromise;
            await assertionPromise;
            expect(await input.value()).toBe('some keywords');
        });
    });
    (0, vitest_1.describe)('enterValue', () => {
        it('should change input value when entering', async () => {
            const onChange = vi.fn();
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { name: "search", onChange: (event) => {
                    onChange(event.target.value);
                }, type: "text" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await driver.$('input').enterValue('some keywords');
            const firstLetter = onChange.mock.calls.at(0)?.[0];
            const value = onChange.mock.calls.at(-1)?.[0];
            expect(firstLetter).toBe('s');
            expect(value).toBe('some keywords');
        });
        it('should change input value when given uncontrolled input', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { name: "search", type: "text" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const input = driver.$('input');
            await input.enterValue('some keywords');
            expect(await input.value()).toBe('some keywords');
        });
        it('should type with a delay if delay prop provided', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("input", { name: "search", type: "text" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const input = driver.$('input');
            const inputPromise = input.enterValue('some keywords', { delay: 100 });
            const assertionPromise = (0, delay_1.delay)(300).then(async () => {
                const value = await driver.$('input').value();
                expect(value.length).toBeGreaterThan(0);
                expect(value.length).toBeLessThan('some keywords'.length);
            });
            await inputPromise;
            await assertionPromise;
            expect(await input.value()).toBe('some keywords');
        });
    });
    (0, vitest_1.describe)('wait', () => {
        it('should throw immediately if element is not found when passed zero timeout', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const firstCompletedTask = await Promise.race([
                driver
                    .$('button')
                    .wait(0)
                    .catch(() => {
                    return 'wait';
                }),
                new Promise((resolve) => setTimeout(() => {
                    resolve('timeout');
                }, 100)),
            ]);
            expect(firstCompletedTask).toBe('wait');
        });
        it('should resolve promise only after the element is in the DOM', async () => {
            const { container, rerender } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const selector = '[data-testid="test-element"]';
            expect(await driver.$(selector).exists()).toBe(false);
            const waitPromise = driver.$(selector).wait();
            rerender(react_2.default.createElement("div", { "data-testid": "test-element" }));
            expect(await driver.$(selector).exists()).toBe(true);
            await expect(waitPromise).resolves.toBe(undefined);
        });
        it('should reject promise if element does not appear in the DOM', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await expect(driver.$('button').wait()).rejects.toThrowError();
        });
    });
    (0, vitest_1.describe)('$', () => {
        (0, vitest_1.describe)('awaited', () => {
            it('should have basic support', async () => {
                const onClick = vi.fn();
                const { container } = (0, react_1.render)(react_2.default.createElement("button", { onClick: onClick }));
                const driver = (0, testUniDriver_1.testUniDriver)(container);
                const task = await driver
                    .$('button')
                    .awaited(100)
                    .click()
                    .then(() => 'click');
                expect(task).toBe('click');
                expect(onClick).toHaveBeenCalledTimes(1);
            });
            it('should wait timeout for element to show if applied to deep driver', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
                const driver = (0, testUniDriver_1.testUniDriver)(container);
                const firstCompletedTask = await Promise.race([
                    driver
                        .$('div')
                        .awaited(100)
                        .$('button')
                        .click()
                        .catch(() => {
                        return 'selector';
                    }),
                    new Promise((resolve) => {
                        setTimeout(() => {
                            resolve('timeout');
                        }, 200);
                    }),
                ]);
                expect(firstCompletedTask).toBe('selector');
            });
            it('should override timeout', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
                const driver = (0, testUniDriver_1.testUniDriver)(container);
                const firstCompletedTask = await Promise.race([
                    driver
                        .$('div')
                        .awaited(300)
                        .$('button')
                        .awaited(100)
                        .click()
                        .catch(() => {
                        return 'selector';
                    }),
                    new Promise((resolve) => {
                        setTimeout(() => {
                            resolve('timeout');
                        }, 200);
                    }),
                ]);
                expect(firstCompletedTask).toBe('selector');
            });
            it('should show full selectors path if element not present', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null,
                        react_2.default.createElement("form", null,
                            react_2.default.createElement("button", null)))));
                const driver = (0, testUniDriver_1.testUniDriver)(container);
                const clickTaskError = await driver
                    .$('div')
                    .$('section')
                    .$('span')
                    .$('div')
                    .$('button')
                    .awaited()
                    .click()
                    .catch((e) => {
                    return e.message;
                });
                expect(clickTaskError).toContain('selector: button\r\n');
                expect(clickTaskError).toContain('Failed path: div > section > span\r\n');
                expect(clickTaskError).toContain('Full path: div > section > span > div > button');
            });
        });
        it('should not throw immediately', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const completedTask = await Promise.race([
                driver
                    .$('button')
                    .click()
                    .catch(() => {
                    return 'selector';
                }),
                new Promise((resolve) => {
                    setTimeout(() => {
                        resolve('timeout');
                    }, 100);
                }),
            ]);
            expect(completedTask).toBe('timeout');
        });
        it('should show full selectors path if element not present', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null,
                react_2.default.createElement("section", null,
                    react_2.default.createElement("form", null,
                        react_2.default.createElement("button", null)))));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const clickTaskError = await driver
                .$('div')
                .$('section')
                .$('span')
                .$('div')
                .$('button')
                .awaited()
                .click()
                .catch((e) => {
                return e.message;
            });
            expect(clickTaskError).toContain('selector: button\r\n');
            expect(clickTaskError).toContain('Failed path: div > section > span\r\n');
            expect(clickTaskError).toContain('Full path: div > section > span > div > button');
        });
        it('should be able to get an element when app renders element with a delay', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement(exports_testing_1.AsyncChildrenApp, { timeout: 20 },
                react_2.default.createElement("div", { "data-testid": "delayed-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            await (0, react_1.waitFor)(async () => {
                expect(await driver.$('[data-testid="delayed-element"]').exists()).toBe(true);
            });
        });
        it('should return an object which syncs with the DOM', async () => {
            const { container, rerender } = (0, react_1.render)(react_2.default.createElement("div", { "data-testid": "test-element" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const element = driver.$('[data-testid="test-element"]');
            expect(await element.exists()).toBe(true);
            rerender(react_2.default.createElement("div", null));
            expect(await element.exists()).toBe(false);
        });
        it('should support spread syntax and not loose context', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", { "data-testid": "test-element" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const element = {
                ...driver.$('[data-testid="test-element"]'),
            };
            await element.mouse.hover();
            expect(await element.exists()).toBe(true);
        });
    });
    (0, vitest_1.describe)('$$', () => {
        it('should return unidriver list', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement(react_2.default.Fragment, null,
                react_2.default.createElement("div", { "data-testid": "test-element" }),
                react_2.default.createElement("div", { "data-testid": "test-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const elementList = driver.$$('[data-testid="test-element"]');
            expect(await elementList.at(0).exists()).toBe(true);
            expect(await elementList.at(1).exists()).toBe(true);
            expect(await elementList.at(2).exists()).toBe(false);
        });
        it('should show full selectors path if element not present', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement(react_2.default.Fragment, null,
                react_2.default.createElement("div", null,
                    react_2.default.createElement("section", null,
                        react_2.default.createElement("form", null,
                            react_2.default.createElement("button", null))),
                    react_2.default.createElement("section", null))));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const clickTaskError = await driver
                .$('div')
                .$$('section')
                .at(0)
                .$('span')
                .$('div')
                .$('button')
                .awaited()
                .click()
                .catch((e) => {
                return e.message;
            });
            expect(clickTaskError).toContain('selector: button\r\n');
            expect(clickTaskError).toContain('Failed path: div > section:nth-child(1) > span\r\n');
            expect(clickTaskError).toContain('Full path: div > section:nth-child(1) > span > div > button');
        });
        it('should be able to get an element(s) when app renders element with a delay', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement(exports_testing_1.AsyncChildrenApp, { timeout: 10 },
                react_2.default.createElement("div", { "data-testid": "delayed-element" }),
                react_2.default.createElement("div", { "data-testid": "delayed-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            expect(await driver.$('[data-testid="delayed-element"]').exists()).toBe(false);
            const elementList = driver.$$('[data-testid="delayed-element"]');
            await (0, react_1.waitFor)(async () => {
                expect(await elementList.at(0).exists()).toBe(true);
                expect(await elementList.at(1).exists()).toBe(true);
            });
        });
        it(`should sync with the DOM when it's updated`, async () => {
            const { container, rerender } = (0, react_1.render)(react_2.default.createElement("div", { "data-testid": "test-element" },
                react_2.default.createElement("div", { "data-testid": "test-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const elementList = driver.$$('[data-testid="test-element"]');
            expect(await elementList.at(0).exists()).toBe(true);
            expect(await elementList.at(1).exists()).toBe(true);
            rerender(react_2.default.createElement("div", null));
            expect(await elementList.at(0).exists()).toBe(false);
            expect(await elementList.at(1).exists()).toBe(false);
        });
        it('should support spread syntax and not loose context', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement(react_2.default.Fragment, null,
                react_2.default.createElement("div", { "data-testid": "test-element" }),
                react_2.default.createElement("div", { "data-testid": "test-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const elementList = { ...driver.$$('[data-testid="test-element"]') };
            expect(await elementList.get(0).exists()).toBe(true);
            expect(await elementList.at(0).exists()).toBe(true);
            expect(await elementList.at(1).exists()).toBe(true);
            expect(await elementList.at(2).exists()).toBe(false);
        });
        (0, vitest_1.describe)('map', () => {
            it('should work if elements are rendered with delay', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement(exports_testing_1.AsyncChildrenApp, { timeout: 20 },
                    react_2.default.createElement("div", { "data-testid": "delayed-element" }),
                    react_2.default.createElement("div", { "data-testid": "delayed-element" })));
                const driver = (0, testUniDriver_1.testUniDriver)(container);
                const driverFactory = (uni) => {
                    return {
                        exists: () => uni.exists(),
                    };
                };
                await (0, react_1.waitFor)(async () => {
                    const $secondElement = (await driver.$$('[data-testid="delayed-element"]').map(async (el) => {
                        return driverFactory(el);
                    }))[1];
                    expect(await $secondElement?.exists()).toBe(true);
                });
            });
            it('should return empty array from map if elements were not found', async () => {
                const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
                const driver = (0, testUniDriver_1.testUniDriver)(container);
                const texts = await driver.$$('span').map((el) => {
                    return el.text();
                });
                expect(texts).toEqual([]);
            });
        });
    });
    (0, vitest_1.describe)('get', () => {
        it('should resolve a promise with a unidriver element', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", { "data-testid": "test-element" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const element = await driver.get('[data-testid="test-element"]');
            expect(await element.exists()).toBe(true);
        });
        it('should be able to get an element when app renders element with a delay', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement(exports_testing_1.AsyncChildrenApp, { timeout: 20 },
                react_2.default.createElement("div", { "data-testid": "delayed-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            expect(await driver.$('[data-testid="delayed-element"]').exists()).toBe(false);
            const element = await driver.get('[data-testid="delayed-element"]');
            expect(await element.exists()).toBe(true);
        });
        it('should throw error when element is not found', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            let error;
            try {
                await driver.get('[data-testid="test-element"]', {
                    timeout: 10,
                });
            }
            catch (e) {
                error = e;
            }
            expect(error).toBeInstanceOf(Error);
        });
        it('should return an object which syncs with the DOM', async () => {
            const { container, rerender } = (0, react_1.render)(react_2.default.createElement("div", { "data-testid": "test-element" }));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const element = await driver.get('[data-testid="test-element"]');
            expect(await element.exists()).toBe(true);
            rerender(react_2.default.createElement("div", null));
            expect(await element.exists()).toBe(false);
        });
    });
    (0, vitest_1.describe)('getAll', () => {
        it('should resolve a promise with a unidriver element list', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", { "data-testid": "test-element" },
                react_2.default.createElement("div", { "data-testid": "test-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const elementList = await driver.getAll('[data-testid="test-element"]');
            expect(await elementList.at(0).exists()).toBe(true);
            expect(await elementList.at(1).exists()).toBe(true);
            expect(await elementList.at(2).exists()).toBe(false);
        });
        it('should be able to get an element(s) when app renders element with a delay', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement(exports_testing_1.AsyncChildrenApp, null,
                react_2.default.createElement("div", { "data-testid": "delayed-element" }),
                react_2.default.createElement("div", { "data-testid": "delayed-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            expect(await driver.$('[data-testid="delayed-element"]').exists()).toBe(false);
            const elementList = await driver.getAll('[data-testid="delayed-element"]');
            expect(await elementList.at(0).exists()).toBe(true);
            expect(await elementList.at(1).exists()).toBe(true);
        });
        it('should throw error when element is not found', async () => {
            const { container } = (0, react_1.render)(react_2.default.createElement("div", null));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const getterPromise = driver.getAll('[data-testid="test-element"]');
            await expect(getterPromise).rejects.toThrowError();
        });
        it('should return an object which syncs with the DOM', async () => {
            const { container, rerender } = (0, react_1.render)(react_2.default.createElement("div", { "data-testid": "test-element" },
                react_2.default.createElement("div", { "data-testid": "test-element" })));
            const driver = (0, testUniDriver_1.testUniDriver)(container);
            const elementList = await driver.getAll('[data-testid="test-element"]');
            expect(await elementList.at(0).exists()).toBe(true);
            expect(await elementList.at(1).exists()).toBe(true);
            rerender(react_2.default.createElement("div", null));
            expect(await elementList.at(0).exists()).toBe(false);
            expect(await elementList.at(1).exists()).toBe(false);
        });
    });
});
//# sourceMappingURL=tests.spec.js.map