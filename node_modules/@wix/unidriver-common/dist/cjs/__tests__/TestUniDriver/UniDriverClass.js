"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniDriverClass = void 0;
const dom_1 = require("@testing-library/dom");
const user_event_1 = require("@testing-library/user-event");
const UniDriverBase_1 = require("../../UniDriverBase/UniDriverBase");
const enterText_1 = require("./enterText");
const UniDriverClassList_1 = require("./UniDriverClassList");
const enterValue_1 = require("./enterValue");
const bindUniDriverApiMethods_1 = require("../../utils/bindUniDriverApiMethods");
class UniDriverClass extends UniDriverBase_1.UniDriverBase {
    constructor(ctx) {
        super(ctx);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'react'
        });
        Object.defineProperty(this, "api", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                attr: async (base, attr) => base.getAttribute(attr),
                unwrap: async (base) => base,
                Class: UniDriverClass,
                click: async (base, options) => {
                    const clickParams = {
                        delay: null,
                        // We don't check pointer events for jsdom as we can't compute styles
                        pointerEventsCheck: user_event_1.PointerEventsCheckLevel.Never,
                    };
                    if (options?.type === 'double') {
                        return user_event_1.userEvent.dblClick(base, clickParams);
                    }
                    return user_event_1.userEvent.click(base, clickParams);
                },
                enterText: async (base, value, options) => {
                    await (0, enterText_1.enterText)(base, value, options);
                },
                enterValue: async (base, value, options) => {
                    await (0, enterValue_1.enterValue)(base, value, options);
                },
                getElementsBySelector: async (base, selector) => [...base.querySelectorAll(selector)],
                getType: () => 'jsdom-react',
                hasClass: async (base, className) => base.classList.contains(className),
                ListClass: UniDriverClassList_1.UniDriverClassList,
                mouse: {
                    hover: async (base) => user_event_1.userEvent.hover(base),
                    leave: async (base) => user_event_1.userEvent.unhover(base),
                    moveTo: async (base, to) => {
                        const { left, top } = (await to.unwrap()).getBoundingClientRect();
                        dom_1.fireEvent.mouseMove(base, { clientX: left, clientY: top });
                    },
                    press: async (base) => {
                        dom_1.fireEvent.mouseDown(base);
                    },
                    release: async (base) => {
                        dom_1.fireEvent.mouseUp(base);
                    },
                },
                pressKey: async (base, keyMeta) => {
                    dom_1.fireEvent.keyDown(base, keyMeta);
                    dom_1.fireEvent.keyUp(base, keyMeta);
                },
                prop: async (base, prop) => base[prop],
                text: async (base) => base.textContent ?? '',
                value: async (base) => {
                    const value = base.value;
                    return typeof value === 'number' ? String(value) : (value ?? '');
                },
            }
        });
        Object.defineProperty(this, "get", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (selector, options) => {
                return (0, dom_1.waitFor)(() => {
                    return super.get(selector, options);
                }, { timeout: this.getTimeBudget(options?.timeout) });
            }
        });
        Object.defineProperty(this, "getAll", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (selector, options) => {
                return (0, dom_1.waitFor)(() => {
                    return super.getAll(selector, options);
                }, { timeout: this.getTimeBudget(options?.timeout) });
            }
        });
        (0, bindUniDriverApiMethods_1.bindUniDriverApiMethods)(this);
    }
    driverSpecificMethod() {
        return 'test';
    }
}
exports.UniDriverClass = UniDriverClass;
//# sourceMappingURL=UniDriverClass.js.map