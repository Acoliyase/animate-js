import { AbstractComponentBuilder } from './AbstractComponentBuilder';

export class SegmentedToggleComponentBuilder extends AbstractComponentBuilder<'SegmentedToggle'> {
  #positiveButtonId = 'positive' as const;
  #negativeButtonId = 'negative' as const;

  constructor(id: string) {
    super(id, 'SegmentedToggle');

    this.patch({
      buttons: [
        { id: 'positive', displayName: '' },
        { id: 'negative', displayName: '' },
      ],
    });
  }

  #withButton(id: string, displayName: string) {
    const state = this.state();

    this.patch({
      buttons: state.buttons!.map((button) =>
        button.id === id ? { id: button.id, displayName } : button,
      ),
    });

    return this;
  }

  setPositiveLabel(label: string) {
    return this.#withButton(this.#positiveButtonId, label);
  }

  setNegativeLabel(label: string) {
    return this.#withButton(this.#negativeButtonId, label);
  }

  override isValid() {
    const { buttons } = this.state();
    const ids = new Set(buttons!.map((button) => button.id));

    const validation = this.createValidationResponse()
      .withParentValidation(super.isValid())
      .withCheck('should be defined both positive and negative buttons', () => {
        return (
          ids.size === 2 &&
          ids.has(this.#positiveButtonId) &&
          ids.has(this.#negativeButtonId)
        );
      });

    return validation.validate();
  }
}
