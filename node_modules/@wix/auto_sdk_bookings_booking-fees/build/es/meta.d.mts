import { ListBookingFeesByBookingIdsRequest as ListBookingFeesByBookingIdsRequest$1, ListBookingFeesByBookingIdsResponse as ListBookingFeesByBookingIdsResponse$1, ApplyBookingFeesToOrderRequest as ApplyBookingFeesToOrderRequest$1, ApplyBookingFeesToOrderResponse as ApplyBookingFeesToOrderResponse$1, CollectAppliedBookingFeesRequest as CollectAppliedBookingFeesRequest$1, CollectAppliedBookingFeesResponse as CollectAppliedBookingFeesResponse$1 } from './index.typings.mjs';
import '@wix/sdk-types';

/**
 * Fee for a specific booking that's calculated according to the associated booking policy snapshot ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policy-snapshots/introduction)). Currently, only cancellation fees, including no-show fees, are supported.
 *
 * Wix Bookings automatically applies the cancellation fee to the eCommerce order ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)) if the customer cancels the booking themselves.
 * Cancellation fees aren't automatically applied to an eCommerce order if the business owner cancels the booking in their dashboard on behalf of the customer.
 * You can call Apply Booking Fee to Order ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-fees/apply-booking-fees-to-order) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/pricing/booking-fees/apply-booking-fees-to-order)) to manually apply booking fees to an eCommerce order.
 */
interface BookingFee {
    /**
     * Booking fee ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * ID of the booking associated with the fee.
     * @format GUID
     */
    bookingId?: string | null;
    /** Cancellation fee details. */
    cancellationFee?: CancellationFee;
    /**
     * Information about the *booking policy snapshot*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policy-snapshots/introduction))
     * according to which the fee was created.
     */
    policyDetails?: PolicyDetails;
}
interface CancellationFee {
    /** Price the customer must pay. */
    price?: Money;
    /** Status of the booking fee. */
    status?: BookingFeeStatusWithLiterals;
    /**
     * Information about what triggered the creation of the booking fee.
     * @readonly
     */
    trigger?: TriggerWithLiterals;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
interface Money {
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     * @decimalValue options { gte:0, maxScale:2 }
     */
    value?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative.
     * @maxLength 50
     * @readonly
     */
    formattedValue?: string | null;
}
declare enum BookingFeeStatus {
    /** There is no eCommerce order associated with the booking. */
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** The fee is informational only; the customer doesn't have to pay it. For example, it shows how much the customer would owe if they canceled the booking now. */
    PREVIEW = "PREVIEW",
    /** The booking fee hasn't been added to the eCommerce order yet. */
    NOT_YET_APPLIED_TO_ORDER = "NOT_YET_APPLIED_TO_ORDER",
    /** The booking fee has been added to the eCommerce order. The customer may not have paid it yet. */
    APPLIED_TO_ORDER = "APPLIED_TO_ORDER"
}
/** @enumType */
type BookingFeeStatusWithLiterals = BookingFeeStatus | 'UNKNOWN_STATUS' | 'PREVIEW' | 'NOT_YET_APPLIED_TO_ORDER' | 'APPLIED_TO_ORDER';
/** The domain event that triggered the booking fee calculation. */
declare enum Trigger {
    /** There is no information about what triggered the creation of the booking fee. */
    UNKNOWN_TRIGGER = "UNKNOWN_TRIGGER",
    /** The booking fee was created because the customer didn't show up to the booking or canceled after the expiration of the last cancellation window. */
    NOT_ATTENDED = "NOT_ATTENDED",
    /** The booking fee was created because the customer canceled the booking before the expiration of the last cancellation window. */
    BOOKING_CANCELED = "BOOKING_CANCELED"
}
/** @enumType */
type TriggerWithLiterals = Trigger | 'UNKNOWN_TRIGGER' | 'NOT_ATTENDED' | 'BOOKING_CANCELED';
interface PolicyDetails {
    /**
     * ID of the booking policy.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * Description of the booking policy.
     * @maxLength 2500
     */
    description?: string | null;
    /**
     * Translated description of the booking policy according to the buyer language of the eCommerce order.
     * @maxLength 2500
     */
    descriptionTranslated?: string | null;
}
interface FailedToApplyBookingFeeToOrder {
    /** Booking fee which couldn't to be applied to the eCommerce order. */
    bookingFee?: BookingFee;
    /**
     * IDs of the booking fees that are related to the booking fee which couldn't be
     * applied to the eCommerce order.
     * @format GUID
     * @maxSize 4
     */
    relatedBookingFeeIds?: string[];
    /** Information about the affected eCommerce order. */
    ecomOrderInfo?: EcomOrderInfo;
    /**
     * Information about whether to notify the business about failing to apply the
     * booking fees to the eCommerce order and the message to send.
     */
    businessNotification?: BusinessNotification;
}
interface EcomOrderInfo {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string | null;
    /** Additional fee price. */
    additionalFeePrice?: Price;
    /**
     * The eCommerce additional fee id that was created on the order.
     * @format GUID
     */
    additionalFeeId?: string | null;
}
interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:2 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     * @maxLength 100
     */
    formattedAmount?: string;
}
interface BusinessNotification {
    /**
     * Whether to notify the business about changes made to the booking fees.
     * Default is false.
     */
    notifyBusiness?: boolean | null;
    /**
     * Optional custom message to send.
     * @minLength 1
     * @maxLength 5000
     */
    message?: string | null;
}
interface FailedToCollectAppliedBookingFees {
    /**
     * IDs of the bookings for which the booking fees couldn't be collected from the
     * customer.
     * @format GUID
     * @maxSize 4
     */
    bookingIds?: string[];
    /** Information about the affected eCommerce order. */
    ecomOrderInfo?: EcomOrderInfo;
    /**
     * Information about whether to notify the business about failing to collect the
     * booking fees from the customer and the message to send.
     */
    businessNotification?: BusinessNotification;
}
interface ListBookingFeesByBookingIdsRequest {
    /**
     * IDs of the bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 5
     */
    bookingIds?: string[];
    /**
     * IDs of the multi service bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 1
     */
    multiServiceBookingIds?: string[];
}
interface ListBookingFeesByBookingIdsResponse {
    /** List of retrieved booking fees. */
    bookingFees?: BookingFee[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface ApplyBookingFeesToOrderRequest {
    /**
     * IDs of the bookings for which to apply booking fees to an eCommerce order.
     * @format GUID
     * @minSize 1
     * @maxSize 5
     */
    bookingIds: string[] | null;
    /**
     * Custom price override for the additional fee that's added to the eCommerce
     * order. The override mustn't exceed the sum of all booking fees. You must have
     * the `OVERRIDE_BOOKING_FEE_PRICE` permission to use this property.
     */
    priceOverride?: Money;
    /**
     * Information about the message to the business and whether to send it if the
     * booking fee application to the eCommerce order fails.
     */
    businessNotification?: BusinessNotification;
}
interface ApplyBookingFeesToOrderResponse {
    /**
     * Booking fees that were applied as a single additional fee to the eCommerce
     * order.
     */
    bookingFees?: BookingFee[];
    /** Information about the eCommerce order to which the booking fees are applied. */
    ecomOrderInfo?: EcomOrderInfo;
}
interface ListNonPreviewBookingFeesByBookingIdsRequest {
    /**
     * IDs of the bookings to retrieve booking fees for.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    bookingIds?: string[];
}
interface ListNonPreviewBookingFeesByBookingIdsResponse {
    /** List of retrieved booking fees. */
    bookingFees?: BookingFee[];
}
interface CollectAppliedBookingFeesRequest {
    /**
     * ID of the eCommerce order that includes the booking fees as a single
     * `additionalFee`.
     * @format GUID
     */
    orderId: string | null;
    /**
     * ID of the additional fee that's related to all given booking fees.
     * @format GUID
     */
    additionalFeeId: string | null;
    /**
     * Information about whether to notify the business about failing to collect the
     * booking fees from the customer and the message to send.
     */
    businessNotification?: BusinessNotification;
}
interface CollectAppliedBookingFeesResponse {
    /** Collected amount. */
    collectedPrice?: Price;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type ListBookingFeesByBookingIdsApplicationErrors = {
    code?: 'MISSING_BOOKING_IDS';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ApplyBookingFeesToOrderApplicationErrors = {
    code?: 'BOOKING_IDS_BELONG_TO_DIFFERENT_ORDERS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRICE_OVERRIDE_EXCEEDS_MAX';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'BOOKING_FEE_ALREADY_APPLIED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'BOOKING_FEE_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_IS_ALREADY_EDITED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PARTIALLY_OR_FULLY_REFUNDED_ORDER_CANNOT_BE_EDITED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_WITH_TAXABLE_EXISTING_ADDITIONAL_FEE_CANNOT_BE_EDITED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_CANNOT_BE_EDITED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'BOOKING_FEE_AND_ORDER_CURRENCIES_ARE_INCONSISTENT';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRICE_OVERRIDE_INSUFFICIENT_PERMISSIONS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'FAILED_CALCULATING_BOOKING_FEE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'FAILED_APPLYING_BOOKING_FEE_TO_ORDER';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'UPDATING_ITEM_WITH_RELATED_DISCOUNT_IS_FORBIDDEN';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'UPDATING_ITEM_WITH_RELATED_ADDITIONAL_FEE_IS_FORBIDDEN';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CollectAppliedBookingFeesApplicationErrors = {
    code?: 'ORDER_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ADDITIONAL_FEE_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'FEE_IS_NOT_BOOKING_FEE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ORDER_BALANCE_NON_POSITIVE';
    description?: string;
    data?: Record<string, any>;
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function listBookingFeesByBookingIds(): __PublicMethodMetaInfo<'GET', {}, ListBookingFeesByBookingIdsRequest$1, ListBookingFeesByBookingIdsRequest, ListBookingFeesByBookingIdsResponse$1, ListBookingFeesByBookingIdsResponse>;
declare function applyBookingFeesToOrder(): __PublicMethodMetaInfo<'POST', {}, ApplyBookingFeesToOrderRequest$1, ApplyBookingFeesToOrderRequest, ApplyBookingFeesToOrderResponse$1, ApplyBookingFeesToOrderResponse>;
declare function collectAppliedBookingFees(): __PublicMethodMetaInfo<'POST', {}, CollectAppliedBookingFeesRequest$1, CollectAppliedBookingFeesRequest, CollectAppliedBookingFeesResponse$1, CollectAppliedBookingFeesResponse>;

export { type ActionEvent as ActionEventOriginal, type ApplyBookingFeesToOrderApplicationErrors as ApplyBookingFeesToOrderApplicationErrorsOriginal, type ApplyBookingFeesToOrderRequest as ApplyBookingFeesToOrderRequestOriginal, type ApplyBookingFeesToOrderResponse as ApplyBookingFeesToOrderResponseOriginal, type BookingFee as BookingFeeOriginal, BookingFeeStatus as BookingFeeStatusOriginal, type BookingFeeStatusWithLiterals as BookingFeeStatusWithLiteralsOriginal, type BusinessNotification as BusinessNotificationOriginal, type CancellationFee as CancellationFeeOriginal, type CollectAppliedBookingFeesApplicationErrors as CollectAppliedBookingFeesApplicationErrorsOriginal, type CollectAppliedBookingFeesRequest as CollectAppliedBookingFeesRequestOriginal, type CollectAppliedBookingFeesResponse as CollectAppliedBookingFeesResponseOriginal, type CursorPagingMetadata as CursorPagingMetadataOriginal, type Cursors as CursorsOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type EcomOrderInfo as EcomOrderInfoOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type FailedToApplyBookingFeeToOrder as FailedToApplyBookingFeeToOrderOriginal, type FailedToCollectAppliedBookingFees as FailedToCollectAppliedBookingFeesOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type ListBookingFeesByBookingIdsApplicationErrors as ListBookingFeesByBookingIdsApplicationErrorsOriginal, type ListBookingFeesByBookingIdsRequest as ListBookingFeesByBookingIdsRequestOriginal, type ListBookingFeesByBookingIdsResponse as ListBookingFeesByBookingIdsResponseOriginal, type ListNonPreviewBookingFeesByBookingIdsRequest as ListNonPreviewBookingFeesByBookingIdsRequestOriginal, type ListNonPreviewBookingFeesByBookingIdsResponse as ListNonPreviewBookingFeesByBookingIdsResponseOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type Money as MoneyOriginal, type PolicyDetails as PolicyDetailsOriginal, type Price as PriceOriginal, type RestoreInfo as RestoreInfoOriginal, Trigger as TriggerOriginal, type TriggerWithLiterals as TriggerWithLiteralsOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, applyBookingFeesToOrder, collectAppliedBookingFees, listBookingFeesByBookingIds };
