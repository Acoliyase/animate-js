import { SearchSpec, Search, NonNullablePaths } from '@wix/sdk-types';

interface Item extends ItemPricingOneOf {
    /** Item price variants. */
    priceVariants?: PriceVariants;
    /** Item price info. */
    priceInfo?: PriceInfo;
    /**
     * Item ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the item is updated. To prevent conflicting changes, the current revision must be passed when updating the item. Ignored when creating a item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the item was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Item name.
     * @minLength 1
     * @maxLength 200
     */
    name?: string;
    /**
     * Item description.
     * @maxLength 1500
     */
    description?: string | null;
    /** Main item image. */
    image?: string;
    /**
     * Additional item images.
     * @maxSize 15
     */
    additionalImages?: string[];
    /**
     * Item labels.
     * @maxSize 10
     */
    labels?: Label[];
    /** Whether the item is visible in the menu for site visitors. */
    visible?: boolean | null;
    /**
     * Whether the item is marked as featured/best seller.
     * Default: `false`.
     */
    featured?: boolean | null;
    /** Online order settings. */
    orderSettings?: OrderSettings;
    /**
     * Item modifier groups.
     * @maxSize 20
     */
    modifierGroups?: ModifierGroup[];
    /** Extended fields. */
    extendedFields?: ExtendedFields;
    /**
     * IDs of the business locations ([SDK](https://dev.wix.com/docs/sdk/backend-modules/restaurants/wix-restaurants-new/about-business-locations) | [REST](https://dev.wix.com/docs/rest/business-solutions/restaurants/wix-restaurants-new/about-business-locations)) where these items are available.
     * @maxSize 100
     * @format GUID
     * @readonly
     */
    businessLocationIds?: string[];
}
/** @oneof */
interface ItemPricingOneOf {
    /** Item price variants. */
    priceVariants?: PriceVariants;
    /** Item price info. */
    priceInfo?: PriceInfo;
}
interface PriceVariants {
    /**
     * List of price variants.
     * @maxSize 50
     */
    variants?: PriceVariant[];
}
interface PriceVariant {
    /**
     * Price variant ID.
     * @format GUID
     */
    variantId?: string | null;
    /**
     * Price of a variant.
     * @decimalValue options { gte:0.00, maxScale:3 }
     * @deprecated Price of a variant.
     * @replacedBy pricing.price_variants.variants.price_info
     * @targetRemovalDate 2024-08-01
     */
    price?: string | null;
    /** Price info of a variant. */
    priceInfo?: PriceInfo;
}
interface PriceInfo {
    /**
     * Price.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    price?: string;
}
interface Label {
    /**
     * Item label ID.
     * @format GUID
     */
    _id?: string;
}
interface OrderSettings {
    /**
     * Whether the item is in stock.
     * Default: `true`.
     */
    inStock?: boolean | null;
    /**
     * Whether a customer can add a special request when ordering this item.
     * Default: `true`.
     */
    acceptSpecialRequests?: boolean | null;
}
interface Availability extends AvailabilityAvailabilityTypeOptionsOneOf {
    /** Settings for availability on a weekly schedule. */
    weeklyScheduleOptions?: WeeklyScheduleOptions;
    /** Settings for availability within a time range. */
    timestampRangesOptions?: TimestampRangesOptions;
    /** Availability type. */
    type?: AvailabilityTypeWithLiterals;
}
/** @oneof */
interface AvailabilityAvailabilityTypeOptionsOneOf {
    /** Settings for availability on a weekly schedule. */
    weeklyScheduleOptions?: WeeklyScheduleOptions;
    /** Settings for availability within a time range. */
    timestampRangesOptions?: TimestampRangesOptions;
}
declare enum AvailabilityType {
    /** Missing type due to an error. */
    UNSPECIFIED_AVAILABILITY_OPTION = "UNSPECIFIED_AVAILABILITY_OPTION",
    /** Available all the time. */
    ALWAYS_AVAILABLE = "ALWAYS_AVAILABLE",
    /** Available on specific days and times throughout the week. */
    WEEKLY_SCHEDULE = "WEEKLY_SCHEDULE",
    /** Available during a specific time range. */
    TIMESTAMP_RANGES = "TIMESTAMP_RANGES"
}
/** @enumType */
type AvailabilityTypeWithLiterals = AvailabilityType | 'UNSPECIFIED_AVAILABILITY_OPTION' | 'ALWAYS_AVAILABLE' | 'WEEKLY_SCHEDULE' | 'TIMESTAMP_RANGES';
interface WeeklyScheduleOptions {
    /**
     * List of available time ranges for specific days of the week.
     * @maxSize 7
     */
    availableTimes?: DayOfWeekAvailability[];
}
interface DayOfWeekAvailability {
    /** The day of week this availability relates to. */
    dayOfWeek?: EntitiesDayOfWeekWithLiterals;
    /** A list of time ranges during which the fulfillment should be available. */
    timeRanges?: TimeOfDayRange[];
}
declare enum EntitiesDayOfWeek {
    /** Monday. */
    MON = "MON",
    /** Tuesday. */
    TUE = "TUE",
    /** Wednesday. */
    WED = "WED",
    /** Thursday. */
    THU = "THU",
    /** Friday. */
    FRI = "FRI",
    /** Saturday. */
    SAT = "SAT",
    /** Sunday. */
    SUN = "SUN"
}
/** @enumType */
type EntitiesDayOfWeekWithLiterals = EntitiesDayOfWeek | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT' | 'SUN';
interface TimeOfDayRange {
    /** The start time in time of day representation. */
    startTime?: TimeOfDay;
    /** The end time in time of day representation. */
    endTime?: TimeOfDay;
}
interface TimeOfDay {
    /**
     * Hours. <br />
     * Min: `0`. <br />
     * Max: `23`.
     */
    hours?: number;
    /**
     * Minutes. <br />
     * Min: `0`. <br />
     * Max: `23`.
     */
    minutes?: number;
}
interface TimestampRangesOptions {
    /**
     * List of available time ranges.
     * @maxSize 50
     */
    ranges?: AvailableRange[];
}
interface AvailableRange {
    /** The start time of the availability in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#combined_date_and_time_representations) format. */
    startTime?: Date | null;
    /** The end time of the availability in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#combined_date_and_time_representations) format. */
    endTime?: Date | null;
}
interface ModifierGroup {
    /**
     * Modifier group ID.
     * @format GUID
     */
    _id?: string | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface ExternalReferenceInfo {
    /**
     * ID of the external integrator app\system associated with this object.
     * @format GUID
     */
    externalAppId?: string | null;
    /**
     * Reference to an external resource ID. Used to link this object to a specific entity in an external system.
     * @maxLength 100
     */
    externalEntityId?: string | null;
    /** Last time this item was synced with the external app. */
    lastSyncDate?: Date | null;
    /** Whether the connection to the external system is currently active. */
    connected?: boolean | null;
}
interface DuplicateItemRequest {
    /**
     * Item id to be duplicated.
     * @format GUID
     */
    _id: string;
    /**
     * Business location ids to duplicate the item to.
     * @format GUID
     * @maxSize 100
     */
    businessLocationIds?: string[] | null;
}
interface DuplicateItemResponse {
    /** @format GUID */
    itemId?: string[];
}
interface UpdateDocumentsEvent extends UpdateDocumentsEventOperationOneOf {
    /** insert/update documents */
    update?: DocumentUpdateOperation;
    /** delete by document ids */
    deleteByIds?: DeleteByIdsOperation;
    /** delete documents matching filter */
    deleteByFilter?: DeleteByFilterOperation;
    /** update documents matching filter */
    updateByFilter?: UpdateByFilterOperation;
    /** update only existing documents */
    updateExisting?: UpdateExistingOperation;
    /**
     * application which owns documents
     * @minLength 2
     */
    appDefId?: string | null;
    /**
     * type of the documents
     * @minLength 2
     */
    documentType?: string | null;
    /**
     * language of the documents
     * @minLength 2
     */
    language?: string | null;
    /**
     * site documents belong to
     * @minLength 2
     */
    msId?: string | null;
}
/** @oneof */
interface UpdateDocumentsEventOperationOneOf {
    /** insert/update documents */
    update?: DocumentUpdateOperation;
    /** delete by document ids */
    deleteByIds?: DeleteByIdsOperation;
    /** delete documents matching filter */
    deleteByFilter?: DeleteByFilterOperation;
    /** update documents matching filter */
    updateByFilter?: UpdateByFilterOperation;
    /** update only existing documents */
    updateExisting?: UpdateExistingOperation;
}
interface DocumentUpdateOperation {
    /** documents to index or update */
    documents?: IndexDocument[];
}
interface IndexDocument {
    /** data bag with non-searchable fields (url, image) */
    payload?: DocumentPayload;
    /** what type of users should documents be visible to */
    exposure?: EnumWithLiterals;
    /** document with mandatory fields (id, title, description) and with fields specific to the type of the document */
    document?: Record<string, any> | null;
    /** what member groups is the document exposed to. Used only with GROUP_PROTECTED exposure */
    permittedMemberGroups?: string[];
    /** if true SEO is disabled for this document */
    seoHidden?: boolean | null;
    /** if true the page is a lightbox popup */
    isPopup?: boolean | null;
}
interface DocumentPayload {
    /** url of the page representing the document */
    url?: string | null;
    /** image which represents the document */
    documentImage?: DocumentImage;
}
interface DocumentImage {
    /** the name of the image */
    name?: string;
    /** the width of the image */
    width?: number;
    /** the height of the image */
    height?: number;
}
declare enum Enum {
    /** Default value. Means that permission not set */
    UNKNOWN = "UNKNOWN",
    /** Protected exposure. Exposed to members and owners */
    PROTECTED = "PROTECTED",
    /** Private exposure. Exposed to owners */
    PRIVATE = "PRIVATE",
    /** Public exposure. Visible to everyone */
    PUBLIC = "PUBLIC",
    /** Used for partial updates, to state that exposure is not changing */
    UNCHANGED = "UNCHANGED",
    /** Protected to members of permitted groups and owners */
    GROUP_PROTECTED = "GROUP_PROTECTED"
}
/** @enumType */
type EnumWithLiterals = Enum | 'UNKNOWN' | 'PROTECTED' | 'PRIVATE' | 'PUBLIC' | 'UNCHANGED' | 'GROUP_PROTECTED';
interface DeleteByIdsOperation {
    /** ids of the documents to delete */
    documentIds?: string[];
}
interface DeleteByFilterOperation {
    /** documents matching this filter wil be deleted. only filterable documents defined in document_type can be used for filtering */
    filter?: Record<string, any> | null;
}
interface UpdateByFilterOperation {
    /** documents matching this filter will be updated */
    filter?: Record<string, any> | null;
    /** partial document to apply */
    document?: IndexDocument;
}
interface UpdateExistingOperation {
    /** documents to update */
    documents?: IndexDocument[];
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface SearchIndexingNotification {
    /** new state of indexing for the site specified in ms_id */
    indexState?: StateWithLiterals;
    /** type of the document the notification is targeted for. Applies to all types if not provided */
    documentType?: string | null;
    /** languaInternalDocumentUpdateByFilterOperationge the notification is targeted for. Applies to all languages if not provided */
    language?: string | null;
    /**
     * site for which notification is targeted
     * @minLength 2
     */
    msId?: string | null;
}
declare enum State {
    /** default state */
    Unknown = "Unknown",
    /** metasite does not require site search indexing */
    Off = "Off",
    /** metasite requires site search indexing */
    On = "On"
}
/** @enumType */
type StateWithLiterals = State | 'Unknown' | 'Off' | 'On';
/** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
interface SitePropertiesNotification {
    /** The site ID for which this update notification applies. */
    metasiteId?: string;
    /** The actual update event. */
    event?: SitePropertiesEvent;
    /**
     * A convenience set of mappings from the MetaSite ID to its constituent services.
     * @maxSize 500
     */
    translations?: Translation[];
    /** Context of the notification */
    changeContext?: ChangeContext;
}
/** The actual update event for a particular notification. */
interface SitePropertiesEvent {
    /** Version of the site's properties represented by this update. */
    version?: number;
    /** Set of properties that were updated - corresponds to the fields in "properties". */
    fields?: string[];
    /** Updated properties. */
    properties?: Properties;
}
interface Properties {
    /** Site categories. */
    categories?: Categories;
    /** Site locale. */
    locale?: Locale;
    /**
     * Site language.
     *
     * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
     */
    language?: string | null;
    /**
     * Site currency format used to bill customers.
     *
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    paymentCurrency?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Fax number. */
    fax?: string | null;
    /** Address. */
    address?: Address;
    /** Site display name. */
    siteDisplayName?: string | null;
    /** Business name. */
    businessName?: string | null;
    /** Path to the site's logo in Wix Media (without Wix Media base URL). */
    logo?: string | null;
    /** Site description. */
    description?: string | null;
    /**
     * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /** Supported languages of a site and the primary language. */
    multilingual?: Multilingual;
    /** Cookie policy the Wix user defined for their site (before the site visitor interacts with/limits it). */
    consentPolicy?: ConsentPolicy;
    /**
     * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
     *
     * Site business type.
     */
    businessConfig?: string | null;
    /** External site URL that uses Wix as its headless business solution. */
    externalSiteUrl?: string | null;
    /** Track clicks analytics. */
    trackClicksAnalytics?: boolean;
}
interface Categories {
    /** Primary site category. */
    primary?: string;
    /**
     * Secondary site category.
     * @maxSize 50
     */
    secondary?: string[];
    /** Business Term Id */
    businessTermId?: string | null;
}
interface Locale {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
    country?: string;
}
interface Address {
    /** Street name. */
    street?: string;
    /** City name. */
    city?: string;
    /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
    country?: string;
    /** State. */
    state?: string;
    /**
     * Zip or postal code.
     * @maxLength 20
     */
    zip?: string;
    /** Extra information to be displayed in the address. */
    hint?: AddressHint;
    /** Whether this address represents a physical location. */
    isPhysical?: boolean;
    /** Google-formatted version of this address. */
    googleFormattedAddress?: string;
    /** Street number. */
    streetNumber?: string;
    /** Apartment number. */
    apartmentNumber?: string;
    /** Geographic coordinates of location. */
    coordinates?: GeoCoordinates;
}
/**
 * Extra information on displayed addresses.
 * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
 * Free text. In addition, the user can state where to display the additional description - before, after, or instead of the address string.
 */
interface AddressHint {
    /** Extra text displayed next to, or instead of, the actual address. */
    text?: string;
    /** Where the extra text should be displayed. */
    placement?: PlacementTypeWithLiterals;
}
/** Where the extra text should be displayed: before, after or instead of the actual address. */
declare enum PlacementType {
    BEFORE = "BEFORE",
    AFTER = "AFTER",
    REPLACE = "REPLACE"
}
/** @enumType */
type PlacementTypeWithLiterals = PlacementType | 'BEFORE' | 'AFTER' | 'REPLACE';
/** Geocoordinates for a particular address. */
interface GeoCoordinates {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number;
}
/** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
interface BusinessSchedule {
    /**
     * Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods.
     * @maxSize 100
     */
    periods?: TimePeriod[];
    /**
     * Exceptions to the business's regular hours. The business can be open or closed during the exception.
     * @maxSize 100
     */
    specialHourPeriod?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the business is regularly open or the service is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     *
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
/** Enumerates the days of the week. */
declare enum DayOfWeek {
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY",
    SUNDAY = "SUNDAY"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /**
     * Whether the business is closed (or the service is not available) during the exception.
     *
     * Default: `true`.
     */
    isClosed?: boolean;
    /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
    comment?: string;
}
interface Multilingual {
    /**
     * Supported languages list.
     * @maxSize 200
     */
    supportedLanguages?: SupportedLanguage[];
    /** Whether to redirect to user language. */
    autoRedirect?: boolean;
}
interface SupportedLanguage {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Locale. */
    locale?: Locale;
    /** Whether the supported language is the primary language for the site. */
    isPrimary?: boolean;
    /** Language icon. */
    countryCode?: string;
    /** How the language will be resolved. For internal use. */
    resolutionMethod?: ResolutionMethodWithLiterals;
    /** Whether the supported language is the primary language for site visitors. */
    isVisitorPrimary?: boolean | null;
}
declare enum ResolutionMethod {
    QUERY_PARAM = "QUERY_PARAM",
    SUBDOMAIN = "SUBDOMAIN",
    SUBDIRECTORY = "SUBDIRECTORY"
}
/** @enumType */
type ResolutionMethodWithLiterals = ResolutionMethod | 'QUERY_PARAM' | 'SUBDOMAIN' | 'SUBDIRECTORY';
interface ConsentPolicy {
    /** Whether the site uses cookies that are essential to site operation. Always `true`. */
    essential?: boolean | null;
    /** Whether the site uses cookies that affect site performance and other functional measurements. */
    functional?: boolean | null;
    /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
    analytics?: boolean | null;
    /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
    advertising?: boolean | null;
    /** CCPA compliance flag. */
    dataToThirdParty?: boolean | null;
}
/** A single mapping from the MetaSite ID to a particular service. */
interface Translation {
    /** The service type. */
    serviceType?: string;
    /** The application definition ID; this only applies to services of type ThirdPartyApps. */
    appDefId?: string;
    /** The instance ID of the service. */
    instanceId?: string;
}
interface ChangeContext extends ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
/** @oneof */
interface ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
interface PropertiesChange {
}
interface SiteCreated {
    /** Origin template site id. */
    originTemplateId?: string | null;
}
interface SiteCloned {
    /** Origin site id. */
    originMetaSiteId?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
    /**
     * tell us why you're invalidating the cache. You don't need to add your app name
     * @maxLength 256
     */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
}
interface App {
    /**
     * The AppDefId
     * @minLength 1
     */
    appDefId?: string;
    /**
     * The instance Id
     * @format GUID
     */
    instanceId?: string;
}
interface Page {
    /**
     * the msid the page is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Page ID
     * @minLength 1
     */
    pageId?: string;
}
interface URI {
    /**
     * the msid the URI is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes
     * @minLength 1
     */
    uriPath?: string;
}
interface File {
    /**
     * the msid the file is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by filename (for media files such as PDFs)
     * @minLength 1
     * @maxLength 256
     */
    fileName?: string;
}
interface CustomTag {
    /**
     * the msid the tag is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Tag to invalidate by
     * @minLength 1
     * @maxLength 256
     */
    tag?: string;
}
interface DeleteLocationIdsFromVariants {
    /**
     * @format GUID
     * @maxSize 100
     */
    businessLocationIds?: string[];
    /**
     * @format GUID
     * @maxSize 1000
     */
    variantIds?: string[];
}
interface DeleteLocationIdsFromModifierGroups {
    /**
     * @format GUID
     * @maxSize 100
     */
    businessLocationIds?: string[];
    /**
     * @format GUID
     * @maxSize 1000
     */
    modifierGroupIds?: string[];
}
interface CreateItemRequest {
    /** Item details. */
    item: Item;
}
interface CreateItemResponse {
    /** Item. */
    item?: Item;
}
interface BulkCreateItemsRequest {
    /**
     * Items details.
     * @maxSize 100
     */
    items: Item[];
    /** Whether to return entity in the response. */
    returnEntity?: boolean;
}
interface BulkCreateItemsResponse {
    /** Information about the created items. */
    results?: BulkCreateItemResult[];
    /** Metadata for the API call. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCreateItemResult {
    /** Metadata for item update. */
    itemMetadata?: ItemMetadata;
    /** Created item. */
    item?: Item;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface GetItemRequest {
    /**
     * Item ID.
     * @format GUID
     */
    itemId: string;
}
interface GetItemResponse {
    /** Item. */
    item?: Item;
}
interface ListItemsRequest {
    /** Item IDs. */
    itemIds?: string[];
    /** The metadata of the paginated results. */
    paging?: CursorPaging;
    /** Whether to return only items that are visible to site visitors. */
    onlyVisible?: boolean | null;
}
interface CursorPaging {
    /**
     * Number of items to load.
     * @max 500
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface ListItemsResponse {
    /** Items. */
    items?: Item[];
    /** The metadata of the paginated results. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    cursors?: Cursors;
    /**
     * Indicates if there are more results after the current page.
     * If `true`, another page of results can be retrieved.
     * If `false`, this is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
interface QueryItemsRequest {
    /** Query options. */
    query?: CursorQuery;
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface QueryItemsResponse {
    /** Retrieved items. */
    items?: Item[];
    /** The metadata of the paginated results. */
    pagingMetadata?: CursorPagingMetadata;
}
interface SearchItemsRequest {
    /** Search options. */
    search?: CursorSearch;
}
interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about cursor paging ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#cursor-paging) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging)).
     */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about filtering ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#the-filter-object) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters)).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about sorting ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#the-sort-array) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting)).
     */
    sort?: Sorting[];
    /** Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories. */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about cursor paging ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#cursor-paging) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging)).
     */
    cursorPaging?: CursorPaging;
}
interface Aggregation extends AggregationKindOneOf {
    /** A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store. */
    value?: ValueAggregation;
    /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. */
    range?: RangeAggregation;
    /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    scalar?: ScalarAggregation;
    /** Aggregation name, returned in `aggregations.results.name`. */
    name?: string | null;
    /** Type of aggregation to perform. Must align with the corresponding aggregation field. */
    type?: AggregationTypeWithLiterals;
    /** Field to aggreg   ate by. Use dot notation to specify a JSON path. For example, `order.address.streetName`. */
    fieldPath?: string;
}
/** @oneof */
interface AggregationKindOneOf {
    /** A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store. */
    value?: ValueAggregation;
    /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. */
    range?: RangeAggregation;
    /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    scalar?: ScalarAggregation;
}
interface RangeBucket {
    /** Inclusive lower bound of the range. Required if `to` is not provided. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if `from` is not provided. */
    to?: number | null;
}
declare enum SortType {
    /** Number of matches in the results. */
    COUNT = "COUNT",
    /** Alphabetically by the field value. */
    VALUE = "VALUE"
}
/** @enumType */
type SortTypeWithLiterals = SortType | 'COUNT' | 'VALUE';
declare enum SortDirection {
    /** Descending order. */
    DESC = "DESC",
    /** Ascending order. */
    ASC = "ASC"
}
/** @enumType */
type SortDirectionWithLiterals = SortDirection | 'DESC' | 'ASC';
declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Total number of distinct values. */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value. */
    MIN = "MIN",
    /** Maximum value. */
    MAX = "MAX"
}
/** @enumType */
type ScalarTypeWithLiterals = ScalarType | 'UNKNOWN_SCALAR_TYPE' | 'COUNT_DISTINCT' | 'MIN' | 'MAX';
declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** Calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. */
    VALUE = "VALUE",
    /** Calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. */
    RANGE = "RANGE",
    /** Calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
    SCALAR = "SCALAR"
}
/** @enumType */
type AggregationTypeWithLiterals = AggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR';
interface ValueAggregation {
    /** Sort type. */
    sortType?: SortTypeWithLiterals;
    /** Sort direction. */
    sortDirection?: SortDirectionWithLiterals;
    /**
     * Number of aggregation results to return.
     * Min: `1`
     * Max: `250`
     * Default: `10`
     */
    limit?: number | null;
}
interface RangeAggregation {
    /** List of range buckets. During aggregation each entity is placed in the first bucket its value falls into, based on the provided range bounds. */
    buckets?: RangeBucket[];
}
interface ScalarAggregation {
    /** Type of scalar aggregation. */
    type?: ScalarTypeWithLiterals;
}
interface SearchDetails {
    /** Search mode. Defines the search logic for combining multiple terms in the `expression`. */
    mode?: ModeWithLiterals;
    /** Search term or expression. */
    expression?: string | null;
    /** Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `order.address.streetName`. */
    fields?: string[];
    /** Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions. */
    fuzzy?: boolean;
}
declare enum Mode {
    /** At least one of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
/** @enumType */
type ModeWithLiterals = Mode | 'OR' | 'AND';
interface SearchItemsResponse {
    /** Retrieved items. */
    items?: Item[];
    /** The metadata of the paginated results. */
    pagingMetadata?: CursorPagingMetadata;
    /** The metadata of the search results. */
    aggregationData?: AggregationData;
}
interface AggregationData {
    /** List of the aggregated data results. */
    results?: AggregationResults[];
}
interface ValueAggregationResult {
    /** Value of the field. */
    value?: string;
    /** Number of entities with this value. */
    count?: number;
}
interface RangeAggregationResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Total number of entities in this range. */
    count?: number;
}
interface ValueResults {
    /** List of value aggregations. */
    results?: ValueAggregationResult[];
}
interface RangeResults {
    /** List of ranges returned in the same order as requested. */
    results?: RangeAggregationResult[];
}
interface ScalarResult {
    /** Type of scalar aggregation. */
    type?: ScalarTypeWithLiterals;
    /** Value of the scalar aggregation. */
    value?: number;
}
interface AggregationResults extends AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: ScalarResult;
    /** Aggregation name, returned in `aggregations.results.name`. */
    name?: string;
    /** Type of aggregation to perform. Must align with the corresponding aggregation field. */
    type?: AggregationTypeWithLiterals;
}
/** @oneof */
interface AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: ScalarResult;
}
interface CountItemsRequest {
    /** Filter for counting items. */
    filter?: Record<string, any> | null;
    /** Search details. */
    searchDetails?: SearchDetails;
}
interface CountItemsResponse {
    /** Counted items. */
    count?: number;
}
interface UpdateItemRequest {
    /** Item to update. */
    item: Item;
}
interface UpdateItemResponse {
    /** Updated item. */
    item?: Item;
}
interface BulkUpdateItemRequest {
    /**
     * Items to update.
     * @minSize 1
     * @maxSize 100
     */
    items: MaskedItem[];
    /** Whether to return entity in the response. */
    returnEntity?: boolean;
}
interface MaskedItem {
    /** Item to update. */
    item?: Item;
    /** Explicit list of fields to update. */
    mask?: string[];
}
interface BulkUpdateItemResponse {
    /**
     * Information about the updated items.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkUpdateItemResponseBulkItemResult[];
    /** Metadata for the API call. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkUpdateItemResponseBulkItemResult {
    /** Metadata for item update. */
    itemMetadata?: ItemMetadata;
    /** Updated item. Only returned if `returnEntity` is set to `true`. */
    item?: Item;
}
interface DeleteItemRequest {
    /**
     * Item ID.
     * @format GUID
     */
    itemId: string;
}
interface DeleteItemResponse {
}
interface BulkDeleteItemsRequest {
    /**
     * Item IDs.
     * @format GUID
     */
    ids: string[];
}
interface BulkDeleteItemsResponse {
    /** Information about the deleted items. */
    results?: BulkDeleteItemResult[];
    /** Metadata for the API call. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkDeleteItemResult {
    /** Metadata for item delete. */
    itemMetadata?: ItemMetadata;
}
interface CloneItemsRequest {
    /**
     * The MetaSiteId to clone from.
     * @format GUID
     */
    metaSiteId?: string;
}
interface CloneItemsResponse {
}
interface BulkUpdateBusinessLocationIdsRequest {
    /**
     * item ids
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    itemIds?: string[];
    /**
     * Business Location Ids.
     * @maxSize 100
     * @format GUID
     */
    businessLocationIds?: string[];
}
interface BulkUpdateBusinessLocationIdsResponse {
    /**
     * Information about the updated items.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkUpdateBusinessLocationIdsResponseBulkItemResult[];
}
interface BulkUpdateBusinessLocationIdsResponseBulkItemResult {
    /** Metadata for item update. */
    itemMetadata?: ItemMetadata;
}
interface BulkUpdateBusinessLocationIdsPerEntityRequest {
    /**
     * @minSize 1
     * @maxSize 100
     */
    itemIdLocationIds?: ItemIdLocationIds[];
}
interface ItemIdLocationIds {
    /**
     * item ID
     * @format GUID
     */
    itemId?: string;
    /**
     * Business Location IDs
     * @maxSize 100
     * @format GUID
     */
    businessLocationIds?: string[];
}
interface BulkUpdateBusinessLocationIdsPerEntityResponse {
    /**
     * Information about the updated items.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkItemResult[];
}
interface BulkItemResult {
    /** Metadata for item update. */
    itemMetadata?: ItemMetadata;
}
interface SyncContentToMultilingualRequest {
    /**
     * MetaSite ID
     * @format GUID
     */
    metaSiteId?: string;
}
interface SyncContentToMultilingualResponse {
}
/** @docsIgnore */
type CountItemsApplicationErrors = {
    code?: 'TOO_MANY_TO_COUNT';
    description?: string;
    data?: Record<string, any>;
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface ItemCreatedEnvelope {
    entity: Item;
    metadata: EventMetadata;
}
/** @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId RESTAURANTS.ITEM_READ
 * @webhook
 * @eventType wix.restaurants.menus.v1.item_created
 * @serviceIdentifier com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem
 * @slug created
 * @documentationMaturity preview
 */
declare function onItemCreated(handler: (event: ItemCreatedEnvelope) => void | Promise<void>): void;
interface ItemDeletedEnvelope {
    entity: Item;
    metadata: EventMetadata;
}
/** @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId RESTAURANTS.ITEM_READ
 * @webhook
 * @eventType wix.restaurants.menus.v1.item_deleted
 * @serviceIdentifier com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem
 * @slug deleted
 * @documentationMaturity preview
 */
declare function onItemDeleted(handler: (event: ItemDeletedEnvelope) => void | Promise<void>): void;
interface ItemUpdatedEnvelope {
    entity: Item;
    metadata: EventMetadata;
}
/**
 * Triggered when an item is updated.
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId RESTAURANTS.ITEM_READ
 * @webhook
 * @eventType wix.restaurants.menus.v1.item_updated
 * @serviceIdentifier com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem
 * @slug updated
 * @documentationMaturity preview
 */
declare function onItemUpdated(handler: (event: ItemUpdatedEnvelope) => void | Promise<void>): void;
/** @param _id - Item id to be duplicated.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId RESTAURANTS.ITEM_CREATE
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.restaurants_duplicate_item.RestaurantsDuplicateItem.DuplicateItem
 */
declare function duplicateItem(_id: string, options?: DuplicateItemOptions): Promise<NonNullablePaths<DuplicateItemResponse, `itemId`, 2>>;
interface DuplicateItemOptions {
    /**
     * Business location ids to duplicate the item to.
     * @format GUID
     * @maxSize 100
     */
    businessLocationIds?: string[] | null;
}
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Creates an item.
 *
 * To create multiple items at once, use [Bulk Create Items](https://dev.wix.com/docs/rest/business-solutions/restaurants/menus/item/bulk-create-items).
 * @param item - Item details.
 * @public
 * @documentationMaturity preview
 * @requiredField item
 * @requiredField item.modifierGroups._id
 * @permissionId RESTAURANTS.ITEM_CREATE
 * @applicableIdentity APP
 * @returns Item.
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.CreateItem
 */
declare function createItem(item: NonNullablePaths<Item, `modifierGroups.${number}._id`, 4>): Promise<NonNullablePaths<Item, `priceVariants.variants` | `priceVariants.variants.${number}.priceInfo.price` | `name` | `additionalImages` | `labels` | `labels.${number}._id` | `modifierGroups` | `businessLocationIds`, 6>>;
/**
 * > **Note:** The Items API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Creates multiple items at once.
 * @param items - Items details.
 * @public
 * @documentationMaturity preview
 * @requiredField items
 * @requiredField items.modifierGroups._id
 * @permissionId RESTAURANTS.ITEM_CREATE
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.BulkCreateItems
 */
declare function bulkCreateItems(items: NonNullablePaths<Item, `modifierGroups.${number}._id`, 4>[], options?: BulkCreateItemsOptions): Promise<NonNullablePaths<BulkCreateItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.priceInfo.price` | `results.${number}.item.name` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkCreateItemsOptions {
    /** Whether to return entity in the response. */
    returnEntity?: boolean;
}
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Retrieves an item by ID.
 * @param itemId - Item ID.
 * @public
 * @documentationMaturity preview
 * @requiredField itemId
 * @permissionId RESTAURANTS.ITEM_READ
 * @applicableIdentity APP
 * @returns Item.
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.GetItem
 */
declare function getItem(itemId: string): Promise<NonNullablePaths<Item, `priceVariants.variants` | `priceVariants.variants.${number}.priceInfo.price` | `name` | `additionalImages` | `labels` | `labels.${number}._id` | `modifierGroups` | `businessLocationIds`, 6>>;
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Retrieves a list of up to 500 items.
 * @public
 * @documentationMaturity preview
 * @permissionId RESTAURANTS.ITEM_READ
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.ListItems
 */
declare function listItems(options?: ListItemsOptions): Promise<NonNullablePaths<ListItemsResponse, `items` | `items.${number}.priceInfo.price` | `items.${number}.name`, 5>>;
interface ListItemsOptions {
    /** Item IDs. */
    itemIds?: string[];
    /** The metadata of the paginated results. */
    paging?: CursorPaging;
    /** Whether to return only items that are visible to site visitors. */
    onlyVisible?: boolean | null;
}
/**
 * Creates a query to retrieve a list of items.
 *
 * The `queryItems()` function builds a query to retrieve a list of items and returns a `ItemsQueryBuilder` object.
 *
 * The returned object contains the query definition, which is used to run the query using the [`find()`](/items/items-query-builder/find) function.
 *
 * You can refine the query by chaining `ItemsQueryBuilder` functions onto the query. `ItemsQueryBuilder` functions enable you to filter, sort, and control the results that `queryItems()` returns.
 *
 * `queryItems()` runs with the following `ItemsQueryBuilder` defaults, which you can override:
 *
 * * [`limit(500)`](/items/items-query-builder/limit)
 *
 * The following `ItemsQueryBuilder` functions are supported for `queryItems()`. For a full description of the item object, see the object returned for the [`items`](/items/items-query-result/items) property in `ItemsQueryResult`.
 * @public
 * @documentationMaturity preview
 * @permissionId RESTAURANTS.ITEM_READ
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.QueryItems
 */
declare function queryItems(): ItemsQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface ItemsQueryResult extends QueryCursorResult {
    items: Item[];
    query: ItemsQueryBuilder;
    next: () => Promise<ItemsQueryResult>;
    prev: () => Promise<ItemsQueryResult>;
}
interface ItemsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: 'priceVariants.variants.variantId' | 'priceVariants.variants.price' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'visible' | 'featured' | 'orderSettings.inStock' | 'orderSettings.acceptSpecialRequests' | 'modifierGroups.id' | 'businessLocationIds' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId' | 'externalReferenceInfo.connected', value: any) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: 'priceVariants.variants.variantId' | 'priceVariants.variants.price' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'visible' | 'featured' | 'orderSettings.inStock' | 'orderSettings.acceptSpecialRequests' | 'modifierGroups.id' | 'businessLocationIds' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId' | 'externalReferenceInfo.connected', value: any) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: 'priceVariants.variants.variantId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'modifierGroups.id' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId', value: any) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: 'priceVariants.variants.variantId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'modifierGroups.id' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId', value: any) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: 'priceVariants.variants.variantId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'modifierGroups.id' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId', value: any) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: 'priceVariants.variants.variantId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'modifierGroups.id' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId', value: any) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: 'priceVariants.variants.variantId' | '_id' | 'name' | 'description' | 'image.id' | 'labels.id' | 'modifierGroups.id' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId', value: string) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: 'priceVariants.variants.variantId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'visible' | 'featured' | 'modifierGroups.id' | 'businessLocationIds' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId' | 'externalReferenceInfo.connected', value: any[]) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasAll: (propertyName: 'businessLocationIds', value: any[]) => ItemsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: 'priceVariants.variants.variantId' | 'priceVariants.variants.price' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'visible' | 'featured' | 'orderSettings.inStock' | 'orderSettings.acceptSpecialRequests' | 'modifierGroups.id' | 'businessLocationIds' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId' | 'externalReferenceInfo.connected', value: any) => ItemsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: 'priceVariants.variants.variantId' | 'priceVariants.variants.price' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'labels.id' | 'visible' | 'featured' | 'orderSettings.inStock' | 'orderSettings.acceptSpecialRequests' | 'modifierGroups.id' | 'businessLocationIds' | 'externalReferenceInfo.externalAppId' | 'externalReferenceInfo.externalEntityId' | 'externalReferenceInfo.connected', value: boolean) => ItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'priceVariants.variants.price' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'visible' | 'featured' | 'orderSettings.inStock' | 'orderSettings.acceptSpecialRequests' | 'orderSettings.taxGroupId' | 'oloMigrationItemId' | 'businessLocationIds'>) => ItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'priceVariants.variants.price' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'image.id' | 'visible' | 'featured' | 'orderSettings.inStock' | 'orderSettings.acceptSpecialRequests' | 'orderSettings.taxGroupId' | 'oloMigrationItemId' | 'businessLocationIds'>) => ItemsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => ItemsQueryBuilder;
    /** @param cursor - A pointer to specific record
     * @documentationMaturity preview
     */
    skipTo: (cursor: string) => ItemsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<ItemsQueryResult>;
}
interface ItemSearchSpec extends SearchSpec {
    searchable: ['name'];
    aggregatable: [
        '_createdDate',
        '_id',
        '_updatedDate',
        'businessLocationIds',
        'featured',
        'image._id',
        'labels._id',
        'modifierGroups._id',
        'name',
        'orderSettings.inStock',
        'visible'
    ];
    paging: 'cursor';
    wql: [
        {
            operators: ['$hasAll', '$hasSome'];
            fields: ['businessLocationIds', 'labels._id', 'modifierGroups._id'];
            sort: 'BOTH';
        },
        {
            operators: '*';
            fields: [
                '_createdDate',
                '_id',
                '_updatedDate',
                'featured',
                'image._id',
                'name',
                'orderSettings.inStock',
                'visible'
            ];
            sort: 'BOTH';
        }
    ];
}
type CommonSearchWithEntityContext = Search<Item, ItemSearchSpec>;
type ItemSearch = {
    /**
    Cursor paging options.
  
    Learn more about cursor paging ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#cursor-paging) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging)).
    */
    cursorPaging?: {
        /**
      Number of items to load.
      @max: 500
      */
        limit?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['limit'] | null;
        /**
      Pointer to the next or previous page in the list of results.
    
      You can get the relevant cursor token
      from the `pagingMetadata` object in the previous call's response.
      Not relevant for the first request.
      */
        cursor?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['cursor'] | null;
    };
    /**
    Filter object.
  
    Learn more about filtering ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#the-filter-object) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters)).
    */
    filter?: CommonSearchWithEntityContext['filter'] | null;
    /**
    Sort object.
  
    Learn more about sorting ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#the-sort-array) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting)).
    */
    sort?: {
        /**
      Name of the field to sort by.
      @maxLength: 512
      */
        fieldName?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['fieldName'];
        /**
      Sort order.
      */
        order?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['order'];
    }[];
    /**
    Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
    */
    aggregations?: {
        /**
      A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store.
      */
        value?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['value'];
        /**
      A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more.
      */
        range?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['range'];
        /**
      A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`.
      */
        scalar?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['scalar'];
        /**
      Aggregation name, returned in `aggregations.results.name`.
      */
        name?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['name'] | null;
        /**
      Type of aggregation to perform. Must align with the corresponding aggregation field.
      */
        type?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['type'];
        /**
      Field to aggreg   ate by. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
      */
        fieldPath?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['fieldPath'];
    }[];
    /**
    Free text to match in searchable fields.
    */
    search?: {
        /**
      Search mode. Defines the search logic for combining multiple terms in the `expression`.
      */
        mode?: NonNullable<CommonSearchWithEntityContext['search']>['mode'];
        /**
      Search term or expression.
      */
        expression?: NonNullable<CommonSearchWithEntityContext['search']>['expression'] | null;
        /**
      Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
      */
        fields?: NonNullable<CommonSearchWithEntityContext['search']>['fields'];
        /**
      Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions.
      */
        fuzzy?: NonNullable<CommonSearchWithEntityContext['search']>['fuzzy'];
    };
};
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Retrieves the number of items that match a specified filter.
 *
 * If a filter isn't passed in the request, the endpoint returns the count of all items.
 * @public
 * @documentationMaturity preview
 * @permissionId RESTAURANTS.ITEM_READ
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.CountItems
 */
declare function countItems(options?: CountItemsOptions): Promise<NonNullablePaths<CountItemsResponse, `count`, 2> & {
    __applicationErrorsType?: CountItemsApplicationErrors;
}>;
interface CountItemsOptions {
    /** Filter for counting items. */
    filter?: Record<string, any> | null;
    /** Search details. */
    searchDetails?: SearchDetails;
}
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Updates an item.
 *
 * To update multiple items at once, use [Bulk Update Item](https://dev.wix.com/docs/rest/business-solutions/restaurants/menus/item/bulk-update-item)
 *
 * Each time an item is updated, its revision increments by 1. The existing revision must be included when updating the item. This ensures you're working with the latest item information, and it prevents unintended overwrites.
 * @param _id - Item ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField item
 * @requiredField item.modifierGroups._id
 * @requiredField item.revision
 * @permissionId RESTAURANTS.ITEM_UPDATE
 * @applicableIdentity APP
 * @returns Updated item.
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.UpdateItem
 */
declare function updateItem(_id: string, item: NonNullablePaths<UpdateItem, `modifierGroups.${number}._id` | `revision`, 4>): Promise<NonNullablePaths<Item, `priceVariants.variants` | `priceVariants.variants.${number}.priceInfo.price` | `name` | `additionalImages` | `labels` | `labels.${number}._id` | `modifierGroups` | `businessLocationIds`, 6>>;
interface UpdateItem {
    /** Item price variants. */
    priceVariants?: PriceVariants;
    /** Item price info. */
    priceInfo?: PriceInfo;
    /**
     * Item ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the item is updated. To prevent conflicting changes, the current revision must be passed when updating the item. Ignored when creating a item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the item was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Item name.
     * @minLength 1
     * @maxLength 200
     */
    name?: string;
    /**
     * Item description.
     * @maxLength 1500
     */
    description?: string | null;
    /** Main item image. */
    image?: string;
    /**
     * Additional item images.
     * @maxSize 15
     */
    additionalImages?: string[];
    /**
     * Item labels.
     * @maxSize 10
     */
    labels?: Label[];
    /** Whether the item is visible in the menu for site visitors. */
    visible?: boolean | null;
    /**
     * Whether the item is marked as featured/best seller.
     * Default: `false`.
     */
    featured?: boolean | null;
    /** Online order settings. */
    orderSettings?: OrderSettings;
    /**
     * Item modifier groups.
     * @maxSize 20
     */
    modifierGroups?: ModifierGroup[];
    /** Extended fields. */
    extendedFields?: ExtendedFields;
    /**
     * IDs of the business locations ([SDK](https://dev.wix.com/docs/sdk/backend-modules/restaurants/wix-restaurants-new/about-business-locations) | [REST](https://dev.wix.com/docs/rest/business-solutions/restaurants/wix-restaurants-new/about-business-locations)) where these items are available.
     * @maxSize 100
     * @format GUID
     * @readonly
     */
    businessLocationIds?: string[];
}
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Updates up to 100 multiple items at once.
 *
 * Each time an item is updated, its revision increments by 1. The existing revision must be included when updating item. This ensures you're working with the latest item information, and it prevents unintended overwrites.
 * @param items - Items to update.
 * @public
 * @documentationMaturity preview
 * @requiredField items
 * @requiredField items.item._id
 * @requiredField items.item.modifierGroups._id
 * @requiredField items.item.revision
 * @permissionId RESTAURANTS.ITEM_UPDATE
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.BulkUpdateItem
 */
declare function bulkUpdateItem(items: NonNullablePaths<MaskedItem, `item._id` | `item.modifierGroups.${number}._id` | `item.revision`, 5>[], options?: BulkUpdateItemOptions): Promise<NonNullablePaths<BulkUpdateItemResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.priceInfo.price` | `results.${number}.item.name` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUpdateItemOptions {
    /** Whether to return entity in the response. */
    returnEntity?: boolean;
}
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Deletes an item.
 * @param itemId - Item ID.
 * @public
 * @documentationMaturity preview
 * @requiredField itemId
 * @permissionId RESTAURANTS.ITEM_DELETE
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.DeleteItem
 */
declare function deleteItem(itemId: string): Promise<void>;
/**
 * > **Note:** The Item API only works with the Wix Restaurants Menus (New) app. Make sure you have installed this app from the [Wix App Market](https://www.wix.com/app-market/wix-restaurants-menus-new).
 *
 * Deletes multiple items at once.
 * @param ids - Item IDs.
 * @public
 * @documentationMaturity preview
 * @requiredField ids
 * @permissionId RESTAURANTS.ITEM_DELETE
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.BulkDeleteItems
 */
declare function bulkDeleteItems(ids: string[]): Promise<NonNullablePaths<BulkDeleteItemsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;

export { type UpdateDocumentsEvent as $, AvailabilityType as A, type BulkCreateItemsOptions as B, type CountItemsOptions as C, type DuplicateItemOptions as D, EntitiesDayOfWeek as E, type Label as F, type Availability as G, type AvailabilityAvailabilityTypeOptionsOneOf as H, type Item as I, type WeeklyScheduleOptions as J, type DayOfWeekAvailability as K, type ListItemsOptions as L, type MaskedItem as M, type TimeOfDay as N, type OrderSettings as O, PlacementType as P, type TimestampRangesOptions as Q, ResolutionMethod as R, type SearchItemsResponse as S, type TimeOfDayRange as T, type UpdateItem as U, type AvailableRange as V, WebhookIdentityType as W, type ModifierGroup as X, type ExtendedFields as Y, type ExternalReferenceInfo as Z, type DuplicateItemRequest as _, type DuplicateItemResponse as a, type QueryItemsRequest as a$, type UpdateDocumentsEventOperationOneOf as a0, type DocumentUpdateOperation as a1, type IndexDocument as a2, type DocumentPayload as a3, type DocumentImage as a4, type DeleteByIdsOperation as a5, type DeleteByFilterOperation as a6, type UpdateByFilterOperation as a7, type UpdateExistingOperation as a8, type DomainEvent as a9, type SiteCreated as aA, type SiteCloned as aB, type MessageEnvelope as aC, type IdentificationData as aD, type IdentificationDataIdOneOf as aE, type InvalidateCache as aF, type InvalidateCacheGetByOneOf as aG, type App as aH, type Page as aI, type URI as aJ, type File as aK, type CustomTag as aL, type DeleteLocationIdsFromVariants as aM, type DeleteLocationIdsFromModifierGroups as aN, type CreateItemRequest as aO, type CreateItemResponse as aP, type BulkCreateItemsRequest as aQ, type BulkCreateItemResult as aR, type ItemMetadata as aS, type ApplicationError as aT, type BulkActionMetadata as aU, type GetItemRequest as aV, type GetItemResponse as aW, type ListItemsRequest as aX, type CursorPaging as aY, type CursorPagingMetadata as aZ, type Cursors as a_, type DomainEventBodyOneOf as aa, type EntityCreatedEvent as ab, type RestoreInfo as ac, type EntityUpdatedEvent as ad, type EntityDeletedEvent as ae, type ActionEvent as af, type Empty as ag, type SearchIndexingNotification as ah, type SitePropertiesNotification as ai, type SitePropertiesEvent as aj, type Properties as ak, type Categories as al, type Locale as am, type Address as an, type AddressHint as ao, type GeoCoordinates as ap, type BusinessSchedule as aq, type TimePeriod as ar, type SpecialHourPeriod as as, type Multilingual as at, type SupportedLanguage as au, type ConsentPolicy as av, type Translation as aw, type ChangeContext as ax, type ChangeContextPayloadOneOf as ay, type PropertiesChange as az, type BulkCreateItemsResponse as b, onItemUpdated as b$, type CursorQuery as b0, type CursorQueryPagingMethodOneOf as b1, type Sorting as b2, type QueryItemsResponse as b3, type SearchItemsRequest as b4, type CursorSearch as b5, type CursorSearchPagingMethodOneOf as b6, type Aggregation as b7, type AggregationKindOneOf as b8, type RangeBucket as b9, type BulkUpdateBusinessLocationIdsPerEntityRequest as bA, type ItemIdLocationIds as bB, type BulkUpdateBusinessLocationIdsPerEntityResponse as bC, type BulkItemResult as bD, type SyncContentToMultilingualRequest as bE, type SyncContentToMultilingualResponse as bF, type BaseEventMetadata as bG, type EventMetadata as bH, type ItemsQueryResult as bI, type ItemSearchSpec as bJ, type AvailabilityTypeWithLiterals as bK, type EntitiesDayOfWeekWithLiterals as bL, type EnumWithLiterals as bM, type StateWithLiterals as bN, type PlacementTypeWithLiterals as bO, type DayOfWeekWithLiterals as bP, type ResolutionMethodWithLiterals as bQ, type WebhookIdentityTypeWithLiterals as bR, type SortOrderWithLiterals as bS, type SortTypeWithLiterals as bT, type SortDirectionWithLiterals as bU, type ScalarTypeWithLiterals as bV, type AggregationTypeWithLiterals as bW, type ModeWithLiterals as bX, type CommonSearchWithEntityContext as bY, onItemCreated as bZ, onItemDeleted as b_, type ValueAggregation as ba, type RangeAggregation as bb, type ScalarAggregation as bc, type SearchDetails as bd, type AggregationData as be, type ValueAggregationResult as bf, type RangeAggregationResult as bg, type ValueResults as bh, type RangeResults as bi, type ScalarResult as bj, type AggregationResults as bk, type AggregationResultsResultOneOf as bl, type CountItemsRequest as bm, type UpdateItemRequest as bn, type UpdateItemResponse as bo, type BulkUpdateItemRequest as bp, type BulkUpdateItemResponseBulkItemResult as bq, type DeleteItemRequest as br, type DeleteItemResponse as bs, type BulkDeleteItemsRequest as bt, type BulkDeleteItemResult as bu, type CloneItemsRequest as bv, type CloneItemsResponse as bw, type BulkUpdateBusinessLocationIdsRequest as bx, type BulkUpdateBusinessLocationIdsResponse as by, type BulkUpdateBusinessLocationIdsResponseBulkItemResult as bz, type ListItemsResponse as c, duplicateItem as c0, createItem as c1, bulkCreateItems as c2, getItem as c3, listItems as c4, queryItems as c5, countItems as c6, updateItem as c7, bulkUpdateItem as c8, deleteItem as c9, bulkDeleteItems as ca, type ItemsQueryBuilder as d, type ItemSearch as e, type CountItemsResponse as f, type CountItemsApplicationErrors as g, type BulkUpdateItemOptions as h, type BulkUpdateItemResponse as i, type BulkDeleteItemsResponse as j, type ItemCreatedEnvelope as k, type ItemDeletedEnvelope as l, type ItemUpdatedEnvelope as m, Enum as n, State as o, DayOfWeek as p, SortOrder as q, SortType as r, SortDirection as s, ScalarType as t, AggregationType as u, Mode as v, type ItemPricingOneOf as w, type PriceVariants as x, type PriceVariant as y, type PriceInfo as z };
