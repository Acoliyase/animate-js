import { CreateQuizRequest as CreateQuizRequest$1, CreateQuizResponse as CreateQuizResponse$1, CloneQuizRequest as CloneQuizRequest$1, CloneQuizResponse as CloneQuizResponse$1, BulkCreateQuizRequest as BulkCreateQuizRequest$1, BulkCreateQuizResponse as BulkCreateQuizResponse$1, BulkCloneQuizRequest as BulkCloneQuizRequest$1, BulkCloneQuizResponse as BulkCloneQuizResponse$1, GetQuizRequest as GetQuizRequest$1, GetQuizResponse as GetQuizResponse$1, DeleteQuizRequest as DeleteQuizRequest$1, DeleteQuizResponse as DeleteQuizResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

interface Quiz {
    /**
     * ID of the quiz
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /** Quiz settings */
    settings?: QuizSettings;
    /**
     * Represents the current state of the quiz. Each time the it is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision
     * @readonly
     */
    revision?: string | null;
    /**
     * The time this quiz was created
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * The time this quiz was last updated
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Quiz fields
     * @minSize 1
     * @maxSize 200
     */
    fields?: QuizField[];
}
interface QuizSettings {
    /**
     * Minimal grade to pass the quiz
     * @max 100
     */
    passingGrade?: number | null;
    /**
     * Quiz title
     * @maxLength 200
     */
    title?: string | null;
    /**
     * Maximal number of submission attempts
     * @min 1
     */
    attempts?: number | null;
}
interface QuizField extends QuizFieldFieldTypeOneOf {
    /** Type for numeric input */
    numeric?: NumericField;
    /** Type for text input */
    shortText?: ShortTextField;
    /** Type for long text input */
    longText?: LongTextField;
    /** Type for input with predefined options where only one can be selected */
    singleChoice?: SingleChoiceField;
    /** Type for input with predefined options where multiple can be selected */
    multiChoice?: MultiChoiceField;
    /** Type for file input */
    fileUpload?: FileUploadField;
    /**
     * Field ID
     * @format GUID
     * @immutable
     */
    id?: string;
    /**
     * Key used in submission
     * @maxLength 200
     * @immutable
     */
    target?: string | null;
    /**
     * Question
     * @minLength 1
     * @maxLength 350
     */
    question?: string | null;
    /** Score of the question when answered right */
    score?: number | null;
    /**
     * Message shown for right answer
     * @maxLength 350
     */
    rightMessage?: string | null;
    /**
     * Message shown for wrong answer
     * @maxLength 350
     */
    wrongMessage?: string | null;
}
/** @oneof */
interface QuizFieldFieldTypeOneOf {
    /** Type for numeric input */
    numeric?: NumericField;
    /** Type for text input */
    shortText?: ShortTextField;
    /** Type for long text input */
    longText?: LongTextField;
    /** Type for input with predefined options where only one can be selected */
    singleChoice?: SingleChoiceField;
    /** Type for input with predefined options where multiple can be selected */
    multiChoice?: MultiChoiceField;
    /** Type for file input */
    fileUpload?: FileUploadField;
}
declare enum FileFormat {
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
    AUDIO = "AUDIO",
    DOCUMENT = "DOCUMENT",
    ARCHIVE = "ARCHIVE"
}
/** @enumType */
type FileFormatWithLiterals = FileFormat | 'IMAGE' | 'VIDEO' | 'AUDIO' | 'DOCUMENT' | 'ARCHIVE';
interface NumericField {
    /** Right answer */
    rightAnswer?: number | null;
}
interface ShortTextField {
    /**
     * Right answer
     * @minLength 1
     * @maxLength 200
     */
    rightAnswer?: string | null;
}
interface LongTextField {
}
interface SingleChoiceField {
    /**
     * Right answer
     * @minLength 1
     * @maxLength 350
     */
    rightAnswer?: string | null;
    /**
     * Answer options
     * @minSize 1
     * @maxSize 90
     * @minLength 1
     * @maxLength 350
     */
    options?: string[] | null;
}
interface MultiChoiceField {
    /**
     * Right answer
     * @maxSize 90
     * @minLength 1
     * @maxLength 350
     */
    rightAnswer?: string[] | null;
    /**
     * Answer options
     * @minSize 1
     * @maxSize 90
     * @minLength 1
     * @maxLength 350
     */
    options?: string[] | null;
}
interface FileUploadField {
    /**
     * Text for upload button
     * @minLength 1
     * @maxLength 100
     */
    buttonText?: string | null;
    /**
     * Limit of upload items
     * @min 1
     * @max 10
     */
    itemsLimit?: number | null;
    /**
     * Formats of files that can be uploaded
     * @minSize 1
     * @maxSize 4
     */
    fileFormats?: FileFormatWithLiterals[];
}
interface CreateQuizRequest {
    /** Quiz to created */
    quiz: Quiz;
}
interface CreateQuizResponse {
    /** Created quiz */
    quiz?: Quiz;
}
interface CloneQuizRequest {
    /**
     * ID of the quiz to be cloned
     * @format GUID
     */
    quizId: string;
}
interface CloneQuizResponse {
    /** Cloned quiz */
    quiz?: Quiz;
}
interface BulkCreateQuizRequest {
    /**
     * Quizzes to be created
     * @maxSize 30
     */
    quizzes: Quiz[];
    /** When set, items will be returned on successful create */
    returnEntity?: boolean;
}
interface BulkCreateQuizResponse {
    /** Created quizzes with metadata */
    results?: BulkQuizResult[];
}
interface BulkQuizResult {
    /** Created quiz metadata */
    itemMetadata?: ItemMetadata;
    /** Created quiz */
    item?: Quiz;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkCloneQuizRequest {
    /**
     * IDs of the quizzes to clone.
     * @minSize 1
     * @maxSize 30
     * @format GUID
     */
    quizIds: string[];
    /**
     * Whether to return the cloned quizzes in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCloneQuizResponse {
    /** Results of the bulk clone operation, including cloned quizzes and metadata. */
    results?: BulkQuizResult[];
    /** Metadata about the bulk operation. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface GetQuizRequest {
    /**
     * ID of the quiz
     * @format GUID
     */
    quizId: string;
}
interface GetQuizResponse {
    /** Requested quiz */
    quiz?: Quiz;
}
interface UpdateQuizRequest {
    /** Quiz to be updated. Maybe partial */
    quiz?: Quiz;
}
interface UpdateQuizResponse {
    /** Updated quiz */
    quiz?: Quiz;
}
interface DeleteQuizRequest {
    /**
     * ID of quiz
     * @format GUID
     */
    quizId: string;
}
interface DeleteQuizResponse {
    /** Deleted quiz */
    quiz?: Quiz;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createQuiz(): __PublicMethodMetaInfo<'POST', {}, CreateQuizRequest$1, CreateQuizRequest, CreateQuizResponse$1, CreateQuizResponse>;
declare function cloneQuiz(): __PublicMethodMetaInfo<'POST', {
    quizId: string;
}, CloneQuizRequest$1, CloneQuizRequest, CloneQuizResponse$1, CloneQuizResponse>;
declare function bulkCreateQuiz(): __PublicMethodMetaInfo<'POST', {}, BulkCreateQuizRequest$1, BulkCreateQuizRequest, BulkCreateQuizResponse$1, BulkCreateQuizResponse>;
declare function bulkCloneQuiz(): __PublicMethodMetaInfo<'POST', {}, BulkCloneQuizRequest$1, BulkCloneQuizRequest, BulkCloneQuizResponse$1, BulkCloneQuizResponse>;
declare function getQuiz(): __PublicMethodMetaInfo<'GET', {
    quizId: string;
}, GetQuizRequest$1, GetQuizRequest, GetQuizResponse$1, GetQuizResponse>;
declare function deleteQuiz(): __PublicMethodMetaInfo<'DELETE', {
    quizId: string;
}, DeleteQuizRequest$1, DeleteQuizRequest, DeleteQuizResponse$1, DeleteQuizResponse>;

export { type ActionEvent as ActionEventOriginal, type ApplicationError as ApplicationErrorOriginal, type BulkActionMetadata as BulkActionMetadataOriginal, type BulkCloneQuizRequest as BulkCloneQuizRequestOriginal, type BulkCloneQuizResponse as BulkCloneQuizResponseOriginal, type BulkCreateQuizRequest as BulkCreateQuizRequestOriginal, type BulkCreateQuizResponse as BulkCreateQuizResponseOriginal, type BulkQuizResult as BulkQuizResultOriginal, type CloneQuizRequest as CloneQuizRequestOriginal, type CloneQuizResponse as CloneQuizResponseOriginal, type CreateQuizRequest as CreateQuizRequestOriginal, type CreateQuizResponse as CreateQuizResponseOriginal, type DeleteQuizRequest as DeleteQuizRequestOriginal, type DeleteQuizResponse as DeleteQuizResponseOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, FileFormat as FileFormatOriginal, type FileFormatWithLiterals as FileFormatWithLiteralsOriginal, type FileUploadField as FileUploadFieldOriginal, type GetQuizRequest as GetQuizRequestOriginal, type GetQuizResponse as GetQuizResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type ItemMetadata as ItemMetadataOriginal, type LongTextField as LongTextFieldOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type MultiChoiceField as MultiChoiceFieldOriginal, type NumericField as NumericFieldOriginal, type QuizFieldFieldTypeOneOf as QuizFieldFieldTypeOneOfOriginal, type QuizField as QuizFieldOriginal, type Quiz as QuizOriginal, type QuizSettings as QuizSettingsOriginal, type RestoreInfo as RestoreInfoOriginal, type ShortTextField as ShortTextFieldOriginal, type SingleChoiceField as SingleChoiceFieldOriginal, type UpdateQuizRequest as UpdateQuizRequestOriginal, type UpdateQuizResponse as UpdateQuizResponseOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, bulkCloneQuiz, bulkCreateQuiz, cloneQuiz, createQuiz, deleteQuiz, getQuiz };
