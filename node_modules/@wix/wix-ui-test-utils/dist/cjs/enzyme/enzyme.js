"use strict";

exports.__esModule = true;
exports.enzymeTestkitFactoryCreator = enzymeTestkitFactoryCreator;
exports.enzymeUniTestkitFactoryCreator = enzymeUniTestkitFactoryCreator;
exports.isEnzymeTestkitExists = isEnzymeTestkitExists;
exports.isUniEnzymeTestkitExists = isUniEnzymeTestkitExists;
var React = _interopRequireWildcard(require("react"));
var _reactHelpers = require("../react-helpers");
var _unidriverJsdomReactLegacy = require("@wix/unidriver-jsdom-react-legacy");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function enzymeTestkitFactoryCreator(driverFactory) {
  return obj => {
    const eventTrigger = (0, _reactHelpers.reactEventTrigger)();
    const regexp = new RegExp(`^<[^>]+data-hook="${obj.dataHook}"`);
    const component = obj.wrapper.findWhere(n => n.length > 0 && typeof n.type() === 'string' && regexp.test(n.html()));
    const element = component.length > 0 ? component.first().getDOMNode() : undefined;
    return driverFactory({
      element,
      wrapper: obj.wrapper,
      eventTrigger,
      dataHook: obj.dataHook
    });
  };
}
function enzymeUniTestkitFactoryCreator(driverFactory) {
  return obj => {
    const regexp = new RegExp(`^<[^>]+data-hook="${obj.dataHook}"`);
    const component = obj.wrapper.findWhere(n => n.length > 0 && typeof n.type() === 'string' && regexp.test(n.html()));
    const element = component.length > 0 ? component.first().getDOMNode() : undefined;
    const base = (0, _unidriverJsdomReactLegacy.jsdomReactUniDriver)(element);
    const body = (0, _unidriverJsdomReactLegacy.jsdomReactUniDriver)(document.body);
    return driverFactory(base, body, {
      dataHook: obj.dataHook
    });
  };
}
/**
 * Checks if the given Element accepts a data hook, and that the testkit factory finds the component's root element using that data hook.
 *
 * This method supports both new snake-case and legacy camelCase data hook prop name (e.g `data-hook` and `dataHook`).
 * The default is to check by both prop name options.
 */
function isEnzymeTestkitExists(Element, testkitFactory, mount, options = {}) {
  return isEnzymeTestkitExistsInternal({
    Element,
    testkitFactory,
    mount,
    ...options
  });
}
async function isUniEnzymeTestkitExists(Element, testkitFactory, mount, {
  withoutDataHook,
  dataHookPropName
} = {}) {
  const dataHook = withoutDataHook ? '' : 'myDataHook';
  const extraProps = dataHookPropName ? {
    [dataHookPropName]: dataHook
  } : {
    dataHook,
    'data-hook': dataHook
  };
  const elementToRender = /*#__PURE__*/React.cloneElement(Element, extraProps);
  const wrapper = mount(elementToRender);
  const testkit = testkitFactory({
    wrapper,
    dataHook
  });
  return testkit.exists();
}

/**
 * This internal function is only in order to allow separate defaults to each options.
 */
function isEnzymeTestkitExistsInternal({
  Element,
  testkitFactory,
  mount,
  withoutDataHook = false,
  dataHookPropName
}) {
  const dataHook = withoutDataHook ? '' : 'myDataHook';
  const extraProps = dataHookPropName ? {
    [dataHookPropName]: dataHook
  } : {
    dataHook,
    'data-hook': dataHook
  };
  const elementToRender = /*#__PURE__*/React.cloneElement(Element, extraProps);
  const wrapper = mount(elementToRender);
  const testkit = testkitFactory({
    wrapper,
    dataHook
  });
  return testkit.exists();
}
//# sourceMappingURL=enzyme.js.map