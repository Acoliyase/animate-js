import * as React from 'react';
import { Simulate } from 'react-dom/test-utils';
export interface ControlledComponentState {
    value: string;
}
export interface ControlledComponentProps {
    value?: string;
    onChange?: (e: React.ChangeEvent<HTMLElement>) => void;
    [otherProps: string]: any;
}
export interface ControlledEventTarget extends EventTarget {
    value: string;
}
export interface ControlledChangeEvent<T> extends React.ChangeEvent<T> {
    target: ControlledEventTarget & T;
}
export declare const isClassExists: (element: HTMLElement, className: String) => Boolean;
export declare const sleep: (ms: number) => Promise<void>;
/** @deprecated */
export declare function makeControlled<T extends ControlledComponentProps>(Component: React.FunctionComponent<T>): {
    new (props: T): {
        state: {
            value: string;
        };
        _onChange: (e: ControlledChangeEvent<any>) => void;
        render(): React.JSX.Element;
        context: unknown;
        setState<K extends "value">(state: ControlledComponentState | ((prevState: Readonly<ControlledComponentState>, props: Readonly<T>) => ControlledComponentState | Pick<ControlledComponentState, K> | null) | Pick<ControlledComponentState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<T>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<T>, nextState: Readonly<ControlledComponentState>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<T>, prevState: Readonly<ControlledComponentState>): any;
        componentDidUpdate?(prevProps: Readonly<T>, prevState: Readonly<ControlledComponentState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<ControlledComponentState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<ControlledComponentState>, nextContext: any): void;
    };
    new (props: T, context: any): {
        state: {
            value: string;
        };
        _onChange: (e: ControlledChangeEvent<any>) => void;
        render(): React.JSX.Element;
        context: unknown;
        setState<K extends "value">(state: ControlledComponentState | ((prevState: Readonly<ControlledComponentState>, props: Readonly<T>) => ControlledComponentState | Pick<ControlledComponentState, K> | null) | Pick<ControlledComponentState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<T>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<T>, nextState: Readonly<ControlledComponentState>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<T>, prevState: Readonly<ControlledComponentState>): any;
        componentDidUpdate?(prevProps: Readonly<T>, prevState: Readonly<ControlledComponentState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<ControlledComponentState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<ControlledComponentState>, nextContext: any): void;
    };
    defaultProps: {
        value: string;
    };
    contextType?: React.Context<any> | undefined;
};
export declare const reactEventTrigger: () => typeof Simulate;
//# sourceMappingURL=helpers.d.ts.map