import * as React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { isClassExists, makeControlled, sleep } from '.';
describe('helpers', () => {
    describe('isClassExists function', () => {
        const classes = 'class class2 class3';
        const element = document.createElement('div');
        element.className = classes;
        describe('existing class', () => {
            classes.split(' ').forEach((className) => it(`should return true for className ${className}`, () => {
                expect(isClassExists(element, className)).toBe(true);
            }));
        });
        describe('none existing classes', () => {
            [undefined, 'cla', 'class4'].forEach((className) => it(`should return false for className ${className}`, () => {
                expect(isClassExists(element, className)).toBe(false);
            }));
        });
    });
    describe('sleep helper', () => {
        it('sleeps', async () => {
            const previousTime = Date.now();
            await sleep(50);
            expect(Date.now()).toBeGreaterThanOrEqual(previousTime + 50);
        });
    });
    describe('makeControlled function', () => {
        const UncontrolledInput = (props) => React.createElement("input", { ...props });
        it('should init uncontrolled component with initial value', () => {
            const ControlledInput = makeControlled(UncontrolledInput);
            const initialValue = 'some value';
            render(React.createElement(ControlledInput, { value: initialValue }));
            const inputElement = screen.getByRole('textbox');
            expect(inputElement).toHaveValue(initialValue);
        });
        it('should invoke onChange callback', () => {
            const onChange = jest.fn();
            const ControlledInput = makeControlled(UncontrolledInput);
            render(React.createElement(ControlledInput, { onChange: onChange }));
            const enteredValue = 'some value';
            const input = screen.getByRole('textbox');
            fireEvent.change(input, { target: { value: enteredValue } });
            expect(onChange).toHaveBeenCalledTimes(1);
            expect(onChange.mock.calls[0][0].target.value).toBe(enteredValue);
            expect(input).toHaveValue(enteredValue);
        });
        it('should bind passed prop-functions to *this*', () => {
            const NotifyOnEnter = ({ onEnter, ...passedProps }) => (React.createElement(UncontrolledInput, { ...passedProps, onKeyDown: (e) => e.key === 'Enter' && onEnter() }));
            const ControlledInput = makeControlled(NotifyOnEnter);
            render(React.createElement(ControlledInput, { value: "some value", onEnter: function () {
                    // NOTE: don't use arrow functions by purpose
                    this.setState({ value: '' });
                } }));
            const input = screen.getByRole('textbox');
            fireEvent.keyDown(input, { key: 'Enter' });
            expect(input).toHaveValue('');
        });
    });
});
//# sourceMappingURL=helpers.spec.js.map