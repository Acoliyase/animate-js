import { SearchSpec, Search, NonNullablePaths } from '@wix/sdk-types';

interface Plan {
    /**
     * Plan ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the plan is updated.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the plan was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the plan was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Plan name displayed to customers.
     * @minLength 1
     * @maxLength 50
     */
    name?: string;
    /**
     * Plan description that explains what customers get with this plan.
     * @maxLength 450
     */
    description?: string | null;
    /** Visual information representing the plan. */
    image?: string;
    /**
     * Unique identifier for this plan within the Wix site. If not provided, generated automatically from the plan name.
     * @format URL_SLUG
     * @maxLength 255
     */
    slug?: string | null;
    /**
     * Terms and conditions text that customers must agree to when purchasing this plan.
     * @maxLength 3000
     */
    termsAndConditions?: string | null;
    /**
     * Maximum number of times the same customer can purchase this plan. Use `0` for unlimited purchases or `1` to limit to one purchase per customer.
     * @max 10
     */
    maxPurchasesPerBuyer?: number;
    /**
     * Pricing variants that define different billing and pricing options for this plan. Currently limited to 1 variant per plan.
     * @minSize 1
     * @maxSize 1
     */
    pricingVariants?: PricingVariant[];
    /**
     * List of benefits or features included with this plan.
     * @maxSize 500
     */
    perks?: Perk[];
    /** Plan visibility. */
    visibility?: VisibilityWithLiterals;
    /** Whether customers can currently purchase this plan. If set to `false`, customer won't be able to buy a plan themselves. In this case a Wix user has to assign the plan through the [dashboard](https://support.wix.com/en/article/pricing-plans-selling-plans-offline). */
    buyable?: boolean;
    /**
     * ID of the form associated with the plan at checkout.
     * @format GUID
     */
    formId?: string | null;
    /** Whether the customer is allowed to cancel their plan. */
    buyerCanCancel?: boolean;
    /**
     * Payment currency.
     * @readonly
     * @format CURRENCY
     */
    currency?: string;
    /** Data extensions. Learn more about [extended fields](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-schema-plugin-extensions). */
    extendedFields?: ExtendedFields;
}
interface PricingVariant {
    /**
     * Pricing variant ID.
     * @format GUID
     */
    _id?: string;
    /**
     * Name for this pricing variant, such as "Monthly" or "Yearly".
     * @minLength 1
     * @maxLength 255
     */
    name?: string;
    /**
     * Number of days customers can use the plan for free before the first charge. Set to `0` for no free trial.
     * @max 999
     */
    freeTrialDays?: number;
    /**
     * Additional fees applied to this pricing variant.
     * @maxSize 10
     */
    fees?: Fee[];
    /** Billing configuration that defines when and how often customers are charged. */
    billingTerms?: BillingTerms;
    /**
     * Promotional message displayed with this pricing variant.
     * @maxLength 255
     */
    promotion?: string | null;
    /**
     * Pricing strategies that determine how much customers pay. Currently limited to 1 strategy per variant.
     * @minSize 1
     * @maxSize 1
     */
    pricingStrategies?: PricingStrategy[];
}
interface FlatRate {
    /**
     * Fixed monetary amount.
     * @decimalValue options { gte:0, maxScale:4 }
     */
    amount?: string;
}
interface Fee extends FeePriceOptionOneOf {
    /** Fixed monetary amount for the fee. */
    fixedAmountOptions?: FixedAmountOption;
    /** @format GUID */
    _id?: string;
    /** Pricing type used for this fee. */
    priceType?: PriceTypeWithLiterals;
    /**
     * Fee name displayed to customers, such as "Setup Fee" or "Processing Fee".
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /** When this fee is charged during the customer's plan lifecycle. */
    appliedAt?: AppliedAtWithLiterals;
}
/** @oneof */
interface FeePriceOptionOneOf {
    /** Fixed monetary amount for the fee. */
    fixedAmountOptions?: FixedAmountOption;
}
declare enum PriceType {
    /** Unknown price type. This value isn't used. */
    UNKNOWN_PRICE_TYPE = "UNKNOWN_PRICE_TYPE",
    /** Fee is charged as a fixed monetary amount. */
    FIXED_AMOUNT = "FIXED_AMOUNT"
}
/** @enumType */
type PriceTypeWithLiterals = PriceType | 'UNKNOWN_PRICE_TYPE' | 'FIXED_AMOUNT';
interface FixedAmountOption {
    /**
     * Fixed monetary amount.
     * @decimalValue options { gt:0, maxScale:4 }
     */
    amount?: string;
}
declare enum AppliedAt {
    UNKNOWN_APPLIED_AT = "UNKNOWN_APPLIED_AT",
    /** Fee is added to the first payment. */
    FIRST_PAYMENT = "FIRST_PAYMENT"
}
/** @enumType */
type AppliedAtWithLiterals = AppliedAt | 'UNKNOWN_APPLIED_AT' | 'FIRST_PAYMENT';
interface BillingTerms extends BillingTermsEndOptionOneOf {
    /** How many billing cycles the plan lasts. */
    cyclesCompletedDetails?: CyclesCompletedDetails;
    /** Duration of each billing cycle, such as 1 month or 2 weeks. Can't be less than 7 days. Only applicable for recurring plans. */
    billingCycle?: Duration;
    /** When the billing starts. */
    startType?: StartTypeWithLiterals;
    /** How long the plan remains active. Plans can run until cancelled or for a specific number of billing cycles. Plan duration can't exceed 10 years. */
    endType?: EndTypeWithLiterals;
}
/** @oneof */
interface BillingTermsEndOptionOneOf {
    /** How many billing cycles the plan lasts. */
    cyclesCompletedDetails?: CyclesCompletedDetails;
}
interface Duration {
    /** Duration of period. */
    period?: PeriodWithLiterals;
    /**
     * Number of periods.
     * @min 1
     */
    count?: string;
}
declare enum Period {
    /** Unknown period. This value isn't used. */
    UNKNOWN_PERIOD = "UNKNOWN_PERIOD",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
/** @enumType */
type PeriodWithLiterals = Period | 'UNKNOWN_PERIOD' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
declare enum StartType {
    /** Unknown start type. This value isn't used. */
    UNKNOWN_START_TYPE = "UNKNOWN_START_TYPE",
    /** Billing starts immediately after purchase. */
    ON_PURCHASE = "ON_PURCHASE",
    /** Customer can choose when billing starts. */
    CUSTOM = "CUSTOM"
}
/** @enumType */
type StartTypeWithLiterals = StartType | 'UNKNOWN_START_TYPE' | 'ON_PURCHASE' | 'CUSTOM';
declare enum EndType {
    /** Unknown end type. This value isn't used. */
    UNKNOWN_END_TYPE = "UNKNOWN_END_TYPE",
    /** Plan continues until customer cancels. */
    UNTIL_CANCELLED = "UNTIL_CANCELLED",
    /** Plan ends after a specified number of billing cycles. */
    CYCLES_COMPLETED = "CYCLES_COMPLETED"
}
/** @enumType */
type EndTypeWithLiterals = EndType | 'UNKNOWN_END_TYPE' | 'UNTIL_CANCELLED' | 'CYCLES_COMPLETED';
interface CyclesCompletedDetails {
    /**
     * Number of billing cycles before the plan automatically ends. For example, if `billingCycle` is 3 months and `billingCycleCount` is 4, the customer will be charged 4 times over 12 months before the plan expires. Only applicable if `endType` is `CYCLES_COMPLETED`.
     * @min 1
     * @max 2000
     */
    billingCycleCount?: string;
}
interface PricingStrategy extends PricingStrategyStrategyOneOf {
    /** Single fixed cost charged regardless of usage. */
    flatRate?: FlatRate;
}
/** @oneof */
interface PricingStrategyStrategyOneOf {
    /** Single fixed cost charged regardless of usage. */
    flatRate?: FlatRate;
}
interface Perk {
    /**
     * Perk ID.
     * @format GUID
     */
    _id?: string;
    /**
     * Perk description.
     * @minLength 1
     * @maxLength 1400
     */
    description?: string;
}
declare enum Visibility {
    /** Unknown visibility. This value isn't used. */
    UNKNOWN_VISIBILITY = "UNKNOWN_VISIBILITY",
    /** Plan is visible and available for purchase by all customers. */
    PUBLIC = "PUBLIC",
    /** Plan is not visible to new customers, unless they get a specific link to the plan. Existing subscribers can continue using it. */
    PRIVATE = "PRIVATE"
}
/** @enumType */
type VisibilityWithLiterals = Visibility | 'UNKNOWN_VISIBILITY' | 'PUBLIC' | 'PRIVATE';
declare enum Status {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    ACTIVE = "ACTIVE"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNKNOWN_STATUS' | 'ACTIVE';
interface TermsAndConditionsSettings {
    /** Whether customers must accept terms and conditions before purchasing. */
    acceptRequired?: boolean;
    /** Whether the terms and conditions checkbox is checked by default. */
    acceptedByDefault?: boolean;
}
interface ThankYouPageSettings {
    /**
     * Thank you page title
     * @maxLength 100
     */
    title?: string;
    /**
     * Thank you page message
     * @maxLength 100000
     */
    message?: string;
    /**
     * Thank you page button text
     * @maxLength 40
     */
    buttonText?: string;
    /**
     * Thank you page button link
     * @maxLength 200
     */
    buttonLink?: string | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface ValidateOptionsRequest {
    /**
     * The plan id, which corresponds to catalogItemId in catalog item reference
     * @format GUID
     */
    planId?: string;
    /** The specific options selected for this plan */
    options?: Options;
    /**
     * The id of the member buying the plan
     * @format GUID
     */
    memberId?: string;
}
interface Options extends OptionsOptionsOneOf {
    /** The options applicable to a plan */
    planOptions?: PlanOptions;
    /** The type of plan product the options refer to. */
    type?: TypeWithLiterals;
}
/** @oneof */
interface OptionsOptionsOneOf {
    /** The options applicable to a plan */
    planOptions?: PlanOptions;
}
declare enum Type {
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    PLAN = "PLAN",
    ADD_ON = "ADD_ON"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNKNOWN_TYPE' | 'PLAN' | 'ADD_ON';
interface PlanOptions {
    /**
     * The selected pricing variant for the plan
     * @format GUID
     */
    pricingVariantId?: string;
    /** Start date for the ordered plan */
    startDate?: Date | null;
    /**
     * Form submission id that was submitted together with the order
     * @format GUID
     */
    submissionId?: string | null;
    /** Indication whether plan purchase requires login */
    membersOnly?: boolean;
    /** The type of Taxable address */
    taxableAddress?: TaxableAddressWithLiterals;
    /** The strategy used to validate the plan */
    validationStrategy?: ValidationStrategyWithLiterals;
}
declare enum TaxableAddress {
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    BILLING = "BILLING",
    BUSINESS = "BUSINESS"
}
/** @enumType */
type TaxableAddressWithLiterals = TaxableAddress | 'UNKNOWN_TYPE' | 'BILLING' | 'BUSINESS';
declare enum ValidationStrategy {
    UNKNOWN_VALIDATION_STRATEGY = "UNKNOWN_VALIDATION_STRATEGY",
    ON_BEHALF = "ON_BEHALF",
    PREVIEW = "PREVIEW"
}
/** @enumType */
type ValidationStrategyWithLiterals = ValidationStrategy | 'UNKNOWN_VALIDATION_STRATEGY' | 'ON_BEHALF' | 'PREVIEW';
interface ValidateOptionsResponse {
    /** Description of value */
    violations?: Violation[];
}
interface Violation {
    /**
     * The code of the violation. The possible values are:
     * plan-not-active
     * plan-not-buyable
     * max-purchases-exceeded
     * start-date-not-applicable
     * start-date-in-past
     * pricing-variant-not-found
     * start-date-not-in-permitted-range
     * @minLength 1
     * @maxLength 50
     */
    code?: string;
    /**
     * User facing message describing the violation
     * @minLength 1
     * @maxLength 255
     */
    message?: string;
}
interface GetPlanConfigurationConstraintsRequest {
    /**
     * The plan id, which corresponds to catalogItemId in catalog item reference
     * @format GUID
     */
    planId?: string;
    /**
     * The selected pricing variant for the plan
     * @format GUID
     */
    pricingVariantId?: string;
}
interface GetPlanConfigurationConstraintsResponse {
    /** Start date limits. */
    startDateLimits?: StartDateLimits;
    /** Start date rules. */
    startDateRules?: StartDateRules;
}
interface StartDateLimits {
    /**
     * Earliest date the customer can select as the start date
     * @format LOCAL_DATE
     */
    earliestDate?: string | null;
    /**
     * Latest date the customer can select as the start date
     * @format LOCAL_DATE
     */
    latestDate?: string | null;
    /**
     * Error message to display if the purchase date is greater than date_to
     * @minLength 1
     * @maxLength 255
     */
    errorMessage?: string | null;
}
interface StartDateRules extends StartDateRulesDateRulesOneOf {
    /** Plan start date is limited to specific fixed dates */
    fixedDatesOptions?: FixedDatesOptions;
    /** Plan start date is limited to specific dates that repeat */
    recurrenceOptions?: RecurrenceOptions;
    /** Rules type */
    type?: RulesTypeWithLiterals;
    /**
     * Error message to show the user if the rules are not applicable based on purchase date
     * @minLength 1
     * @maxLength 255
     */
    errorMessage?: string | null;
}
/** @oneof */
interface StartDateRulesDateRulesOneOf {
    /** Plan start date is limited to specific fixed dates */
    fixedDatesOptions?: FixedDatesOptions;
    /** Plan start date is limited to specific dates that repeat */
    recurrenceOptions?: RecurrenceOptions;
}
declare enum RulesType {
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    AVAILABLE_IMMEDIATELY = "AVAILABLE_IMMEDIATELY",
    FIXED_DATES = "FIXED_DATES",
    RECURRENCE = "RECURRENCE"
}
/** @enumType */
type RulesTypeWithLiterals = RulesType | 'UNKNOWN_TYPE' | 'AVAILABLE_IMMEDIATELY' | 'FIXED_DATES' | 'RECURRENCE';
interface FixedDatesOptions {
    /**
     * Dates when the plan can start
     * @format LOCAL_DATE
     * @minSize 1
     * @maxSize 1000
     */
    dates?: string[];
}
interface RecurrenceOptions extends RecurrenceOptionsRecurrenceOneOf {
    /** Weekly recurrence */
    weeklyOptions?: WeeklyRecurrence;
    /** Monthly recurrence */
    monthlyOptions?: MonthlyRecurrence;
    /**
     * Start date of the recurrence pattern. Required.
     * @format LOCAL_DATE
     */
    startDate?: string;
    /**
     * End date of the recurrence pattern. If not provided, it is infinite.
     * @format LOCAL_DATE
     */
    endDate?: string | null;
    /**
     * How often to repeat (every X weeks/months)
     * @min 1
     * @max 100
     */
    interval?: number;
    /** Recurrence pattern */
    recurrenceType?: RecurrenceTypeWithLiterals;
}
/** @oneof */
interface RecurrenceOptionsRecurrenceOneOf {
    /** Weekly recurrence */
    weeklyOptions?: WeeklyRecurrence;
    /** Monthly recurrence */
    monthlyOptions?: MonthlyRecurrence;
}
declare enum RecurrenceType {
    UNKNOWN_RECURRENCE_TYPE = "UNKNOWN_RECURRENCE_TYPE",
    WEEKLY = "WEEKLY",
    MONTHLY = "MONTHLY"
}
/** @enumType */
type RecurrenceTypeWithLiterals = RecurrenceType | 'UNKNOWN_RECURRENCE_TYPE' | 'WEEKLY' | 'MONTHLY';
interface WeeklyRecurrence {
    /** Day of the week */
    weekday?: V1DayOfWeekWithLiterals;
}
declare enum V1DayOfWeek {
    UNKNOWN_DAY_OF_WEEK = "UNKNOWN_DAY_OF_WEEK",
    SUNDAY = "SUNDAY",
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY"
}
/** @enumType */
type V1DayOfWeekWithLiterals = V1DayOfWeek | 'UNKNOWN_DAY_OF_WEEK' | 'SUNDAY' | 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY';
interface MonthlyRecurrence {
    /**
     * Day of the month
     * @min 1
     * @max 31
     */
    dayOfMonth?: number;
}
interface GetPlanPreviewRequest {
    /**
     * The plan id, which corresponds to catalogItemId in catalog item reference
     * @format GUID
     */
    planId?: string;
    /**
     * The selected pricing variant for the plan
     * @format GUID
     */
    pricingVariantId?: string;
}
interface GetPlanPreviewResponse {
    /** The plan preview. */
    plan?: Plan;
}
/** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
interface SitePropertiesNotification {
    /** The site ID for which this update notification applies. */
    metasiteId?: string;
    /** The actual update event. */
    event?: SitePropertiesEvent;
    /**
     * A convenience set of mappings from the MetaSite ID to its constituent services.
     * @maxSize 500
     */
    translations?: Translation[];
    /** Context of the notification */
    changeContext?: ChangeContext;
}
/** The actual update event for a particular notification. */
interface SitePropertiesEvent {
    /** Version of the site's properties represented by this update. */
    version?: number;
    /** Set of properties that were updated - corresponds to the fields in "properties". */
    fields?: string[];
    /** Updated properties. */
    properties?: Properties;
}
interface Properties {
    /** Site categories. */
    categories?: Categories;
    /** Site locale. */
    locale?: Locale;
    /**
     * Site language.
     *
     * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
     */
    language?: string | null;
    /**
     * Site currency format used to bill customers.
     *
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    paymentCurrency?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Fax number. */
    fax?: string | null;
    /** Address. */
    address?: Address;
    /** Site display name. */
    siteDisplayName?: string | null;
    /** Business name. */
    businessName?: string | null;
    /** Path to the site's logo in Wix Media (without Wix Media base URL). */
    logo?: string | null;
    /** Site description. */
    description?: string | null;
    /**
     * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /** Supported languages of a site and the primary language. */
    multilingual?: Multilingual;
    /** Cookie policy the Wix user defined for their site (before the site visitor interacts with/limits it). */
    consentPolicy?: ConsentPolicy;
    /**
     * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
     *
     * Site business type.
     */
    businessConfig?: string | null;
    /** External site URL that uses Wix as its headless business solution. */
    externalSiteUrl?: string | null;
    /** Track clicks analytics. */
    trackClicksAnalytics?: boolean;
}
interface Categories {
    /** Primary site category. */
    primary?: string;
    /**
     * Secondary site category.
     * @maxSize 50
     */
    secondary?: string[];
    /** Business Term Id */
    businessTermId?: string | null;
}
interface Locale {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
    country?: string;
}
interface Address {
    /** Street name. */
    street?: string;
    /** City name. */
    city?: string;
    /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
    country?: string;
    /** State. */
    state?: string;
    /**
     * Zip or postal code.
     * @maxLength 20
     */
    zip?: string;
    /** Extra information to be displayed in the address. */
    hint?: AddressHint;
    /** Whether this address represents a physical location. */
    isPhysical?: boolean;
    /** Google-formatted version of this address. */
    googleFormattedAddress?: string;
    /** Street number. */
    streetNumber?: string;
    /** Apartment number. */
    apartmentNumber?: string;
    /** Geographic coordinates of location. */
    coordinates?: GeoCoordinates;
}
/**
 * Extra information on displayed addresses.
 * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
 * Free text. In addition, the user can state where to display the additional description - before, after, or instead of the address string.
 */
interface AddressHint {
    /** Extra text displayed next to, or instead of, the actual address. */
    text?: string;
    /** Where the extra text should be displayed. */
    placement?: PlacementTypeWithLiterals;
}
/** Where the extra text should be displayed: before, after or instead of the actual address. */
declare enum PlacementType {
    BEFORE = "BEFORE",
    AFTER = "AFTER",
    REPLACE = "REPLACE"
}
/** @enumType */
type PlacementTypeWithLiterals = PlacementType | 'BEFORE' | 'AFTER' | 'REPLACE';
/** Geocoordinates for a particular address. */
interface GeoCoordinates {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number;
}
/** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
interface BusinessSchedule {
    /**
     * Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods.
     * @maxSize 100
     */
    periods?: TimePeriod[];
    /**
     * Exceptions to the business's regular hours. The business can be open or closed during the exception.
     * @maxSize 100
     */
    specialHourPeriod?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the business is regularly open or the service is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     *
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
/** Enumerates the days of the week. */
declare enum DayOfWeek {
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY",
    SUNDAY = "SUNDAY"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /**
     * Whether the business is closed (or the service is not available) during the exception.
     *
     * Default: `true`.
     */
    isClosed?: boolean;
    /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
    comment?: string;
}
interface Multilingual {
    /**
     * Supported languages list.
     * @maxSize 200
     */
    supportedLanguages?: SupportedLanguage[];
    /** Whether to redirect to user language. */
    autoRedirect?: boolean;
}
interface SupportedLanguage {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Locale. */
    locale?: Locale;
    /** Whether the supported language is the primary language for the site. */
    isPrimary?: boolean;
    /** Language icon. */
    countryCode?: string;
    /** How the language will be resolved. For internal use. */
    resolutionMethod?: ResolutionMethodWithLiterals;
    /** Whether the supported language is the primary language for site visitors. */
    isVisitorPrimary?: boolean | null;
}
declare enum ResolutionMethod {
    QUERY_PARAM = "QUERY_PARAM",
    SUBDOMAIN = "SUBDOMAIN",
    SUBDIRECTORY = "SUBDIRECTORY"
}
/** @enumType */
type ResolutionMethodWithLiterals = ResolutionMethod | 'QUERY_PARAM' | 'SUBDOMAIN' | 'SUBDIRECTORY';
interface ConsentPolicy {
    /** Whether the site uses cookies that are essential to site operation. Always `true`. */
    essential?: boolean | null;
    /** Whether the site uses cookies that affect site performance and other functional measurements. */
    functional?: boolean | null;
    /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
    analytics?: boolean | null;
    /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
    advertising?: boolean | null;
    /** CCPA compliance flag. */
    dataToThirdParty?: boolean | null;
}
/** A single mapping from the MetaSite ID to a particular service. */
interface Translation {
    /** The service type. */
    serviceType?: string;
    /** The application definition ID; this only applies to services of type ThirdPartyApps. */
    appDefId?: string;
    /** The instance ID of the service. */
    instanceId?: string;
}
interface ChangeContext extends ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
/** @oneof */
interface ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
interface PropertiesChange {
}
interface SiteCreated {
    /** Origin template site id. */
    originTemplateId?: string | null;
}
interface SiteCloned {
    /** Origin site id. */
    originMetaSiteId?: string;
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface CreatePlanRequest {
    /** Plan to create. */
    plan: Plan;
    /**
     * Unique key to prevent duplicate plan creation. If the same key is used within a short time period, the original plan will be returned instead of creating a duplicate.
     * @format GUID
     */
    idempotencyKey?: string | null;
}
interface CreatePlanResponse {
    /** Created plan. */
    plan?: Plan;
}
interface GetPlanRequest {
    /**
     * ID of the plan to retrieve.
     * @format GUID
     */
    planId: string;
}
interface GetPlanResponse {
    /** Requested plan. */
    plan?: Plan;
}
interface UpdatePlanRequest {
    /** plan to update. */
    plan: Plan;
    /**
     * Type of cascade to apply.
     * @internal
     */
    cascade?: CascadeWithLiterals;
}
declare enum Cascade {
    /** Change the price for the plan only, without affecting existing subscriptions. */
    NEW_SUBSCRIPTIONS = "NEW_SUBSCRIPTIONS",
    /** Change the price for the plan and apply it to existing subscriptions. */
    ALL_SUBSCRIPTIONS = "ALL_SUBSCRIPTIONS"
}
/** @enumType */
type CascadeWithLiterals = Cascade | 'NEW_SUBSCRIPTIONS' | 'ALL_SUBSCRIPTIONS';
interface UpdatePlanResponse {
    /** Updated plan. */
    plan?: Plan;
}
interface BulkUpdatePlansRequest {
    /**
     * Plans to update.
     * @minSize 1
     * @maxSize 100
     */
    plans: MaskedPlan[];
    /** Set the value to `true` to receive details of the updated plans. */
    returnEntity?: boolean;
    /**
     * Type of cascade to apply.
     * @internal
     */
    cascade?: CascadeWithLiterals;
}
interface MaskedPlan {
    /** Plan to update. */
    plan?: Plan;
}
interface BulkUpdatePlansResponse {
    /**
     * Updated plans.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkPlanResult[];
    /** Action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface ItemMetadata {
    /**
     * Item ID. Should always be available, unless it's impossible (for example, when failing to create an item).
     * @format GUID
     */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkPlanResult {
    /** Metadata for a specific updated item. */
    itemMetadata?: ItemMetadata;
    /** Updated plan details. Only returned if the `returnEntity` field was set to `true`. */
    item?: Plan;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface DeletePlanRequest {
    /**
     * ID of the plan to delete.
     * @format GUID
     */
    planId: string;
}
interface DeletePlanResponse {
}
interface QueryPlansRequest {
    /** Query options. See [API Query Language](https://dev.wix.com/docs/rest/articles/get-started/api-query-language) for more details. */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 5
     */
    sort?: Sorting[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryPlansResponse {
    /** List of plans. */
    plans?: Plan[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface SearchPlansRequest {
    /** Search options. See [API Query Language](https://dev.wix.com/docs/rest/articles/get-started/api-query-language) for more details. */
    search?: CursorSearch;
}
interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 10
     */
    sort?: Sorting[];
    /**
     * Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
     * @maxSize 10
     */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
     * @maxLength 50
     */
    timeZone?: string | null;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
    cursorPaging?: CursorPaging;
}
interface Aggregation extends AggregationKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation */
    nested?: NestedAggregation;
    /**
     * User-defined name of aggregation, should be unique, will appear in aggregation results
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: AggregationTypeWithLiterals;
    /**
     * Field to aggregate by, use dot notation to specify json path
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface AggregationKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation */
    nested?: NestedAggregation;
}
interface RangeBucket {
    /** Inclusive lower bound of the range. Required if to is not given */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if from is not given */
    to?: number | null;
}
declare enum SortType {
    /** Should sort by number of matches */
    COUNT = "COUNT",
    /** Should sort by value of the field alphabetically */
    VALUE = "VALUE"
}
/** @enumType */
type SortTypeWithLiterals = SortType | 'COUNT' | 'VALUE';
declare enum SortDirection {
    /** Should sort in descending order */
    DESC = "DESC",
    /** Should sort in ascending order */
    ASC = "ASC"
}
/** @enumType */
type SortDirectionWithLiterals = SortDirection | 'DESC' | 'ASC';
declare enum MissingValues {
    /** Should missing values be excluded from the aggregation results */
    EXCLUDE = "EXCLUDE",
    /** Should missing values be included in the aggregation results */
    INCLUDE = "INCLUDE"
}
/** @enumType */
type MissingValuesWithLiterals = MissingValues | 'EXCLUDE' | 'INCLUDE';
interface IncludeMissingValuesOptions {
    /**
     * Can specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ...
     * @maxLength 20
     */
    addToBucket?: string;
}
declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value */
    MIN = "MIN",
    /** Maximum value */
    MAX = "MAX"
}
/** @enumType */
type ScalarTypeWithLiterals = ScalarType | 'UNKNOWN_SCALAR_TYPE' | 'COUNT_DISTINCT' | 'MIN' | 'MAX';
interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** Options for including missing values */
    includeOptions?: IncludeMissingValuesOptions;
    /** Should sort by number of matches or value of the field */
    sortType?: SortTypeWithLiterals;
    /** Should sort in ascending or descending order */
    sortDirection?: SortDirectionWithLiterals;
    /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Should missing values be included or excluded from the aggregation results. Default is EXCLUDE */
    missingValues?: MissingValuesWithLiterals;
}
/** @oneof */
interface ValueAggregationOptionsOneOf {
    /** Options for including missing values */
    includeOptions?: IncludeMissingValuesOptions;
}
declare enum NestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
/** @enumType */
type NestedAggregationTypeWithLiterals = NestedAggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM';
interface RangeAggregation {
    /**
     * List of range buckets, where during aggregation each entity will be placed in the first bucket where its value falls into based on provided range bounds
     * @maxSize 50
     */
    buckets?: RangeBucket[];
}
interface ScalarAggregation {
    /** Define the operator for the scalar aggregation */
    type?: ScalarTypeWithLiterals;
}
interface DateHistogramAggregation {
    /** Interval for date histogram aggregation */
    interval?: IntervalWithLiterals;
}
declare enum Interval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
/** @enumType */
type IntervalWithLiterals = Interval | 'UNKNOWN_INTERVAL' | 'YEAR' | 'MONTH' | 'WEEK' | 'DAY' | 'HOUR' | 'MINUTE' | 'SECOND';
interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /**
     * User-defined name of aggregation, should be unique, will appear in aggregation results
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: NestedAggregationTypeWithLiterals;
    /**
     * Field to aggregate by, use dont notation to specify json path
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
}
declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one */
    NESTED = "NESTED"
}
/** @enumType */
type AggregationTypeWithLiterals = AggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM' | 'NESTED';
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one */
interface NestedAggregation {
    /**
     * Flattened list of aggregations, where each next aggregation is nested within previous one
     * @minSize 2
     * @maxSize 3
     */
    nestedAggregations?: NestedAggregationItem[];
}
interface SearchDetails {
    /** Defines how separate search terms in `expression` are combined */
    mode?: ModeWithLiterals;
    /**
     * Search term or expression
     * @maxLength 100
     */
    expression?: string | null;
    /**
     * Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path
     * @maxLength 200
     * @maxSize 20
     */
    fields?: string[];
    /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
    fuzzy?: boolean;
}
declare enum Mode {
    /** Any of the search terms must be present */
    OR = "OR",
    /** All search terms must be present */
    AND = "AND"
}
/** @enumType */
type ModeWithLiterals = Mode | 'OR' | 'AND';
interface SearchPlansResponse {
    /** List of plans. */
    plans?: Plan[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface CountPlansRequest {
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /** Free text to match in searchable fields. When specified, the method uses search instead of filter, and may be less consistent. */
    search?: SearchDetails;
}
interface CountPlansResponse {
    /** The number of plans. */
    count?: number;
}
interface ChangePriceRequest {
    /**
     * ID of the plan to change.
     * @format GUID
     */
    planId: string;
    /**
     * ID of the pricing variant to change.
     * @format GUID
     */
    pricingVariantId: string;
    /**
     * New pricing strategy.
     * @minSize 1
     * @maxSize 1
     */
    pricingStrategies: PricingStrategy[];
    /** To prevent conflicting changes, the current plan revision must be passed when updating the price. */
    revision: string | null;
    /** Type of cascade to apply. */
    cascade?: CascadeWithLiterals;
}
interface ChangePriceResponse {
    /** Updated Plan. */
    plan?: Plan;
}
interface UpdateExtendedFieldsRequest {
    /** ID of the entity to update. */
    _id?: string;
    /** Identifier for the app whose extended fields are being updated. */
    namespace?: string;
    /** Data to update. Structured according to the [schema](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields#json-schema-for-extended-fields) defined when the extended fields were configured. */
    namespaceData?: Record<string, any> | null;
}
interface UpdateExtendedFieldsResponse {
    /** Updated Plan. */
    plan?: Plan;
}
/** @docsIgnore */
type CreatePlanApplicationErrors = {
    code?: 'CURRENCY_MISSING';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CreatePlanValidationErrors = {
    ruleName?: 'NAME_NOT_BLANK';
} | {
    ruleName?: 'VALID_BILLING_CYCLE';
} | {
    ruleName?: 'VALID_PLAN_DURATION';
} | {
    ruleName?: 'FREE_PRICING_VARIANT_IS_NOT_RECURRING';
} | {
    ruleName?: 'FREE_TRIAL_IS_APPLICABLE';
} | {
    ruleName?: 'CYCLES_COMPLETED_END_OPTION_IS_APPLICABLE';
} | {
    ruleName?: 'PRICING_VARIANT_IDS_UNIQUE';
} | {
    ruleName?: 'FEE_IDS_UNIQUE';
} | {
    ruleName?: 'PERK_IDS_UNIQUE';
};
/** @docsIgnore */
type UpdatePlanValidationErrors = {
    ruleName?: 'NAME_NOT_BLANK';
} | {
    ruleName?: 'VALID_BILLING_CYCLE';
} | {
    ruleName?: 'VALID_PLAN_DURATION';
} | {
    ruleName?: 'FREE_PRICING_VARIANT_IS_NOT_RECURRING';
} | {
    ruleName?: 'FREE_TRIAL_IS_APPLICABLE';
} | {
    ruleName?: 'CYCLES_COMPLETED_END_OPTION_IS_APPLICABLE';
} | {
    ruleName?: 'PRICING_VARIANT_IDS_UNIQUE';
} | {
    ruleName?: 'FEE_IDS_UNIQUE';
} | {
    ruleName?: 'PERK_IDS_UNIQUE';
} | {
    ruleName?: 'REQUIRED_FIELD';
};
/** @docsIgnore */
type BulkUpdatePlansValidationErrors = {
    ruleName?: 'NAME_NOT_BLANK';
} | {
    ruleName?: 'VALID_BILLING_CYCLE';
} | {
    ruleName?: 'VALID_PLAN_DURATION';
} | {
    ruleName?: 'FREE_PRICING_VARIANT_IS_NOT_RECURRING';
} | {
    ruleName?: 'FREE_TRIAL_IS_APPLICABLE';
} | {
    ruleName?: 'CYCLES_COMPLETED_END_OPTION_IS_APPLICABLE';
} | {
    ruleName?: 'PRICING_VARIANT_IDS_UNIQUE';
} | {
    ruleName?: 'FEE_IDS_UNIQUE';
} | {
    ruleName?: 'PERK_IDS_UNIQUE';
} | {
    ruleName?: 'REQUIRED_FIELD';
} | {
    ruleName?: 'BULK_UPDATE_NOT_SUPPORTED';
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface PlanCreatedEnvelope {
    entity: Plan;
    metadata: EventMetadata;
}
/**
 * Triggered when a plan is created.
 * @permissionScope Read Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-PLANS
 * @permissionScope Manage plans and orders of Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS-AND-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS
 * @permissionId PRICING_PLANS.PLAN_READ
 * @webhook
 * @eventType wix.pricing_plans.v3.plan_created
 * @slug created
 * @documentationMaturity preview
 */
declare function onPlanCreated(handler: (event: PlanCreatedEnvelope) => void | Promise<void>): void;
interface PlanDeletedEnvelope {
    entity: Plan;
    metadata: EventMetadata;
}
/**
 * Triggered when a plan is deleted.
 * @permissionScope Read Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-PLANS
 * @permissionScope Manage plans and orders of Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS-AND-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS
 * @permissionId PRICING_PLANS.PLAN_READ
 * @webhook
 * @eventType wix.pricing_plans.v3.plan_deleted
 * @slug deleted
 * @documentationMaturity preview
 */
declare function onPlanDeleted(handler: (event: PlanDeletedEnvelope) => void | Promise<void>): void;
interface PlanUpdatedEnvelope {
    entity: Plan;
    metadata: EventMetadata;
}
/**
 * Triggered when a plan is updated.
 * @permissionScope Read Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-PLANS
 * @permissionScope Manage plans and orders of Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS-AND-ORDERS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS
 * @permissionId PRICING_PLANS.PLAN_READ
 * @webhook
 * @eventType wix.pricing_plans.v3.plan_updated
 * @slug updated
 * @documentationMaturity preview
 */
declare function onPlanUpdated(handler: (event: PlanUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a plan with specified billing terms and a pricing strategy.
 * @param plan - Plan to create.
 * @public
 * @documentationMaturity preview
 * @requiredField plan
 * @requiredField plan.pricingVariants._id
 * @requiredField plan.pricingVariants.name
 * @requiredField plan.status
 * @requiredField plan.visibility
 * @permissionId PRICING_PLANS.PLAN_CREATE
 * @applicableIdentity APP
 * @returns Created plan.
 * @fqn wix.pricing_plans.plans.v3.PlanService.CreatePlan
 */
declare function createPlan(plan: NonNullablePaths<Plan, `pricingVariants.${number}._id` | `pricingVariants.${number}.billingTerms` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.endType` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.fees.${number}.appliedAt` | `pricingVariants.${number}.fees.${number}.priceType` | `pricingVariants.${number}.name` | `visibility`, 6>, options?: CreatePlanOptions): Promise<NonNullablePaths<Plan, `name` | `maxPurchasesPerBuyer` | `pricingVariants` | `pricingVariants.${number}._id` | `pricingVariants.${number}.name` | `pricingVariants.${number}.freeTrialDays` | `pricingVariants.${number}.billingTerms.cyclesCompletedDetails.billingCycleCount` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.billingCycle.count` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.billingTerms.endType` | `perks` | `perks.${number}._id` | `perks.${number}.description` | `visibility` | `buyable` | `buyerCanCancel` | `currency`, 6> & {
    __applicationErrorsType?: CreatePlanApplicationErrors;
    __validationErrorsType?: CreatePlanValidationErrors;
}>;
interface CreatePlanOptions {
    /**
     * Unique key to prevent duplicate plan creation. If the same key is used within a short time period, the original plan will be returned instead of creating a duplicate.
     * @format GUID
     */
    idempotencyKey?: string | null;
}
/**
 * Retrieves a plan by ID.
 * @param planId - ID of the plan to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField planId
 * @permissionId PRICING_PLANS.PLAN_READ_PUBLIC
 * @permissionId PRICING_PLANS.PLAN_READ
 * @applicableIdentity APP
 * @returns Requested plan.
 * @fqn wix.pricing_plans.plans.v3.PlanService.GetPlan
 */
declare function getPlan(planId: string): Promise<NonNullablePaths<Plan, `name` | `maxPurchasesPerBuyer` | `pricingVariants` | `pricingVariants.${number}._id` | `pricingVariants.${number}.name` | `pricingVariants.${number}.freeTrialDays` | `pricingVariants.${number}.billingTerms.cyclesCompletedDetails.billingCycleCount` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.billingCycle.count` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.billingTerms.endType` | `perks` | `perks.${number}._id` | `perks.${number}.description` | `visibility` | `buyable` | `buyerCanCancel` | `currency`, 6>>;
/**
 * Updates a single plan.
 *
 * To update multiple plans at once, call Bulk Update Plans.
 * @param _id - Plan ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField plan
 * @requiredField plan.pricingVariants._id
 * @requiredField plan.pricingVariants.name
 * @requiredField plan.revision
 * @permissionId PRICING_PLANS.PLAN_UPDATE
 * @permissionId PRICING_PLANS.UPDATE_ALL_SUBSCRIPTIONS
 * @applicableIdentity APP
 * @returns Updated plan.
 * @fqn wix.pricing_plans.plans.v3.PlanService.UpdatePlan
 */
declare function updatePlan(_id: string, plan: NonNullablePaths<UpdatePlan, `pricingVariants.${number}._id` | `pricingVariants.${number}.billingTerms` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.endType` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.fees.${number}.appliedAt` | `pricingVariants.${number}.fees.${number}.priceType` | `pricingVariants.${number}.name` | `revision`, 6>, options?: UpdatePlanOptions): Promise<NonNullablePaths<Plan, `name` | `maxPurchasesPerBuyer` | `pricingVariants` | `pricingVariants.${number}._id` | `pricingVariants.${number}.name` | `pricingVariants.${number}.freeTrialDays` | `pricingVariants.${number}.billingTerms.cyclesCompletedDetails.billingCycleCount` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.billingCycle.count` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.billingTerms.endType` | `perks` | `perks.${number}._id` | `perks.${number}.description` | `visibility` | `buyable` | `buyerCanCancel` | `currency`, 6> & {
    __validationErrorsType?: UpdatePlanValidationErrors;
}>;
interface UpdatePlan {
    /**
     * Plan ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the plan is updated.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the plan was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the plan was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Plan name displayed to customers.
     * @minLength 1
     * @maxLength 50
     */
    name?: string;
    /**
     * Plan description that explains what customers get with this plan.
     * @maxLength 450
     */
    description?: string | null;
    /** Visual information representing the plan. */
    image?: string;
    /**
     * Unique identifier for this plan within the Wix site. If not provided, generated automatically from the plan name.
     * @format URL_SLUG
     * @maxLength 255
     */
    slug?: string | null;
    /**
     * Terms and conditions text that customers must agree to when purchasing this plan.
     * @maxLength 3000
     */
    termsAndConditions?: string | null;
    /**
     * Maximum number of times the same customer can purchase this plan. Use `0` for unlimited purchases or `1` to limit to one purchase per customer.
     * @max 10
     */
    maxPurchasesPerBuyer?: number;
    /**
     * Pricing variants that define different billing and pricing options for this plan. Currently limited to 1 variant per plan.
     * @minSize 1
     * @maxSize 1
     */
    pricingVariants?: PricingVariant[];
    /**
     * List of benefits or features included with this plan.
     * @maxSize 500
     */
    perks?: Perk[];
    /** Plan visibility. */
    visibility?: VisibilityWithLiterals;
    /** Whether customers can currently purchase this plan. If set to `false`, customer won't be able to buy a plan themselves. In this case a Wix user has to assign the plan through the [dashboard](https://support.wix.com/en/article/pricing-plans-selling-plans-offline). */
    buyable?: boolean;
    /**
     * ID of the form associated with the plan at checkout.
     * @format GUID
     */
    formId?: string | null;
    /** Whether the customer is allowed to cancel their plan. */
    buyerCanCancel?: boolean;
    /**
     * Payment currency.
     * @readonly
     * @format CURRENCY
     */
    currency?: string;
    /** Data extensions. Learn more about [extended fields](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-schema-plugin-extensions). */
    extendedFields?: ExtendedFields;
}
interface UpdatePlanOptions {
    /**
     * Type of cascade to apply.
     * @internal
     */
    cascade?: CascadeWithLiterals;
}
/**
 * Updates multiple plans at once.
 *
 * You can't change plan names with this method.
 *
 * To update a single plan, call Update Plan.
 * @param plans - Plans to update.
 * @public
 * @documentationMaturity preview
 * @requiredField plans
 * @requiredField plans.plan
 * @requiredField plans.plan._id
 * @requiredField plans.plan.pricingVariants._id
 * @requiredField plans.plan.pricingVariants.name
 * @requiredField plans.plan.revision
 * @permissionId PRICING_PLANS.PLAN_UPDATE
 * @permissionId PRICING_PLANS.UPDATE_ALL_SUBSCRIPTIONS
 * @applicableIdentity APP
 * @fqn wix.pricing_plans.plans.v3.PlanService.BulkUpdatePlans
 */
declare function bulkUpdatePlans(plans: NonNullablePaths<MaskedPlan, `plan` | `plan._id` | `plan.pricingVariants.${number}._id` | `plan.pricingVariants.${number}.billingTerms` | `plan.pricingVariants.${number}.billingTerms.billingCycle.period` | `plan.pricingVariants.${number}.billingTerms.endType` | `plan.pricingVariants.${number}.billingTerms.startType` | `plan.pricingVariants.${number}.fees.${number}.appliedAt` | `plan.pricingVariants.${number}.fees.${number}.priceType` | `plan.pricingVariants.${number}.name` | `plan.revision`, 7>[], options?: BulkUpdatePlansOptions): Promise<NonNullablePaths<BulkUpdatePlansResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.name` | `results.${number}.item.maxPurchasesPerBuyer` | `results.${number}.item.visibility` | `results.${number}.item.buyable` | `results.${number}.item.buyerCanCancel` | `results.${number}.item.currency` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __validationErrorsType?: BulkUpdatePlansValidationErrors;
}>;
interface BulkUpdatePlansOptions {
    /** Set the value to `true` to receive details of the updated plans. */
    returnEntity?: boolean;
    /**
     * Type of cascade to apply.
     * @internal
     */
    cascade?: CascadeWithLiterals;
}
/**
 * Deletes a plan.
 * @param planId - ID of the plan to delete.
 * @public
 * @documentationMaturity preview
 * @requiredField planId
 * @permissionId PRICING_PLANS.PLAN_DELETE
 * @applicableIdentity APP
 * @fqn wix.pricing_plans.plans.v3.PlanService.DeletePlan
 */
declare function deletePlan(planId: string): Promise<void>;
/**
 * Creates a query to retrieve a list of plans.
 *
 * The `queryPlans()` method builds a query to retrieve a list of plans and returns a [`PlansQueryBuilder`](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans-v3/plans-query-builder/ascending) object.
 *
 * The returned object contains the query definition, which is typically used to run the query using the [`find()`](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans-v3/plans-query-builder/find) method.
 *
 * You can refine the query by chaining `PlansQueryBuilder` methods onto the query. `PlansQueryBuilder` methods enable you to sort, filter, and control the results `queryPlans()` returns.
 *
 * `queryPlans()` runs with these `PlansQueryBuilder` defaults, which you can override:
 *
 * - [`limit(50)`](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans-v3/plans-query-builder/limit)
 * @public
 * @documentationMaturity preview
 * @permissionId PRICING_PLANS.PLAN_READ_PUBLIC
 * @permissionId PRICING_PLANS.PLAN_READ
 * @applicableIdentity APP
 * @fqn wix.pricing_plans.plans.v3.PlanService.QueryPlans
 */
declare function queryPlans(): PlansQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface PlansQueryResult extends QueryCursorResult {
    items: Plan[];
    query: PlansQueryBuilder;
    next: () => Promise<PlansQueryResult>;
    prev: () => Promise<PlansQueryResult>;
}
interface PlansQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'visibility' | 'formId', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'visibility' | 'formId', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'formId', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'formId', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'formId', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'formId', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'formId', value: string) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'visibility' | 'formId', value: any[]) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasAll: (propertyName: string, value: any[]) => PlansQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'visibility' | 'formId', value: any) => PlansQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'visibility' | 'formId', value: boolean) => PlansQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'visibility' | 'status' | 'formId' | 'archived' | 'primary' | 'displayIndex'>) => PlansQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_id' | '_createdDate' | '_updatedDate' | 'name' | 'slug' | 'termsAndConditions' | 'pricingVariants.id' | 'pricingVariants.name' | 'visibility' | 'status' | 'formId' | 'archived' | 'primary' | 'displayIndex'>) => PlansQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => PlansQueryBuilder;
    /** @param cursor - A pointer to specific record
     * @documentationMaturity preview
     */
    skipTo: (cursor: string) => PlansQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<PlansQueryResult>;
}
interface PlanSearchSpec extends SearchSpec {
    searchable: ['name'];
    aggregatable: [
        '_createdDate',
        '_id',
        '_updatedDate',
        'archived',
        'displayIndex',
        'formId',
        'name',
        'pricingVariants._id',
        'pricingVariants.name',
        'pricingVariants.pricingStrategies.flatRate.amount',
        'primary',
        'slug',
        'status',
        'termsAndConditions',
        'visibility'
    ];
    paging: 'cursor';
    wql: [
        {
            operators: ['$hasAll', '$hasSome'];
            fields: ['pricingVariants.pricingStrategies.flatRate.amount'];
            sort: 'NONE';
        },
        {
            operators: ['$hasAll', '$hasSome'];
            fields: ['pricingVariants._id', 'pricingVariants.name'];
            sort: 'BOTH';
        },
        {
            operators: '*';
            fields: [
                '_createdDate',
                '_id',
                '_updatedDate',
                'archived',
                'displayIndex',
                'formId',
                'name',
                'primary',
                'slug',
                'status',
                'termsAndConditions',
                'visibility'
            ];
            sort: 'BOTH';
        }
    ];
}
type CommonSearchWithEntityContext = Search<Plan, PlanSearchSpec>;
type PlanSearch = {
    /**
    Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort.
    */
    cursorPaging?: {
        /**
      Maximum number of items to return in the results.
      @max: 100
      */
        limit?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['limit'] | null;
        /**
      Pointer to the next or previous page in the list of results.
    
      Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
      Not relevant for the first request.
      @maxLength: 16000
      */
        cursor?: NonNullable<CommonSearchWithEntityContext['cursorPaging']>['cursor'] | null;
    };
    /**
    Filter object.
  
    Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
    */
    filter?: CommonSearchWithEntityContext['filter'] | null;
    /**
    Sort object.
  
    Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
    @maxSize: 10
    */
    sort?: {
        /**
      Name of the field to sort by.
      @maxLength: 512
      */
        fieldName?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['fieldName'];
        /**
      Sort order.
      */
        order?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['order'];
    }[];
    /**
    Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
    @maxSize: 10
    */
    aggregations?: {
        /**
      Value aggregation
      */
        value?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['value'];
        /**
      Range aggregation
      */
        range?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['range'];
        /**
      Scalar aggregation
      */
        scalar?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['scalar'];
        /**
      Date histogram aggregation
      */
        dateHistogram?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['dateHistogram'];
        /**
      Nested aggregation
      */
        nested?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['nested'];
        /**
      User-defined name of aggregation, should be unique, will appear in aggregation results
      @maxLength: 100
      */
        name?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['name'] | null;
        /**
      Type of aggregation, client must provide matching aggregation field below
      */
        type?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['type'];
        /**
      Field to aggregate by, use dot notation to specify json path
      @maxLength: 200
      */
        fieldPath?: NonNullable<CommonSearchWithEntityContext['aggregations']>[number]['fieldPath'];
    }[];
    /**
    Free text to match in searchable fields.
    */
    search?: {
        /**
      Defines how separate search terms in `expression` are combined
      */
        mode?: NonNullable<CommonSearchWithEntityContext['search']>['mode'];
        /**
      Search term or expression
      @maxLength: 100
      */
        expression?: NonNullable<CommonSearchWithEntityContext['search']>['expression'] | null;
        /**
      Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path
      @maxLength: 200,
      @maxSize: 20
      */
        fields?: NonNullable<CommonSearchWithEntityContext['search']>['fields'];
        /**
      Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm)
      */
        fuzzy?: NonNullable<CommonSearchWithEntityContext['search']>['fuzzy'];
    };
    /**
    Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
    @maxLength: 50
    */
    timeZone?: CommonSearchWithEntityContext['timeZone'] | null;
};
/**
 * Counts plans by the provided filter.
 *
 * To learn about working with queries, see [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language).
 * @public
 * @documentationMaturity preview
 * @permissionId PRICING_PLANS.PLAN_READ
 * @applicableIdentity APP
 * @fqn wix.pricing_plans.plans.v3.PlanService.CountPlans
 */
declare function countPlans(options?: CountPlansOptions): Promise<NonNullablePaths<CountPlansResponse, `count`, 2>>;
interface CountPlansOptions {
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /** Free text to match in searchable fields. When specified, the method uses search instead of filter, and may be less consistent. */
    search?: SearchDetails;
}
/**
 * Changes the price of a pricing plan and applies it to existing subscriptions if requested
 * @param planId - ID of the plan to change.
 * @param pricingVariantId - ID of the pricing variant to change.
 * @internal
 * @documentationMaturity preview
 * @requiredField options.pricingStrategies
 * @requiredField options.revision
 * @requiredField planId
 * @requiredField pricingVariantId
 * @permissionId PRICING_PLANS.CHANGE_PRICE
 * @applicableIdentity APP
 * @fqn wix.pricing_plans.plans.v3.PlanService.ChangePrice
 */
declare function changePrice(planId: string, pricingVariantId: string, options?: NonNullablePaths<ChangePriceOptions, `pricingStrategies` | `revision`, 2>): Promise<NonNullablePaths<ChangePriceResponse, `plan.name` | `plan.maxPurchasesPerBuyer` | `plan.pricingVariants` | `plan.pricingVariants.${number}._id` | `plan.pricingVariants.${number}.name` | `plan.pricingVariants.${number}.freeTrialDays` | `plan.pricingVariants.${number}.billingTerms.cyclesCompletedDetails.billingCycleCount` | `plan.pricingVariants.${number}.billingTerms.billingCycle.period` | `plan.pricingVariants.${number}.billingTerms.billingCycle.count` | `plan.pricingVariants.${number}.billingTerms.startType` | `plan.pricingVariants.${number}.billingTerms.endType` | `plan.perks` | `plan.perks.${number}._id` | `plan.perks.${number}.description` | `plan.visibility` | `plan.buyable` | `plan.buyerCanCancel` | `plan.currency`, 7>>;
interface ChangePriceOptions {
    /**
     * New pricing strategy.
     * @minSize 1
     * @maxSize 1
     */
    pricingStrategies: PricingStrategy[];
    /** To prevent conflicting changes, the current plan revision must be passed when updating the price. */
    revision: string | null;
    /** Type of cascade to apply. */
    cascade?: CascadeWithLiterals;
}

export { type BillingTerms as $, AppliedAt as A, type BulkUpdatePlansOptions as B, type CreatePlanOptions as C, DayOfWeek as D, EndType as E, SortOrder as F, SortType as G, SortDirection as H, MissingValues as I, ScalarType as J, Interval as K, AggregationType as L, type MaskedPlan as M, NestedAggregationType as N, Mode as O, type Plan as P, type PricingVariant as Q, RulesType as R, type SearchPlansResponse as S, Type as T, type UpdatePlan as U, Visibility as V, WebhookIdentityType as W, type FlatRate as X, type Fee as Y, type FeePriceOptionOneOf as Z, type FixedAmountOption as _, type CreatePlanApplicationErrors as a, type UpdatePlanResponse as a$, type BillingTermsEndOptionOneOf as a0, type Duration as a1, type CyclesCompletedDetails as a2, type PricingStrategy as a3, type PricingStrategyStrategyOneOf as a4, type Perk as a5, type TermsAndConditionsSettings as a6, type ThankYouPageSettings as a7, type ExtendedFields as a8, type ValidateOptionsRequest as a9, type TimePeriod as aA, type SpecialHourPeriod as aB, type Multilingual as aC, type SupportedLanguage as aD, type ConsentPolicy as aE, type Translation as aF, type ChangeContext as aG, type ChangeContextPayloadOneOf as aH, type PropertiesChange as aI, type SiteCreated as aJ, type SiteCloned as aK, type Empty as aL, type DomainEvent as aM, type DomainEventBodyOneOf as aN, type EntityCreatedEvent as aO, type RestoreInfo as aP, type EntityUpdatedEvent as aQ, type EntityDeletedEvent as aR, type ActionEvent as aS, type MessageEnvelope as aT, type IdentificationData as aU, type IdentificationDataIdOneOf as aV, type CreatePlanRequest as aW, type CreatePlanResponse as aX, type GetPlanRequest as aY, type GetPlanResponse as aZ, type UpdatePlanRequest as a_, type Options as aa, type OptionsOptionsOneOf as ab, type PlanOptions as ac, type ValidateOptionsResponse as ad, type Violation as ae, type GetPlanConfigurationConstraintsRequest as af, type GetPlanConfigurationConstraintsResponse as ag, type StartDateLimits as ah, type StartDateRules as ai, type StartDateRulesDateRulesOneOf as aj, type FixedDatesOptions as ak, type RecurrenceOptions as al, type RecurrenceOptionsRecurrenceOneOf as am, type WeeklyRecurrence as an, type MonthlyRecurrence as ao, type GetPlanPreviewRequest as ap, type GetPlanPreviewResponse as aq, type SitePropertiesNotification as ar, type SitePropertiesEvent as as, type Properties as at, type Categories as au, type Locale as av, type Address as aw, type AddressHint as ax, type GeoCoordinates as ay, type BusinessSchedule as az, type CreatePlanValidationErrors as b, type ScalarTypeWithLiterals as b$, type BulkUpdatePlansRequest as b0, type ItemMetadata as b1, type ApplicationError as b2, type BulkPlanResult as b3, type BulkActionMetadata as b4, type DeletePlanRequest as b5, type DeletePlanResponse as b6, type QueryPlansRequest as b7, type QueryV2 as b8, type QueryV2PagingMethodOneOf as b9, type UpdateExtendedFieldsResponse as bA, type BaseEventMetadata as bB, type EventMetadata as bC, type PlansQueryResult as bD, type PlanSearchSpec as bE, type PriceTypeWithLiterals as bF, type AppliedAtWithLiterals as bG, type PeriodWithLiterals as bH, type StartTypeWithLiterals as bI, type EndTypeWithLiterals as bJ, type VisibilityWithLiterals as bK, type StatusWithLiterals as bL, type TypeWithLiterals as bM, type TaxableAddressWithLiterals as bN, type ValidationStrategyWithLiterals as bO, type RulesTypeWithLiterals as bP, type RecurrenceTypeWithLiterals as bQ, type V1DayOfWeekWithLiterals as bR, type PlacementTypeWithLiterals as bS, type DayOfWeekWithLiterals as bT, type ResolutionMethodWithLiterals as bU, type WebhookIdentityTypeWithLiterals as bV, type CascadeWithLiterals as bW, type SortOrderWithLiterals as bX, type SortTypeWithLiterals as bY, type SortDirectionWithLiterals as bZ, type MissingValuesWithLiterals as b_, type Sorting as ba, type Paging as bb, type CursorPaging as bc, type QueryPlansResponse as bd, type PagingMetadataV2 as be, type Cursors as bf, type SearchPlansRequest as bg, type CursorSearch as bh, type CursorSearchPagingMethodOneOf as bi, type Aggregation as bj, type AggregationKindOneOf as bk, type RangeBucket as bl, type IncludeMissingValuesOptions as bm, type ValueAggregation as bn, type ValueAggregationOptionsOneOf as bo, type RangeAggregation as bp, type ScalarAggregation as bq, type DateHistogramAggregation as br, type NestedAggregationItem as bs, type NestedAggregationItemKindOneOf as bt, type NestedAggregation as bu, type SearchDetails as bv, type CursorPagingMetadata as bw, type CountPlansRequest as bx, type ChangePriceRequest as by, type UpdateExtendedFieldsRequest as bz, type UpdatePlanOptions as c, type NestedAggregationTypeWithLiterals as c0, type IntervalWithLiterals as c1, type AggregationTypeWithLiterals as c2, type ModeWithLiterals as c3, type CommonSearchWithEntityContext as c4, onPlanCreated as c5, onPlanDeleted as c6, onPlanUpdated as c7, createPlan as c8, getPlan as c9, updatePlan as ca, bulkUpdatePlans as cb, deletePlan as cc, queryPlans as cd, countPlans as ce, changePrice as cf, type UpdatePlanValidationErrors as d, type BulkUpdatePlansResponse as e, type BulkUpdatePlansValidationErrors as f, type PlansQueryBuilder as g, type PlanSearch as h, type CountPlansOptions as i, type CountPlansResponse as j, type ChangePriceOptions as k, type ChangePriceResponse as l, type PlanCreatedEnvelope as m, type PlanDeletedEnvelope as n, type PlanUpdatedEnvelope as o, PriceType as p, Period as q, StartType as r, Status as s, TaxableAddress as t, ValidationStrategy as u, RecurrenceType as v, V1DayOfWeek as w, PlacementType as x, ResolutionMethod as y, Cascade as z };
