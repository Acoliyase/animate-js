import { HttpClient, NonNullablePaths, EventDefinition, MaybeContext, BuildRESTFunction, BuildEventDefinition } from '@wix/sdk-types';
import { P as Plan, C as CreatePlanOptions, a as CreatePlanApplicationErrors, b as CreatePlanValidationErrors, U as UpdatePlan, c as UpdatePlanOptions, d as UpdatePlanValidationErrors, M as MaskedPlan, B as BulkUpdatePlansOptions, e as BulkUpdatePlansResponse, f as BulkUpdatePlansValidationErrors, g as PlansQueryBuilder, h as PlanSearch, S as SearchPlansResponse, i as CountPlansOptions, j as CountPlansResponse, k as PlanCreatedEnvelope, l as PlanDeletedEnvelope, m as PlanUpdatedEnvelope } from './pricing-plans-v3-plan-plans-v-3.universal-Y-yJFHML.mjs';
export { aQ as ActionEvent, au as Address, av as AddressHint, bh as Aggregation, bi as AggregationKindOneOf, J as AggregationType, c2 as AggregationTypeWithLiterals, b0 as ApplicationError, A as AppliedAt, bG as AppliedAtWithLiterals, bA as BaseEventMetadata, Z as BillingTerms, _ as BillingTermsEndOptionOneOf, b2 as BulkActionMetadata, b1 as BulkPlanResult, a_ as BulkUpdatePlansRequest, ax as BusinessSchedule, x as Cascade, bW as CascadeWithLiterals, as as Categories, aE as ChangeContext, aF as ChangeContextPayloadOneOf, bE as ChangePriceOptions, bw as ChangePriceRequest, bx as ChangePriceResponse, c4 as CommonSearchWithEntityContext, aC as ConsentPolicy, bv as CountPlansRequest, aU as CreatePlanRequest, aV as CreatePlanResponse, ba as CursorPaging, bu as CursorPagingMetadata, bf as CursorSearch, bg as CursorSearchPagingMethodOneOf, bd as Cursors, a0 as CyclesCompletedDetails, bp as DateHistogramAggregation, D as DayOfWeek, bT as DayOfWeekWithLiterals, b3 as DeletePlanRequest, b4 as DeletePlanResponse, aK as DomainEvent, aL as DomainEventBodyOneOf, $ as Duration, aJ as Empty, E as EndType, bJ as EndTypeWithLiterals, aM as EntityCreatedEvent, aP as EntityDeletedEvent, aO as EntityUpdatedEvent, bB as EventMetadata, a6 as ExtendedFields, Q as Fee, X as FeePriceOptionOneOf, Y as FixedAmountOption, ai as FixedDatesOptions, O as FlatRate, aw as GeoCoordinates, ad as GetPlanConfigurationConstraintsRequest, ae as GetPlanConfigurationConstraintsResponse, an as GetPlanPreviewRequest, ao as GetPlanPreviewResponse, aW as GetPlanRequest, aX as GetPlanResponse, aS as IdentificationData, aT as IdentificationDataIdOneOf, bk as IncludeMissingValuesOptions, I as Interval, c1 as IntervalWithLiterals, a$ as ItemMetadata, at as Locale, aR as MessageEnvelope, G as MissingValues, b_ as MissingValuesWithLiterals, K as Mode, c3 as ModeWithLiterals, am as MonthlyRecurrence, aA as Multilingual, bs as NestedAggregation, bq as NestedAggregationItem, br as NestedAggregationItemKindOneOf, N as NestedAggregationType, c0 as NestedAggregationTypeWithLiterals, a8 as Options, a9 as OptionsOptionsOneOf, b9 as Paging, bc as PagingMetadataV2, o as Period, bH as PeriodWithLiterals, a3 as Perk, v as PlacementType, bS as PlacementTypeWithLiterals, aa as PlanOptions, bD as PlanSearchSpec, bC as PlansQueryResult, n as PriceType, bF as PriceTypeWithLiterals, a1 as PricingStrategy, a2 as PricingStrategyStrategyOneOf, L as PricingVariant, ar as Properties, aG as PropertiesChange, b5 as QueryPlansRequest, bb as QueryPlansResponse, b6 as QueryV2, b7 as QueryV2PagingMethodOneOf, bn as RangeAggregation, bj as RangeBucket, aj as RecurrenceOptions, ak as RecurrenceOptionsRecurrenceOneOf, t as RecurrenceType, bQ as RecurrenceTypeWithLiterals, w as ResolutionMethod, bU as ResolutionMethodWithLiterals, aN as RestoreInfo, R as RulesType, bP as RulesTypeWithLiterals, bo as ScalarAggregation, H as ScalarType, b$ as ScalarTypeWithLiterals, bt as SearchDetails, be as SearchPlansRequest, aI as SiteCloned, aH as SiteCreated, aq as SitePropertiesEvent, ap as SitePropertiesNotification, F as SortDirection, bZ as SortDirectionWithLiterals, y as SortOrder, bX as SortOrderWithLiterals, z as SortType, bY as SortTypeWithLiterals, b8 as Sorting, az as SpecialHourPeriod, af as StartDateLimits, ag as StartDateRules, ah as StartDateRulesDateRulesOneOf, p as StartType, bI as StartTypeWithLiterals, q as Status, bL as StatusWithLiterals, aB as SupportedLanguage, r as TaxableAddress, bN as TaxableAddressWithLiterals, a4 as TermsAndConditionsSettings, a5 as ThankYouPageSettings, ay as TimePeriod, aD as Translation, T as Type, bM as TypeWithLiterals, by as UpdateExtendedFieldsRequest, bz as UpdateExtendedFieldsResponse, aY as UpdatePlanRequest, aZ as UpdatePlanResponse, u as V1DayOfWeek, bR as V1DayOfWeekWithLiterals, a7 as ValidateOptionsRequest, ab as ValidateOptionsResponse, s as ValidationStrategy, bO as ValidationStrategyWithLiterals, bl as ValueAggregation, bm as ValueAggregationOptionsOneOf, ac as Violation, V as Visibility, bK as VisibilityWithLiterals, W as WebhookIdentityType, bV as WebhookIdentityTypeWithLiterals, al as WeeklyRecurrence } from './pricing-plans-v3-plan-plans-v-3.universal-Y-yJFHML.mjs';

declare function createPlan$1(httpClient: HttpClient): CreatePlanSignature;
interface CreatePlanSignature {
    /**
     * Creates a plan with specified billing terms and a pricing strategy.
     * @param - Plan to create.
     * @returns Created plan.
     */
    (plan: NonNullablePaths<Plan, `pricingVariants.${number}._id` | `pricingVariants.${number}.billingTerms` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.endType` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.fees.${number}.appliedAt` | `pricingVariants.${number}.fees.${number}.priceType` | `pricingVariants.${number}.name` | `visibility`, 6>, options?: CreatePlanOptions): Promise<NonNullablePaths<Plan, `name` | `maxPurchasesPerBuyer` | `pricingVariants` | `pricingVariants.${number}._id` | `pricingVariants.${number}.name` | `pricingVariants.${number}.freeTrialDays` | `pricingVariants.${number}.billingTerms.cyclesCompletedDetails.billingCycleCount` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.billingCycle.count` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.billingTerms.endType` | `perks` | `perks.${number}._id` | `perks.${number}.description` | `visibility` | `buyable` | `buyerCanCancel` | `currency`, 6> & {
        __applicationErrorsType?: CreatePlanApplicationErrors;
        __validationErrorsType?: CreatePlanValidationErrors;
    }>;
}
declare function getPlan$1(httpClient: HttpClient): GetPlanSignature;
interface GetPlanSignature {
    /**
     * Retrieves a plan by ID.
     * @param - ID of the plan to retrieve.
     * @returns Requested plan.
     */
    (planId: string): Promise<NonNullablePaths<Plan, `name` | `maxPurchasesPerBuyer` | `pricingVariants` | `pricingVariants.${number}._id` | `pricingVariants.${number}.name` | `pricingVariants.${number}.freeTrialDays` | `pricingVariants.${number}.billingTerms.cyclesCompletedDetails.billingCycleCount` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.billingCycle.count` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.billingTerms.endType` | `perks` | `perks.${number}._id` | `perks.${number}.description` | `visibility` | `buyable` | `buyerCanCancel` | `currency`, 6>>;
}
declare function updatePlan$1(httpClient: HttpClient): UpdatePlanSignature;
interface UpdatePlanSignature {
    /**
     * Updates a single plan.
     *
     * To update multiple plans at once, call Bulk Update Plans.
     * @param - Plan ID.
     * @returns Updated plan.
     */
    (_id: string, plan: NonNullablePaths<UpdatePlan, `pricingVariants.${number}._id` | `pricingVariants.${number}.billingTerms` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.endType` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.fees.${number}.appliedAt` | `pricingVariants.${number}.fees.${number}.priceType` | `pricingVariants.${number}.name` | `revision`, 6>, options?: UpdatePlanOptions): Promise<NonNullablePaths<Plan, `name` | `maxPurchasesPerBuyer` | `pricingVariants` | `pricingVariants.${number}._id` | `pricingVariants.${number}.name` | `pricingVariants.${number}.freeTrialDays` | `pricingVariants.${number}.billingTerms.cyclesCompletedDetails.billingCycleCount` | `pricingVariants.${number}.billingTerms.billingCycle.period` | `pricingVariants.${number}.billingTerms.billingCycle.count` | `pricingVariants.${number}.billingTerms.startType` | `pricingVariants.${number}.billingTerms.endType` | `perks` | `perks.${number}._id` | `perks.${number}.description` | `visibility` | `buyable` | `buyerCanCancel` | `currency`, 6> & {
        __validationErrorsType?: UpdatePlanValidationErrors;
    }>;
}
declare function bulkUpdatePlans$1(httpClient: HttpClient): BulkUpdatePlansSignature;
interface BulkUpdatePlansSignature {
    /**
     * Updates multiple plans at once.
     *
     * You can't change plan names with this method.
     *
     * To update a single plan, call Update Plan.
     * @param - Plans to update.
     */
    (plans: NonNullablePaths<MaskedPlan, `plan` | `plan._id` | `plan.pricingVariants.${number}._id` | `plan.pricingVariants.${number}.billingTerms` | `plan.pricingVariants.${number}.billingTerms.billingCycle.period` | `plan.pricingVariants.${number}.billingTerms.endType` | `plan.pricingVariants.${number}.billingTerms.startType` | `plan.pricingVariants.${number}.fees.${number}.appliedAt` | `plan.pricingVariants.${number}.fees.${number}.priceType` | `plan.pricingVariants.${number}.name` | `plan.revision`, 7>[], options?: BulkUpdatePlansOptions): Promise<NonNullablePaths<BulkUpdatePlansResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item.name` | `results.${number}.item.maxPurchasesPerBuyer` | `results.${number}.item.visibility` | `results.${number}.item.buyable` | `results.${number}.item.buyerCanCancel` | `results.${number}.item.currency` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __validationErrorsType?: BulkUpdatePlansValidationErrors;
    }>;
}
declare function deletePlan$1(httpClient: HttpClient): DeletePlanSignature;
interface DeletePlanSignature {
    /**
     * Deletes a plan.
     * @param - ID of the plan to delete.
     */
    (planId: string): Promise<void>;
}
declare function queryPlans$1(httpClient: HttpClient): QueryPlansSignature;
interface QueryPlansSignature {
    /**
     * Creates a query to retrieve a list of plans.
     *
     * The `queryPlans()` method builds a query to retrieve a list of plans and returns a [`PlansQueryBuilder`](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans-v3/plans-query-builder/ascending) object.
     *
     * The returned object contains the query definition, which is typically used to run the query using the [`find()`](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans-v3/plans-query-builder/find) method.
     *
     * You can refine the query by chaining `PlansQueryBuilder` methods onto the query. `PlansQueryBuilder` methods enable you to sort, filter, and control the results `queryPlans()` returns.
     *
     * `queryPlans()` runs with these `PlansQueryBuilder` defaults, which you can override:
     *
     * - [`limit(50)`](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans-v3/plans-query-builder/limit)
     */
    (): PlansQueryBuilder;
}
declare function searchPlans$1(httpClient: HttpClient): SearchPlansSignature;
interface SearchPlansSignature {
    /**
     * Retrieves a list of plans that match the provided search query and optionally performs aggregations on the data queried.
     *
     * To learn about working with queries, see [Search, Query and List Methods](https://dev.wix.com/docs/rest/articles/get-started/search-query-and-list-methods).
     * @param - Search options. See [API Query Language](https://dev.wix.com/docs/rest/articles/get-started/api-query-language) for more details.
     */
    (search: PlanSearch): Promise<NonNullablePaths<SearchPlansResponse, `plans` | `plans.${number}.name` | `plans.${number}.maxPurchasesPerBuyer` | `plans.${number}.visibility` | `plans.${number}.buyable` | `plans.${number}.buyerCanCancel` | `plans.${number}.currency`, 4>>;
}
declare function countPlans$1(httpClient: HttpClient): CountPlansSignature;
interface CountPlansSignature {
    /**
     * Counts plans by the provided filter.
     *
     * To learn about working with queries, see [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language).
     */
    (options?: CountPlansOptions): Promise<NonNullablePaths<CountPlansResponse, `count`, 2>>;
}
declare const onPlanCreated$1: EventDefinition<PlanCreatedEnvelope, "wix.pricing_plans.v3.plan_created">;
declare const onPlanDeleted$1: EventDefinition<PlanDeletedEnvelope, "wix.pricing_plans.v3.plan_deleted">;
declare const onPlanUpdated$1: EventDefinition<PlanUpdatedEnvelope, "wix.pricing_plans.v3.plan_updated">;

declare const createPlan: MaybeContext<BuildRESTFunction<typeof createPlan$1> & typeof createPlan$1>;
declare const getPlan: MaybeContext<BuildRESTFunction<typeof getPlan$1> & typeof getPlan$1>;
declare const updatePlan: MaybeContext<BuildRESTFunction<typeof updatePlan$1> & typeof updatePlan$1>;
declare const bulkUpdatePlans: MaybeContext<BuildRESTFunction<typeof bulkUpdatePlans$1> & typeof bulkUpdatePlans$1>;
declare const deletePlan: MaybeContext<BuildRESTFunction<typeof deletePlan$1> & typeof deletePlan$1>;
declare const queryPlans: MaybeContext<BuildRESTFunction<typeof queryPlans$1> & typeof queryPlans$1>;
declare const searchPlans: MaybeContext<BuildRESTFunction<typeof searchPlans$1> & typeof searchPlans$1>;
declare const countPlans: MaybeContext<BuildRESTFunction<typeof countPlans$1> & typeof countPlans$1>;
/**
 * Triggered when a plan is created.
 */
declare const onPlanCreated: BuildEventDefinition<typeof onPlanCreated$1> & typeof onPlanCreated$1;
/**
 * Triggered when a plan is deleted.
 */
declare const onPlanDeleted: BuildEventDefinition<typeof onPlanDeleted$1> & typeof onPlanDeleted$1;
/**
 * Triggered when a plan is updated.
 */
declare const onPlanUpdated: BuildEventDefinition<typeof onPlanUpdated$1> & typeof onPlanUpdated$1;

export { BulkUpdatePlansOptions, BulkUpdatePlansResponse, BulkUpdatePlansValidationErrors, CountPlansOptions, CountPlansResponse, CreatePlanApplicationErrors, CreatePlanOptions, CreatePlanValidationErrors, MaskedPlan, Plan, PlanCreatedEnvelope, PlanDeletedEnvelope, PlanSearch, PlanUpdatedEnvelope, PlansQueryBuilder, SearchPlansResponse, UpdatePlan, UpdatePlanOptions, UpdatePlanValidationErrors, bulkUpdatePlans, countPlans, createPlan, deletePlan, getPlan, onPlanCreated, onPlanDeleted, onPlanUpdated, queryPlans, searchPlans, updatePlan };
