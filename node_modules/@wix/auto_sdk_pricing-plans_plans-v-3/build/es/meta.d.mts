import { aU as CreatePlanRequest$1, aV as CreatePlanResponse$1, aW as GetPlanRequest$1, aX as GetPlanResponse$1, aY as UpdatePlanRequest$1, aZ as UpdatePlanResponse$1, a_ as BulkUpdatePlansRequest$1, e as BulkUpdatePlansResponse$1, b3 as DeletePlanRequest$1, b4 as DeletePlanResponse$1, b5 as QueryPlansRequest$1, bb as QueryPlansResponse$1, be as SearchPlansRequest$1, S as SearchPlansResponse$1, bv as CountPlansRequest$1, j as CountPlansResponse$1, bw as ChangePriceRequest$1, bx as ChangePriceResponse$1 } from './pricing-plans-v3-plan-plans-v-3.universal-Y-yJFHML.mjs';
import '@wix/sdk-types';

interface Plan {
    /**
     * Plan ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the plan is updated.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the plan was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the plan was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Plan name displayed to customers.
     * @minLength 1
     * @maxLength 50
     */
    name?: string;
    /**
     * Plan description that explains what customers get with this plan.
     * @maxLength 450
     */
    description?: string | null;
    /** Visual information representing the plan. */
    image?: Image;
    /**
     * Unique identifier for this plan within the Wix site. If not provided, generated automatically from the plan name.
     * @format URL_SLUG
     * @maxLength 255
     */
    slug?: string | null;
    /**
     * Terms and conditions text that customers must agree to when purchasing this plan.
     * @maxLength 3000
     */
    termsAndConditions?: string | null;
    /**
     * Maximum number of times the same customer can purchase this plan. Use `0` for unlimited purchases or `1` to limit to one purchase per customer.
     * @max 10
     */
    maxPurchasesPerBuyer?: number;
    /**
     * Pricing variants that define different billing and pricing options for this plan. Currently limited to 1 variant per plan.
     * @minSize 1
     * @maxSize 1
     */
    pricingVariants?: PricingVariant[];
    /**
     * List of benefits or features included with this plan.
     * @maxSize 500
     */
    perks?: Perk[];
    /** Plan visibility. */
    visibility?: VisibilityWithLiterals;
    /** Whether customers can currently purchase this plan. If set to `false`, customer won't be able to buy a plan themselves. In this case a Wix user has to assign the plan through the [dashboard](https://support.wix.com/en/article/pricing-plans-selling-plans-offline). */
    buyable?: boolean;
    /**
     * ID of the form associated with the plan at checkout.
     * @format GUID
     */
    formId?: string | null;
    /** Whether the customer is allowed to cancel their plan. */
    buyerCanCancel?: boolean;
    /**
     * Payment currency.
     * @readonly
     * @format CURRENCY
     */
    currency?: string;
    /** Data extensions. Learn more about [extended fields](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-schema-plugin-extensions). */
    extendedFields?: ExtendedFields;
}
interface Image {
    /**
     * WixMedia image ID.
     * @maxLength 255
     */
    id?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /**
     * Image alt text.
     * @maxLength 1000
     */
    altText?: string | null;
}
interface PricingVariant {
    /**
     * Pricing variant ID.
     * @format GUID
     */
    id?: string;
    /**
     * Name for this pricing variant, such as "Monthly" or "Yearly".
     * @minLength 1
     * @maxLength 255
     */
    name?: string;
    /**
     * Number of days customers can use the plan for free before the first charge. Set to `0` for no free trial.
     * @max 999
     */
    freeTrialDays?: number;
    /**
     * Additional fees applied to this pricing variant.
     * @maxSize 10
     */
    fees?: Fee[];
    /** Billing configuration that defines when and how often customers are charged. */
    billingTerms?: BillingTerms;
    /**
     * Promotional message displayed with this pricing variant.
     * @maxLength 255
     */
    promotion?: string | null;
    /**
     * Pricing strategies that determine how much customers pay. Currently limited to 1 strategy per variant.
     * @minSize 1
     * @maxSize 1
     */
    pricingStrategies?: PricingStrategy[];
}
interface FlatRate {
    /**
     * Fixed monetary amount.
     * @decimalValue options { gte:0, maxScale:4 }
     */
    amount?: string;
}
interface Fee extends FeePriceOptionOneOf {
    /** Fixed monetary amount for the fee. */
    fixedAmountOptions?: FixedAmountOption;
    /** @format GUID */
    id?: string;
    /** Pricing type used for this fee. */
    priceType?: PriceTypeWithLiterals;
    /**
     * Fee name displayed to customers, such as "Setup Fee" or "Processing Fee".
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /** When this fee is charged during the customer's plan lifecycle. */
    appliedAt?: AppliedAtWithLiterals;
}
/** @oneof */
interface FeePriceOptionOneOf {
    /** Fixed monetary amount for the fee. */
    fixedAmountOptions?: FixedAmountOption;
}
declare enum PriceType {
    /** Unknown price type. This value isn't used. */
    UNKNOWN_PRICE_TYPE = "UNKNOWN_PRICE_TYPE",
    /** Fee is charged as a fixed monetary amount. */
    FIXED_AMOUNT = "FIXED_AMOUNT"
}
/** @enumType */
type PriceTypeWithLiterals = PriceType | 'UNKNOWN_PRICE_TYPE' | 'FIXED_AMOUNT';
interface FixedAmountOption {
    /**
     * Fixed monetary amount.
     * @decimalValue options { gt:0, maxScale:4 }
     */
    amount?: string;
}
declare enum AppliedAt {
    UNKNOWN_APPLIED_AT = "UNKNOWN_APPLIED_AT",
    /** Fee is added to the first payment. */
    FIRST_PAYMENT = "FIRST_PAYMENT"
}
/** @enumType */
type AppliedAtWithLiterals = AppliedAt | 'UNKNOWN_APPLIED_AT' | 'FIRST_PAYMENT';
interface BillingTerms extends BillingTermsEndOptionOneOf {
    /** How many billing cycles the plan lasts. */
    cyclesCompletedDetails?: CyclesCompletedDetails;
    /** Duration of each billing cycle, such as 1 month or 2 weeks. Can't be less than 7 days. Only applicable for recurring plans. */
    billingCycle?: Duration;
    /** When the billing starts. */
    startType?: StartTypeWithLiterals;
    /** How long the plan remains active. Plans can run until cancelled or for a specific number of billing cycles. Plan duration can't exceed 10 years. */
    endType?: EndTypeWithLiterals;
}
/** @oneof */
interface BillingTermsEndOptionOneOf {
    /** How many billing cycles the plan lasts. */
    cyclesCompletedDetails?: CyclesCompletedDetails;
}
interface Duration {
    /** Duration of period. */
    period?: PeriodWithLiterals;
    /**
     * Number of periods.
     * @min 1
     */
    count?: string;
}
declare enum Period {
    /** Unknown period. This value isn't used. */
    UNKNOWN_PERIOD = "UNKNOWN_PERIOD",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
/** @enumType */
type PeriodWithLiterals = Period | 'UNKNOWN_PERIOD' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
declare enum StartType {
    /** Unknown start type. This value isn't used. */
    UNKNOWN_START_TYPE = "UNKNOWN_START_TYPE",
    /** Billing starts immediately after purchase. */
    ON_PURCHASE = "ON_PURCHASE",
    /** Customer can choose when billing starts. */
    CUSTOM = "CUSTOM"
}
/** @enumType */
type StartTypeWithLiterals = StartType | 'UNKNOWN_START_TYPE' | 'ON_PURCHASE' | 'CUSTOM';
declare enum EndType {
    /** Unknown end type. This value isn't used. */
    UNKNOWN_END_TYPE = "UNKNOWN_END_TYPE",
    /** Plan continues until customer cancels. */
    UNTIL_CANCELLED = "UNTIL_CANCELLED",
    /** Plan ends after a specified number of billing cycles. */
    CYCLES_COMPLETED = "CYCLES_COMPLETED"
}
/** @enumType */
type EndTypeWithLiterals = EndType | 'UNKNOWN_END_TYPE' | 'UNTIL_CANCELLED' | 'CYCLES_COMPLETED';
interface CyclesCompletedDetails {
    /**
     * Number of billing cycles before the plan automatically ends. For example, if `billingCycle` is 3 months and `billingCycleCount` is 4, the customer will be charged 4 times over 12 months before the plan expires. Only applicable if `endType` is `CYCLES_COMPLETED`.
     * @min 1
     * @max 2000
     */
    billingCycleCount?: string;
}
interface PricingStrategy extends PricingStrategyStrategyOneOf {
    /** Single fixed cost charged regardless of usage. */
    flatRate?: FlatRate;
}
/** @oneof */
interface PricingStrategyStrategyOneOf {
    /** Single fixed cost charged regardless of usage. */
    flatRate?: FlatRate;
}
interface Perk {
    /**
     * Perk ID.
     * @format GUID
     */
    id?: string;
    /**
     * Perk description.
     * @minLength 1
     * @maxLength 1400
     */
    description?: string;
}
declare enum Visibility {
    /** Unknown visibility. This value isn't used. */
    UNKNOWN_VISIBILITY = "UNKNOWN_VISIBILITY",
    /** Plan is visible and available for purchase by all customers. */
    PUBLIC = "PUBLIC",
    /** Plan is not visible to new customers, unless they get a specific link to the plan. Existing subscribers can continue using it. */
    PRIVATE = "PRIVATE"
}
/** @enumType */
type VisibilityWithLiterals = Visibility | 'UNKNOWN_VISIBILITY' | 'PUBLIC' | 'PRIVATE';
declare enum Status {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    ACTIVE = "ACTIVE"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNKNOWN_STATUS' | 'ACTIVE';
interface TermsAndConditionsSettings {
    /** Whether customers must accept terms and conditions before purchasing. */
    acceptRequired?: boolean;
    /** Whether the terms and conditions checkbox is checked by default. */
    acceptedByDefault?: boolean;
}
interface ThankYouPageSettings {
    /**
     * Thank you page title
     * @maxLength 100
     */
    title?: string;
    /**
     * Thank you page message
     * @maxLength 100000
     */
    message?: string;
    /**
     * Thank you page button text
     * @maxLength 40
     */
    buttonText?: string;
    /**
     * Thank you page button link
     * @maxLength 200
     */
    buttonLink?: string | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface ValidateOptionsRequest {
    /**
     * The plan id, which corresponds to catalogItemId in catalog item reference
     * @format GUID
     */
    planId?: string;
    /** The specific options selected for this plan */
    options?: Options;
    /**
     * The id of the member buying the plan
     * @format GUID
     */
    memberId?: string;
}
interface Options extends OptionsOptionsOneOf {
    /** The options applicable to a plan */
    planOptions?: PlanOptions;
    /** The type of plan product the options refer to. */
    type?: TypeWithLiterals;
}
/** @oneof */
interface OptionsOptionsOneOf {
    /** The options applicable to a plan */
    planOptions?: PlanOptions;
}
declare enum Type {
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    PLAN = "PLAN",
    ADD_ON = "ADD_ON"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNKNOWN_TYPE' | 'PLAN' | 'ADD_ON';
interface PlanOptions {
    /**
     * The selected pricing variant for the plan
     * @format GUID
     */
    pricingVariantId?: string;
    /** Start date for the ordered plan */
    startDate?: Date | null;
    /**
     * Form submission id that was submitted together with the order
     * @format GUID
     */
    submissionId?: string | null;
    /** Indication whether plan purchase requires login */
    membersOnly?: boolean;
    /** The type of Taxable address */
    taxableAddress?: TaxableAddressWithLiterals;
    /** The strategy used to validate the plan */
    validationStrategy?: ValidationStrategyWithLiterals;
}
declare enum TaxableAddress {
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    BILLING = "BILLING",
    BUSINESS = "BUSINESS"
}
/** @enumType */
type TaxableAddressWithLiterals = TaxableAddress | 'UNKNOWN_TYPE' | 'BILLING' | 'BUSINESS';
declare enum ValidationStrategy {
    UNKNOWN_VALIDATION_STRATEGY = "UNKNOWN_VALIDATION_STRATEGY",
    ON_BEHALF = "ON_BEHALF",
    PREVIEW = "PREVIEW"
}
/** @enumType */
type ValidationStrategyWithLiterals = ValidationStrategy | 'UNKNOWN_VALIDATION_STRATEGY' | 'ON_BEHALF' | 'PREVIEW';
interface ValidateOptionsResponse {
    /** Description of value */
    violations?: Violation[];
}
interface Violation {
    /**
     * The code of the violation. The possible values are:
     * plan-not-active
     * plan-not-buyable
     * max-purchases-exceeded
     * start-date-not-applicable
     * start-date-in-past
     * pricing-variant-not-found
     * start-date-not-in-permitted-range
     * @minLength 1
     * @maxLength 50
     */
    code?: string;
    /**
     * User facing message describing the violation
     * @minLength 1
     * @maxLength 255
     */
    message?: string;
}
interface GetPlanConfigurationConstraintsRequest {
    /**
     * The plan id, which corresponds to catalogItemId in catalog item reference
     * @format GUID
     */
    planId?: string;
    /**
     * The selected pricing variant for the plan
     * @format GUID
     */
    pricingVariantId?: string;
}
interface GetPlanConfigurationConstraintsResponse {
    /** Start date limits. */
    startDateLimits?: StartDateLimits;
    /** Start date rules. */
    startDateRules?: StartDateRules;
}
interface StartDateLimits {
    /**
     * Earliest date the customer can select as the start date
     * @format LOCAL_DATE
     */
    earliestDate?: string | null;
    /**
     * Latest date the customer can select as the start date
     * @format LOCAL_DATE
     */
    latestDate?: string | null;
    /**
     * Error message to display if the purchase date is greater than date_to
     * @minLength 1
     * @maxLength 255
     */
    errorMessage?: string | null;
}
interface StartDateRules extends StartDateRulesDateRulesOneOf {
    /** Plan start date is limited to specific fixed dates */
    fixedDatesOptions?: FixedDatesOptions;
    /** Plan start date is limited to specific dates that repeat */
    recurrenceOptions?: RecurrenceOptions;
    /** Rules type */
    type?: RulesTypeWithLiterals;
    /**
     * Error message to show the user if the rules are not applicable based on purchase date
     * @minLength 1
     * @maxLength 255
     */
    errorMessage?: string | null;
}
/** @oneof */
interface StartDateRulesDateRulesOneOf {
    /** Plan start date is limited to specific fixed dates */
    fixedDatesOptions?: FixedDatesOptions;
    /** Plan start date is limited to specific dates that repeat */
    recurrenceOptions?: RecurrenceOptions;
}
declare enum RulesType {
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    AVAILABLE_IMMEDIATELY = "AVAILABLE_IMMEDIATELY",
    FIXED_DATES = "FIXED_DATES",
    RECURRENCE = "RECURRENCE"
}
/** @enumType */
type RulesTypeWithLiterals = RulesType | 'UNKNOWN_TYPE' | 'AVAILABLE_IMMEDIATELY' | 'FIXED_DATES' | 'RECURRENCE';
interface FixedDatesOptions {
    /**
     * Dates when the plan can start
     * @format LOCAL_DATE
     * @minSize 1
     * @maxSize 1000
     */
    dates?: string[];
}
interface RecurrenceOptions extends RecurrenceOptionsRecurrenceOneOf {
    /** Weekly recurrence */
    weeklyOptions?: WeeklyRecurrence;
    /** Monthly recurrence */
    monthlyOptions?: MonthlyRecurrence;
    /**
     * Start date of the recurrence pattern. Required.
     * @format LOCAL_DATE
     */
    startDate?: string;
    /**
     * End date of the recurrence pattern. If not provided, it is infinite.
     * @format LOCAL_DATE
     */
    endDate?: string | null;
    /**
     * How often to repeat (every X weeks/months)
     * @min 1
     * @max 100
     */
    interval?: number;
    /** Recurrence pattern */
    recurrenceType?: RecurrenceTypeWithLiterals;
}
/** @oneof */
interface RecurrenceOptionsRecurrenceOneOf {
    /** Weekly recurrence */
    weeklyOptions?: WeeklyRecurrence;
    /** Monthly recurrence */
    monthlyOptions?: MonthlyRecurrence;
}
declare enum RecurrenceType {
    UNKNOWN_RECURRENCE_TYPE = "UNKNOWN_RECURRENCE_TYPE",
    WEEKLY = "WEEKLY",
    MONTHLY = "MONTHLY"
}
/** @enumType */
type RecurrenceTypeWithLiterals = RecurrenceType | 'UNKNOWN_RECURRENCE_TYPE' | 'WEEKLY' | 'MONTHLY';
interface WeeklyRecurrence {
    /** Day of the week */
    weekday?: V1DayOfWeekWithLiterals;
}
declare enum V1DayOfWeek {
    UNKNOWN_DAY_OF_WEEK = "UNKNOWN_DAY_OF_WEEK",
    SUNDAY = "SUNDAY",
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY"
}
/** @enumType */
type V1DayOfWeekWithLiterals = V1DayOfWeek | 'UNKNOWN_DAY_OF_WEEK' | 'SUNDAY' | 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY';
interface MonthlyRecurrence {
    /**
     * Day of the month
     * @min 1
     * @max 31
     */
    dayOfMonth?: number;
}
interface GetPlanPreviewRequest {
    /**
     * The plan id, which corresponds to catalogItemId in catalog item reference
     * @format GUID
     */
    planId?: string;
    /**
     * The selected pricing variant for the plan
     * @format GUID
     */
    pricingVariantId?: string;
}
interface GetPlanPreviewResponse {
    /** The plan preview. */
    plan?: Plan;
}
/** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
interface SitePropertiesNotification {
    /** The site ID for which this update notification applies. */
    metasiteId?: string;
    /** The actual update event. */
    event?: SitePropertiesEvent;
    /**
     * A convenience set of mappings from the MetaSite ID to its constituent services.
     * @maxSize 500
     */
    translations?: Translation[];
    /** Context of the notification */
    changeContext?: ChangeContext;
}
/** The actual update event for a particular notification. */
interface SitePropertiesEvent {
    /** Version of the site's properties represented by this update. */
    version?: number;
    /** Set of properties that were updated - corresponds to the fields in "properties". */
    fields?: string[];
    /** Updated properties. */
    properties?: Properties;
}
interface Properties {
    /** Site categories. */
    categories?: Categories;
    /** Site locale. */
    locale?: Locale;
    /**
     * Site language.
     *
     * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
     */
    language?: string | null;
    /**
     * Site currency format used to bill customers.
     *
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    paymentCurrency?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Fax number. */
    fax?: string | null;
    /** Address. */
    address?: Address;
    /** Site display name. */
    siteDisplayName?: string | null;
    /** Business name. */
    businessName?: string | null;
    /** Path to the site's logo in Wix Media (without Wix Media base URL). */
    logo?: string | null;
    /** Site description. */
    description?: string | null;
    /**
     * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /** Supported languages of a site and the primary language. */
    multilingual?: Multilingual;
    /** Cookie policy the Wix user defined for their site (before the site visitor interacts with/limits it). */
    consentPolicy?: ConsentPolicy;
    /**
     * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
     *
     * Site business type.
     */
    businessConfig?: string | null;
    /** External site URL that uses Wix as its headless business solution. */
    externalSiteUrl?: string | null;
    /** Track clicks analytics. */
    trackClicksAnalytics?: boolean;
}
interface Categories {
    /** Primary site category. */
    primary?: string;
    /**
     * Secondary site category.
     * @maxSize 50
     */
    secondary?: string[];
    /** Business Term Id */
    businessTermId?: string | null;
}
interface Locale {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
    country?: string;
}
interface Address {
    /** Street name. */
    street?: string;
    /** City name. */
    city?: string;
    /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
    country?: string;
    /** State. */
    state?: string;
    /**
     * Zip or postal code.
     * @maxLength 20
     */
    zip?: string;
    /** Extra information to be displayed in the address. */
    hint?: AddressHint;
    /** Whether this address represents a physical location. */
    isPhysical?: boolean;
    /** Google-formatted version of this address. */
    googleFormattedAddress?: string;
    /** Street number. */
    streetNumber?: string;
    /** Apartment number. */
    apartmentNumber?: string;
    /** Geographic coordinates of location. */
    coordinates?: GeoCoordinates;
}
/**
 * Extra information on displayed addresses.
 * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
 * Free text. In addition, the user can state where to display the additional description - before, after, or instead of the address string.
 */
interface AddressHint {
    /** Extra text displayed next to, or instead of, the actual address. */
    text?: string;
    /** Where the extra text should be displayed. */
    placement?: PlacementTypeWithLiterals;
}
/** Where the extra text should be displayed: before, after or instead of the actual address. */
declare enum PlacementType {
    BEFORE = "BEFORE",
    AFTER = "AFTER",
    REPLACE = "REPLACE"
}
/** @enumType */
type PlacementTypeWithLiterals = PlacementType | 'BEFORE' | 'AFTER' | 'REPLACE';
/** Geocoordinates for a particular address. */
interface GeoCoordinates {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number;
}
/** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
interface BusinessSchedule {
    /**
     * Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods.
     * @maxSize 100
     */
    periods?: TimePeriod[];
    /**
     * Exceptions to the business's regular hours. The business can be open or closed during the exception.
     * @maxSize 100
     */
    specialHourPeriod?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the business is regularly open or the service is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     *
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
/** Enumerates the days of the week. */
declare enum DayOfWeek {
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY",
    SUNDAY = "SUNDAY"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /**
     * Whether the business is closed (or the service is not available) during the exception.
     *
     * Default: `true`.
     */
    isClosed?: boolean;
    /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
    comment?: string;
}
interface Multilingual {
    /**
     * Supported languages list.
     * @maxSize 200
     */
    supportedLanguages?: SupportedLanguage[];
    /** Whether to redirect to user language. */
    autoRedirect?: boolean;
}
interface SupportedLanguage {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Locale. */
    locale?: Locale;
    /** Whether the supported language is the primary language for the site. */
    isPrimary?: boolean;
    /** Language icon. */
    countryCode?: string;
    /** How the language will be resolved. For internal use. */
    resolutionMethod?: ResolutionMethodWithLiterals;
    /** Whether the supported language is the primary language for site visitors. */
    isVisitorPrimary?: boolean | null;
}
declare enum ResolutionMethod {
    QUERY_PARAM = "QUERY_PARAM",
    SUBDOMAIN = "SUBDOMAIN",
    SUBDIRECTORY = "SUBDIRECTORY"
}
/** @enumType */
type ResolutionMethodWithLiterals = ResolutionMethod | 'QUERY_PARAM' | 'SUBDOMAIN' | 'SUBDIRECTORY';
interface ConsentPolicy {
    /** Whether the site uses cookies that are essential to site operation. Always `true`. */
    essential?: boolean | null;
    /** Whether the site uses cookies that affect site performance and other functional measurements. */
    functional?: boolean | null;
    /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
    analytics?: boolean | null;
    /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
    advertising?: boolean | null;
    /** CCPA compliance flag. */
    dataToThirdParty?: boolean | null;
}
/** A single mapping from the MetaSite ID to a particular service. */
interface Translation {
    /** The service type. */
    serviceType?: string;
    /** The application definition ID; this only applies to services of type ThirdPartyApps. */
    appDefId?: string;
    /** The instance ID of the service. */
    instanceId?: string;
}
interface ChangeContext extends ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
/** @oneof */
interface ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
interface PropertiesChange {
}
interface SiteCreated {
    /** Origin template site id. */
    originTemplateId?: string | null;
}
interface SiteCloned {
    /** Origin site id. */
    originMetaSiteId?: string;
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface CreatePlanRequest {
    /** Plan to create. */
    plan: Plan;
    /**
     * Unique key to prevent duplicate plan creation. If the same key is used within a short time period, the original plan will be returned instead of creating a duplicate.
     * @format GUID
     */
    idempotencyKey?: string | null;
}
interface CreatePlanResponse {
    /** Created plan. */
    plan?: Plan;
}
interface GetPlanRequest {
    /**
     * ID of the plan to retrieve.
     * @format GUID
     */
    planId: string;
}
interface GetPlanResponse {
    /** Requested plan. */
    plan?: Plan;
}
interface UpdatePlanRequest {
    /** plan to update. */
    plan: Plan;
}
declare enum Cascade {
    /** Change the price for the plan only, without affecting existing subscriptions. */
    NEW_SUBSCRIPTIONS = "NEW_SUBSCRIPTIONS",
    /** Change the price for the plan and apply it to existing subscriptions. */
    ALL_SUBSCRIPTIONS = "ALL_SUBSCRIPTIONS"
}
/** @enumType */
type CascadeWithLiterals = Cascade | 'NEW_SUBSCRIPTIONS' | 'ALL_SUBSCRIPTIONS';
interface UpdatePlanResponse {
    /** Updated plan. */
    plan?: Plan;
}
interface BulkUpdatePlansRequest {
    /**
     * Plans to update.
     * @minSize 1
     * @maxSize 100
     */
    plans: MaskedPlan[];
    /** Set the value to `true` to receive details of the updated plans. */
    returnEntity?: boolean;
}
interface MaskedPlan {
    /** Plan to update. */
    plan?: Plan;
}
interface BulkUpdatePlansResponse {
    /**
     * Updated plans.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkPlanResult[];
    /** Action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface ItemMetadata {
    /**
     * Item ID. Should always be available, unless it's impossible (for example, when failing to create an item).
     * @format GUID
     */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkPlanResult {
    /** Metadata for a specific updated item. */
    itemMetadata?: ItemMetadata;
    /** Updated plan details. Only returned if the `returnEntity` field was set to `true`. */
    item?: Plan;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface DeletePlanRequest {
    /**
     * ID of the plan to delete.
     * @format GUID
     */
    planId: string;
}
interface DeletePlanResponse {
}
interface QueryPlansRequest {
    /** Query options. See [API Query Language](https://dev.wix.com/docs/rest/articles/get-started/api-query-language) for more details. */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 5
     */
    sort?: Sorting[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryPlansResponse {
    /** List of plans. */
    plans?: Plan[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface SearchPlansRequest {
    /** Search options. See [API Query Language](https://dev.wix.com/docs/rest/articles/get-started/api-query-language) for more details. */
    search?: CursorSearch;
}
interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
     * @maxSize 10
     */
    sort?: Sorting[];
    /**
     * Logical groupings of data into facets, with summaries for each facet. For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
     * @maxSize 10
     */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
     * @maxLength 50
     */
    timeZone?: string | null;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
    cursorPaging?: CursorPaging;
}
interface Aggregation extends AggregationKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation */
    nested?: NestedAggregation;
    /**
     * User-defined name of aggregation, should be unique, will appear in aggregation results
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: AggregationTypeWithLiterals;
    /**
     * Field to aggregate by, use dot notation to specify json path
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface AggregationKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation */
    nested?: NestedAggregation;
}
interface RangeBucket {
    /** Inclusive lower bound of the range. Required if to is not given */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if from is not given */
    to?: number | null;
}
declare enum SortType {
    /** Should sort by number of matches */
    COUNT = "COUNT",
    /** Should sort by value of the field alphabetically */
    VALUE = "VALUE"
}
/** @enumType */
type SortTypeWithLiterals = SortType | 'COUNT' | 'VALUE';
declare enum SortDirection {
    /** Should sort in descending order */
    DESC = "DESC",
    /** Should sort in ascending order */
    ASC = "ASC"
}
/** @enumType */
type SortDirectionWithLiterals = SortDirection | 'DESC' | 'ASC';
declare enum MissingValues {
    /** Should missing values be excluded from the aggregation results */
    EXCLUDE = "EXCLUDE",
    /** Should missing values be included in the aggregation results */
    INCLUDE = "INCLUDE"
}
/** @enumType */
type MissingValuesWithLiterals = MissingValues | 'EXCLUDE' | 'INCLUDE';
interface IncludeMissingValuesOptions {
    /**
     * Can specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ...
     * @maxLength 20
     */
    addToBucket?: string;
}
declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value */
    MIN = "MIN",
    /** Maximum value */
    MAX = "MAX"
}
/** @enumType */
type ScalarTypeWithLiterals = ScalarType | 'UNKNOWN_SCALAR_TYPE' | 'COUNT_DISTINCT' | 'MIN' | 'MAX';
interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** Options for including missing values */
    includeOptions?: IncludeMissingValuesOptions;
    /** Should sort by number of matches or value of the field */
    sortType?: SortTypeWithLiterals;
    /** Should sort in ascending or descending order */
    sortDirection?: SortDirectionWithLiterals;
    /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Should missing values be included or excluded from the aggregation results. Default is EXCLUDE */
    missingValues?: MissingValuesWithLiterals;
}
/** @oneof */
interface ValueAggregationOptionsOneOf {
    /** Options for including missing values */
    includeOptions?: IncludeMissingValuesOptions;
}
declare enum NestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
/** @enumType */
type NestedAggregationTypeWithLiterals = NestedAggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM';
interface RangeAggregation {
    /**
     * List of range buckets, where during aggregation each entity will be placed in the first bucket where its value falls into based on provided range bounds
     * @maxSize 50
     */
    buckets?: RangeBucket[];
}
interface ScalarAggregation {
    /** Define the operator for the scalar aggregation */
    type?: ScalarTypeWithLiterals;
}
interface DateHistogramAggregation {
    /** Interval for date histogram aggregation */
    interval?: IntervalWithLiterals;
}
declare enum Interval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
/** @enumType */
type IntervalWithLiterals = Interval | 'UNKNOWN_INTERVAL' | 'YEAR' | 'MONTH' | 'WEEK' | 'DAY' | 'HOUR' | 'MINUTE' | 'SECOND';
interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /**
     * User-defined name of aggregation, should be unique, will appear in aggregation results
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: NestedAggregationTypeWithLiterals;
    /**
     * Field to aggregate by, use dont notation to specify json path
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
}
declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one */
    NESTED = "NESTED"
}
/** @enumType */
type AggregationTypeWithLiterals = AggregationType | 'UNKNOWN_AGGREGATION_TYPE' | 'VALUE' | 'RANGE' | 'SCALAR' | 'DATE_HISTOGRAM' | 'NESTED';
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one */
interface NestedAggregation {
    /**
     * Flattened list of aggregations, where each next aggregation is nested within previous one
     * @minSize 2
     * @maxSize 3
     */
    nestedAggregations?: NestedAggregationItem[];
}
interface SearchDetails {
    /** Defines how separate search terms in `expression` are combined */
    mode?: ModeWithLiterals;
    /**
     * Search term or expression
     * @maxLength 100
     */
    expression?: string | null;
    /**
     * Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path
     * @maxLength 200
     * @maxSize 20
     */
    fields?: string[];
    /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
    fuzzy?: boolean;
}
declare enum Mode {
    /** Any of the search terms must be present */
    OR = "OR",
    /** All search terms must be present */
    AND = "AND"
}
/** @enumType */
type ModeWithLiterals = Mode | 'OR' | 'AND';
interface SearchPlansResponse {
    /** List of plans. */
    plans?: Plan[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface CountPlansRequest {
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /** Free text to match in searchable fields. When specified, the method uses search instead of filter, and may be less consistent. */
    search?: SearchDetails;
}
interface CountPlansResponse {
    /** The number of plans. */
    count?: number;
}
interface ChangePriceRequest {
    /**
     * ID of the plan to change.
     * @format GUID
     */
    planId: string;
    /**
     * ID of the pricing variant to change.
     * @format GUID
     */
    pricingVariantId: string;
    /**
     * New pricing strategy.
     * @minSize 1
     * @maxSize 1
     */
    pricingStrategies: PricingStrategy[];
    /** To prevent conflicting changes, the current plan revision must be passed when updating the price. */
    revision: string | null;
    /** Type of cascade to apply. */
    cascade?: CascadeWithLiterals;
}
interface ChangePriceResponse {
    /** Updated Plan. */
    plan?: Plan;
}
interface UpdateExtendedFieldsRequest {
    /** ID of the entity to update. */
    id?: string;
    /** Identifier for the app whose extended fields are being updated. */
    namespace?: string;
    /** Data to update. Structured according to the [schema](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields#json-schema-for-extended-fields) defined when the extended fields were configured. */
    namespaceData?: Record<string, any> | null;
}
interface UpdateExtendedFieldsResponse {
    /** Updated Plan. */
    plan?: Plan;
}
/** @docsIgnore */
type CreatePlanApplicationErrors = {
    code?: 'CURRENCY_MISSING';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CreatePlanValidationErrors = {
    ruleName?: 'NAME_NOT_BLANK';
} | {
    ruleName?: 'VALID_BILLING_CYCLE';
} | {
    ruleName?: 'VALID_PLAN_DURATION';
} | {
    ruleName?: 'FREE_PRICING_VARIANT_IS_NOT_RECURRING';
} | {
    ruleName?: 'FREE_TRIAL_IS_APPLICABLE';
} | {
    ruleName?: 'CYCLES_COMPLETED_END_OPTION_IS_APPLICABLE';
} | {
    ruleName?: 'PRICING_VARIANT_IDS_UNIQUE';
} | {
    ruleName?: 'FEE_IDS_UNIQUE';
} | {
    ruleName?: 'PERK_IDS_UNIQUE';
};
/** @docsIgnore */
type UpdatePlanValidationErrors = {
    ruleName?: 'NAME_NOT_BLANK';
} | {
    ruleName?: 'VALID_BILLING_CYCLE';
} | {
    ruleName?: 'VALID_PLAN_DURATION';
} | {
    ruleName?: 'FREE_PRICING_VARIANT_IS_NOT_RECURRING';
} | {
    ruleName?: 'FREE_TRIAL_IS_APPLICABLE';
} | {
    ruleName?: 'CYCLES_COMPLETED_END_OPTION_IS_APPLICABLE';
} | {
    ruleName?: 'PRICING_VARIANT_IDS_UNIQUE';
} | {
    ruleName?: 'FEE_IDS_UNIQUE';
} | {
    ruleName?: 'PERK_IDS_UNIQUE';
} | {
    ruleName?: 'REQUIRED_FIELD';
};
/** @docsIgnore */
type BulkUpdatePlansValidationErrors = {
    ruleName?: 'NAME_NOT_BLANK';
} | {
    ruleName?: 'VALID_BILLING_CYCLE';
} | {
    ruleName?: 'VALID_PLAN_DURATION';
} | {
    ruleName?: 'FREE_PRICING_VARIANT_IS_NOT_RECURRING';
} | {
    ruleName?: 'FREE_TRIAL_IS_APPLICABLE';
} | {
    ruleName?: 'CYCLES_COMPLETED_END_OPTION_IS_APPLICABLE';
} | {
    ruleName?: 'PRICING_VARIANT_IDS_UNIQUE';
} | {
    ruleName?: 'FEE_IDS_UNIQUE';
} | {
    ruleName?: 'PERK_IDS_UNIQUE';
} | {
    ruleName?: 'REQUIRED_FIELD';
} | {
    ruleName?: 'BULK_UPDATE_NOT_SUPPORTED';
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createPlan(): __PublicMethodMetaInfo<'POST', {}, CreatePlanRequest$1, CreatePlanRequest, CreatePlanResponse$1, CreatePlanResponse>;
declare function getPlan(): __PublicMethodMetaInfo<'GET', {
    planId: string;
}, GetPlanRequest$1, GetPlanRequest, GetPlanResponse$1, GetPlanResponse>;
declare function updatePlan(): __PublicMethodMetaInfo<'PATCH', {
    planId: string;
}, UpdatePlanRequest$1, UpdatePlanRequest, UpdatePlanResponse$1, UpdatePlanResponse>;
declare function bulkUpdatePlans(): __PublicMethodMetaInfo<'POST', {}, BulkUpdatePlansRequest$1, BulkUpdatePlansRequest, BulkUpdatePlansResponse$1, BulkUpdatePlansResponse>;
declare function deletePlan(): __PublicMethodMetaInfo<'DELETE', {
    planId: string;
}, DeletePlanRequest$1, DeletePlanRequest, DeletePlanResponse$1, DeletePlanResponse>;
declare function queryPlans(): __PublicMethodMetaInfo<'GET', {}, QueryPlansRequest$1, QueryPlansRequest, QueryPlansResponse$1, QueryPlansResponse>;
declare function searchPlans(): __PublicMethodMetaInfo<'GET', {}, SearchPlansRequest$1, SearchPlansRequest, SearchPlansResponse$1, SearchPlansResponse>;
declare function countPlans(): __PublicMethodMetaInfo<'POST', {}, CountPlansRequest$1, CountPlansRequest, CountPlansResponse$1, CountPlansResponse>;
declare function changePrice(): __PublicMethodMetaInfo<'POST', {
    planId: string;
}, ChangePriceRequest$1, ChangePriceRequest, ChangePriceResponse$1, ChangePriceResponse>;

export { type ActionEvent as ActionEventOriginal, type AddressHint as AddressHintOriginal, type Address as AddressOriginal, type AggregationKindOneOf as AggregationKindOneOfOriginal, type Aggregation as AggregationOriginal, AggregationType as AggregationTypeOriginal, type AggregationTypeWithLiterals as AggregationTypeWithLiteralsOriginal, type ApplicationError as ApplicationErrorOriginal, AppliedAt as AppliedAtOriginal, type AppliedAtWithLiterals as AppliedAtWithLiteralsOriginal, type BillingTermsEndOptionOneOf as BillingTermsEndOptionOneOfOriginal, type BillingTerms as BillingTermsOriginal, type BulkActionMetadata as BulkActionMetadataOriginal, type BulkPlanResult as BulkPlanResultOriginal, type BulkUpdatePlansRequest as BulkUpdatePlansRequestOriginal, type BulkUpdatePlansResponse as BulkUpdatePlansResponseOriginal, type BulkUpdatePlansValidationErrors as BulkUpdatePlansValidationErrorsOriginal, type BusinessSchedule as BusinessScheduleOriginal, Cascade as CascadeOriginal, type CascadeWithLiterals as CascadeWithLiteralsOriginal, type Categories as CategoriesOriginal, type ChangeContext as ChangeContextOriginal, type ChangeContextPayloadOneOf as ChangeContextPayloadOneOfOriginal, type ChangePriceRequest as ChangePriceRequestOriginal, type ChangePriceResponse as ChangePriceResponseOriginal, type ConsentPolicy as ConsentPolicyOriginal, type CountPlansRequest as CountPlansRequestOriginal, type CountPlansResponse as CountPlansResponseOriginal, type CreatePlanApplicationErrors as CreatePlanApplicationErrorsOriginal, type CreatePlanRequest as CreatePlanRequestOriginal, type CreatePlanResponse as CreatePlanResponseOriginal, type CreatePlanValidationErrors as CreatePlanValidationErrorsOriginal, type CursorPagingMetadata as CursorPagingMetadataOriginal, type CursorPaging as CursorPagingOriginal, type CursorSearch as CursorSearchOriginal, type CursorSearchPagingMethodOneOf as CursorSearchPagingMethodOneOfOriginal, type Cursors as CursorsOriginal, type CyclesCompletedDetails as CyclesCompletedDetailsOriginal, type DateHistogramAggregation as DateHistogramAggregationOriginal, DayOfWeek as DayOfWeekOriginal, type DayOfWeekWithLiterals as DayOfWeekWithLiteralsOriginal, type DeletePlanRequest as DeletePlanRequestOriginal, type DeletePlanResponse as DeletePlanResponseOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type Duration as DurationOriginal, type Empty as EmptyOriginal, EndType as EndTypeOriginal, type EndTypeWithLiterals as EndTypeWithLiteralsOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type ExtendedFields as ExtendedFieldsOriginal, type Fee as FeeOriginal, type FeePriceOptionOneOf as FeePriceOptionOneOfOriginal, type FixedAmountOption as FixedAmountOptionOriginal, type FixedDatesOptions as FixedDatesOptionsOriginal, type FlatRate as FlatRateOriginal, type GeoCoordinates as GeoCoordinatesOriginal, type GetPlanConfigurationConstraintsRequest as GetPlanConfigurationConstraintsRequestOriginal, type GetPlanConfigurationConstraintsResponse as GetPlanConfigurationConstraintsResponseOriginal, type GetPlanPreviewRequest as GetPlanPreviewRequestOriginal, type GetPlanPreviewResponse as GetPlanPreviewResponseOriginal, type GetPlanRequest as GetPlanRequestOriginal, type GetPlanResponse as GetPlanResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type Image as ImageOriginal, type IncludeMissingValuesOptions as IncludeMissingValuesOptionsOriginal, Interval as IntervalOriginal, type IntervalWithLiterals as IntervalWithLiteralsOriginal, type ItemMetadata as ItemMetadataOriginal, type Locale as LocaleOriginal, type MaskedPlan as MaskedPlanOriginal, type MessageEnvelope as MessageEnvelopeOriginal, MissingValues as MissingValuesOriginal, type MissingValuesWithLiterals as MissingValuesWithLiteralsOriginal, Mode as ModeOriginal, type ModeWithLiterals as ModeWithLiteralsOriginal, type MonthlyRecurrence as MonthlyRecurrenceOriginal, type Multilingual as MultilingualOriginal, type NestedAggregationItemKindOneOf as NestedAggregationItemKindOneOfOriginal, type NestedAggregationItem as NestedAggregationItemOriginal, type NestedAggregation as NestedAggregationOriginal, NestedAggregationType as NestedAggregationTypeOriginal, type NestedAggregationTypeWithLiterals as NestedAggregationTypeWithLiteralsOriginal, type OptionsOptionsOneOf as OptionsOptionsOneOfOriginal, type Options as OptionsOriginal, type PagingMetadataV2 as PagingMetadataV2Original, type Paging as PagingOriginal, Period as PeriodOriginal, type PeriodWithLiterals as PeriodWithLiteralsOriginal, type Perk as PerkOriginal, PlacementType as PlacementTypeOriginal, type PlacementTypeWithLiterals as PlacementTypeWithLiteralsOriginal, type PlanOptions as PlanOptionsOriginal, type Plan as PlanOriginal, PriceType as PriceTypeOriginal, type PriceTypeWithLiterals as PriceTypeWithLiteralsOriginal, type PricingStrategy as PricingStrategyOriginal, type PricingStrategyStrategyOneOf as PricingStrategyStrategyOneOfOriginal, type PricingVariant as PricingVariantOriginal, type PropertiesChange as PropertiesChangeOriginal, type Properties as PropertiesOriginal, type QueryPlansRequest as QueryPlansRequestOriginal, type QueryPlansResponse as QueryPlansResponseOriginal, type QueryV2 as QueryV2Original, type QueryV2PagingMethodOneOf as QueryV2PagingMethodOneOfOriginal, type RangeAggregation as RangeAggregationOriginal, type RangeBucket as RangeBucketOriginal, type RecurrenceOptions as RecurrenceOptionsOriginal, type RecurrenceOptionsRecurrenceOneOf as RecurrenceOptionsRecurrenceOneOfOriginal, RecurrenceType as RecurrenceTypeOriginal, type RecurrenceTypeWithLiterals as RecurrenceTypeWithLiteralsOriginal, ResolutionMethod as ResolutionMethodOriginal, type ResolutionMethodWithLiterals as ResolutionMethodWithLiteralsOriginal, type RestoreInfo as RestoreInfoOriginal, RulesType as RulesTypeOriginal, type RulesTypeWithLiterals as RulesTypeWithLiteralsOriginal, type ScalarAggregation as ScalarAggregationOriginal, ScalarType as ScalarTypeOriginal, type ScalarTypeWithLiterals as ScalarTypeWithLiteralsOriginal, type SearchDetails as SearchDetailsOriginal, type SearchPlansRequest as SearchPlansRequestOriginal, type SearchPlansResponse as SearchPlansResponseOriginal, type SiteCloned as SiteClonedOriginal, type SiteCreated as SiteCreatedOriginal, type SitePropertiesEvent as SitePropertiesEventOriginal, type SitePropertiesNotification as SitePropertiesNotificationOriginal, SortDirection as SortDirectionOriginal, type SortDirectionWithLiterals as SortDirectionWithLiteralsOriginal, SortOrder as SortOrderOriginal, type SortOrderWithLiterals as SortOrderWithLiteralsOriginal, SortType as SortTypeOriginal, type SortTypeWithLiterals as SortTypeWithLiteralsOriginal, type Sorting as SortingOriginal, type SpecialHourPeriod as SpecialHourPeriodOriginal, type StartDateLimits as StartDateLimitsOriginal, type StartDateRulesDateRulesOneOf as StartDateRulesDateRulesOneOfOriginal, type StartDateRules as StartDateRulesOriginal, StartType as StartTypeOriginal, type StartTypeWithLiterals as StartTypeWithLiteralsOriginal, Status as StatusOriginal, type StatusWithLiterals as StatusWithLiteralsOriginal, type SupportedLanguage as SupportedLanguageOriginal, TaxableAddress as TaxableAddressOriginal, type TaxableAddressWithLiterals as TaxableAddressWithLiteralsOriginal, type TermsAndConditionsSettings as TermsAndConditionsSettingsOriginal, type ThankYouPageSettings as ThankYouPageSettingsOriginal, type TimePeriod as TimePeriodOriginal, type Translation as TranslationOriginal, Type as TypeOriginal, type TypeWithLiterals as TypeWithLiteralsOriginal, type UpdateExtendedFieldsRequest as UpdateExtendedFieldsRequestOriginal, type UpdateExtendedFieldsResponse as UpdateExtendedFieldsResponseOriginal, type UpdatePlanRequest as UpdatePlanRequestOriginal, type UpdatePlanResponse as UpdatePlanResponseOriginal, type UpdatePlanValidationErrors as UpdatePlanValidationErrorsOriginal, V1DayOfWeek as V1DayOfWeekOriginal, type V1DayOfWeekWithLiterals as V1DayOfWeekWithLiteralsOriginal, type ValidateOptionsRequest as ValidateOptionsRequestOriginal, type ValidateOptionsResponse as ValidateOptionsResponseOriginal, ValidationStrategy as ValidationStrategyOriginal, type ValidationStrategyWithLiterals as ValidationStrategyWithLiteralsOriginal, type ValueAggregationOptionsOneOf as ValueAggregationOptionsOneOfOriginal, type ValueAggregation as ValueAggregationOriginal, type Violation as ViolationOriginal, Visibility as VisibilityOriginal, type VisibilityWithLiterals as VisibilityWithLiteralsOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type WeeklyRecurrence as WeeklyRecurrenceOriginal, type __PublicMethodMetaInfo, bulkUpdatePlans, changePrice, countPlans, createPlan, deletePlan, getPlan, queryPlans, searchPlans, updatePlan };
