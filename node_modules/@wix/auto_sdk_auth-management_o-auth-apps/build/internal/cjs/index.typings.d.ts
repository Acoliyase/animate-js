import { NonNullablePaths } from '@wix/sdk-types';

/** An intermediary application that authorizes and authenticates an external client to access data on a Wix project or site. */
interface OAuthApp {
    /**
     * ID of the OAuth app.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Date and time the OAuth app was created, in ISO 8601 format.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Display name of the OAuth app, as it appears in the dashboard.
     * @minLength 2
     * @maxLength 256
     */
    name?: string | null;
    /** Description of the OAuth app, as it appears in the dashboard. */
    description?: string | null;
    /**
     * For internal use only.
     * @readonly
     * @deprecated
     */
    secret?: string | null;
    /**
     * External login URL to which users are redirected automatically to authenticate. If no login URL is specified, the user is redirected to Wix to authenticate.
     * @format WEB_URL
     */
    loginUrl?: string | null;
    /**
     * List of URIs to which redirection from Wix is allowed after authentication.
     *
     * When a client redirects a user to Wix for authentication, the client provides a URI to redirect the user back to after the user has been authenticated.
     * Wix only redirects the user if the exact URI is contained in this array.
     * @format URI
     * @maxSize 20
     */
    allowedRedirectUris?: string[];
    /**
     * List of domains to which redirection from Wix is allowed after processes other than authentication.
     *
     * When a client redirects a user to a Wix page (for example, for checkout), the client provides a URL to redirect the user back to.
     * Wix only redirects the user if the URL is in one of the specified domains.
     * @maxSize 20
     */
    allowedRedirectDomains?: string[];
    /** For internal use only. */
    allowSecretGeneration?: boolean | null;
    /**
     * External logout URL to which we invoke when user logout at wix. If no logout URL is specified, the user is logged out only at Wix.
     * @format WEB_URL
     */
    logoutUrl?: string | null;
    /** OAuth application type. */
    applicationType?: OAuthAppTypeWithLiterals;
    /** OAuth technology used by the oauth application. */
    technology?: OAuthTechnologiesWithLiterals;
    /**
     * List of domain mappings from external domains to Wix domains.
     * When a user accesses a non-Wix domain, they can be automatically forwarded to the corresponding
     * Wix domain based on these mappings. This enables domain-level redirection from
     * external domains to Wix-hosted pages.
     * @maxSize 200
     */
    wixPagesDomainsMappings?: WixPagesDomainMapping[];
    /**
     * Redirect url for Wix-hosted pages.
     * @maxLength 1024
     */
    redirectUrlWixPages?: string | null;
}
/** OAuth application type. */
declare enum OAuthAppType {
    /** OAuth app type is not specified. */
    OAUTH_APP_TYPE_UNSPECIFIED = "OAUTH_APP_TYPE_UNSPECIFIED",
    /** OAuth app type is a web application. */
    WEB_APP = "WEB_APP",
    /** OAuth app type is a mobile application. */
    MOBILE = "MOBILE",
    /** OAuth app type is some other type of application. */
    OTHER = "OTHER"
}
/** @enumType */
type OAuthAppTypeWithLiterals = OAuthAppType | 'OAUTH_APP_TYPE_UNSPECIFIED' | 'WEB_APP' | 'MOBILE' | 'OTHER';
/** OAuth technology used by the oauth application. */
declare enum OAuthTechnologies {
    /** The OAuth technology is not specified. */
    OAUTH_TECHNOLOGY_UNSPECIFIED = "OAUTH_TECHNOLOGY_UNSPECIFIED",
    /** OAuth technology using JavaScript. */
    JAVASCRIPT = "JAVASCRIPT",
    /** OAuth technology using Angular. */
    ANGULAR = "ANGULAR",
    /** OAuth technology using Vue.js. */
    VUE = "VUE",
    /** OAuth technology using React. */
    REACT = "REACT",
    /** OAuth technology using React Native. */
    REACT_NATIVE = "REACT_NATIVE",
    /** OAuth technology using iOS. */
    IOS = "IOS",
    /** OAuth technology using Android. */
    ANDROID = "ANDROID",
    /** OAuth technology using some other kind of technology. */
    OTHER_TECHNOLOGY = "OTHER_TECHNOLOGY"
}
/** @enumType */
type OAuthTechnologiesWithLiterals = OAuthTechnologies | 'OAUTH_TECHNOLOGY_UNSPECIFIED' | 'JAVASCRIPT' | 'ANGULAR' | 'VUE' | 'REACT' | 'REACT_NATIVE' | 'IOS' | 'ANDROID' | 'OTHER_TECHNOLOGY';
interface WixPagesDomainMapping {
    /** @maxLength 2048 */
    origin?: string;
    /** @maxLength 2048 */
    destination?: string;
}
interface CreateOAuthAppRequest {
    /** OAuth app to create. */
    oAuthApp: OAuthApp;
}
interface CreateOAuthAppResponse {
    /** Created OAuth app info. */
    oAuthApp?: OAuthApp;
}
interface GetOAuthAppRequest {
    /**
     * ID of the OAuth app to retrieve.
     * @format GUID
     */
    oAuthAppId: string;
}
interface GetOAuthAppResponse {
    /** Retrieved OAuth app info. */
    oAuthApp?: OAuthApp;
}
interface UpdateOAuthAppRequest {
    /** Updated OAuth app details. May include some or all fields. */
    oAuthApp: OAuthApp;
    /** Explicit list of fields to update. Only fields listed are updated. */
    mask?: string[];
}
interface UpdateOAuthAppResponse {
    /** Updated OAuth app info. */
    oAuthApp?: OAuthApp;
}
interface DeleteOAuthAppRequest {
    /**
     * ID of the OAuth app to delete.
     * @format GUID
     */
    oAuthAppId: string;
}
interface DeleteOAuthAppResponse {
}
interface QueryOAuthAppsRequest {
    /** Query options. */
    query?: PlatformQuery;
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"name","order":"ASC"},{"fieldName":"created_date","order":"DESC"}]`
     * @maxSize 3
     */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryOAuthAppsResponse {
    /** List of OAuth apps matching the query. */
    oAuthApps?: OAuthApp[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface GenerateOAuthAppSecretRequest {
    /**
     * ID of the OAuth app to generate a secret for.
     * @format GUID
     */
    oAuthAppId: string;
}
interface GenerateOAuthAppSecretResponse {
    /** Secret generated. */
    oAuthAppSecret?: string;
}
interface MetaSiteSpecialEvent extends MetaSiteSpecialEventPayloadOneOf {
    /** Emitted on a meta site creation. */
    siteCreated?: SiteCreated;
    /** Emitted on a meta site transfer completion. */
    siteTransferred?: SiteTransferred;
    /** Emitted on a meta site deletion. */
    siteDeleted?: SiteDeleted;
    /** Emitted on a meta site restoration. */
    siteUndeleted?: SiteUndeleted;
    /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
    sitePublished?: SitePublished;
    /** Emitted on a meta site unpublish. */
    siteUnpublished?: SiteUnpublished;
    /** Emitted when meta site is marked as template. */
    siteMarkedAsTemplate?: SiteMarkedAsTemplate;
    /** Emitted when meta site is marked as a WixSite. */
    siteMarkedAsWixSite?: SiteMarkedAsWixSite;
    /** Emitted when an application is provisioned (installed). */
    serviceProvisioned?: ServiceProvisioned;
    /** Emitted when an application is removed (uninstalled). */
    serviceRemoved?: ServiceRemoved;
    /** Emitted when meta site name (URL slug) is changed. */
    siteRenamedPayload?: SiteRenamed;
    /** Emitted when meta site was permanently deleted. */
    hardDeleted?: SiteHardDeleted;
    /** Emitted on a namespace change. */
    namespaceChanged?: NamespaceChanged;
    /** Emitted when Studio is attached. */
    studioAssigned?: StudioAssigned;
    /** Emitted when Studio is detached. */
    studioUnassigned?: StudioUnassigned;
    /**
     * Emitted when one of the URLs is changed. After this event you may call `urls-server` to fetch
     * the actual URL.
     *
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1732520791210559?thread_ts=1732027914.294059&cid=C0UHEBPFT
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1744115197619459
     */
    urlChanged?: SiteUrlChanged;
    /** Site is marked as PurgedExternally */
    sitePurgedExternally?: SitePurgedExternally;
    /** Emitted when Odeditor is attached. */
    odeditorAssigned?: OdeditorAssigned;
    /** Emitted when Odeditor is detached. */
    odeditorUnassigned?: OdeditorUnassigned;
    /** Emitted when Picasso is attached. */
    picassoAssigned?: PicassoAssigned;
    /** Emitted when Picasso is detached. */
    picassoUnassigned?: PicassoUnassigned;
    /** Emitted when Wixel is attached. */
    wixelAssigned?: WixelAssigned;
    /** Emitted when Wixel is detached. */
    wixelUnassigned?: WixelUnassigned;
    /** Emitted when StudioTwo is attached. */
    studioTwoAssigned?: StudioTwoAssigned;
    /** Emitted when StudioTwo is detached. */
    studioTwoUnassigned?: StudioTwoUnassigned;
    /**
     * A meta site id.
     * @format GUID
     */
    metaSiteId?: string;
    /** A meta site version. Monotonically increasing. */
    version?: string;
    /** A timestamp of the event. */
    timestamp?: string;
    /**
     * TODO(meta-site): Change validation once validations are disabled for consumers
     * More context: https://wix.slack.com/archives/C0UHEBPFT/p1720957844413149 and https://wix.slack.com/archives/CFWKX325T/p1728892152855659
     * @maxSize 4000
     */
    assets?: Asset[];
}
/** @oneof */
interface MetaSiteSpecialEventPayloadOneOf {
    /** Emitted on a meta site creation. */
    siteCreated?: SiteCreated;
    /** Emitted on a meta site transfer completion. */
    siteTransferred?: SiteTransferred;
    /** Emitted on a meta site deletion. */
    siteDeleted?: SiteDeleted;
    /** Emitted on a meta site restoration. */
    siteUndeleted?: SiteUndeleted;
    /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
    sitePublished?: SitePublished;
    /** Emitted on a meta site unpublish. */
    siteUnpublished?: SiteUnpublished;
    /** Emitted when meta site is marked as template. */
    siteMarkedAsTemplate?: SiteMarkedAsTemplate;
    /** Emitted when meta site is marked as a WixSite. */
    siteMarkedAsWixSite?: SiteMarkedAsWixSite;
    /** Emitted when an application is provisioned (installed). */
    serviceProvisioned?: ServiceProvisioned;
    /** Emitted when an application is removed (uninstalled). */
    serviceRemoved?: ServiceRemoved;
    /** Emitted when meta site name (URL slug) is changed. */
    siteRenamedPayload?: SiteRenamed;
    /** Emitted when meta site was permanently deleted. */
    hardDeleted?: SiteHardDeleted;
    /** Emitted on a namespace change. */
    namespaceChanged?: NamespaceChanged;
    /** Emitted when Studio is attached. */
    studioAssigned?: StudioAssigned;
    /** Emitted when Studio is detached. */
    studioUnassigned?: StudioUnassigned;
    /**
     * Emitted when one of the URLs is changed. After this event you may call `urls-server` to fetch
     * the actual URL.
     *
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1732520791210559?thread_ts=1732027914.294059&cid=C0UHEBPFT
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1744115197619459
     */
    urlChanged?: SiteUrlChanged;
    /** Site is marked as PurgedExternally */
    sitePurgedExternally?: SitePurgedExternally;
    /** Emitted when Odeditor is attached. */
    odeditorAssigned?: OdeditorAssigned;
    /** Emitted when Odeditor is detached. */
    odeditorUnassigned?: OdeditorUnassigned;
    /** Emitted when Picasso is attached. */
    picassoAssigned?: PicassoAssigned;
    /** Emitted when Picasso is detached. */
    picassoUnassigned?: PicassoUnassigned;
    /** Emitted when Wixel is attached. */
    wixelAssigned?: WixelAssigned;
    /** Emitted when Wixel is detached. */
    wixelUnassigned?: WixelUnassigned;
    /** Emitted when StudioTwo is attached. */
    studioTwoAssigned?: StudioTwoAssigned;
    /** Emitted when StudioTwo is detached. */
    studioTwoUnassigned?: StudioTwoUnassigned;
}
interface Asset {
    /**
     * An application definition id (app_id in dev-center). For legacy reasons may be UUID or a string (from Java Enum).
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * An instance id. For legacy reasons may be UUID or a string.
     * @maxLength 200
     */
    instanceId?: string;
    /** An application state. */
    state?: StateWithLiterals;
}
declare enum State {
    UNKNOWN = "UNKNOWN",
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    PENDING = "PENDING",
    DEMO = "DEMO"
}
/** @enumType */
type StateWithLiterals = State | 'UNKNOWN' | 'ENABLED' | 'DISABLED' | 'PENDING' | 'DEMO';
interface SiteCreated {
    /**
     * A template identifier (empty if not created from a template).
     * @maxLength 36
     */
    originTemplateId?: string;
    /**
     * An account id of the owner.
     * @format GUID
     */
    ownerId?: string;
    /** A context in which meta site was created. */
    context?: SiteCreatedContextWithLiterals;
    /**
     * A meta site id from which this site was created.
     *
     * In case of a creation from a template it's a template id.
     * In case of a site duplication ("Save As" in dashboard or duplicate in UM) it's an id of a source site.
     * @format GUID
     */
    originMetaSiteId?: string | null;
    /**
     * A meta site name (URL slug).
     * @maxLength 20
     */
    siteName?: string;
    /** A namespace. */
    namespace?: NamespaceWithLiterals;
}
declare enum SiteCreatedContext {
    /** A valid option, we don't expose all reasons why site might be created. */
    OTHER = "OTHER",
    /** A meta site was created from template. */
    FROM_TEMPLATE = "FROM_TEMPLATE",
    /** A meta site was created by copying of the transfferred meta site. */
    DUPLICATE_BY_SITE_TRANSFER = "DUPLICATE_BY_SITE_TRANSFER",
    /** A copy of existing meta site. */
    DUPLICATE = "DUPLICATE",
    /** A meta site was created as a transfferred site (copy of the original), old flow, should die soon. */
    OLD_SITE_TRANSFER = "OLD_SITE_TRANSFER",
    /** deprecated A meta site was created for Flash editor. */
    FLASH = "FLASH"
}
/** @enumType */
type SiteCreatedContextWithLiterals = SiteCreatedContext | 'OTHER' | 'FROM_TEMPLATE' | 'DUPLICATE_BY_SITE_TRANSFER' | 'DUPLICATE' | 'OLD_SITE_TRANSFER' | 'FLASH';
declare enum Namespace {
    UNKNOWN_NAMESPACE = "UNKNOWN_NAMESPACE",
    /** Default namespace for UGC sites. MetaSites with this namespace will be shown in a user's site list by default. */
    WIX = "WIX",
    /** ShoutOut stand alone product. These are siteless (no actual Wix site, no HtmlWeb). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    SHOUT_OUT = "SHOUT_OUT",
    /** MetaSites created by the Albums product, they appear as part of the Albums app. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    ALBUMS = "ALBUMS",
    /** Part of the WixStores migration flow, a user tries to migrate and gets this site to view and if the user likes it then stores removes this namespace and deletes the old site with the old stores. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    WIX_STORES_TEST_DRIVE = "WIX_STORES_TEST_DRIVE",
    /** Hotels standalone (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    HOTELS = "HOTELS",
    /** Clubs siteless MetaSites, a club without a wix website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    CLUBS = "CLUBS",
    /** A partially created ADI website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    ONBOARDING_DRAFT = "ONBOARDING_DRAFT",
    /** AppBuilder for AppStudio / shmite (c). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    DEV_SITE = "DEV_SITE",
    /** LogoMaker websites offered to the user after logo purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    LOGOS = "LOGOS",
    /** VideoMaker websites offered to the user after video purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    VIDEO_MAKER = "VIDEO_MAKER",
    /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
    PARTNER_DASHBOARD = "PARTNER_DASHBOARD",
    /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
    DEV_CENTER_COMPANY = "DEV_CENTER_COMPANY",
    /**
     * A draft created by HTML editor on open. Upon "first save" it will be moved to be of WIX domain.
     *
     * Meta site with this namespace will *not* be shown in a user's site list by default.
     */
    HTML_DRAFT = "HTML_DRAFT",
    /**
     * the user-journey for Fitness users who want to start from managing their business instead of designing their website.
     * Will be accessible from Site List and will not have a website app.
     * Once the user attaches a site, the site will become a regular wixsite.
     */
    SITELESS_BUSINESS = "SITELESS_BUSINESS",
    /** Belongs to "strategic products" company. Supports new product in the creator's economy space. */
    CREATOR_ECONOMY = "CREATOR_ECONOMY",
    /** It is to be used in the Business First efforts. */
    DASHBOARD_FIRST = "DASHBOARD_FIRST",
    /** Bookings business flow with no site. */
    ANYWHERE = "ANYWHERE",
    /** Namespace for Headless Backoffice with no editor */
    HEADLESS = "HEADLESS",
    /**
     * Namespace for master site that will exist in parent account that will be referenced by subaccounts
     * The site will be used for account level CSM feature for enterprise
     */
    ACCOUNT_MASTER_CMS = "ACCOUNT_MASTER_CMS",
    /** Rise.ai Siteless account management for Gift Cards and Store Credit. */
    RISE = "RISE",
    /**
     * As part of the branded app new funnel, users now can create a meta site that will be branded app first.
     * There's a blank site behind the scene but it's blank).
     * The Mobile company will be the owner of this namespace.
     */
    BRANDED_FIRST = "BRANDED_FIRST",
    /** Nownia.com Siteless account management for Ai Scheduling Assistant. */
    NOWNIA = "NOWNIA",
    /**
     * UGC Templates are templates that are created by users for personal use and to sale to other users.
     * The Partners company owns this namespace.
     */
    UGC_TEMPLATE = "UGC_TEMPLATE",
    /** Codux Headless Sites */
    CODUX = "CODUX",
    /** Bobb - AI Design Creator. */
    MEDIA_DESIGN_CREATOR = "MEDIA_DESIGN_CREATOR",
    /**
     * Shared Blog Site is a unique single site across Enterprise account,
     * This site will hold all Blog posts related to the Marketing product.
     */
    SHARED_BLOG_ENTERPRISE = "SHARED_BLOG_ENTERPRISE",
    /** Standalone forms (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    STANDALONE_FORMS = "STANDALONE_FORMS",
    /** Standalone events (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    STANDALONE_EVENTS = "STANDALONE_EVENTS",
    /** MIMIR - Siteless account for MIMIR Ai Job runner. */
    MIMIR = "MIMIR",
    /** Wix Twins platform. */
    TWINS = "TWINS",
    /** Wix Nano. */
    NANO = "NANO"
}
/** @enumType */
type NamespaceWithLiterals = Namespace | 'UNKNOWN_NAMESPACE' | 'WIX' | 'SHOUT_OUT' | 'ALBUMS' | 'WIX_STORES_TEST_DRIVE' | 'HOTELS' | 'CLUBS' | 'ONBOARDING_DRAFT' | 'DEV_SITE' | 'LOGOS' | 'VIDEO_MAKER' | 'PARTNER_DASHBOARD' | 'DEV_CENTER_COMPANY' | 'HTML_DRAFT' | 'SITELESS_BUSINESS' | 'CREATOR_ECONOMY' | 'DASHBOARD_FIRST' | 'ANYWHERE' | 'HEADLESS' | 'ACCOUNT_MASTER_CMS' | 'RISE' | 'BRANDED_FIRST' | 'NOWNIA' | 'UGC_TEMPLATE' | 'CODUX' | 'MEDIA_DESIGN_CREATOR' | 'SHARED_BLOG_ENTERPRISE' | 'STANDALONE_FORMS' | 'STANDALONE_EVENTS' | 'MIMIR' | 'TWINS' | 'NANO';
/** Site transferred to another user. */
interface SiteTransferred {
    /**
     * A previous owner id (user that transfers meta site).
     * @format GUID
     */
    oldOwnerId?: string;
    /**
     * A new owner id (user that accepts meta site).
     * @format GUID
     */
    newOwnerId?: string;
}
/** Soft deletion of the meta site. Could be restored. */
interface SiteDeleted {
    /** A deletion context. */
    deleteContext?: DeleteContext;
}
interface DeleteContext {
    /** When the meta site was deleted. */
    dateDeleted?: Date | null;
    /** A status. */
    deleteStatus?: DeleteStatusWithLiterals;
    /**
     * A reason (flow).
     * @maxLength 255
     */
    deleteOrigin?: string;
    /**
     * A service that deleted it.
     * @maxLength 255
     */
    initiatorId?: string | null;
}
declare enum DeleteStatus {
    UNKNOWN = "UNKNOWN",
    TRASH = "TRASH",
    DELETED = "DELETED",
    PENDING_PURGE = "PENDING_PURGE",
    PURGED_EXTERNALLY = "PURGED_EXTERNALLY"
}
/** @enumType */
type DeleteStatusWithLiterals = DeleteStatus | 'UNKNOWN' | 'TRASH' | 'DELETED' | 'PENDING_PURGE' | 'PURGED_EXTERNALLY';
/** Restoration of the meta site. */
interface SiteUndeleted {
}
/** First publish of a meta site. Or subsequent publish after unpublish. */
interface SitePublished {
}
interface SiteUnpublished {
    /**
     * A list of URLs previously associated with the meta site.
     * @maxLength 4000
     * @maxSize 10000
     */
    urls?: string[];
}
interface SiteMarkedAsTemplate {
}
interface SiteMarkedAsWixSite {
}
/**
 * Represents a service provisioned a site.
 *
 * Note on `origin_instance_id`:
 * There is no guarantee that you will be able to find a meta site using `origin_instance_id`.
 * This is because of the following scenario:
 *
 * Imagine you have a template where a third-party application (TPA) includes some stub data,
 * such as a product catalog. When you create a site from this template, you inherit this
 * default product catalog. However, if the template's product catalog is modified,
 * your site will retain the catalog as it was at the time of site creation. This ensures that
 * your site remains consistent with what you initially received and does not include any
 * changes made to the original template afterward.
 * To ensure this, the TPA on the template gets a new instance_id.
 */
interface ServiceProvisioned {
    /**
     * Either UUID or EmbeddedServiceType.
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * Not only UUID. Something here could be something weird.
     * @maxLength 36
     */
    instanceId?: string;
    /**
     * An instance id from which this instance is originated.
     * @maxLength 36
     */
    originInstanceId?: string;
    /**
     * A version.
     * @maxLength 500
     */
    version?: string | null;
    /**
     * The origin meta site id
     * @format GUID
     */
    originMetaSiteId?: string | null;
}
interface ServiceRemoved {
    /**
     * Either UUID or EmbeddedServiceType.
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * Not only UUID. Something here could be something weird.
     * @maxLength 36
     */
    instanceId?: string;
    /**
     * A version.
     * @maxLength 500
     */
    version?: string | null;
}
/** Rename of the site. Meaning, free public url has been changed as well. */
interface SiteRenamed {
    /**
     * A new meta site name (URL slug).
     * @maxLength 20
     */
    newSiteName?: string;
    /**
     * A previous meta site name (URL slug).
     * @maxLength 255
     */
    oldSiteName?: string;
}
/**
 * Hard deletion of the meta site.
 *
 * Could not be restored. Therefore it's desirable to cleanup data.
 */
interface SiteHardDeleted {
    /** A deletion context. */
    deleteContext?: DeleteContext;
}
interface NamespaceChanged {
    /** A previous namespace. */
    oldNamespace?: NamespaceWithLiterals;
    /** A new namespace. */
    newNamespace?: NamespaceWithLiterals;
}
/** Assigned Studio editor */
interface StudioAssigned {
}
/** Unassigned Studio editor */
interface StudioUnassigned {
}
/**
 * Fired in case site URLs were changed in any way: new secondary domain, published, account slug rename, site rename etc.
 *
 * This is an internal event, it's not propagated in special events, because it's non-actionable. If you need to keep up
 * with sites and its urls, you need to listen to another topic/event. Read about it:
 *
 * https://bo.wix.com/wix-docs/rest/meta-site/meta-site---urls-service
 */
interface SiteUrlChanged {
}
/**
 * Used at the end of the deletion flow for both draft sites and when a user deletes a site.
 * Consumed by other teams to remove relevant data.
 */
interface SitePurgedExternally {
    /**
     * @maxLength 2048
     * @maxSize 100
     * @deprecated
     * @targetRemovalDate 2025-04-15
     */
    appDefId?: string[];
}
/** Assigned Odeditor */
interface OdeditorAssigned {
}
/** Unassigned Odeditor */
interface OdeditorUnassigned {
}
/** Assigned Picasso editor */
interface PicassoAssigned {
}
/** Unassigned Picasso */
interface PicassoUnassigned {
}
/** Assigned Wixel */
interface WixelAssigned {
}
/** Unassigned Wixel */
interface WixelUnassigned {
}
/** Assigned StudioTwo */
interface StudioTwoAssigned {
}
/** Unassigned StudioTwo */
interface StudioTwoUnassigned {
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface OAuthAppCreatedEnvelope {
    entity: OAuthApp;
    metadata: EventMetadata;
}
/**
 * Triggered when an OAuth app is created.
 * @permissionScope Headless Manage
 * @permissionScopeId SCOPE.HEADLESS.MANAGE
 * @permissionScope Read OAuth Apps
 * @permissionScopeId SCOPE.OAUTH_APP.READ
 * @permissionScope Manage OAuth Apps
 * @permissionScopeId SCOPE.OAUTH_APP.MANAGE
 * @permissionId OAUTH_APP.APP_READ
 * @webhook
 * @eventType wix.headless.v1.o_auth_app_created
 * @serviceIdentifier wix.headless.v1.OAuthAppService
 * @slug created
 * @documentationMaturity preview
 */
declare function onOAuthAppCreated(handler: (event: OAuthAppCreatedEnvelope) => void | Promise<void>): void;
interface OAuthAppDeletedEnvelope {
    metadata: EventMetadata;
}
/**
 * Triggered when an OAuth app is deleted.
 * @permissionScope Headless Manage
 * @permissionScopeId SCOPE.HEADLESS.MANAGE
 * @permissionScope Read OAuth Apps
 * @permissionScopeId SCOPE.OAUTH_APP.READ
 * @permissionScope Manage OAuth Apps
 * @permissionScopeId SCOPE.OAUTH_APP.MANAGE
 * @permissionId OAUTH_APP.APP_READ
 * @webhook
 * @eventType wix.headless.v1.o_auth_app_deleted
 * @serviceIdentifier wix.headless.v1.OAuthAppService
 * @slug deleted
 * @documentationMaturity preview
 */
declare function onOAuthAppDeleted(handler: (event: OAuthAppDeletedEnvelope) => void | Promise<void>): void;
interface OAuthAppUpdatedEnvelope {
    entity: OAuthApp;
    metadata: EventMetadata;
}
/**
 * Triggered when an OAuth app is updated.
 * @permissionScope Headless Manage
 * @permissionScopeId SCOPE.HEADLESS.MANAGE
 * @permissionScope Read OAuth Apps
 * @permissionScopeId SCOPE.OAUTH_APP.READ
 * @permissionScope Manage OAuth Apps
 * @permissionScopeId SCOPE.OAUTH_APP.MANAGE
 * @permissionId OAUTH_APP.APP_READ
 * @webhook
 * @eventType wix.headless.v1.o_auth_app_updated
 * @serviceIdentifier wix.headless.v1.OAuthAppService
 * @slug updated
 * @documentationMaturity preview
 */
declare function onOAuthAppUpdated(handler: (event: OAuthAppUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a new OAuth app for a Wix Headless client.
 *
 * Use this API to enable headless functionality for a Wix site. An OAuth app allows external sites or apps to securely access your site's data and services using Wix APIs.
 * @param oAuthApp - OAuth app to create.
 * @public
 * @documentationMaturity preview
 * @requiredField oAuthApp
 * @requiredField oAuthApp.name
 * @permissionId OAUTH_APP.APP_CREATE
 * @applicableIdentity APP
 * @returns Created OAuth app info.
 * @fqn wix.headless.v1.OAuthAppService.CreateOAuthApp
 */
declare function createOAuthApp(oAuthApp: NonNullablePaths<OAuthApp, `name`, 2>): Promise<NonNullablePaths<OAuthApp, `allowedRedirectUris` | `allowedRedirectDomains` | `applicationType` | `technology` | `wixPagesDomainsMappings` | `wixPagesDomainsMappings.${number}.origin` | `wixPagesDomainsMappings.${number}.destination`, 4>>;
/**
 * Retrieves an OAuth app by ID.
 * @param oAuthAppId - ID of the OAuth app to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField oAuthAppId
 * @permissionId OAUTH_APP.APP_READ
 * @applicableIdentity APP
 * @returns Retrieved OAuth app info.
 * @fqn wix.headless.v1.OAuthAppService.GetOAuthApp
 */
declare function getOAuthApp(oAuthAppId: string): Promise<NonNullablePaths<OAuthApp, `allowedRedirectUris` | `allowedRedirectDomains` | `applicationType` | `technology` | `wixPagesDomainsMappings` | `wixPagesDomainsMappings.${number}.origin` | `wixPagesDomainsMappings.${number}.destination`, 4>>;
/**
 * Updates an OAuth app.
 *
 *
 * Only fields provided in `mask.paths` are updated.
 *
 * You can update the following fields:
 * + `name`
 * + `description`
 * + `allowedDomain`
 * + `loginUrl`
 * + `logoutUrl`
 * + `technology`
 * @param _id - ID of the OAuth app.
 * @param mask - Explicit list of fields to update. Only fields listed are updated.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField mask
 * @requiredField oAuthApp
 * @permissionId OAUTH_APP.APP_UPDATE
 * @applicableIdentity APP
 * @returns Updated OAuth app info.
 * @fqn wix.headless.v1.OAuthAppService.UpdateOAuthApp
 */
declare function updateOAuthApp(_id: string, oAuthApp: UpdateOAuthApp, mask: string[]): Promise<NonNullablePaths<OAuthApp, `allowedRedirectUris` | `allowedRedirectDomains` | `applicationType` | `technology` | `wixPagesDomainsMappings` | `wixPagesDomainsMappings.${number}.origin` | `wixPagesDomainsMappings.${number}.destination`, 4>>;
interface UpdateOAuthApp {
    /**
     * ID of the OAuth app.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Date and time the OAuth app was created, in ISO 8601 format.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Display name of the OAuth app, as it appears in the dashboard.
     * @minLength 2
     * @maxLength 256
     */
    name?: string | null;
    /** Description of the OAuth app, as it appears in the dashboard. */
    description?: string | null;
    /**
     * For internal use only.
     * @readonly
     * @deprecated
     */
    secret?: string | null;
    /**
     * External login URL to which users are redirected automatically to authenticate. If no login URL is specified, the user is redirected to Wix to authenticate.
     * @format WEB_URL
     */
    loginUrl?: string | null;
    /**
     * List of URIs to which redirection from Wix is allowed after authentication.
     *
     * When a client redirects a user to Wix for authentication, the client provides a URI to redirect the user back to after the user has been authenticated.
     * Wix only redirects the user if the exact URI is contained in this array.
     * @format URI
     * @maxSize 20
     */
    allowedRedirectUris?: string[];
    /**
     * List of domains to which redirection from Wix is allowed after processes other than authentication.
     *
     * When a client redirects a user to a Wix page (for example, for checkout), the client provides a URL to redirect the user back to.
     * Wix only redirects the user if the URL is in one of the specified domains.
     * @maxSize 20
     */
    allowedRedirectDomains?: string[];
    /** For internal use only. */
    allowSecretGeneration?: boolean | null;
    /**
     * External logout URL to which we invoke when user logout at wix. If no logout URL is specified, the user is logged out only at Wix.
     * @format WEB_URL
     */
    logoutUrl?: string | null;
    /** OAuth application type. */
    applicationType?: OAuthAppTypeWithLiterals;
    /** OAuth technology used by the oauth application. */
    technology?: OAuthTechnologiesWithLiterals;
    /**
     * List of domain mappings from external domains to Wix domains.
     * When a user accesses a non-Wix domain, they can be automatically forwarded to the corresponding
     * Wix domain based on these mappings. This enables domain-level redirection from
     * external domains to Wix-hosted pages.
     * @maxSize 200
     */
    wixPagesDomainsMappings?: WixPagesDomainMapping[];
    /**
     * Redirect url for Wix-hosted pages.
     * @maxLength 1024
     */
    redirectUrlWixPages?: string | null;
}
/**
 * Deletes an OAuth app by ID.
 *
 *
 * > **Note:** After you delete an OAuth app, an external client can no longer make API calls by authenticating with its client ID.
 * @param oAuthAppId - ID of the OAuth app to delete.
 * @internal
 * @documentationMaturity preview
 * @requiredField oAuthAppId
 * @permissionId OAUTH_APP.APP_DELETE
 * @applicableIdentity APP
 * @fqn wix.headless.v1.OAuthAppService.DeleteOAuthApp
 */
declare function deleteOAuthApp(oAuthAppId: string): Promise<void>;
/**
 * Retrieves a list of OAuth apps, given the provided paging, filtering, and sorting.
 *
 *
 * Query OAuth Apps runs with these defaults, which you can override:
 * + Results are sorted by `id` in descending order.
 * + `paging.offset` is `0`.
 * @public
 * @documentationMaturity preview
 * @permissionId OAUTH_APP.APP_READ
 * @applicableIdentity APP
 * @fqn wix.headless.v1.OAuthAppService.QueryOAuthApps
 */
declare function queryOAuthApps(): OAuthAppsQueryBuilder;
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface OAuthAppsQueryResult extends QueryOffsetResult {
    items: OAuthApp[];
    query: OAuthAppsQueryBuilder;
    next: () => Promise<OAuthAppsQueryResult>;
    prev: () => Promise<OAuthAppsQueryResult>;
}
interface OAuthAppsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id', value: any) => OAuthAppsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_createdDate' | 'name'>) => OAuthAppsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_createdDate' | 'name'>) => OAuthAppsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => OAuthAppsQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results.
     * @documentationMaturity preview
     */
    skip: (skip: number) => OAuthAppsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<OAuthAppsQueryResult>;
}
/**
 * Generates a secret for an existing OAuth app.
 *
 *
 * > **Note:** You can only generate a secret once for each OAuth app, and the secret can't be retrieved later. Store the secret securely.
 * @param oAuthAppId - ID of the OAuth app to generate a secret for.
 * @internal
 * @documentationMaturity preview
 * @requiredField oAuthAppId
 * @permissionId OAUTH_APP.APP_UPDATE
 * @applicableIdentity APP
 * @fqn wix.headless.v1.OAuthAppService.GenerateOAuthAppSecret
 */
declare function generateOAuthAppSecret(oAuthAppId: string): Promise<NonNullablePaths<GenerateOAuthAppSecretResponse, `oAuthAppSecret`, 2>>;

export { type ActionEvent, type Asset, type BaseEventMetadata, type CreateOAuthAppRequest, type CreateOAuthAppResponse, type CursorPaging, type Cursors, type DeleteContext, type DeleteOAuthAppRequest, type DeleteOAuthAppResponse, DeleteStatus, type DeleteStatusWithLiterals, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type GenerateOAuthAppSecretRequest, type GenerateOAuthAppSecretResponse, type GetOAuthAppRequest, type GetOAuthAppResponse, type IdentificationData, type IdentificationDataIdOneOf, type MessageEnvelope, type MetaSiteSpecialEvent, type MetaSiteSpecialEventPayloadOneOf, Namespace, type NamespaceChanged, type NamespaceWithLiterals, type OAuthApp, type OAuthAppCreatedEnvelope, type OAuthAppDeletedEnvelope, OAuthAppType, type OAuthAppTypeWithLiterals, type OAuthAppUpdatedEnvelope, type OAuthAppsQueryBuilder, type OAuthAppsQueryResult, OAuthTechnologies, type OAuthTechnologiesWithLiterals, type OdeditorAssigned, type OdeditorUnassigned, type Paging, type PagingMetadataV2, type PicassoAssigned, type PicassoUnassigned, type PlatformQuery, type PlatformQueryPagingMethodOneOf, type QueryOAuthAppsRequest, type QueryOAuthAppsResponse, type RestoreInfo, type ServiceProvisioned, type ServiceRemoved, type SiteCreated, SiteCreatedContext, type SiteCreatedContextWithLiterals, type SiteDeleted, type SiteHardDeleted, type SiteMarkedAsTemplate, type SiteMarkedAsWixSite, type SitePublished, type SitePurgedExternally, type SiteRenamed, type SiteTransferred, type SiteUndeleted, type SiteUnpublished, type SiteUrlChanged, SortOrder, type SortOrderWithLiterals, type Sorting, State, type StateWithLiterals, type StudioAssigned, type StudioTwoAssigned, type StudioTwoUnassigned, type StudioUnassigned, type UpdateOAuthApp, type UpdateOAuthAppRequest, type UpdateOAuthAppResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, type WixPagesDomainMapping, type WixelAssigned, type WixelUnassigned, createOAuthApp, deleteOAuthApp, generateOAuthAppSecret, getOAuthApp, onOAuthAppCreated, onOAuthAppDeleted, onOAuthAppUpdated, queryOAuthApps, updateOAuthApp };
