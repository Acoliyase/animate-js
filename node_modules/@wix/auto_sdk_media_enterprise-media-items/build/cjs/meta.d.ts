import { y as ItemUploadCallbackRequest$1, a as ItemUploadCallbackResponse$1, z as GenerateFileUploadUrlRequest$1, b as GenerateFileUploadUrlResponse$1, e as ImportFileRequest$1, d as ImportFileResponse$1, C as BulkImportFilesRequest$1, f as BulkImportFilesResponse$1, K as SearchItemsRequest$1, S as SearchItemsResponse$1, _ as QueryItemsRequest$1, a1 as QueryItemsResponse$1, i as UpdateItemRequest$1, a2 as UpdateItemResponse$1, a4 as BulkUpdateItemRequest$1, k as BulkUpdateItemResponse$1, a6 as GetItemRequest$1, a7 as GetItemResponse$1, a8 as LinkItemToCategoriesRequest$1, l as LinkItemToCategoriesResponse$1, a9 as UnlinkItemFromCategoriesRequest$1, n as UnlinkItemFromCategoriesResponse$1, aa as OverwriteItemCategoriesRequest$1, o as OverwriteItemCategoriesResponse$1 } from './media-enterprise-public-media-v1-enterprise-item-enterprise-media-items.universal-DPDumpLH.js';
import '@wix/sdk-types';

/**
 * Duration for video fits better if there will be type specific media item.. however, is it ok to implement
 * an additional one of field called details?
 */
interface EnterpriseMediaItem {
    /**
     * Id of the item in public media
     * @maxLength 100
     * @readonly
     */
    id?: string;
    /**
     * Media type of the item
     * @readonly
     */
    mediaType?: MediaTypeWithLiterals;
    /**
     * Size of the uploaded file in bytes.
     * @readonly
     * @maxLength 1000
     */
    sizeInBytes?: string | null;
    /**
     * The item title, part of searchable fields
     * @maxLength 1000
     */
    title?: string | null;
    /**
     * The aspect ratio of the item
     * An object containing urls for different views of the item
     * @readonly
     */
    assets?: ItemAssets;
    /**
     * Tags describing the image, part of searchable fields
     * @maxSize 100
     * @maxLength 100
     */
    displayTags?: string[] | null;
    /**
     * Tags for internal client use, part of searchable fields
     * @maxSize 100
     * @maxLength 100
     */
    internalTags?: string[] | null;
    /**
     * Tags for filtering items in the search
     * @maxSize 100
     * @maxLength 100
     * @readonly
     */
    systemTags?: string[] | null;
    /**
     * Category ids this item belongs to
     * @maxSize 100
     * @maxLength 100
     * @readonly
     */
    parentCategoryIds?: string[] | null;
    /** Status of the item */
    publishStatus?: PublishStatusWithLiterals;
    /**
     * Date and time the item was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the item was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * An internal id used with different wix media systems
     * @maxLength 100
     * @readonly
     */
    internalId?: string | null;
}
declare enum MediaType {
    MIXED = "MIXED",
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
    AUDIO = "AUDIO",
    DOCUMENT = "DOCUMENT",
    VECTOR = "VECTOR",
    ARCHIVE = "ARCHIVE",
    MODEL3D = "MODEL3D"
}
/** @enumType */
type MediaTypeWithLiterals = MediaType | 'MIXED' | 'IMAGE' | 'VIDEO' | 'AUDIO' | 'DOCUMENT' | 'VECTOR' | 'ARCHIVE' | 'MODEL3D';
interface ItemAssets extends ItemAssetsAssetsOneOf {
    /** Assets for image media type */
    image?: Image;
    /** Assets for video media type */
    video?: VideoV2;
    /** Assets for vector media type */
    vector?: Image;
    /** Assets for audio media type */
    audio?: Audio;
    /** Assets for document media type */
    document?: Document;
    /** Information about the archive. */
    archive?: Archive;
    /** Information about the 3D Model. */
    model3d?: Model3D;
}
/** @oneof */
interface ItemAssetsAssetsOneOf {
    /** Assets for image media type */
    image?: Image;
    /** Assets for video media type */
    video?: VideoV2;
    /** Assets for vector media type */
    vector?: Image;
    /** Assets for audio media type */
    audio?: Audio;
    /** Assets for document media type */
    document?: Document;
    /** Information about the archive. */
    archive?: Archive;
    /** Information about the 3D Model. */
    model3d?: Model3D;
}
interface Image {
    /** WixMedia image ID. */
    id?: string;
    /** Image URL. */
    url?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Image filename.
     * @readonly
     */
    filename?: string | null;
}
interface VideoV2 {
    /** WixMedia ID. */
    id?: string;
    /**
     * Available resolutions for the video, starting with the optimal resolution.
     * @readonly
     * @maxSize 100
     */
    resolutions?: VideoResolution[];
    /**
     * Video filename.
     * @readonly
     */
    filename?: string | null;
}
interface VideoResolution {
    /** Video URL. */
    url?: string;
    /** Video height. */
    height?: number;
    /** Video width. */
    width?: number;
    /**
     * Video format
     * Possible values: ['144p.mp4' '144p.webm' '240p.mp4' '240p.webm' '360p.mp4' '360p.webm' '480p.mp4' '480p.webm'
     * '720p.mp4' '720p.webm' '1080p.mp4' '1080p.webm' ]
     */
    format?: string;
}
interface Audio {
    /** WixMedia ID. */
    id?: string;
    /** Audio URL. */
    url?: string;
    /**
     * Audio filename.
     * @readonly
     */
    filename?: string | null;
}
interface Document {
    /** WixMedia ID. */
    id?: string;
    /** Document URL. */
    url?: string;
    /** Document filename. */
    filename?: string | null;
}
interface Archive {
    /** WixMedia ID. */
    id?: string;
    /** Archive URL. */
    url?: string;
    /**
     * Archive URL expiration date (when relevant).
     * @readonly
     */
    urlExpirationDate?: Date | null;
    /**
     * Archive size in bytes.
     * @format DECIMAL_VALUE
     */
    sizeInBytes?: string | null;
    /** Archive filename. */
    filename?: string | null;
}
interface Model3D {
    /** WixMedia 3D ID. */
    id?: string;
    /** 3D URL. */
    url?: string;
    /** 3D thumbnail Image */
    thumbnail?: Image;
    /** 3D alt text. */
    altText?: string | null;
    /**
     * 3D URL expiration date (when relevant).
     * @readonly
     */
    urlExpirationDate?: Date | null;
    /**
     * 3D filename.
     * @readonly
     */
    filename?: string | null;
    /**
     * 3D size in bytes.
     * @readonly
     * @format DECIMAL_VALUE
     */
    sizeInBytes?: string | null;
}
declare enum PublishStatus {
    UNDEFINED = "UNDEFINED",
    UNPUBLISHED = "UNPUBLISHED",
    PUBLISHED = "PUBLISHED",
    WIX_ONLY = "WIX_ONLY"
}
/** @enumType */
type PublishStatusWithLiterals = PublishStatus | 'UNDEFINED' | 'UNPUBLISHED' | 'PUBLISHED' | 'WIX_ONLY';
interface ItemUploadCallbackRequest {
    /**
     * The item id of the created item
     * @maxLength 100
     */
    itemId?: string;
    /**
     * The callback passed to the upload endpoint
     * @maxLength 10000
     */
    callbackToken?: string;
}
interface ItemUploadCallbackResponse {
    /** A message describing what happened on the endpoint */
    message?: string | null;
}
interface GenerateFileUploadUrlRequest {
    /**
     * The uploaded original file name including the extension
     * @maxLength 1000
     */
    fileName?: string;
    /**
     * The file mime-type - will be used to identify the type of media
     * @maxLength 1000
     */
    contentType?: string;
    /** The file size in bytes */
    sizeInBytes?: number;
    /**
     * An optional list of categories to link the created item to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
}
interface GenerateFileUploadUrlResponse {
    /**
     * The upload url to upload the file to
     * @maxLength 10000
     */
    uploadUrl?: string;
}
interface ImportFileRequest {
    /**
     * The url to the file to be imported
     * @format WEB_URL
     */
    url: string;
    /**
     * The uploaded original file name including the extension - will be used as the initial display name
     * @maxLength 1000
     */
    fileName?: string | null;
    /**
     * The file mime-type - will be used to identify the type of media
     * @maxLength 1000
     */
    contentType?: string | null;
    /** The file size in bytes */
    sizeInBytes?: number | null;
    /**
     * An optional list of categories to link the created item to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
    /** The media type of the uploaded file */
    mediaType?: MediaTypeWithLiterals;
    /**
     * A unique identifier of the client that imported the file
     * This information will exist in the system_tags field prefixed by '_external_uploader:{uploader_system_tag}'
     * @maxLength 100
     */
    uploaderSystemTag?: string | null;
    /**
     * An additional container for external information
     * mostly used to pass identifying information of related entities in external services
     * This information will exist in the system_tags field prefixed by '_external_uploader_info:{uploader_info_system_tag}'
     * @maxLength 1000
     */
    uploaderInfoSystemTag?: string | null;
}
interface ImportFileResponse {
    /**
     * Partial item - without the assets
     * At this stage of implementation only the 'internal_id' will be filled
     * all other required values will be fake values
     */
    item?: EnterpriseMediaItem;
}
interface BulkImportFilesRequest {
    /**
     * Information about the files to import.
     * @minSize 1
     * @maxSize 100
     */
    importFileRequests: ImportFileRequest[];
    /**
     * Whether to include the imported File Descriptor in the response. Set to `false` to exclude the File Descriptor from the returned object.
     * Default: `true`
     */
    returnEntity?: boolean | null;
    /**
     * An optional list of categories to link all the items to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
}
interface BulkImportFilesResponse {
    /** Items created by bulk action. */
    results?: BulkImportFilesResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkImportFilesResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Imported file. This field is returned if the operation was successful and `returnEntity` is not set to `false`. */
    item?: EnterpriseMediaItem;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface SearchItemsRequest {
    /** Items search query */
    query?: Search;
}
interface Search extends SearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can not be used together with 'cursor_paging' */
    paging?: Paging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]
     * @maxSize 50
     */
    sort?: Sorting[];
    /** free text to match in searchable fields */
    search?: SearchDetails;
}
/** @oneof */
interface SearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can not be used together with 'cursor_paging' */
    paging?: Paging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface SearchDetails {
    /** search term or expression */
    expression?: string | null;
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface SearchItemsResponse {
    /**
     * A list of items matching the request
     * @maxSize 200
     */
    items?: EnterpriseMediaItem[];
    /** Information about the search results. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
}
interface QueryItemsRequest {
    /** Items query */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
}
interface QueryItemsResponse {
    /**
     * A list of items matching the request
     * @maxSize 200
     */
    items?: EnterpriseMediaItem[];
    /** Information for the next request. */
    pagingMetadata?: PagingMetadataV2;
}
interface UpdateItemRequest {
    /** The category object that will be created */
    item: EnterpriseMediaItem;
}
interface UpdateItemResponse {
    /** Updated item info */
    item?: EnterpriseMediaItem;
}
interface BulkUpdateItemRequest {
    /**
     * Requests to update individual item
     * @maxSize 20
     * @minSize 1
     */
    updateItemRequests: UpdateItemRequest[];
    /** Should the response return the updated item */
    returnEntity?: boolean;
}
interface BulkUpdateItemResponse {
    /** Results of the individual item operation */
    results?: BulkItemUpdateResult[];
    /** Metadata of the operation */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkItemUpdateResult {
    /** updated item metadata */
    itemMetadata?: ItemMetadata;
    /** only returned if operation was successful and if returnEntity flag was on */
    item?: EnterpriseMediaItem;
}
interface GetItemRequest {
    /**
     * Item id
     * @maxLength 100
     */
    itemId: string;
}
interface GetItemResponse {
    /** item info */
    item?: EnterpriseMediaItem;
}
interface LinkItemToCategoriesRequest {
    /**
     * The item id
     * @maxLength 100
     */
    itemId: string;
    /**
     * The category ids that the item will be linked to
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
interface LinkItemToCategoriesResponse {
    /**
     * The linked category ids
     * @maxLength 100
     * @maxSize 20
     */
    linkedCategoryIds?: string[] | null;
}
interface UnlinkItemFromCategoriesRequest {
    /**
     * The item id
     * @maxLength 100
     */
    itemId: string;
    /**
     * The category ids that the item will be unlinked from
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
interface UnlinkItemFromCategoriesResponse {
    /**
     * The unlinked category ids
     * @maxLength 100
     * @maxSize 20
     */
    unlinkedCategoryIds?: string[] | null;
}
interface OverwriteItemCategoriesRequest {
    /**
     * The item id
     * @maxLength 100
     */
    itemId: string;
    /**
     * The category ids the item will be linked to after this operation
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
interface OverwriteItemCategoriesResponse {
    /**
     * The linked category ids
     * @maxLength 100
     * @maxSize 20
     */
    linkedCategoryIds?: string[] | null;
    /**
     * The unlinked category ids
     * @maxLength 100
     * @maxSize 20
     */
    unlinkedCategoryIds?: string[] | null;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function itemUploadCallback(): __PublicMethodMetaInfo<'POST', {}, ItemUploadCallbackRequest$1, ItemUploadCallbackRequest, ItemUploadCallbackResponse$1, ItemUploadCallbackResponse>;
declare function generateFileUploadUrl(): __PublicMethodMetaInfo<'POST', {}, GenerateFileUploadUrlRequest$1, GenerateFileUploadUrlRequest, GenerateFileUploadUrlResponse$1, GenerateFileUploadUrlResponse>;
declare function importFile(): __PublicMethodMetaInfo<'POST', {}, ImportFileRequest$1, ImportFileRequest, ImportFileResponse$1, ImportFileResponse>;
declare function bulkImportFiles(): __PublicMethodMetaInfo<'POST', {}, BulkImportFilesRequest$1, BulkImportFilesRequest, BulkImportFilesResponse$1, BulkImportFilesResponse>;
declare function searchItems(): __PublicMethodMetaInfo<'POST', {}, SearchItemsRequest$1, SearchItemsRequest, SearchItemsResponse$1, SearchItemsResponse>;
declare function queryItems(): __PublicMethodMetaInfo<'POST', {}, QueryItemsRequest$1, QueryItemsRequest, QueryItemsResponse$1, QueryItemsResponse>;
declare function updateItem(): __PublicMethodMetaInfo<'PATCH', {
    itemId: string;
}, UpdateItemRequest$1, UpdateItemRequest, UpdateItemResponse$1, UpdateItemResponse>;
declare function bulkUpdateItem(): __PublicMethodMetaInfo<'PATCH', {}, BulkUpdateItemRequest$1, BulkUpdateItemRequest, BulkUpdateItemResponse$1, BulkUpdateItemResponse>;
declare function getItem(): __PublicMethodMetaInfo<'GET', {
    itemId: string;
}, GetItemRequest$1, GetItemRequest, GetItemResponse$1, GetItemResponse>;
declare function linkItemToCategories(): __PublicMethodMetaInfo<'POST', {
    itemId: string;
}, LinkItemToCategoriesRequest$1, LinkItemToCategoriesRequest, LinkItemToCategoriesResponse$1, LinkItemToCategoriesResponse>;
declare function unlinkItemFromCategories(): __PublicMethodMetaInfo<'POST', {
    itemId: string;
}, UnlinkItemFromCategoriesRequest$1, UnlinkItemFromCategoriesRequest, UnlinkItemFromCategoriesResponse$1, UnlinkItemFromCategoriesResponse>;
declare function overwriteItemCategories(): __PublicMethodMetaInfo<'POST', {
    itemId: string;
}, OverwriteItemCategoriesRequest$1, OverwriteItemCategoriesRequest, OverwriteItemCategoriesResponse$1, OverwriteItemCategoriesResponse>;

export { type __PublicMethodMetaInfo, bulkImportFiles, bulkUpdateItem, generateFileUploadUrl, getItem, importFile, itemUploadCallback, linkItemToCategories, overwriteItemCategories, queryItems, searchItems, unlinkItemFromCategories, updateItem };
