import { SearchSpec, Search as Search$1, NonNullablePaths } from '@wix/sdk-types';

/**
 * Duration for video fits better if there will be type specific media item.. however, is it ok to implement
 * an additional one of field called details?
 */
interface EnterpriseMediaItem {
    /**
     * Id of the item in public media
     * @maxLength 100
     * @readonly
     */
    _id?: string;
    /**
     * Media type of the item
     * @readonly
     */
    mediaType?: MediaTypeWithLiterals;
    /**
     * Size of the uploaded file in bytes.
     * @readonly
     * @maxLength 1000
     */
    sizeInBytes?: string | null;
    /**
     * The item title, part of searchable fields
     * @maxLength 1000
     */
    title?: string | null;
    /**
     * The aspect ratio of the item
     * An object containing urls for different views of the item
     * @readonly
     */
    assets?: ItemAssets;
    /**
     * Tags describing the image, part of searchable fields
     * @maxSize 100
     * @maxLength 100
     */
    displayTags?: string[] | null;
    /**
     * Tags for internal client use, part of searchable fields
     * @maxSize 100
     * @maxLength 100
     */
    internalTags?: string[] | null;
    /**
     * Tags for filtering items in the search
     * @maxSize 100
     * @maxLength 100
     * @readonly
     */
    systemTags?: string[] | null;
    /**
     * Category ids this item belongs to
     * @maxSize 100
     * @maxLength 100
     * @readonly
     */
    parentCategoryIds?: string[] | null;
    /** Status of the item */
    publishStatus?: PublishStatusWithLiterals;
    /**
     * Date and time the item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the item was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * An internal id used with different wix media systems
     * @maxLength 100
     * @readonly
     */
    internalId?: string | null;
}
declare enum MediaType {
    MIXED = "MIXED",
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
    AUDIO = "AUDIO",
    DOCUMENT = "DOCUMENT",
    VECTOR = "VECTOR",
    ARCHIVE = "ARCHIVE",
    MODEL3D = "MODEL3D"
}
/** @enumType */
type MediaTypeWithLiterals = MediaType | 'MIXED' | 'IMAGE' | 'VIDEO' | 'AUDIO' | 'DOCUMENT' | 'VECTOR' | 'ARCHIVE' | 'MODEL3D';
interface ItemAssets extends ItemAssetsAssetsOneOf {
    /** Assets for image media type */
    image?: string;
    /** Assets for video media type */
    video?: string;
    /** Assets for vector media type */
    vector?: string;
    /** Assets for audio media type */
    audio?: string;
    /** Assets for document media type */
    document?: string;
    /** Information about the archive. */
    archive?: Archive;
    /** Information about the 3D Model. */
    model3d?: Model3D;
}
/** @oneof */
interface ItemAssetsAssetsOneOf {
    /** Assets for image media type */
    image?: string;
    /** Assets for video media type */
    video?: string;
    /** Assets for vector media type */
    vector?: string;
    /** Assets for audio media type */
    audio?: string;
    /** Assets for document media type */
    document?: string;
    /** Information about the archive. */
    archive?: Archive;
    /** Information about the 3D Model. */
    model3d?: Model3D;
}
interface VideoResolution {
    /** Video URL. */
    url?: string;
    /** Video height. */
    height?: number;
    /** Video width. */
    width?: number;
    /**
     * Video format
     * Possible values: ['144p.mp4' '144p.webm' '240p.mp4' '240p.webm' '360p.mp4' '360p.webm' '480p.mp4' '480p.webm'
     * '720p.mp4' '720p.webm' '1080p.mp4' '1080p.webm' ]
     */
    format?: string;
}
interface Archive {
    /** WixMedia ID. */
    _id?: string;
    /** Archive URL. */
    url?: string;
    /**
     * Archive URL expiration date (when relevant).
     * @readonly
     */
    urlExpirationDate?: Date | null;
    /**
     * Archive size in bytes.
     * @format DECIMAL_VALUE
     */
    sizeInBytes?: string | null;
    /** Archive filename. */
    filename?: string | null;
}
interface Model3D {
    /** WixMedia 3D ID. */
    _id?: string;
    /** 3D URL. */
    url?: string;
    /** 3D thumbnail Image */
    thumbnail?: string;
    /** 3D alt text. */
    altText?: string | null;
    /**
     * 3D URL expiration date (when relevant).
     * @readonly
     */
    urlExpirationDate?: Date | null;
    /**
     * 3D filename.
     * @readonly
     */
    filename?: string | null;
    /**
     * 3D size in bytes.
     * @readonly
     * @format DECIMAL_VALUE
     */
    sizeInBytes?: string | null;
}
declare enum PublishStatus {
    UNDEFINED = "UNDEFINED",
    UNPUBLISHED = "UNPUBLISHED",
    PUBLISHED = "PUBLISHED",
    WIX_ONLY = "WIX_ONLY"
}
/** @enumType */
type PublishStatusWithLiterals = PublishStatus | 'UNDEFINED' | 'UNPUBLISHED' | 'PUBLISHED' | 'WIX_ONLY';
interface ItemCategoriesChanged {
    /**
     * A list of the current item categories
     * @maxLength 100
     * @maxSize 100
     */
    itemCategoryIds?: string[] | null;
    /**
     * A list of the categories that where unlinked from the item
     * @maxLength 100
     * @maxSize 20
     */
    unlinkedCategoryIds?: string[] | null;
    /**
     * A list of the categories that where linked to the item
     * @maxLength 100
     * @maxSize 20
     */
    linkedCategoryIds?: string[] | null;
    /** The full updated item information */
    entity?: EnterpriseMediaItem;
}
interface ItemUploadCallbackRequest {
    /**
     * The item id of the created item
     * @maxLength 100
     */
    itemId?: string;
    /**
     * The callback passed to the upload endpoint
     * @maxLength 10000
     */
    callbackToken?: string;
}
interface ItemUploadCallbackResponse {
    /** A message describing what happened on the endpoint */
    message?: string | null;
}
interface GenerateFileUploadUrlRequest {
    /**
     * The uploaded original file name including the extension
     * @maxLength 1000
     */
    fileName?: string;
    /**
     * The file mime-type - will be used to identify the type of media
     * @maxLength 1000
     */
    contentType?: string;
    /** The file size in bytes */
    sizeInBytes?: number;
    /**
     * An optional list of categories to link the created item to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
}
interface GenerateFileUploadUrlResponse {
    /**
     * The upload url to upload the file to
     * @maxLength 10000
     */
    uploadUrl?: string;
}
interface ImportFileRequest {
    /**
     * The url to the file to be imported
     * @format WEB_URL
     */
    url: string;
    /**
     * The uploaded original file name including the extension - will be used as the initial display name
     * @maxLength 1000
     */
    fileName?: string | null;
    /**
     * The file mime-type - will be used to identify the type of media
     * @maxLength 1000
     */
    contentType?: string | null;
    /** The file size in bytes */
    sizeInBytes?: number | null;
    /**
     * An optional list of categories to link the created item to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
    /** The media type of the uploaded file */
    mediaType?: MediaTypeWithLiterals;
    /**
     * A unique identifier of the client that imported the file
     * This information will exist in the system_tags field prefixed by '_external_uploader:{uploader_system_tag}'
     * @maxLength 100
     */
    uploaderSystemTag?: string | null;
    /**
     * An additional container for external information
     * mostly used to pass identifying information of related entities in external services
     * This information will exist in the system_tags field prefixed by '_external_uploader_info:{uploader_info_system_tag}'
     * @maxLength 1000
     */
    uploaderInfoSystemTag?: string | null;
}
interface ImportFileResponse {
    /**
     * Partial item - without the assets
     * At this stage of implementation only the 'internal_id' will be filled
     * all other required values will be fake values
     */
    item?: EnterpriseMediaItem;
}
interface BulkImportFilesRequest {
    /**
     * Information about the files to import.
     * @minSize 1
     * @maxSize 100
     */
    importFileRequests: ImportFileRequest[];
    /**
     * Whether to include the imported File Descriptor in the response. Set to `false` to exclude the File Descriptor from the returned object.
     * Default: `true`
     */
    returnEntity?: boolean | null;
    /**
     * An optional list of categories to link all the items to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
}
interface BulkImportFilesResponse {
    /** Items created by bulk action. */
    results?: BulkImportFilesResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkImportFilesResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Imported file. This field is returned if the operation was successful and `returnEntity` is not set to `false`. */
    item?: EnterpriseMediaItem;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface SearchItemsRequest {
    /** Items search query */
    query?: Search;
}
interface Search extends SearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can not be used together with 'cursor_paging' */
    paging?: Paging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]
     * @maxSize 50
     */
    sort?: Sorting[];
    /** free text to match in searchable fields */
    search?: SearchDetails;
}
/** @oneof */
interface SearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can not be used together with 'cursor_paging' */
    paging?: Paging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface SearchDetails {
    /** search term or expression */
    expression?: string | null;
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface SearchItemsResponse {
    /**
     * A list of items matching the request
     * @maxSize 200
     */
    items?: EnterpriseMediaItem[];
    /** Information about the search results. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
}
interface QueryItemsRequest {
    /** Items query */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
}
interface QueryItemsResponse {
    /**
     * A list of items matching the request
     * @maxSize 200
     */
    items?: EnterpriseMediaItem[];
    /** Information for the next request. */
    pagingMetadata?: PagingMetadataV2;
}
interface UpdateItemRequest {
    /** The category object that will be created */
    item: EnterpriseMediaItem;
}
interface UpdateItemResponse {
    /** Updated item info */
    item?: EnterpriseMediaItem;
}
interface PublishStatusChanged {
    /** The new item status */
    publishStatus?: PublishStatusWithLiterals;
    /** The full updated item information */
    entity?: EnterpriseMediaItem;
}
interface BulkUpdateItemRequest {
    /**
     * Requests to update individual item
     * @maxSize 20
     * @minSize 1
     */
    updateItemRequests: UpdateItemRequest[];
    /** Should the response return the updated item */
    returnEntity?: boolean;
}
interface BulkUpdateItemResponse {
    /** Results of the individual item operation */
    results?: BulkItemUpdateResult[];
    /** Metadata of the operation */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkItemUpdateResult {
    /** updated item metadata */
    itemMetadata?: ItemMetadata;
    /** only returned if operation was successful and if returnEntity flag was on */
    item?: EnterpriseMediaItem;
}
interface GetItemRequest {
    /**
     * Item id
     * @maxLength 100
     */
    itemId: string;
}
interface GetItemResponse {
    /** item info */
    item?: EnterpriseMediaItem;
}
interface LinkItemToCategoriesRequest {
    /**
     * The item id
     * @maxLength 100
     */
    itemId: string;
    /**
     * The category ids that the item will be linked to
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
interface LinkItemToCategoriesResponse {
    /**
     * The linked category ids
     * @maxLength 100
     * @maxSize 20
     */
    linkedCategoryIds?: string[] | null;
}
interface UnlinkItemFromCategoriesRequest {
    /**
     * The item id
     * @maxLength 100
     */
    itemId: string;
    /**
     * The category ids that the item will be unlinked from
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
interface UnlinkItemFromCategoriesResponse {
    /**
     * The unlinked category ids
     * @maxLength 100
     * @maxSize 20
     */
    unlinkedCategoryIds?: string[] | null;
}
interface OverwriteItemCategoriesRequest {
    /**
     * The item id
     * @maxLength 100
     */
    itemId: string;
    /**
     * The category ids the item will be linked to after this operation
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
interface OverwriteItemCategoriesResponse {
    /**
     * The linked category ids
     * @maxLength 100
     * @maxSize 20
     */
    linkedCategoryIds?: string[] | null;
    /**
     * The unlinked category ids
     * @maxLength 100
     * @maxSize 20
     */
    unlinkedCategoryIds?: string[] | null;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface EnterpriseItemCreatedEnvelope {
    entity: EnterpriseMediaItem;
    metadata: EventMetadata;
}
/**
 * Triggered when an item is created.
 * @webhook
 * @eventType wix.media.enterprise_public_media.v1.enterprise_item_created
 * @serviceIdentifier com.wix.media.enterprise_public_media.v1.EnterpriseItemsService
 * @slug created
 * @documentationMaturity preview
 */
declare function onEnterpriseItemCreated(handler: (event: EnterpriseItemCreatedEnvelope) => void | Promise<void>): void;
interface EnterpriseItemItemCategoriesChangedEnvelope {
    data: ItemCategoriesChanged;
    metadata: EventMetadata;
}
/**
 * Triggered when an is linked to a category or unlinked from a category
 * @webhook
 * @eventType wix.media.enterprise_public_media.v1.enterprise_item_item_categories_changed
 * @serviceIdentifier com.wix.media.enterprise_public_media.v1.EnterpriseItemsService
 * @slug item_categories_changed
 * @documentationMaturity preview
 */
declare function onEnterpriseItemItemCategoriesChanged(handler: (event: EnterpriseItemItemCategoriesChangedEnvelope) => void | Promise<void>): void;
interface EnterpriseItemPublishStatusChangedEnvelope {
    data: PublishStatusChanged;
    metadata: EventMetadata;
}
/**
 * Triggered when an item is Published or Unpublished
 * @webhook
 * @eventType wix.media.enterprise_public_media.v1.enterprise_item_publish_status_changed
 * @serviceIdentifier com.wix.media.enterprise_public_media.v1.EnterpriseItemsService
 * @slug publish_status_changed
 * @documentationMaturity preview
 */
declare function onEnterpriseItemPublishStatusChanged(handler: (event: EnterpriseItemPublishStatusChangedEnvelope) => void | Promise<void>): void;
interface EnterpriseItemUpdatedEnvelope {
    entity: EnterpriseMediaItem;
    metadata: EventMetadata;
}
/**
 * Triggered when an item is updated, including when an item is archived or linked to a category
 * @webhook
 * @eventType wix.media.enterprise_public_media.v1.enterprise_item_updated
 * @serviceIdentifier com.wix.media.enterprise_public_media.v1.EnterpriseItemsService
 * @slug updated
 * @documentationMaturity preview
 */
declare function onEnterpriseItemUpdated(handler: (event: EnterpriseItemUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Internal API called by the public media backend, notify about a file that was created enterprise public media server
 * @public
 * @documentationMaturity preview
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.ItemUploadCallback
 */
declare function itemUploadCallback(options?: ItemUploadCallbackOptions): Promise<ItemUploadCallbackResponse>;
interface ItemUploadCallbackOptions {
    /**
     * The item id of the created item
     * @maxLength 100
     */
    itemId?: string;
    /**
     * The callback passed to the upload endpoint
     * @maxLength 10000
     */
    callbackToken?: string;
}
/**
 * Generate an upload url that will make public media to call the enterprise callback endpoint
 * @public
 * @documentationMaturity preview
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_GENERATE_UPLOAD_URL
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.GenerateFileUploadUrl
 */
declare function generateFileUploadUrl(options?: GenerateFileUploadUrlOptions): Promise<NonNullablePaths<GenerateFileUploadUrlResponse, `uploadUrl`, 2>>;
interface GenerateFileUploadUrlOptions {
    /**
     * The uploaded original file name including the extension
     * @maxLength 1000
     */
    fileName?: string;
    /**
     * The file mime-type - will be used to identify the type of media
     * @maxLength 1000
     */
    contentType?: string;
    /** The file size in bytes */
    sizeInBytes?: number;
    /**
     * An optional list of categories to link the created item to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
}
/**
 * Import a file using a url
 * @param url - The url to the file to be imported
 * @public
 * @documentationMaturity preview
 * @requiredField url
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_IMPORT
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.ImportFile
 */
declare function importFile(url: string, options?: ImportFileOptions): Promise<NonNullablePaths<ImportFileResponse, `item._id` | `item.mediaType` | `item.assets.archive._id` | `item.assets.archive.url` | `item.assets.model3d._id` | `item.assets.model3d.url` | `item.displayTags` | `item.internalTags` | `item.systemTags` | `item.parentCategoryIds` | `item.publishStatus`, 5>>;
interface ImportFileOptions {
    /**
     * The uploaded original file name including the extension - will be used as the initial display name
     * @maxLength 1000
     */
    fileName?: string | null;
    /**
     * The file mime-type - will be used to identify the type of media
     * @maxLength 1000
     */
    contentType?: string | null;
    /** The file size in bytes */
    sizeInBytes?: number | null;
    /**
     * An optional list of categories to link the created item to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
    /** The media type of the uploaded file */
    mediaType?: MediaTypeWithLiterals;
    /**
     * A unique identifier of the client that imported the file
     * This information will exist in the system_tags field prefixed by '_external_uploader:{uploader_system_tag}'
     * @maxLength 100
     */
    uploaderSystemTag?: string | null;
    /**
     * An additional container for external information
     * mostly used to pass identifying information of related entities in external services
     * This information will exist in the system_tags field prefixed by '_external_uploader_info:{uploader_info_system_tag}'
     * @maxLength 1000
     */
    uploaderInfoSystemTag?: string | null;
}
/** @param importFileRequests - Information about the files to import.
 * @public
 * @documentationMaturity preview
 * @requiredField importFileRequests
 * @requiredField importFileRequests.url
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_IMPORT
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.BulkImportFiles
 */
declare function bulkImportFiles(importFileRequests: NonNullablePaths<ImportFileRequest, `url`, 2>[], options?: BulkImportFilesOptions): Promise<NonNullablePaths<BulkImportFilesResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item._id` | `results.${number}.item.mediaType` | `results.${number}.item.publishStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkImportFilesOptions {
    /**
     * Whether to include the imported File Descriptor in the response. Set to `false` to exclude the File Descriptor from the returned object.
     * Default: `true`
     */
    returnEntity?: boolean | null;
    /**
     * An optional list of categories to link all the items to
     * The item will be linked to the account category automatically
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[] | null;
}
interface EnterpriseMediaItemSearchSpec extends SearchSpec {
    paging: 'offset';
    wql: [
        {
            operators: ['$any'];
            fields: ['parentCategoryIds'];
            sort: 'NONE';
        },
        {
            operators: ['$eq'];
            fields: ['_createdDate', '_updatedDate', 'sizeInBytes', 'title'];
            sort: 'BOTH';
        }
    ];
}
type CommonSearchWithEntityContext = Search$1<EnterpriseMediaItem, EnterpriseMediaItemSearchSpec>;
type EnterpriseMediaItemSearch = {
    /**
    Pointer to page of results using offset. Can not be used together with 'cursor_paging'
    */
    paging?: {
        /**
      Number of items to load.
      */
        limit?: NonNullable<CommonSearchWithEntityContext['paging']>['limit'] | null;
        /**
      Number of items to skip in the current sort order.
      */
        offset?: NonNullable<CommonSearchWithEntityContext['paging']>['offset'] | null;
    };
    /**
    A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf)
    */
    filter?: CommonSearchWithEntityContext['filter'] | null;
    /**
    Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]
    @maxSize: 50
    */
    sort?: {
        /**
      Name of the field to sort by.
      */
        fieldName?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['fieldName'];
        /**
      Sort order.
      */
        order?: NonNullable<CommonSearchWithEntityContext['sort']>[number]['order'];
    }[];
    /**
    free text to match in searchable fields
    */
    search?: {
        /**
      search term or expression
      */
        expression?: NonNullable<CommonSearchWithEntityContext['search']>['expression'] | null;
    };
};
/**
 * Query items allowing to sort by specified fields, all filters only support equality
 * Each query must contain a categoryId filter
 * @public
 * @documentationMaturity preview
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_READ
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.QueryItems
 */
declare function queryItems(): ItemsQueryBuilder;
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface ItemsQueryResult extends QueryOffsetResult {
    items: EnterpriseMediaItem[];
    query: ItemsQueryBuilder;
    next: () => Promise<ItemsQueryResult>;
    prev: () => Promise<ItemsQueryResult>;
}
interface ItemsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: 'sizeInBytes' | 'title' | '_createdDate' | '_updatedDate', value: any) => ItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: 'parentCategoryIds', value: any[]) => ItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'sizeInBytes' | 'title' | '_createdDate' | '_updatedDate'>) => ItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'sizeInBytes' | 'title' | '_createdDate' | '_updatedDate'>) => ItemsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => ItemsQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results.
     * @documentationMaturity preview
     */
    skip: (skip: number) => ItemsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<ItemsQueryResult>;
}
/**
 * Update an item
 * @param _id - Id of the item in public media
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField item
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_UPDATE
 * @returns Updated item info
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.UpdateItem
 */
declare function updateItem(_id: string, item: UpdateItem): Promise<NonNullablePaths<EnterpriseMediaItem, `_id` | `mediaType` | `assets.archive._id` | `assets.archive.url` | `assets.model3d._id` | `assets.model3d.url` | `displayTags` | `internalTags` | `systemTags` | `parentCategoryIds` | `publishStatus`, 4>>;
interface UpdateItem {
    /**
     * Id of the item in public media
     * @maxLength 100
     * @readonly
     */
    _id?: string;
    /**
     * Media type of the item
     * @readonly
     */
    mediaType?: MediaTypeWithLiterals;
    /**
     * Size of the uploaded file in bytes.
     * @readonly
     * @maxLength 1000
     */
    sizeInBytes?: string | null;
    /**
     * The item title, part of searchable fields
     * @maxLength 1000
     */
    title?: string | null;
    /**
     * The aspect ratio of the item
     * An object containing urls for different views of the item
     * @readonly
     */
    assets?: ItemAssets;
    /**
     * Tags describing the image, part of searchable fields
     * @maxSize 100
     * @maxLength 100
     */
    displayTags?: string[] | null;
    /**
     * Tags for internal client use, part of searchable fields
     * @maxSize 100
     * @maxLength 100
     */
    internalTags?: string[] | null;
    /**
     * Tags for filtering items in the search
     * @maxSize 100
     * @maxLength 100
     * @readonly
     */
    systemTags?: string[] | null;
    /**
     * Category ids this item belongs to
     * @maxSize 100
     * @maxLength 100
     * @readonly
     */
    parentCategoryIds?: string[] | null;
    /** Status of the item */
    publishStatus?: PublishStatusWithLiterals;
    /**
     * Date and time the item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the item was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * An internal id used with different wix media systems
     * @maxLength 100
     * @readonly
     */
    internalId?: string | null;
}
/**
 * Bulk update an item
 * @param updateItemRequests - Requests to update individual item
 * @public
 * @documentationMaturity preview
 * @requiredField updateItemRequests
 * @requiredField updateItemRequests.item._id
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_UPDATE
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.BulkUpdateItem
 */
declare function bulkUpdateItem(updateItemRequests: NonNullablePaths<UpdateItemRequest, `item._id`, 3>[], options?: BulkUpdateItemOptions): Promise<NonNullablePaths<BulkUpdateItemResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.item._id` | `results.${number}.item.mediaType` | `results.${number}.item.publishStatus` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUpdateItemOptions {
    /** Should the response return the updated item */
    returnEntity?: boolean;
}
/**
 * Get item details
 * @param itemId - Item id
 * @public
 * @documentationMaturity preview
 * @requiredField itemId
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_READ
 * @returns item info
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.GetItem
 */
declare function getItem(itemId: string): Promise<NonNullablePaths<EnterpriseMediaItem, `_id` | `mediaType` | `assets.archive._id` | `assets.archive.url` | `assets.model3d._id` | `assets.model3d.url` | `displayTags` | `internalTags` | `systemTags` | `parentCategoryIds` | `publishStatus`, 4>>;
/**
 * Link the item to multiple categories
 * @param itemId - The item id
 * @public
 * @documentationMaturity preview
 * @requiredField itemId
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_UPDATE_CATEGORIES
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.LinkItemToCategories
 */
declare function linkItemToCategories(itemId: string, options?: LinkItemToCategoriesOptions): Promise<NonNullablePaths<LinkItemToCategoriesResponse, `linkedCategoryIds`, 2>>;
interface LinkItemToCategoriesOptions {
    /**
     * The category ids that the item will be linked to
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
/**
 * Unlink the item from multiple categories
 * @param itemId - The item id
 * @public
 * @documentationMaturity preview
 * @requiredField itemId
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_UPDATE_CATEGORIES
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.UnlinkItemFromCategories
 */
declare function unlinkItemFromCategories(itemId: string, options?: UnlinkItemFromCategoriesOptions): Promise<NonNullablePaths<UnlinkItemFromCategoriesResponse, `unlinkedCategoryIds`, 2>>;
interface UnlinkItemFromCategoriesOptions {
    /**
     * The category ids that the item will be unlinked from
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}
/**
 * Overwrite item categories
 * @param itemId - The item id
 * @public
 * @documentationMaturity preview
 * @requiredField itemId
 * @permissionId MEDIA.ENTERPRISE_MEDIA_ITEMS_UPDATE_CATEGORIES
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseItemsService.OverwriteItemCategories
 */
declare function overwriteItemCategories(itemId: string, options?: OverwriteItemCategoriesOptions): Promise<NonNullablePaths<OverwriteItemCategoriesResponse, `linkedCategoryIds` | `unlinkedCategoryIds`, 2>>;
interface OverwriteItemCategoriesOptions {
    /**
     * The category ids the item will be linked to after this operation
     * @maxLength 100
     * @maxSize 20
     */
    categoryIds?: string[];
}

export { type QueryV2 as $, type Archive as A, type BulkImportFilesOptions as B, type BulkImportFilesRequest as C, type BulkImportFilesResult as D, type EnterpriseMediaItemSearch as E, type ItemMetadata as F, type GenerateFileUploadUrlOptions as G, type ApplicationError as H, type ItemUploadCallbackOptions as I, type BulkActionMetadata as J, type SearchItemsRequest as K, type LinkItemToCategoriesOptions as L, MediaType as M, type Search as N, type OverwriteItemCategoriesOptions as O, PublishStatus as P, type SearchPagingMethodOneOf as Q, type Sorting as R, type SearchItemsResponse as S, type SearchDetails as T, type UpdateItem as U, type VideoResolution as V, WebhookIdentityType as W, type Paging as X, type PagingMetadataV2 as Y, type Cursors as Z, type QueryItemsRequest as _, type ItemUploadCallbackResponse as a, type QueryV2PagingMethodOneOf as a0, type QueryItemsResponse as a1, type UpdateItemResponse as a2, type PublishStatusChanged as a3, type BulkUpdateItemRequest as a4, type BulkItemUpdateResult as a5, type GetItemRequest as a6, type GetItemResponse as a7, type LinkItemToCategoriesRequest as a8, type UnlinkItemFromCategoriesRequest as a9, importFile as aA, bulkImportFiles as aB, queryItems as aC, updateItem as aD, bulkUpdateItem as aE, getItem as aF, linkItemToCategories as aG, unlinkItemFromCategories as aH, overwriteItemCategories as aI, type OverwriteItemCategoriesRequest as aa, type DomainEvent as ab, type DomainEventBodyOneOf as ac, type EntityCreatedEvent as ad, type RestoreInfo as ae, type EntityUpdatedEvent as af, type EntityDeletedEvent as ag, type ActionEvent as ah, type MessageEnvelope as ai, type IdentificationData as aj, type IdentificationDataIdOneOf as ak, type BaseEventMetadata as al, type EventMetadata as am, type EnterpriseMediaItemSearchSpec as an, type ItemsQueryResult as ao, type MediaTypeWithLiterals as ap, type PublishStatusWithLiterals as aq, type SortOrderWithLiterals as ar, type WebhookIdentityTypeWithLiterals as as, type CommonSearchWithEntityContext as at, onEnterpriseItemCreated as au, onEnterpriseItemItemCategoriesChanged as av, onEnterpriseItemPublishStatusChanged as aw, onEnterpriseItemUpdated as ax, itemUploadCallback as ay, generateFileUploadUrl as az, type GenerateFileUploadUrlResponse as b, type ImportFileOptions as c, type ImportFileResponse as d, type ImportFileRequest as e, type BulkImportFilesResponse as f, type ItemsQueryBuilder as g, type EnterpriseMediaItem as h, type UpdateItemRequest as i, type BulkUpdateItemOptions as j, type BulkUpdateItemResponse as k, type LinkItemToCategoriesResponse as l, type UnlinkItemFromCategoriesOptions as m, type UnlinkItemFromCategoriesResponse as n, type OverwriteItemCategoriesResponse as o, type EnterpriseItemCreatedEnvelope as p, type EnterpriseItemItemCategoriesChangedEnvelope as q, type EnterpriseItemPublishStatusChangedEnvelope as r, type EnterpriseItemUpdatedEnvelope as s, SortOrder as t, type ItemAssets as u, type ItemAssetsAssetsOneOf as v, type Model3D as w, type ItemCategoriesChanged as x, type ItemUploadCallbackRequest as y, type GenerateFileUploadUrlRequest as z };
