# Pages Configuration

## ‚ö†Ô∏è Critical Page Rules

- **Pages array must contain exactly two pages** - one collectionPage and one entityPage
- **Exactly one page must have `appMainPage: true`** to designate it as the main page
- **All page IDs referenced in relationships must exist in the configuration** - validate all `parentPageId` and `entityPageId` references
- **Bind `type` strictly to matching fields** - if `type: 'collectionPage'`, only `collectionPage` field exists (no `entityPage` field), and vice versa

## Default Generation

* **Always generate two pages**:

  * One **collectionPage** (routePath: `/`)
  * One **entityPage** (routePath: `/[segment]/:entityId`)

    * Always use `entityId` as the dynamic URL parameter, not `id`.
    * The route path **must** include a descriptive segment (e.g., `/product/:entityId`, `/pet/:entityId`)
    * **Never use just `/:entityId`** - this conflicts with the collection page route and breaks routing

## Type and Structure Binding

* If `type: 'collectionPage'`, then **only** `collectionPage` field exists (no `entityPage` field).
* If `type: 'entityPage'`, then **only** `entityPage` field exists (no `collectionPage` field).
* **No cross-mixing** allowed.

## Page Connection Configuration

### Main Page Designation

* One page must be designated as the main page using the `appMainPage` property:
  * **Exactly one page** must have `appMainPage: true`
  * When users navigate to the root path (`/`), they will be automatically redirected to this page
  * This is typically set on the collection page, but can be any page based on your application's requirements

### Collection-Entity Page Relationships

A two-way connection must be established between collection pages and entity pages:

1. **From EntityPage to CollectionPage**:
   * Each entity page must specify its parent collection page using `parentPageId`
   * This property on the entity page references the `id` of its parent collection page

2. **From CollectionPage to EntityPage**:
   * Each collection page's component must reference its corresponding entity page:
   * Inside the table or grid configuration (not directly in the collectionPage), specify `entityPageId` pointing to the entity page's `id`:
   ```json
   "components": [
     {
       "type": "Table", // or "Grid"
       "table": {       // or "grid"
         "entityPageId": "my-entity-page-id",
         // other table/grid configuration
       }
     }
   ]
   ```
   * ‚ö†Ô∏è **IMPORTANT**: The `entityPageId` field is located within the specific component configuration (table or grid), not at the collection page level

### Entity Page URL Configuration

* For entity pages (`type: "entityPage"`), the following URL configuration is **mandatory**:

  1. **Route Path Structure**:
     * The `route.path` **must** include a relative path segment followed by a dynamic parameter (e.g., `/product/:entityId` or `/pets/:entityId`)
     * **Never use just `/:entityId`** - this conflicts with the collection page route `/` and breaks routing
     * The relative path segment should be descriptive of the entity type (e.g., `/product/`, `/pet/`, `/user/`)
     * This parameter is typically named `:entityId` by convention, but any parameter name prefixed with `:` is valid

  2. **Route Parameters Mapping**:
     * The `route.params` property is required and must map the dynamic parameter:
     ```json
     "route": {
       "path": "/product/:entityId",
       "params": {
         "id": "entityId"
       }
     }
     ```
     * The `id` field in `route.params` must match the parameter name used in `route.path` (without the colon)


### Key Rules for Page Connections

* **Main Page Requirement**: Exactly one page must have `appMainPage: true`
* **Reference Validity**: All page IDs referenced in `parentPageId` and `entityPageId` must exist in the configuration
* **Relationship Consistency**: The two-way connection must be consistent - if entity page A points to collection page B, then collection page B must point to entity page A
* **Route Structure**: Entity pages must use `/[segment]/:entityId` format (e.g., `/product/:entityId` or `/pets/:entityId`), never just `/:entityId`
* **Route Parameters Configuration**: All entity pages must have both a dynamic parameter in `route.path` and a matching configuration in `route.params`

## ‚ö†Ô∏è Common Type and Route Mistakes to Avoid

- Using incorrect field types
- Missing required fields
- Including fields from wrong page type
- Missing route.params for entity pages
- Using `/:entityId` instead of `/segment/:entityId` for entity page routes (causes routing conflicts)

# Sticky Columns Configuration

## Overview

Sticky columns allow you to keep specific columns visible while users scroll horizontally through wide tables. This feature improves usability by ensuring important information (like names or IDs) remains accessible during scrolling.

## Configuration Properties

### stickyColumns

- **Type**: `number` (optional)
- **Description**: Number of columns to make sticky from the start of the table
- **Behavior**: Sticky columns are always the **first N columns** in the `columns` array
- **Default**: `undefined` (no sticky columns)

## Key Behavior Rules

### üîë **Critical Rule: Position-Based Stickiness**
- `stickyColumns: 2` means "make the **first 2 columns** sticky" (positions 0 and 1 in the `columns` array)
- The sticky columns are determined by **array position**, not by column content
- If columns are reordered, the sticky behavior follows the new order

### üîí **Important: Reorder Protection**
- To protect specific columns from being reordered away from their sticky positions, set `reorderDisabled: true` on those columns
- This allows `customColumns.enabled: true` while protecting sticky columns from being moved
- Without reorder protection, users can accidentally move intended sticky columns away from the beginning

### ‚ö†Ô∏è **Validation Rules**
- `stickyColumns` must be a positive number
- `stickyColumns` should not exceed the total number of columns
- Invalid values are ignored (treated as `undefined`)
