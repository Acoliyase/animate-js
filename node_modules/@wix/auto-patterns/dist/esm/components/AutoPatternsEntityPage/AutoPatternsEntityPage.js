import React, { useMemo, useRef } from 'react';
import { EntityPage, useEntity, useEntityPage, useEntityPageContext, MoreActions } from '@wix/patterns';
import { useForm } from '@wix/patterns/form';
import { Card, Cell, Layout } from '@wix/design-system';
import { useParams } from 'react-router-dom';
import { useSchema } from '../../providers/SchemaContext';
import { FormFieldInput } from './Fields/FormFieldInput';
import { useEntityPageHeaderTexts, useNavigation } from '../../hooks';
import { usePatternsWizardOverridesContext } from '../../providers';
import { useEntityPageMoreActions } from '../../hooks/useEntityPageMoreActions';
import { useActionsSDK } from '../../hooks/useActionsSDK';
const RenderLayoutContent = _ref => {
  var _content$container$ch, _overrides$components;
  let {
    content,
    level,
    sectionId,
    cardIndex,
    contentIndex,
    setInputRef
  } = _ref;
  const schema = useSchema();
  const overrides = usePatternsWizardOverridesContext();
  const pageState = useEntityPageContext();
  switch (content.type) {
    case 'field':
      if (!content.field.fieldId) {
        return null;
      }
      const field = schema.fields[content.field.fieldId];
      if (!field) {
        return null;
      }
      return /*#__PURE__*/React.createElement(Cell, {
        span: content.field.span
      }, /*#__PURE__*/React.createElement(FormFieldInput, {
        key: content.field.fieldId,
        field: field,
        inputRef: ref => setInputRef(content.field.fieldId, ref)
      }));
    case 'container':
      if (!((_content$container$ch = content.container.children) != null && _content$container$ch.length)) {
        return null;
      }
      return /*#__PURE__*/React.createElement(Cell, {
        span: content.container.span
      }, /*#__PURE__*/React.createElement(Layout, null, content.container.children.map((child, index) => /*#__PURE__*/React.createElement(RenderLayoutContent, {
        key: `${sectionId}-card-${cardIndex}-content-${contentIndex}-level-${level}-child-${index}`,
        content: child,
        level: level + 1,
        sectionId: sectionId,
        cardIndex: cardIndex,
        contentIndex: index,
        setInputRef: setInputRef
      }))));
    case 'component':
      if (!content.component.componentId) {
        return null;
      }
      const Component = overrides == null || (_overrides$components = overrides.components) == null ? void 0 : _overrides$components[content.component.componentId];
      if (!Component) {
        return null;
      }
      return /*#__PURE__*/React.createElement(Cell, {
        span: content.component.span
      }, /*#__PURE__*/React.createElement(Component, {
        form: pageState.form,
        entity: pageState.entity
      }));
    default:
      return null;
  }
};
const RenderLayoutCard = _ref2 => {
  var _layout$card$subtitle;
  let {
    layout,
    sectionId,
    cardIndex,
    setInputRef
  } = _ref2;
  switch (layout.type) {
    case 'card':
      return /*#__PURE__*/React.createElement(EntityPage.Card, {
        minHeight: "50px"
      }, /*#__PURE__*/React.createElement(Card.Header, {
        title: layout.card.title.text,
        subtitle: (_layout$card$subtitle = layout.card.subtitle) == null ? void 0 : _layout$card$subtitle.text
      }), /*#__PURE__*/React.createElement(Card.Divider, null), /*#__PURE__*/React.createElement(Card.Content, null, /*#__PURE__*/React.createElement(Layout, null, layout.card.children.map((child, index) => /*#__PURE__*/React.createElement(RenderLayoutContent, {
        key: `${sectionId}-card-${cardIndex}-content-${index}`,
        content: child,
        level: 0,
        sectionId: sectionId,
        cardIndex: cardIndex,
        contentIndex: index,
        setInputRef: setInputRef
      })))));
    default:
      return null;
  }
};
export const AutoPatternsEntityPage = _ref3 => {
  var _pageLayout$main, _pageLayout$sidebar;
  let {
    configuration
  } = _ref3;
  const {
    layout: pageLayout,
    parentPageId,
    route,
    moreActions,
    collectionId
  } = configuration;
  const form = useForm({
    mode: 'onChange'
  });
  const params = useParams();
  const entityId = params[route.params.id];
  const schema = useSchema();
  const isCreateMode = !entityId;
  const inputRefs = useRef({});
  const setInputRef = (id, input) => {
    inputRefs.current[id] = input;
  };
  const validate = () => {
    const invalidFieldId = Object.keys(inputRefs.current).find(fieldId => {
      var _inputRefs$current$fi;
      return (_inputRefs$current$fi = inputRefs.current[fieldId]) == null ? void 0 : _inputRefs$current$fi.invalid;
    });
    if (invalidFieldId) {
      var _inputRefs$current$in;
      (_inputRefs$current$in = inputRefs.current[invalidFieldId]) == null || _inputRefs$current$in.focus == null || _inputRefs$current$in.focus();
      throw new Error('Invalid form');
    }
  };
  const {
    getParentPagePath
  } = useNavigation();
  const parentPath = useMemo(() => getParentPagePath(parentPageId), [parentPageId, getParentPagePath]);
  const state = useEntityPage({
    parentPath,
    form,
    onSave: async () => {
      validate();
      const formValues = form.getValues();
      const baseEntity = state.entity || {};
      const updatedEntity = {
        ...baseEntity,
        ...formValues
      };
      const newEntity = entityId ? await schema.actions.update(updatedEntity) : await schema.actions.create(updatedEntity);
      return {
        updatedEntity: newEntity
      };
    },
    fetch: async () => {
      if (!entityId) {
        return {
          entity: undefined
        };
      }
      const entity = await schema.actions.get(entityId);
      return {
        entity
      };
    }
  });
  const entity = useEntity(state);
  const {
    title,
    subtitle
  } = useEntityPageHeaderTexts({
    config: configuration,
    isCreateMode,
    entityDisplayName: entity == null ? void 0 : entity[schema.displayField]
  });
  const sdk = useActionsSDK({
    collectionId
  });
  const resolvedMoreActions = useEntityPageMoreActions(moreActions, entity, sdk, form);
  return /*#__PURE__*/React.createElement(EntityPage, {
    state: state,
    dataHook: "auto-patterns-entity-page"
  }, /*#__PURE__*/React.createElement(EntityPage.Header, {
    title: title,
    subtitle: subtitle,
    moreActions: resolvedMoreActions.length > 0 ? /*#__PURE__*/React.createElement(MoreActions, {
      items: resolvedMoreActions
    }) : undefined
  }), /*#__PURE__*/React.createElement(EntityPage.Content, null, /*#__PURE__*/React.createElement(EntityPage.MainContent, {
    dataHook: "entity-page-main-content"
  }, pageLayout == null || (_pageLayout$main = pageLayout.main) == null ? void 0 : _pageLayout$main.map((layout, layoutIndex) => /*#__PURE__*/React.createElement(RenderLayoutCard, {
    key: `main-section-card-${layoutIndex}`,
    layout: layout,
    sectionId: "main",
    cardIndex: layoutIndex,
    setInputRef: setInputRef
  }))), pageLayout != null && pageLayout.sidebar ? /*#__PURE__*/React.createElement(EntityPage.AdditionalContent, null, (_pageLayout$sidebar = pageLayout.sidebar) == null ? void 0 : _pageLayout$sidebar.map((layout, layoutIndex) => /*#__PURE__*/React.createElement(RenderLayoutCard, {
    key: `sidebar-section-card-${layoutIndex}`,
    layout: layout,
    sectionId: "sidebar",
    cardIndex: layoutIndex,
    setInputRef: setInputRef
  }))) : null));
};

/*
  Key structure explanation:

  Main cards: main-section-card-{layoutIndex}
  Sidebar cards: sidebar-section-card-{layoutIndex}

  Layout content:
  {sectionId}-card-{cardIndex}-content-{contentIndex}

  Nested children:
  {sectionId}-card-{cardIndex}-content-{parentContentIndex}-level-{level}-child-{childIndex}

  This ensures uniqueness across all levels and sections.
*/
//# sourceMappingURL=AutoPatternsEntityPage.js.map