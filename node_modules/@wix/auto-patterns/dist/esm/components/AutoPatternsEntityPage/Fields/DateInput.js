import React, { useState, useRef } from 'react';
import { FormField, DatePicker } from '@wix/design-system';
import { getDateWithoutTimezone, getISODateStringWithFixedTimezone } from './utils/dates';
import { useSelector, useWixPatternsContainer, useEntityPageContext } from '@wix/patterns';
import { useController } from '@wix/patterns/form';
function validateDateField(value, validation, t, format, validationType) {
  if (validation != null && validation.required && (value === null || value === undefined || value === '')) {
    return t('cairo.fieldValidation.requiredField');
  } else if (validationType === 'formatError' && format) {
    return t('cairo.customFields.fieldType.date.invalid.value', {
      dateFormat: format
    });
  }
  return '';
}
export const DateInput = props => {
  var _pageState$entity, _field$validation;
  const {
    field,
    dataHook,
    inputRef
  } = props;
  const {
    translate: t,
    ...container
  } = useWixPatternsContainer();
  useSelector(() => container.initTask.status);
  const pageState = useEntityPageContext();
  const controller = useController({
    name: (field == null ? void 0 : field.id) ?? '',
    control: pageState.form.control,
    defaultValue: (_pageState$entity = pageState.entity) == null ? void 0 : _pageState$entity[(field == null ? void 0 : field.id) ?? ''],
    rules: {
      validate: value => {
        const error = validateDateField(value, field.validation, t);
        return error || true;
      }
    }
  });
  const [date, setDate] = useState(() => {
    if (controller.field.value) {
      return getDateWithoutTimezone(getISODateStringWithFixedTimezone(controller.field.value));
    }
    return undefined;
  });
  const ref = useRef({});
  const [errorMessage, setErrorMessage] = useState('');
  return /*#__PURE__*/React.createElement(FormField, {
    label: field.displayName,
    required: (_field$validation = field.validation) == null ? void 0 : _field$validation.required,
    dataHook: dataHook
  }, /*#__PURE__*/React.createElement(DatePicker, {
    ref: internalRef => {
      inputRef == null || inputRef(ref.current);
      // @ts-expect-error: WSR internal API hack for focusing
      ref.current.focus = () => {
        var _internalRef$state;
        return internalRef == null || (_internalRef$state = internalRef.state) == null || (_internalRef$state = _internalRef$state.inputRef) == null || _internalRef$state.focus == null ? void 0 : _internalRef$state.focus();
      };
    },
    dataHook: `date-${field.id}`,
    width: "100%",
    value: date,
    onChange: newValue => {
      setDate(newValue);
      if (newValue) {
        const formattedDate = getISODateStringWithFixedTimezone(newValue);
        controller.field.onChange(formattedDate.split('T')[0]);
      } else {
        controller.field.onChange(null);
      }
    },
    onValidate: _ref => {
      let {
        validationType,
        value: newValue,
        format
      } = _ref;
      const error = validateDateField(newValue, field.validation, t, format, validationType);
      setErrorMessage(error);
      ref.current.invalid = !!error;
      if (validationType === 'formatError' && newValue === '') {
        setDate(undefined);
        controller.field.onChange(null);
      }
    },
    status: errorMessage ? 'error' : undefined,
    statusMessage: errorMessage
  }));
};
//# sourceMappingURL=DateInput.js.map