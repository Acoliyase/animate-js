import { collections, items } from '@wix/data';
import { fetchCmsData } from './fetchCmsData';
export const CmsFieldTypeToPatternsFieldType = {
  [collections.Type.TEXT]: 'SHORT_TEXT',
  [collections.Type.DATE]: 'DATE',
  [collections.Type.DATETIME]: 'DATETIME',
  [collections.Type.NUMBER]: 'NUMBER',
  [collections.Type.BOOLEAN]: 'BOOLEAN',
  [collections.Type.URL]: 'URL',
  [collections.Type.ADDRESS]: 'SHORT_TEXT',
  [collections.Type.OBJECT]: 'LONG_TEXT',
  [collections.Type.RICH_TEXT]: 'LONG_TEXT',
  [collections.Type.RICH_CONTENT]: 'SHORT_TEXT',
  [collections.Type.ARRAY]: 'ARRAY',
  [collections.Type.ARRAY_STRING]: 'ARRAY',
  [collections.Type.REFERENCE]: 'REFERENCE',
  [collections.Type.IMAGE]: 'IMAGE'
};
export async function fetchCmsSchema(collectionId) {
  var _schema$fields$find;
  const schema = await collections.getDataCollection(collectionId);
  const transformedFields = schema.fields.reduce((acc, field) => {
    var _field$capabilities, _field$capabilities2, _field$typeMetadata;
    if (!field.key) {
      return acc;
    }
    const fieldType = field.type ? CmsFieldTypeToPatternsFieldType[field.type] || 'SHORT_TEXT' : 'SHORT_TEXT';
    const baseField = {
      id: field.key,
      displayName: field.displayName || '',
      validation: {
        numberRange: field.numberRange ? {
          min: field.numberRange.min ?? undefined,
          max: field.numberRange.max ?? undefined
        } : undefined,
        stringLengthRange: field.stringLengthRange ? {
          minLength: field.stringLengthRange.minLength ?? undefined,
          maxLength: field.stringLengthRange.maxLength ?? undefined
        } : undefined,
        required: field.required ?? false
      },
      capabilities: {
        supportedQueryOperators: ((_field$capabilities = field.capabilities) == null ? void 0 : _field$capabilities.queryOperators) || [],
        sortable: ((_field$capabilities2 = field.capabilities) == null ? void 0 : _field$capabilities2.sortable) || false
      }
    };
    if (fieldType === 'REFERENCE' && (_field$typeMetadata = field.typeMetadata) != null && (_field$typeMetadata = _field$typeMetadata.reference) != null && _field$typeMetadata.referencedCollectionId) {
      const referenceField = {
        ...baseField,
        type: 'REFERENCE',
        referenceMetadata: {
          referencedCollectionId: field.typeMetadata.reference.referencedCollectionId
        }
      };
      acc[field.key] = referenceField;
    } else {
      const nonReferenceType = fieldType === 'REFERENCE' ? 'SHORT_TEXT' : fieldType;
      const nonReferenceField = {
        ...baseField,
        type: nonReferenceType
      };
      acc[field.key] = nonReferenceField;
    }
    return acc;
  }, {});
  const schemaConfig = {
    id: collectionId,
    displayField: schema.displayField ?? '_id',
    idField: '_id',
    imageField: (_schema$fields$find = schema.fields.find(field => field.type === 'IMAGE')) == null ? void 0 : _schema$fields$find.key,
    fields: transformedFields,
    actions: {
      get: entityId => {
        return items.get(collectionId, entityId);
      },
      create: entity => {
        return items.insert(collectionId, entity);
      },
      update: entity => {
        return items.update(collectionId, entity);
      },
      delete: entityId => {
        return items.remove(collectionId, entityId);
      },
      bulkDelete: entityIds => {
        return items.bulkRemove(collectionId, entityIds);
      },
      find: async function (query, options) {
        if (options === void 0) {
          options = {};
        }
        return fetchCmsData(collectionId, query, transformedFields, options);
      }
    }
  };
  return schemaConfig;
}
//# sourceMappingURL=cmsAdapter.js.map