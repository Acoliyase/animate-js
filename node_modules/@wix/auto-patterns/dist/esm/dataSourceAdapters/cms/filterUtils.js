import { items } from '@wix/data';
import { BooleanFilters, FilterPropToOperator } from '../constants';
const FilterPropToMethod = {
  from: 'ge',
  to: 'le'
};
function isValidFilterProp(prop) {
  return prop in FilterPropToMethod;
}
function getOperatorForFilter(prop) {
  if (isValidFilterProp(prop)) {
    return FilterPropToMethod[prop];
  }
  return undefined;
}
const isSupportedOperator = (fields, filterProp, filterKey) => {
  const field = fields[filterKey];
  if (!field) {
    return false;
  }
  if (!isValidFilterProp(filterProp)) {
    return false;
  }
  const operator = FilterPropToOperator[filterProp];
  const supportedOperators = field.capabilities.supportedQueryOperators;
  return supportedOperators.includes(operator);
};
export function addFiltersToDataQuery(_ref) {
  let {
    dataQuery,
    query,
    fields,
    filterFieldMapping
  } = _ref;
  if (!filterFieldMapping) {
    return dataQuery;
  }
  let dataQueryWithFilters = dataQuery;
  const {
    filters
  } = query;
  for (const fieldKey in filters) {
    const fieldId = filterFieldMapping[fieldKey].fieldId;
    const filter = filters[fieldKey];
    if (filter) {
      if (Array.isArray(filter)) {
        var _fields$fieldId;
        const filterArray = filter;
        if (((_fields$fieldId = fields[fieldId]) == null ? void 0 : _fields$fieldId.type) === 'BOOLEAN') {
          if (filterArray.some(item => item.id === BooleanFilters.checked)) {
            dataQueryWithFilters = dataQueryWithFilters.eq(fieldId, true);
          } else {
            const falseFilter = items.filter().eq(fieldId, false);
            const undefinedFilter = items.filter().eq(fieldId, undefined);
            dataQueryWithFilters = dataQueryWithFilters.and(falseFilter.or(undefinedFilter));
          }
        } else {
          dataQueryWithFilters = dataQueryWithFilters.hasSome(fieldId, filterArray.map(item => item.id));
        }
      } else if (typeof filter === 'object') {
        const filterObj = filter;
        for (const filterProp in filterObj) {
          const operator = getOperatorForFilter(filterProp);
          if (operator && typeof dataQuery[operator] === 'function' && isSupportedOperator(fields, filterProp, fieldId)) {
            const value = filterObj[filterProp];
            if (value !== undefined && value !== null) {
              dataQueryWithFilters = dataQueryWithFilters[operator](fieldId, value);
            }
          }
        }
      }
    }
  }
  return dataQueryWithFilters;
}
const TEXT_FIELD_TYPES = ['LONG_TEXT', 'SHORT_TEXT'];
export function addSearchToDataQuery(_ref2) {
  let {
    dataQuery,
    query,
    fields,
    searchableFieldIds
  } = _ref2;
  const searchableFields = Object.keys(fields).filter(fieldId => {
    const field = fields[fieldId];
    const isFieldSearchable = searchableFieldIds.includes(fieldId);
    return isFieldSearchable && field && TEXT_FIELD_TYPES.includes(field.type);
  });
  if (query.search && searchableFields.length > 0) {
    let searchFilter = null;
    searchableFields.forEach(field => {
      const currentFilter = items.filter().contains(field, query.search);
      searchFilter = searchFilter ? searchFilter.or(currentFilter) : currentFilter;
    });
    if (searchFilter) {
      dataQuery = dataQuery.and(searchFilter);
    }
  }
  return dataQuery;
}
//# sourceMappingURL=filterUtils.js.map