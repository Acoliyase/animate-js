import React, { createContext, useContext, useEffect, useState } from 'react';
import { getSchema } from '../dataSourceAdapters/factory';
import { useSchemaRegistry } from './SchemaRegistryContext';
import { usePatternsWizardOverridesContext } from './PatternsWizardOverridesContext';
import { useWixPatternsContainer } from '@wix/patterns';
const SchemaContext = /*#__PURE__*/createContext(null);
export const SchemaProvider = _ref => {
  var _collection$custom;
  let {
    collection,
    children,
    skeleton
  } = _ref;
  const {
    collectionId,
    entityTypeSource
  } = collection;
  const customDataSourceId = collection.entityTypeSource === 'custom' && 'custom' in collection ? (_collection$custom = collection.custom) == null ? void 0 : _collection$custom.id : undefined;
  const {
    getSchema: getSchemaFromRegistry,
    addSchema: addSchemaToRegistry
  } = useSchemaRegistry();
  const [schema, setSchema] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const overrides = usePatternsWizardOverridesContext();
  const {
    httpClient
  } = useWixPatternsContainer();
  useEffect(() => {
    const fetchSchemaForCollection = async (targetCollectionId, targetCustomDataSourceId) => {
      if (entityTypeSource === 'custom' && targetCustomDataSourceId && overrides != null && overrides.customDataSources) {
        const customSchemaProvider = overrides.customDataSources[targetCustomDataSourceId];
        if (customSchemaProvider) {
          return customSchemaProvider(targetCollectionId, {
            httpClient
          });
        }
        throw new Error(`Custom schema provider '${targetCustomDataSourceId}' not found`);
      }
      return getSchema(targetCollectionId, entityTypeSource);
    };
    const fetchReferencedSchemas = async referencedSchema => {
      const referencedCollectionIds = new Set();
      Object.values(referencedSchema.fields).forEach(field => {
        if (field && field.type === 'REFERENCE' && field.referenceMetadata) {
          const {
            referencedCollectionId
          } = field.referenceMetadata;
          if (referencedCollectionId && !getSchemaFromRegistry(referencedCollectionId)) {
            referencedCollectionIds.add(referencedCollectionId);
          }
        }
      });
      if (referencedCollectionIds.size === 0) {
        return;
      }
      const fetchPromises = Array.from(referencedCollectionIds).map(async refCollectionId => {
        try {
          const refSchema = await fetchSchemaForCollection(refCollectionId);
          addSchemaToRegistry(refCollectionId, refSchema);
          await fetchReferencedSchemas(refSchema);
        } catch (error) {
          console.error(`Error fetching referenced schema ${refCollectionId}:`, error);
        }
      });
      await Promise.all(fetchPromises);
    };
    const cachedSchema = getSchemaFromRegistry(collectionId);
    if (cachedSchema) {
      setSchema(cachedSchema);
      return;
    }
    setIsLoading(true);
    fetchSchemaForCollection(collectionId, customDataSourceId).then(async fetchedSchema => {
      setSchema(fetchedSchema);
      addSchemaToRegistry(collectionId, fetchedSchema);
      await fetchReferencedSchemas(fetchedSchema);
    }).catch(error => {
      console.error('Error fetching schema config:', error);
    }).finally(() => {
      setIsLoading(false);
    });
  }, [collectionId, entityTypeSource, customDataSourceId, addSchemaToRegistry, getSchemaFromRegistry, overrides, httpClient]);
  if (!schema || isLoading) {
    return skeleton;
  }
  return /*#__PURE__*/React.createElement(SchemaContext.Provider, {
    value: schema
  }, children);
};
export const useSchema = () => {
  const context = useContext(SchemaContext);
  if (!context) {
    throw new Error('useSchema must be used within a SchemaProvider');
  }
  return context;
};
//# sourceMappingURL=SchemaContext.js.map