import { useCallback } from 'react';
import { useActionsSDK } from './useActionsSDK';
import { updateAction, customAction, resolveAction, deleteAction } from '../utils/actions';
const cleanupActionsWithDividers = (actions, inlineCount) => {
  const clean = a => a.filter((x, i, ar) => {
    var _ar;
    return (x == null ? void 0 : x.divider) !== true || i > 0 && i < ar.length - 1 && ((_ar = ar[i - 1]) == null ? void 0 : _ar.divider) !== true;
  });
  return !(actions != null && actions.length) || !inlineCount || inlineCount >= actions.length ? clean(actions || []) : [...clean(actions.slice(0, inlineCount)), ...clean(actions.slice(inlineCount))];
};
export const useActionCell = _ref => {
  let {
    config,
    collectionId
  } = _ref;
  const sdk = useActionsSDK({
    collectionId
  });
  const buildCellActions = useCallback((item, index, api) => {
    var _config$primaryAction, _config$secondaryActi, _config$secondaryActi2, _config$secondaryActi3, _config$secondaryActi4;
    const buildAction = actionConfig => {
      if (actionConfig.type === 'divider') {
        return {
          divider: true
        };
      }
      let actionToResolve = null;
      const baseParams = {
        actionParams: {
          item,
          index,
          api
        },
        sdk
      };
      switch (actionConfig.type) {
        case 'update':
          actionToResolve = updateAction({
            action: actionConfig,
            ...baseParams
          });
          break;
        case 'delete':
          actionToResolve = deleteAction({
            action: actionConfig,
            ...baseParams
          });
          break;
        case 'custom':
          actionToResolve = customAction({
            action: actionConfig,
            ...baseParams
          });
          break;
        default:
          return null;
      }
      if (!actionToResolve) {
        return null;
      }
      const resolvedAction = resolveAction(actionConfig, actionToResolve);
      const {
        label,
        tooltip,
        ...resolvedActionProps
      } = resolvedAction;
      return {
        ...resolvedActionProps,
        text: resolvedAction.label,
        disabledDescription: resolvedAction.tooltip
      };
    };
    const primaryAction = config != null && (_config$primaryAction = config.primaryAction) != null && _config$primaryAction.item ? buildAction(config.primaryAction.item) : undefined;
    const rawSecondaryActions = config != null && (_config$secondaryActi = config.secondaryActions) != null && _config$secondaryActi.items.length ? config.secondaryActions.items.map(buildAction).filter(Boolean) : [];

    // Process secondary actions with inline count consideration
    const secondaryActions = cleanupActionsWithDividers(rawSecondaryActions, config == null || (_config$secondaryActi2 = config.secondaryActions) == null ? void 0 : _config$secondaryActi2.inlineCount);
    const numOfVisibleSecondaryActions = config == null || (_config$secondaryActi3 = config.secondaryActions) == null ? void 0 : _config$secondaryActi3.inlineCount;
    const alwaysShowSecondaryActions = config == null || (_config$secondaryActi4 = config.secondaryActions) == null ? void 0 : _config$secondaryActi4.inlineAlwaysVisible;
    if (!primaryAction && !secondaryActions.length) {
      return {};
    }
    return {
      ...(primaryAction ? {
        primaryAction
      } : {
        primaryAction: undefined
      }),
      ...(secondaryActions.length && {
        secondaryActions
      }),
      numOfVisibleSecondaryActions,
      alwaysShowSecondaryActions
    };
  }, [config, sdk]);
  return buildCellActions;
};
//# sourceMappingURL=useActionCell.js.map