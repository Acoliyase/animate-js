import React from 'react';
import { usePatternsWizardOverridesContext, useSchema, useSchemaRegistry } from '../providers';
import { camelCase, get } from 'lodash';
import { Avatar, Box, Image } from '@wix/design-system';
import { getImageUrl } from '../utils/media/getImageUrl';
export const useColumns = columns => {
  const {
    fields
  } = useSchema();
  const {
    getSchema
  } = useSchemaRegistry();
  const overrides = usePatternsWizardOverridesContext();
  const existingColumns = columns.filter(column => {
    var _overrides$columns;
    return !!fields[column.id] || (overrides == null || (_overrides$columns = overrides.columns) == null ? void 0 : _overrides$columns[column.id]);
  });
  const createRenderer = (fieldDefinition, itemValue) => {
    if (itemValue == null) {
      return '';
    }
    switch (fieldDefinition.type) {
      case 'BOOLEAN':
        return itemValue ? '✔' : '✖';
      case 'DATE':
        if (itemValue instanceof Date) {
          return itemValue.toLocaleDateString();
        }
        if (typeof itemValue === 'string') {
          const date = new Date(itemValue);
          return date.toLocaleDateString();
        }
        return itemValue;
      case 'DATETIME':
        if (itemValue instanceof Date) {
          return itemValue.toLocaleString();
        }
        if (typeof itemValue === 'string') {
          const date = new Date(itemValue);
          return date.toLocaleString();
        }
        return itemValue;
      case 'ARRAY':
        // We assume that the array contains strings
        // If the array contains objects, we need to handle it differently
        return itemValue.join(', ');
      case 'REFERENCE':
        if (fieldDefinition.referenceMetadata && getSchema) {
          const {
            referencedCollectionId
          } = fieldDefinition.referenceMetadata;
          const refSchema = getSchema(referencedCollectionId);
          if (refSchema) {
            let nameValue;
            let imageValue;
            const displayField = refSchema.displayField;
            if (typeof itemValue === 'object' && itemValue !== null) {
              nameValue = itemValue[displayField] || '';
              imageValue = refSchema.imageField && itemValue[refSchema.imageField];
            }
            const imageUrl = imageValue && getImageUrl(imageValue);
            return /*#__PURE__*/React.createElement(Box, {
              gap: "SP2",
              verticalAlign: "middle"
            }, imageUrl && /*#__PURE__*/React.createElement(Avatar, {
              size: "size24",
              name: nameValue,
              imgProps: {
                src: imageUrl
              }
            }), /*#__PURE__*/React.createElement("div", null, nameValue));
          }
        }
        return itemValue;
      case 'IMAGE':
        const imageUrl = getImageUrl(itemValue);
        return /*#__PURE__*/React.createElement(Image, {
          src: imageUrl,
          width: "48px",
          dataHook: "auto-patterns-image"
        });
      default:
        return itemValue;
    }
  };
  return existingColumns.map(column => {
    var _overrides$columns2, _fieldDefinition$capa;
    const fieldDefinition = fields[column.id];
    if (!fieldDefinition && !(overrides != null && (_overrides$columns2 = overrides.columns) != null && _overrides$columns2[column.id])) {
      return null;
    }
    const sortable = column.sortable && (fieldDefinition == null || (_fieldDefinition$capa = fieldDefinition.capabilities) == null ? void 0 : _fieldDefinition$capa.sortable);
    const baseColumnConfig = {
      id: column.id,
      title: column.name || (fieldDefinition == null ? void 0 : fieldDefinition.displayName),
      width: column.width,
      ...createSortConfiguration(column, sortable),
      ...createCustomColumnConfiguration(column),
      render: row => {
        var _overrides$columns3;
        const itemValue = get(row, column.id);
        if (overrides != null && (_overrides$columns3 = overrides.columns) != null && _overrides$columns3[camelCase(column.id)]) {
          var _overrides$columns4, _overrides$columns4$c;
          return overrides == null || (_overrides$columns4 = overrides.columns) == null || (_overrides$columns4$c = _overrides$columns4[camelCase(column.id)]) == null ? void 0 : _overrides$columns4$c.call(_overrides$columns4, {
            value: itemValue,
            row
          });
        }
        if (fieldDefinition) {
          return createRenderer(fieldDefinition, itemValue);
        }
        return null; // Shouldn't really happen
      }
    };
    return baseColumnConfig;
  }).filter(Boolean);
};
const createSortConfiguration = (column, sortable) => {
  if (!sortable) {
    return {};
  }
  const sortableColumnConfig = {
    sortable,
    defaultSortOrder: column.defaultSortOrder
  };

  // default sort mode is ['asc', 'desc', undefined]
  // so if sort mode is 'desc' -> we want to override the default
  // and set it to ['desc', 'asc', undefined]
  if (column.sortMode && column.sortMode === 'desc') {
    return {
      ...sortableColumnConfig,
      sortMode: ['desc', 'asc', undefined]
    };
  }
  return {
    ...sortableColumnConfig
  };
};
const createCustomColumnConfiguration = column => {
  const reorderDisabled = !!column.reorderDisabled;
  if (column.hiddenFromCustomColumnsSelection) {
    return {
      hiddenFromCustomColumnsSelection: true
    };
  }
  if (column.hideable === false) {
    return {
      hideable: false,
      reorderDisabled
    };
  }
  return {
    defaultHidden: !!column.defaultHidden,
    reorderDisabled
  };
};
//# sourceMappingURL=useColumns.js.map