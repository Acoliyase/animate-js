"use strict";

exports.__esModule = true;
exports.useSchema = exports.SchemaProvider = void 0;
var _react = _interopRequireWildcard(require("react"));
var _factory = require("../dataSourceAdapters/factory");
var _SchemaRegistryContext = require("./SchemaRegistryContext");
var _PatternsWizardOverridesContext = require("./PatternsWizardOverridesContext");
var _patterns = require("@wix/patterns");
var _jsxFileName = "/home/builduser/work/73d19ce3378ce4dd/packages/auto-patterns/dist/cjs/providers/SchemaContext.tsx";
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const SchemaContext = /*#__PURE__*/(0, _react.createContext)(null);
const SchemaProvider = ({
  collection,
  children,
  skeleton
}) => {
  var _collection$custom;
  const {
    collectionId,
    entityTypeSource
  } = collection;
  const customDataSourceId = collection.entityTypeSource === 'custom' && 'custom' in collection ? (_collection$custom = collection.custom) == null ? void 0 : _collection$custom.id : undefined;
  const {
    getSchema: getSchemaFromRegistry,
    addSchema: addSchemaToRegistry
  } = (0, _SchemaRegistryContext.useSchemaRegistry)();
  const [schema, setSchema] = (0, _react.useState)(null);
  const [isLoading, setIsLoading] = (0, _react.useState)(false);
  const overrides = (0, _PatternsWizardOverridesContext.usePatternsWizardOverridesContext)();
  const {
    httpClient
  } = (0, _patterns.useWixPatternsContainer)();
  (0, _react.useEffect)(() => {
    const fetchSchemaForCollection = async (targetCollectionId, targetCustomDataSourceId) => {
      if (entityTypeSource === 'custom' && targetCustomDataSourceId && overrides != null && overrides.customDataSources) {
        const customSchemaProvider = overrides.customDataSources[targetCustomDataSourceId];
        if (customSchemaProvider) {
          return customSchemaProvider(targetCollectionId, {
            httpClient
          });
        }
        throw new Error(`Custom schema provider '${targetCustomDataSourceId}' not found`);
      }
      return (0, _factory.getSchema)(targetCollectionId, entityTypeSource);
    };
    const fetchReferencedSchemas = async referencedSchema => {
      const referencedCollectionIds = new Set();
      Object.values(referencedSchema.fields).forEach(field => {
        if (field && field.type === 'REFERENCE' && field.referenceMetadata) {
          const {
            referencedCollectionId
          } = field.referenceMetadata;
          if (referencedCollectionId && !getSchemaFromRegistry(referencedCollectionId)) {
            referencedCollectionIds.add(referencedCollectionId);
          }
        }
      });
      if (referencedCollectionIds.size === 0) {
        return;
      }
      const fetchPromises = Array.from(referencedCollectionIds).map(async refCollectionId => {
        try {
          const refSchema = await fetchSchemaForCollection(refCollectionId);
          addSchemaToRegistry(refCollectionId, refSchema);
          await fetchReferencedSchemas(refSchema);
        } catch (error) {
          console.error(`Error fetching referenced schema ${refCollectionId}:`, error);
        }
      });
      await Promise.all(fetchPromises);
    };
    const cachedSchema = getSchemaFromRegistry(collectionId);
    if (cachedSchema) {
      setSchema(cachedSchema);
      return;
    }
    setIsLoading(true);
    fetchSchemaForCollection(collectionId, customDataSourceId).then(async fetchedSchema => {
      setSchema(fetchedSchema);
      addSchemaToRegistry(collectionId, fetchedSchema);
      await fetchReferencedSchemas(fetchedSchema);
    }).catch(error => {
      console.error('Error fetching schema config:', error);
    }).finally(() => {
      setIsLoading(false);
    });
  }, [collectionId, entityTypeSource, customDataSourceId, addSchemaToRegistry, getSchemaFromRegistry, overrides, httpClient]);
  if (!schema || isLoading) {
    return skeleton;
  }
  return /*#__PURE__*/_react.default.createElement(SchemaContext.Provider, {
    value: schema,
    __self: void 0,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 135,
      columnNumber: 5
    }
  }, children);
};
exports.SchemaProvider = SchemaProvider;
const useSchema = () => {
  const context = (0, _react.useContext)(SchemaContext);
  if (!context) {
    throw new Error('useSchema must be used within a SchemaProvider');
  }
  return context;
};
exports.useSchema = useSchema;
//# sourceMappingURL=SchemaContext.js.map