"use strict";

exports.__esModule = true;
exports.DateInput = void 0;
var _react = _interopRequireWildcard(require("react"));
var _designSystem = require("@wix/design-system");
var _dates = require("./utils/dates");
var _patterns = require("@wix/patterns");
var _form = require("@wix/patterns/form");
var _jsxFileName = "/home/builduser/work/73d19ce3378ce4dd/packages/auto-patterns/dist/cjs/components/AutoPatternsEntityPage/Fields/DateInput.tsx";
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function validateDateField(value, validation, t, format, validationType) {
  if (validation != null && validation.required && (value === null || value === undefined || value === '')) {
    return t('cairo.fieldValidation.requiredField');
  } else if (validationType === 'formatError' && format) {
    return t('cairo.customFields.fieldType.date.invalid.value', {
      dateFormat: format
    });
  }
  return '';
}
const DateInput = props => {
  var _pageState$entity, _field$validation;
  const {
    field,
    dataHook,
    inputRef
  } = props;
  const {
    translate: t,
    ...container
  } = (0, _patterns.useWixPatternsContainer)();
  (0, _patterns.useSelector)(() => container.initTask.status);
  const pageState = (0, _patterns.useEntityPageContext)();
  const controller = (0, _form.useController)({
    name: (field == null ? void 0 : field.id) ?? '',
    control: pageState.form.control,
    defaultValue: (_pageState$entity = pageState.entity) == null ? void 0 : _pageState$entity[(field == null ? void 0 : field.id) ?? ''],
    rules: {
      validate: value => {
        const error = validateDateField(value, field.validation, t);
        return error || true;
      }
    }
  });
  const [date, setDate] = (0, _react.useState)(() => {
    if (controller.field.value) {
      return (0, _dates.getDateWithoutTimezone)((0, _dates.getISODateStringWithFixedTimezone)(controller.field.value));
    }
    return undefined;
  });
  const ref = (0, _react.useRef)({});
  const [errorMessage, setErrorMessage] = (0, _react.useState)('');
  return /*#__PURE__*/_react.default.createElement(_designSystem.FormField, {
    label: field.displayName,
    required: (_field$validation = field.validation) == null ? void 0 : _field$validation.required,
    dataHook: dataHook,
    __self: void 0,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 5
    }
  }, /*#__PURE__*/_react.default.createElement(_designSystem.DatePicker, {
    ref: internalRef => {
      inputRef == null || inputRef(ref.current);
      // @ts-expect-error: WSR internal API hack for focusing
      ref.current.focus = () => {
        var _internalRef$state;
        return internalRef == null || (_internalRef$state = internalRef.state) == null || (_internalRef$state = _internalRef$state.inputRef) == null || _internalRef$state.focus == null ? void 0 : _internalRef$state.focus();
      };
    },
    dataHook: `date-${field.id}`,
    width: "100%",
    value: date,
    onChange: newValue => {
      setDate(newValue);
      if (newValue) {
        const formattedDate = (0, _dates.getISODateStringWithFixedTimezone)(newValue);
        controller.field.onChange(formattedDate.split('T')[0]);
      } else {
        controller.field.onChange(null);
      }
    },
    onValidate: ({
      validationType,
      value: newValue,
      format
    }) => {
      const error = validateDateField(newValue, field.validation, t, format, validationType);
      setErrorMessage(error);
      ref.current.invalid = !!error;
      if (validationType === 'formatError' && newValue === '') {
        setDate(undefined);
        controller.field.onChange(null);
      }
    },
    status: errorMessage ? 'error' : undefined,
    statusMessage: errorMessage,
    __self: void 0,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 75,
      columnNumber: 7
    }
  }));
};
exports.DateInput = DateInput;
//# sourceMappingURL=DateInput.js.map