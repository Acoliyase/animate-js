"use strict";

exports.__esModule = true;
exports.useActionCell = void 0;
var _react = require("react");
var _useActionsSDK = require("./useActionsSDK");
var _actions = require("../utils/actions");
const cleanupActionsWithDividers = (actions, inlineCount) => {
  const clean = a => a.filter((x, i, ar) => {
    var _ar;
    return (x == null ? void 0 : x.divider) !== true || i > 0 && i < ar.length - 1 && ((_ar = ar[i - 1]) == null ? void 0 : _ar.divider) !== true;
  });
  return !(actions != null && actions.length) || !inlineCount || inlineCount >= actions.length ? clean(actions || []) : [...clean(actions.slice(0, inlineCount)), ...clean(actions.slice(inlineCount))];
};
const useActionCell = ({
  config,
  collectionId
}) => {
  const sdk = (0, _useActionsSDK.useActionsSDK)({
    collectionId
  });
  const buildCellActions = (0, _react.useCallback)((item, index, api) => {
    var _config$primaryAction, _config$secondaryActi, _config$secondaryActi2, _config$secondaryActi3, _config$secondaryActi4;
    const buildAction = actionConfig => {
      if (actionConfig.type === 'divider') {
        return {
          divider: true
        };
      }
      let actionToResolve = null;
      const baseParams = {
        actionParams: {
          item,
          index,
          api
        },
        sdk
      };
      switch (actionConfig.type) {
        case 'update':
          actionToResolve = (0, _actions.updateAction)({
            action: actionConfig,
            ...baseParams
          });
          break;
        case 'delete':
          actionToResolve = (0, _actions.deleteAction)({
            action: actionConfig,
            ...baseParams
          });
          break;
        case 'custom':
          actionToResolve = (0, _actions.customAction)({
            action: actionConfig,
            ...baseParams
          });
          break;
        default:
          return null;
      }
      if (!actionToResolve) {
        return null;
      }
      const resolvedAction = (0, _actions.resolveAction)(actionConfig, actionToResolve);
      const {
        label,
        tooltip,
        ...resolvedActionProps
      } = resolvedAction;
      return {
        ...resolvedActionProps,
        text: resolvedAction.label,
        disabledDescription: resolvedAction.tooltip
      };
    };
    const primaryAction = config != null && (_config$primaryAction = config.primaryAction) != null && _config$primaryAction.item ? buildAction(config.primaryAction.item) : undefined;
    const rawSecondaryActions = config != null && (_config$secondaryActi = config.secondaryActions) != null && _config$secondaryActi.items.length ? config.secondaryActions.items.map(buildAction).filter(Boolean) : [];

    // Process secondary actions with inline count consideration
    const secondaryActions = cleanupActionsWithDividers(rawSecondaryActions, config == null || (_config$secondaryActi2 = config.secondaryActions) == null ? void 0 : _config$secondaryActi2.inlineCount);
    const numOfVisibleSecondaryActions = config == null || (_config$secondaryActi3 = config.secondaryActions) == null ? void 0 : _config$secondaryActi3.inlineCount;
    const alwaysShowSecondaryActions = config == null || (_config$secondaryActi4 = config.secondaryActions) == null ? void 0 : _config$secondaryActi4.inlineAlwaysVisible;
    if (!primaryAction && !secondaryActions.length) {
      return {};
    }
    return {
      ...(primaryAction ? {
        primaryAction
      } : {
        primaryAction: undefined
      }),
      ...(secondaryActions.length && {
        secondaryActions
      }),
      numOfVisibleSecondaryActions,
      alwaysShowSecondaryActions
    };
  }, [config, sdk]);
  return buildCellActions;
};
exports.useActionCell = useActionCell;
//# sourceMappingURL=useActionCell.js.map