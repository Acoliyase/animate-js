import { NonNullablePaths } from '@wix/sdk-types';

/** An index is a map of a collection's data, organized according to specific fields to increase query speed. */
interface Index {
    /**
     * ID of the index.
     * @readonly
     * @format GUID
     */
    _id?: string;
    /**
     * Name of the index.
     * @minLength 1
     * @maxLength 128
     */
    name?: string;
    /**
     * Fields for which the index is defined.
     *
     * Max: 3 fields (for a unique index: 1 field)
     * @minSize 1
     * @maxSize 3
     */
    fields?: Field[];
    /**
     * Current status of the index.
     * @readonly
     */
    status?: StatusWithLiterals;
    /**
     * Contains details about the reasons for failure when `status` is `FAILED`.
     * @readonly
     */
    failure?: Failure;
    /**
     * Whether the index enforces uniqueness of values in the field for which it's defined.
     * If `true`, the index can have only 1 field.
     *
     * Default: `false`
     */
    unique?: boolean;
    /**
     * Whether the index ignores case.
     *
     * Default: `false`
     */
    caseInsensitive?: boolean;
    /**
     * Source of the index. See index sources in [Index Types](https://dev.wix.com/docs/api-reference/business-solutions/cms/indexes/index-types#index-sources).
     *
     * Default: `USER`
     */
    source?: IndexSourceWithLiterals;
}
/**
 * Order determines how values are ordered in the index. This is important when
 * ordering and/or range querying by indexed fields.
 */
declare enum Order {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type OrderWithLiterals = Order | 'ASC' | 'DESC';
interface Field {
    /**
     * Path of the field to index. For example: `title` or `options.price`.
     * @minLength 1
     * @maxLength 128
     */
    path?: string;
    /**
     * Sort order for the index. Base on how the data is regularly queried.
     *
     * Default: `ASC`
     */
    order?: OrderWithLiterals;
}
declare enum Status {
    /** Place holder. Never returned by the service. */
    UNKNOWN = "UNKNOWN",
    /** Index creation is in progress. */
    BUILDING = "BUILDING",
    /** Index has been successfully created and can be used in queries. */
    ACTIVE = "ACTIVE",
    /** Index is in the process of being dropped. */
    DROPPING = "DROPPING",
    /** Index has been dropped successfully. */
    DROPPED = "DROPPED",
    /** Index creation has failed. */
    FAILED = "FAILED",
    /** Index contains incorrectly indexed data. */
    INVALID = "INVALID"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNKNOWN' | 'BUILDING' | 'ACTIVE' | 'DROPPING' | 'DROPPED' | 'FAILED' | 'INVALID';
interface Failure {
    /**
     * Error code.
     * - `WDE0112`: Unknown error while building collection index.
     * - `WDE0113`: Duplicate key error while building collection index.
     * - `WDE0114`: Document too large while building collection index.
     * @maxLength 7
     */
    code?: string;
    /**
     * Description of the failure.
     * @maxLength 1024
     */
    description?: string;
    /**
     * ID of the data item that caused the failure.
     * For example, if `unique` is `true`, the ID of an item containing a duplicate value.
     * @maxLength 16000
     */
    itemId?: string | null;
}
declare enum IndexSource {
    /** Place holder. Never returned by the service. */
    UNKNOWN_INDEX_SOURCE = "UNKNOWN_INDEX_SOURCE",
    /**
     * Automatically created by Wix for all collections.
     *
     * System indexes are created for essential attributes, such as ID and creation date.
     * You can't delete them and they don't count towards the index limit.
     */
    SYSTEM = "SYSTEM",
    /** Created by a Wix user via the API or in the dashboard. */
    USER = "USER",
    /**
     * Created automatically by Wix based on a Wix user's queries.
     *
     * For large collections, Wix identifies slow-running queries and creates indexes automatically to improve performance.
     * These indexes don't count towards the index limit. They're created dynamically, and may be deleted if they no longer fit
     * the system's parameters. To keep an automatic index permanently, manually create an identical `USER` index.
     */
    AUTO = "AUTO"
}
/** @enumType */
type IndexSourceWithLiterals = IndexSource | 'UNKNOWN_INDEX_SOURCE' | 'SYSTEM' | 'USER' | 'AUTO';
interface CreateIndexRequest {
    /** Details of the index to be created. */
    index: Index;
    /**
     * ID of the data collection for which to generate the index.
     * @maxLength 256
     */
    dataCollectionId: string;
}
declare enum Environment {
    /** Place holder. Never returned by the service. */
    UNKNOWN_ENVIRONMENT = "UNKNOWN_ENVIRONMENT",
    /** Collection [sandbox environment](https://support.wix.com/en/article/cms-about-sandbox-and-live-collections-and-syncing#sandbox-collections). */
    SANDBOX = "SANDBOX",
    /** If the [collection's sandbox environment is enabled](https://support.wix.com/en/article/cms-accessing-and-syncing-your-sandbox-and-live-collections#enabling-sandbox-collections), run the task in the collection's sandbox environment. If not, run the task in the collection's live environment. */
    SANDBOX_PREFERRED = "SANDBOX_PREFERRED",
    /** Collection [live environment](https://support.wix.com/en/article/cms-about-sandbox-and-live-collections-and-syncing#live-collections). */
    LIVE = "LIVE"
}
/** @enumType */
type EnvironmentWithLiterals = Environment | 'UNKNOWN_ENVIRONMENT' | 'SANDBOX' | 'SANDBOX_PREFERRED' | 'LIVE';
interface CreateIndexResponse {
    /** Details of the index being generated. */
    index?: Index;
}
interface DropIndexRequest {
    /**
     * Name of the index to drop.
     * @minLength 1
     * @maxLength 128
     */
    indexName: string;
    /**
     * ID of the data collection for which the index to be dropped is defined.
     * @maxLength 1024
     */
    dataCollectionId: string;
}
interface DropIndexResponse {
}
interface ListIndexesRequest {
    /**
     * ID of the data collection for which to list indexes.
     * @maxLength 1024
     */
    dataCollectionId: string;
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface ListIndexesResponse {
    /** List of all indexes for the requested data collection. */
    indexes?: Index[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadata;
}
interface PagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
}
interface ListAvailableIndexesRequest {
    /**
     * Data collection to show available indexes for
     * @maxLength 256
     */
    dataCollectionId: string;
}
interface ListAvailableIndexesResponse {
    /**
     * limit of regular single-field indexes, even if 0 1-field indices may be created using
     * 3-field quota (if available)
     */
    regular1Field?: number;
    /** limit of regular indexes up to 3-fields (in addition to 1-field indexes quota) */
    regular3Field?: number;
    /** limit of unique indexes */
    unique1Field?: number;
    /** Overall index limit, missing value means there's no overall limit */
    total?: number | null;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface IndexCreatedEnvelope {
    entity: Index;
    metadata: EventMetadata;
}
/**
 * Triggered when an index is created.
 * @permissionScope Manage Data Indexes
 * @permissionScopeId SCOPE.DC-DATA.INDEXES-MANAGE
 * @permissionId WIX_DATA.LIST_INDEXES
 * @webhook
 * @eventType wix.data.v2.index_created
 * @slug created
 * @documentationMaturity preview
 */
declare function onIndexCreated(handler: (event: IndexCreatedEnvelope) => void | Promise<void>): void;
interface IndexDeletedEnvelope {
    metadata: EventMetadata;
}
/**
 * Triggered when an index is dropped.
 * @permissionScope Manage Data Indexes
 * @permissionScopeId SCOPE.DC-DATA.INDEXES-MANAGE
 * @permissionId WIX_DATA.LIST_INDEXES
 * @webhook
 * @eventType wix.data.v2.index_deleted
 * @slug deleted
 * @documentationMaturity preview
 */
declare function onIndexDeleted(handler: (event: IndexDeletedEnvelope) => void | Promise<void>): void;
interface IndexUpdatedEnvelope {
    entity: Index;
    metadata: EventMetadata;
}
/**
 * Triggered when an index's status field is updated.
 *
 * For example, during index creation, the index's status transitions from `BUILDING` to `ACTIVE` or `FAILED`. Either transition triggers this event.
 * @permissionScope Manage Data Indexes
 * @permissionScopeId SCOPE.DC-DATA.INDEXES-MANAGE
 * @permissionId WIX_DATA.LIST_INDEXES
 * @webhook
 * @eventType wix.data.v2.index_updated
 * @slug updated
 * @documentationMaturity preview
 */
declare function onIndexUpdated(handler: (event: IndexUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates an index for a data collection.
 *
 * The index can't be used immediately, as the process of generating the index takes time.
 * You can check whether an index is ready by calling List Indexes.
 *
 * Note that when an index fails to create, the failed index still occupies a slot.
 * To remove the failed index and free up the slot for a new index, call Drop Index.
 * @param dataCollectionId - ID of the data collection for which to generate the index.
 * @param index - Details of the index to be created.
 * @public
 * @requiredField dataCollectionId
 * @requiredField index
 * @requiredField index.fields
 * @requiredField index.fields.path
 * @requiredField index.name
 * @param options - Options for creating an index.
 * @permissionId WIX_DATA.CREATE_INDEX
 * @applicableIdentity APP
 * @returns Details of the index being generated.
 * @fqn com.wixpress.cloud.data.api.index.IndexService.CreateIndex
 */
declare function createIndex(dataCollectionId: string, index: NonNullablePaths<Index, `fields` | `fields.${number}.path` | `name`, 4>): Promise<NonNullablePaths<Index, `_id` | `name` | `fields` | `fields.${number}.path` | `fields.${number}.order` | `status` | `failure.code` | `failure.description` | `unique` | `caseInsensitive` | `source`, 4>>;
/**
 * Removes an index from a data collection.
 *
 * The process of dropping an index from a collection takes time.
 * You can check whether an index has been dropped by calling List Indexes.
 * @param dataCollectionId - ID of the data collection for which the index to be dropped is defined.
 * @param indexName - Name of the index to drop.
 * @public
 * @requiredField dataCollectionId
 * @requiredField indexName
 * @param options - Options for dropping an index.
 * @permissionId WIX_DATA.DROP_INDEX
 * @applicableIdentity APP
 * @fqn com.wixpress.cloud.data.api.index.IndexService.DropIndex
 */
declare function dropIndex(dataCollectionId: string, indexName: string): Promise<void>;
/**
 * Lists all indexes defined for a data collection.
 *
 * When an index's status is `ACTIVE`, it is ready to use.
 * While it is still being created, its status is `BUILDING`.
 *
 * When an index's status is `DROPPED`, it has been dropped successfully.
 * While it is still in the process of being removed, its status is `DROPPING`.
 * @param dataCollectionId - ID of the data collection for which to list indexes.
 * @public
 * @requiredField dataCollectionId
 * @param options - Options for retrieving a list of indexes.
 * @permissionId WIX_DATA.LIST_INDEXES
 * @applicableIdentity APP
 * @fqn com.wixpress.cloud.data.api.index.IndexService.ListIndexes
 */
declare function listIndexes(dataCollectionId: string, options?: ListIndexesOptions): Promise<NonNullablePaths<ListIndexesResponse, `indexes` | `indexes.${number}._id` | `indexes.${number}.name` | `indexes.${number}.status` | `indexes.${number}.failure.code` | `indexes.${number}.failure.description` | `indexes.${number}.unique` | `indexes.${number}.caseInsensitive` | `indexes.${number}.source`, 5>>;
interface ListIndexesOptions {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
}
/**
 * Lists available indexes limits
 * @param dataCollectionId - Data collection to show available indexes for
 * @internal
 * @documentationMaturity preview
 * @requiredField dataCollectionId
 * @permissionId WIX_DATA.LIST_INDEXES
 * @applicableIdentity APP
 * @fqn com.wixpress.cloud.data.api.index.IndexService.ListAvailableIndexes
 */
declare function listAvailableIndexes(dataCollectionId: string): Promise<NonNullablePaths<ListAvailableIndexesResponse, `regular1Field` | `regular3Field` | `unique1Field`, 2>>;

export { type ActionEvent, type BaseEventMetadata, type CreateIndexRequest, type CreateIndexResponse, type DomainEvent, type DomainEventBodyOneOf, type DropIndexRequest, type DropIndexResponse, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, Environment, type EnvironmentWithLiterals, type EventMetadata, type Failure, type Field, type IdentificationData, type IdentificationDataIdOneOf, type Index, type IndexCreatedEnvelope, type IndexDeletedEnvelope, IndexSource, type IndexSourceWithLiterals, type IndexUpdatedEnvelope, type ListAvailableIndexesRequest, type ListAvailableIndexesResponse, type ListIndexesOptions, type ListIndexesRequest, type ListIndexesResponse, type MessageEnvelope, Order, type OrderWithLiterals, type Paging, type PagingMetadata, type RestoreInfo, Status, type StatusWithLiterals, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, createIndex, dropIndex, listAvailableIndexes, listIndexes, onIndexCreated, onIndexDeleted, onIndexUpdated };
