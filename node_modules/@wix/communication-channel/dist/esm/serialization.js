import { proxy } from 'comlink';
const proxyCallbackMarker = '__proxyCallbackId__wixSDK__';
const proxyPromiseMarker = '__proxyPromiseId__wixSDK__';
export const serializeAllMethodsIn = sdk => {
  return wrapMethodsWithProxy(sdk, originalMethod => {
    return async function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const [proxies, argsNoProxies] = extractProxies(args);
      const originalResult = await originalMethod(proxy(proxies), argsNoProxies);
      return deserializeReturnValue(originalResult);
    };
  });
};
export const deserializeAllMethodsIn = api => {
  return wrapMethodsWithProxy(api, originalMethod => {
    return (proxies, args) => {
      const argsWithProxies = insertProxies(proxies, args);
      const originalRun = originalMethod(...argsWithProxies);
      return serializeReturnValue(originalRun);
    };
  });
};
const serializeReturnValue = async value => {
  const [proxies, clonables] = extractProxies(await value);
  return proxy({
    proxies,
    clonables
  });
};
const deserializeReturnValue = async value => {
  return insertProxies(value == null ? void 0 : value.proxies, await (value == null ? void 0 : value.clonables));
};
const extractProxies = data => {
  const walker = (proxies, val) => {
    if (isPromise(val)) {
      const proxyId = uniqueId();
      proxies.promises[proxyId] = val;
      return {
        [proxyPromiseMarker]: proxyId
      };
    }
    if (isFunction(val)) {
      const proxyId = uniqueId();
      proxies.callbacks[proxyId] = (innerProxies, argsAsArray) => {
        const argsWithProxies = insertProxies(innerProxies, argsAsArray);
        const exec = val(...argsWithProxies);
        return serializeReturnValue(exec);
      };
      return {
        [proxyCallbackMarker]: proxyId
      };
    }
    if (Array.isArray(val)) {
      return val.map(i => walker(proxies, i));
    }
    if (isObject(val)) {
      return mapObjectValues(val, i => walker(proxies, i));
    }
    return val;
  };
  const proxies = {
    promises: {},
    callbacks: {}
  };
  const dataWithoutProxies = walker(proxies, data);
  return [proxies, dataWithoutProxies];
};
const insertProxies = (proxies, data) => {
  if (Array.isArray(data)) {
    return data.map(i => insertProxies(proxies, i));
  }
  if (isObject(data) && data.hasOwnProperty(proxyPromiseMarker)) {
    const promiseId = data[proxyPromiseMarker];
    return proxies.promises[promiseId];
  }
  if (isObject(data) && data.hasOwnProperty(proxyCallbackMarker)) {
    const callbackId = data[proxyCallbackMarker];
    // passing args in spread syntax to comlink proxy generates problem when transpiling to old JS version
    // so pass it as array and handle it on the deserialization level:
    return async function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      const [innerProxies, argsNoProxies] = extractProxies(args);
      const exec = await proxies.callbacks[callbackId](proxy(innerProxies), argsNoProxies);
      return deserializeReturnValue(exec);
    };
  }
  if (isObject(data)) {
    return mapObjectValues(data, i => insertProxies(proxies, i));
  }
  return data;
};
const wrapMethodsWithProxy = (obj, callback) => {
  return new Proxy(obj, {
    get(target, prop) {
      if (!target[prop]) {
        return () => {
          throw new Error(`Serialization error occurred while accessing ${prop} property of ${target}`);
        };
      }
      return callback(target[prop]);
    }
  });
};
const isPromise = val => val instanceof Promise;
const isObject = val => val && typeof val === 'object' && !isPromise(val);
const isFunction = val => typeof val === 'function';
const mapObjectValues = (obj, callback) => {
  const mapEntries = _ref => {
    let [key, value] = _ref;
    return [key, callback(value)];
  };
  return Object.fromEntries(Object.entries(obj).map(mapEntries));
};
const uniqueId = (() => {
  let counter = 0;
  return () => ++counter;
})();
//# sourceMappingURL=serialization.js.map