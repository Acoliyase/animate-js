"use strict";

exports.__esModule = true;
exports.serializeAllMethodsIn = exports.deserializeAllMethodsIn = void 0;
var _comlink = require("comlink");
const proxyCallbackMarker = '__proxyCallbackId__wixSDK__';
const proxyPromiseMarker = '__proxyPromiseId__wixSDK__';
const serializeAllMethodsIn = sdk => {
  return wrapMethodsWithProxy(sdk, originalMethod => {
    return async (...args) => {
      const [proxies, argsNoProxies] = extractProxies(args);
      const originalResult = await originalMethod((0, _comlink.proxy)(proxies), argsNoProxies);
      return deserializeReturnValue(originalResult);
    };
  });
};
exports.serializeAllMethodsIn = serializeAllMethodsIn;
const deserializeAllMethodsIn = api => {
  return wrapMethodsWithProxy(api, originalMethod => {
    return (proxies, args) => {
      const argsWithProxies = insertProxies(proxies, args);
      const originalRun = originalMethod(...argsWithProxies);
      return serializeReturnValue(originalRun);
    };
  });
};
exports.deserializeAllMethodsIn = deserializeAllMethodsIn;
const serializeReturnValue = async value => {
  const [proxies, clonables] = extractProxies(await value);
  return (0, _comlink.proxy)({
    proxies,
    clonables
  });
};
const deserializeReturnValue = async value => {
  return insertProxies(value == null ? void 0 : value.proxies, await (value == null ? void 0 : value.clonables));
};
const extractProxies = data => {
  const walker = (proxies, val) => {
    if (isPromise(val)) {
      const proxyId = uniqueId();
      proxies.promises[proxyId] = val;
      return {
        [proxyPromiseMarker]: proxyId
      };
    }
    if (isFunction(val)) {
      const proxyId = uniqueId();
      proxies.callbacks[proxyId] = (innerProxies, argsAsArray) => {
        const argsWithProxies = insertProxies(innerProxies, argsAsArray);
        const exec = val(...argsWithProxies);
        return serializeReturnValue(exec);
      };
      return {
        [proxyCallbackMarker]: proxyId
      };
    }
    if (Array.isArray(val)) {
      return val.map(i => walker(proxies, i));
    }
    if (isObject(val)) {
      return mapObjectValues(val, i => walker(proxies, i));
    }
    return val;
  };
  const proxies = {
    promises: {},
    callbacks: {}
  };
  const dataWithoutProxies = walker(proxies, data);
  return [proxies, dataWithoutProxies];
};
const insertProxies = (proxies, data) => {
  if (Array.isArray(data)) {
    return data.map(i => insertProxies(proxies, i));
  }
  if (isObject(data) && data.hasOwnProperty(proxyPromiseMarker)) {
    const promiseId = data[proxyPromiseMarker];
    return proxies.promises[promiseId];
  }
  if (isObject(data) && data.hasOwnProperty(proxyCallbackMarker)) {
    const callbackId = data[proxyCallbackMarker];
    // passing args in spread syntax to comlink proxy generates problem when transpiling to old JS version
    // so pass it as array and handle it on the deserialization level:
    return async (...args) => {
      const [innerProxies, argsNoProxies] = extractProxies(args);
      const exec = await proxies.callbacks[callbackId]((0, _comlink.proxy)(innerProxies), argsNoProxies);
      return deserializeReturnValue(exec);
    };
  }
  if (isObject(data)) {
    return mapObjectValues(data, i => insertProxies(proxies, i));
  }
  return data;
};
const wrapMethodsWithProxy = (obj, callback) => {
  return new Proxy(obj, {
    get(target, prop) {
      if (!target[prop]) {
        return () => {
          throw new Error(`Serialization error occurred while accessing ${prop} property of ${target}`);
        };
      }
      return callback(target[prop]);
    }
  });
};
const isPromise = val => val instanceof Promise;
const isObject = val => val && typeof val === 'object' && !isPromise(val);
const isFunction = val => typeof val === 'function';
const mapObjectValues = (obj, callback) => {
  const mapEntries = ([key, value]) => [key, callback(value)];
  return Object.fromEntries(Object.entries(obj).map(mapEntries));
};
const uniqueId = (() => {
  let counter = 0;
  return () => ++counter;
})();
//# sourceMappingURL=serialization.js.map