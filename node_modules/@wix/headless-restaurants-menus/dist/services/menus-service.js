import { defineService, implementService } from '@wix/services-definitions';
import { menus, sections, items, itemVariants, itemLabels, itemModifierGroups, itemModifiers, } from '@wix/restaurants';
import { SignalsServiceDefinition, } from '@wix/services-definitions/core-services/signals';
export const MenusServiceDefinition = defineService('MenusService');
async function fetchAllPaginated(apiCall, dataKey) {
    const allData = [];
    let cursor;
    do {
        try {
            const response = await apiCall(cursor ? { cursor } : undefined);
            const currentData = response[dataKey] ?? [];
            allData.push(...currentData);
            cursor = response.pagingMetadata?.cursors?.next;
        }
        catch (error) {
            console.error(`Error fetching ${dataKey}:`, error);
            break;
        }
    } while (cursor);
    return allData;
}
function createEnhancedEntities(items, variants, labels, modifierGroups, modifiers) {
    const enhancedModifierGroups = modifierGroups.map((modifierGroup) => ({
        ...modifierGroup,
        modifiers: modifierGroup.modifiers
            ?.map((modifierRef) => {
            const modifier = modifiers.find((m) => m._id === modifierRef._id);
            return modifier
                ? {
                    ...modifier,
                    additionalChargeInfo: modifierRef.additionalChargeInfo,
                    preSelected: modifierRef.preSelected,
                }
                : null;
        })
            .filter(Boolean) ?? [],
    }));
    const enhancedItems = items.map((item) => {
        let mappedLabels = [];
        if (item.labels && Array.isArray(item.labels)) {
            if (item.labels.length > 0) {
                if (typeof item.labels[0] === 'string') {
                    mappedLabels = item.labels
                        .map((labelId) => labels.find((label) => label._id === labelId))
                        .filter(Boolean);
                }
                else if (item.labels[0] &&
                    typeof item.labels[0] === 'object' &&
                    '_id' in item.labels[0]) {
                    mappedLabels = item.labels
                        .map((labelRef) => labels.find((label) => label._id === labelRef._id))
                        .filter(Boolean);
                }
                else {
                    mappedLabels = item.labels;
                }
            }
        }
        return {
            ...item,
            labels: mappedLabels,
            modifierGroups: item.modifierGroups
                ?.map((modifierGroupRef) => enhancedModifierGroups.find((mg) => mg._id === modifierGroupRef._id))
                .filter(Boolean) ?? [],
            priceVariants: item.priceVariants
                ? item.priceVariants.variants?.map((variant) => {
                    const variantObj = variants.find((v) => v._id === variant.variantId) ||
                        {};
                    return {
                        ...variantObj,
                        priceInfo: variant.priceInfo,
                    };
                })
                : undefined,
        };
    });
    return {
        enhancedItems,
        enhancedModifierGroups,
    };
}
export const getLocations = (menus) => {
    return menus.reduce((acc, menu) => {
        const locationId = menu.businessLocationId;
        const locationName = menu.businessLocationDetails?.name;
        const archived = menu.businessLocationDetails?.archived;
        if (locationId && !archived) {
            const existingLocation = acc.find((loc) => loc.id === locationId);
            if (!existingLocation) {
                acc.push({
                    id: locationId,
                    name: locationName || `Location ${locationId}`,
                });
            }
        }
        return acc;
    }, []);
};
export const MenusService = implementService.withConfig()(MenusServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(SignalsServiceDefinition);
    const menusSignal = signalsService.signal(config.menus || []);
    const sectionsSignal = signalsService.signal(config.sections || []);
    const itemsSignal = signalsService.signal(config.items || []);
    const variantsSignal = signalsService.signal(config.variants || []);
    const labelsSignal = signalsService.signal(config.labels || []);
    const modifierGroupsSignal = signalsService.signal(config.modifierGroups || []);
    const modifiersSignal = signalsService.signal(config.modifiers || []);
    const locationsSignal = signalsService.signal([]);
    const loadingSignal = signalsService.signal(false);
    const errorSignal = signalsService.signal(null);
    const selectedMenuSignal = signalsService.signal(null);
    const selectedLocationSignal = signalsService.signal(null);
    const updateLocations = () => {
        const currentMenus = menusSignal.get();
        const locations = getLocations(currentMenus);
        locationsSignal.set(locations);
    };
    const filterMenusByLocation = () => {
        const allMenus = menusSignal.get();
        const selectedLocationId = selectedLocationSignal.get();
        if (!selectedLocationId || selectedLocationId === 'all') {
            // If no location selected or "all" selected, show all menus
            return allMenus;
        }
        // Filter menus by selected location
        return allMenus.filter((menu) => menu.businessLocationId === selectedLocationId);
    };
    signalsService.effect(() => {
        updateLocations();
    });
    // Reset selected menu when location changes
    signalsService.effect(() => {
        const selectedMenu = selectedMenuSignal.get();
        // If there's a selected menu, check if it's still valid for the current location
        if (selectedMenu) {
            const filteredMenus = filterMenusByLocation();
            const isMenuStillValid = filteredMenus.some((menu) => menu._id === selectedMenu._id);
            // If the selected menu is not available in the filtered menus, reset selection
            if (!isMenuStillValid) {
                selectedMenuSignal.set(null);
            }
        }
    });
    // Create a computed signal for filtered menus
    const filteredMenusSignal = signalsService.computed(() => {
        return filterMenusByLocation();
    });
    return {
        menus: menusSignal,
        filteredMenus: filteredMenusSignal,
        sections: sectionsSignal,
        items: itemsSignal,
        variants: variantsSignal,
        labels: labelsSignal,
        modifierGroups: modifierGroupsSignal,
        modifiers: modifiersSignal,
        locations: locationsSignal,
        loading: loadingSignal,
        error: errorSignal,
        selectedMenu: selectedMenuSignal,
        selectedLocation: selectedLocationSignal,
    };
});
export async function loadMenusServiceConfig() {
    try {
        const [allMenus, allSections, allItems, allVariants, allLabels, allModifierGroups, allModifiers,] = await Promise.all([
            fetchAllPaginated((paging) => menus.listMenus({ onlyVisible: true, paging }), 'menus'),
            fetchAllPaginated((paging) => sections.listSections({ onlyVisible: true, paging }), 'sections'),
            fetchAllPaginated((paging) => items.listItems({ onlyVisible: true, paging }), 'items'),
            fetchAllPaginated((paging) => itemVariants.listVariants({ paging }), 'variants'),
            fetchAllPaginated(() => itemLabels.listLabels(), 'labels'),
            fetchAllPaginated((paging) => itemModifierGroups.listModifierGroups({ paging }), 'modifierGroups'),
            fetchAllPaginated((paging) => itemModifiers.listModifiers({ paging }), 'modifiers'),
        ]);
        const enhanced = createEnhancedEntities(allItems, allVariants, allLabels, allModifierGroups, allModifiers);
        return {
            menus: allMenus,
            sections: allSections,
            items: enhanced.enhancedItems,
            variants: allVariants,
            labels: allLabels,
            modifierGroups: enhanced.enhancedModifierGroups,
            modifiers: allModifiers,
        };
    }
    catch (err) {
        throw err;
    }
}
