import { jsx as _jsx } from "react/jsx-runtime";
/**
 * @fileoverview Sort Primitive Components
 *
 * This module provides unstyled, composable components for building sort controls.
 * These components follow the Radix UI primitive pattern, offering:
 *
 * - **Unstyled**: No default styling, only functional behavior
 * - **Composable**: Support for the `asChild` pattern for flexible DOM structure
 * - **Accessible**: Built-in keyboard navigation and ARIA attributes
 * - **Flexible**: Render props pattern for maximum customization
 *
 * ## Architecture
 *
 * These components are the **primitive layer** that provides platform-agnostic
 * sort functionality without being tied to any specific vertical.
 *
 * ## Usage
 *
 * ```tsx
 * import { Sort } from '@wix/headless-components/react';
 *
 * // Declarative API
 * function SortControls({ sortOptions, value, onChange }) {
 *   return (
 *     <Sort.Root
 *       value={value}
 *       onChange={onChange}
 *       sortOptions={sortOptions}
 *       as="select"
 *     />
 *   );
 * }
 *
 * // Programmatic API
 * function CustomSort({ value, onChange }) {
 *   return (
 *     <Sort.Root value={value} onChange={onChange}>
 *       <Sort.Option fieldName="price" order="asc" label="Price: Low to High" />
 *       <Sort.Option fieldName="price" order="desc" label="Price: High to Low" />
 *     </Sort.Root>
 *   );
 * }
 * ```
 *
 * @module Sort
 */
import React, { createContext, useContext } from 'react';
import { Slot } from '@radix-ui/react-slot';
import { AsChildSlot } from '@wix/headless-utils/react';
/**
 * TestIds enum for Sort components
 */
var TestIds;
(function (TestIds) {
    TestIds["sortRoot"] = "sort-root";
    TestIds["sortOption"] = "sort-option";
})(TestIds || (TestIds = {}));
const SortContext = createContext(null);
function useSortContext() {
    const context = useContext(SortContext);
    if (!context) {
        throw new Error('useSortContext must be used within a Sort.Root component');
    }
    return context;
}
const SelectRenderer = React.forwardRef((props, ref) => {
    const { currentSort, options, onChange, ...otherProps } = props;
    const toStringValue = (fieldName, order) => {
        return `${fieldName ?? ''}-${order ?? ''}`;
    };
    const fromStringValue = (value) => {
        const [fieldName, order] = value.split('-');
        return {
            fieldName: fieldName === '' ? undefined : fieldName,
            order: order === '' ? undefined : order,
        };
    };
    const currentValue = toStringValue(currentSort?.fieldName, currentSort?.order);
    return (_jsx("select", { ref: ref, value: currentValue, onChange: (e) => {
            const { fieldName, order } = fromStringValue(e.target.value);
            onChange(fieldName, order);
        }, ...otherProps, children: options.map((option, index) => (_jsx("option", { value: toStringValue(option?.fieldName, option?.order), children: option.label }, `${option?.fieldName}-${option?.order}-${index}`))) }));
});
SelectRenderer.displayName = 'Sort.SelectRenderer';
const ListRenderer = React.forwardRef((props, ref) => {
    const { currentSort, options, ...otherProps } = props;
    return (_jsx("ul", { ref: ref, ...otherProps, children: options.map((option, index) => (_jsx(Option, { className: otherProps.className, fieldName: option.fieldName, asChild: option.asChild, children: option.children, order: option.order, label: option.label }, `${option?.fieldName ?? ''}-${option?.order ?? ''}-${index}`))) }));
});
ListRenderer.displayName = 'Sort.ListRenderer';
/**
 * Root component that provides sort context and can render as select or custom controls.
 * Supports both declarative (sortOptions prop) and programmatic (children) APIs.
 *
 * @component
 * @example
 * ```tsx
 * // Declarative API with native select
 * <Sort.Root
 *   value={sort}
 *   onChange={setSort}
 *   sortOptions={[
 *     { fieldName: 'price', label: 'Price: Low to High', order: 'ASC' },
 *     { fieldName: 'price', label: 'Price: High to Low', order: 'DESC' },
 *   ]}
 *   as="select"
 *   className="w-full"
 * />
 *
 * // Custom component replacing the entire Sort root
 * <Sort.Root
 *   value={sort}
 *   onChange={setSort}
 *   sortOptions={sortOptions}
 *   asChild
 * >
 *   <CustomSortComponent />
 * </Sort.Root>
 *
 * // List mode with custom buttons
 * <Sort.Root value={sort} onChange={setSort} as="list">
 *   <Sort.Option fieldName="price" order="ASC" label="Price ↑" />
 *   <Sort.Option fieldName="price" order="DESC" label="Price ↓" />
 * </Sort.Root>
 *
 * // Custom list container with asChild
 * <Sort.Root value={sort} onChange={setSort} as="list" asChild>
 *   <div className="custom-sort-container">
 *     <Sort.Option fieldName="price" order="ASC" label="Price ↑" />
 *     <Sort.Option fieldName="price" order="DESC" label="Price ↓" />
 *   </div>
 * </Sort.Root>
 * ```
 */
// Helper function to get current sort from array or default to first option
const getCurrentSort = (sortArray, options) => {
    const currentSort = sortArray?.find((sort) => sort);
    const mostSimillarOption = options.find((option) => {
        if ('fieldName' in option && 'order' in option) {
            return (option.fieldName === currentSort?.fieldName &&
                option.order === currentSort?.order);
        }
        if ('fieldName' in option) {
            return option.fieldName === currentSort?.fieldName;
        }
        if ('order' in option) {
            return option.order === currentSort?.order;
        }
        return false;
    });
    return mostSimillarOption;
};
export const Root = React.forwardRef((props, ref) => {
    const { value, onChange, sortOptions = [], as = 'select', asChild, children, ...otherProps } = props;
    const currentValue = value?.[0];
    // Handle change events - create Wix SDK array format
    const handleChange = (fieldName, order) => {
        onChange([
            {
                fieldName: fieldName || currentValue?.fieldName,
                order: order || currentValue?.order,
            },
        ]);
    };
    // Use EITHER sortOptions prop OR extract from children - not both
    let completeOptions = [];
    if (sortOptions.length > 0) {
        // Use sortOptions prop (declarative API)
        completeOptions = sortOptions.map((option) => {
            // Type guards to safely access properties
            const fieldName = 'fieldName' in option ? option.fieldName : undefined;
            const order = 'order' in option ? option.order : undefined;
            const isSelected = isSelectedHelper(fieldName, order, currentValue);
            return {
                fieldName,
                label: option.label,
                order,
                isSelected,
                onSelect: () => handleChange(fieldName, order),
            };
        });
    }
    else if (children) {
        // Extract options from children (programmatic API)
        React.Children.forEach(children, (child) => {
            if (React.isValidElement(child)) {
                // Check if it's the primitive Option or a styled wrapper containing it
                const isOption = child.type === Option ||
                    (child.type &&
                        typeof child.type === 'function' &&
                        child.props?.fieldName !== undefined);
                if (isOption) {
                    const { fieldName, order, label, asChild, children } = child.props;
                    if (fieldName && label) {
                        const isSelected = isSelectedHelper(fieldName, order, currentValue);
                        completeOptions.push({
                            fieldName,
                            asChild,
                            children,
                            order,
                            label,
                            onSelect: () => handleChange(fieldName, order),
                            isSelected,
                        });
                    }
                }
            }
        });
    }
    // Get current sort from sortOptions directly
    const currentSortOption = getCurrentSort(value, completeOptions);
    const contextValue = {
        currentSort: currentSortOption,
        onChange,
    };
    // Determine the component to render
    let Comp;
    let compProps;
    const commonProps = {
        'data-testid': TestIds.sortRoot,
        currentSort: currentSortOption,
        options: completeOptions,
        onChange: handleChange,
    };
    if (asChild) {
        Comp = Slot;
        compProps = {
            ref,
            ...commonProps,
            ...otherProps,
        };
    }
    else if (as === 'select') {
        Comp = SelectRenderer;
        compProps = {
            ref: ref,
            ...commonProps,
            ...otherProps,
        };
    }
    else {
        // as === 'list'
        Comp = ListRenderer;
        compProps = {
            ref: ref,
            ...commonProps,
            ...otherProps,
        };
    }
    return (_jsx(SortContext.Provider, { value: contextValue, children: _jsx(Comp, { ...compProps, children: children }) }));
});
/**
 * Option component that represents a single sort option.
 * Can be used to set field name, order, or both.
 *
 * @component
 * @example
 * ```tsx
 * // Set both field and order
 * <Sort.Option fieldName="price" order="asc" label="Price: Low to High" />
 *
 * // Set only field (keeps current order)
 * <Sort.Option fieldName="name" label="Sort by Name" />
 *
 * // Set only order (keeps current field)
 * <Sort.Option order="desc" label="Descending" />
 *
 * // Custom rendering with asChild
 * <Sort.Option fieldName="price" order="asc" label="Price" asChild>
 *   {({ isSelected, onSelect, label }) => (
 *     <button
 *       onClick={onSelect}
 *       className={isSelected ? 'bg-blue-500 text-white' : 'bg-gray-200'}
 *     >
 *       {label}
 *     </button>
 *   )}
 * </Sort.Option>
 * ```
 */
export const Option = React.forwardRef((props, ref) => {
    const { fieldName, order, label, asChild, children, className, ...otherProps } = props;
    const { currentSort, onChange } = useSortContext();
    const handleSelect = () => {
        const targetFieldName = fieldName || currentSort.fieldName;
        const targetOrder = order || currentSort.order;
        onChange([{ fieldName: targetFieldName, order: targetOrder }]);
    };
    const isSelected = isSelectedHelper(fieldName, order, currentSort);
    const attributes = {
        'data-testid': TestIds.sortOption,
        'data-selected': isSelected,
        'data-field-name': fieldName,
        'data-order': order,
        ...otherProps,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, onClick: handleSelect, customElement: children, customElementProps: {
            isSelected,
            onSelect: handleSelect,
            label,
            fieldName,
            order,
        }, children: _jsx("li", { children: _jsx("button", { className: className, children: React.isValidElement(children) ? children : label }) }) }));
});
// ============================================================================
// EXPORTS WITH NAMESPACING
// ============================================================================
// Set display names for debugging
Root.displayName = 'Sort.Root';
Option.displayName = 'Sort.Option';
function isSelectedHelper(fieldName, order, currentValue) {
    return ((!fieldName || currentValue?.fieldName === fieldName) &&
        (!order || currentValue?.order === order));
}
