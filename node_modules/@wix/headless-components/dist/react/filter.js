import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 * @fileoverview Filter Primitive Components
 *
 * This module provides unstyled, composable components for building filter controls.
 * These components follow the Radix UI primitive pattern, offering:
 *
 * - **Unstyled**: No default styling, only functional behavior
 * - **Composable**: Support for the `asChild` pattern for flexible DOM structure
 * - **Accessible**: Built-in keyboard navigation and ARIA attributes
 * - **Flexible**: Render props pattern for maximum customization
 *
 * ## Architecture
 *
 * These components are the **primitive layer** that provides platform-agnostic
 * filter functionality without being tied to any specific vertical.
 *
 * ## Usage
 *
 * ```tsx
 * import { Filter } from '@wix/headless-components/react';
 *
 * function FilterControls({ filter, onChange, onFilterChange, filterOptions }) {
 *   return (
 *     <Filter.Root value={filter} onChange={onChange} onFilterChange={onFilterChange} filterOptions={filterOptions}>
 *       <Filter.Filtered>
 *         <Filter.Action.Clear label="Clear Filters" />
 *       </Filter.Filtered>
 *       <Filter.FilterOptions>
 *         <Filter.FilterOptionRepeater>
 *           <Filter.FilterOption.Label />
 *           <Filter.FilterOption.SingleFilter />
 *           <Filter.FilterOption.MultiFilter />
 *           <Filter.FilterOption.RangeFilter />
 *         </Filter.FilterOptionRepeater>
 *       </Filter.FilterOptions>
 *     </Filter.Root>
 *   );
 * }
 * ```
 *
 * @module Filter
 */
import React, { createContext, useContext } from 'react';
import { Slot } from '@radix-ui/react-slot';
import * as Slider from '@radix-ui/react-slider';
import * as ToggleGroup from '@radix-ui/react-toggle-group';
import { AsChildSlot } from '@wix/headless-utils/react';
/**
 * TestIds enum for Filter components
 */
var TestIds;
(function (TestIds) {
    TestIds["filterRoot"] = "filter-root";
    TestIds["filterFiltered"] = "filter-filtered";
    TestIds["filterActionClear"] = "filter-action-clear";
    TestIds["filterOptions"] = "filter-options";
    TestIds["filterOptionRepeater"] = "filter-option-repeater";
    TestIds["filterOption"] = "filter-option";
    TestIds["filterOptionLabel"] = "filter-option-label";
    TestIds["filterOptionSingle"] = "filter-option-single";
    TestIds["filterOptionMulti"] = "filter-option-multi";
    TestIds["filterOptionRange"] = "filter-option-range";
})(TestIds || (TestIds = {}));
const FilterContext = createContext(null);
function useFilterContext() {
    const context = useContext(FilterContext);
    if (!context) {
        throw new Error('useFilterContext must be used within a Filter.Root component');
    }
    return context;
}
const FilterOptionContext = createContext(null);
function useFilterOptionContext() {
    const context = useContext(FilterOptionContext);
    if (!context) {
        throw new Error('useFilterOptionContext must be used within a Filter.FilterOptionRepeater component');
    }
    return context;
}
// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
/**
 * Check if any filters are currently active
 */
function hasActiveFilters(filter, filterOptions) {
    if (!filter)
        return false;
    return filterOptions.some((option) => {
        if (option.type === 'range') {
            const extractedValue = rangeFilterGetUIValue(filter, option);
            return (Array.isArray(extractedValue) &&
                extractedValue.length > 0 &&
                extractedValue.some((v) => v !== undefined && v !== null));
        }
        if (option.type === 'multi') {
            const extractedValue = multiFilterGetUIValue(filter, option);
            return Array.isArray(extractedValue) && extractedValue.length > 0;
        }
        if (option.type === 'single') {
            const extractedValue = singleFilterGetUIValue(filter, option);
            return (extractedValue !== undefined &&
                extractedValue !== null &&
                extractedValue !== '');
        }
        return false;
    });
}
/**
 * Root component that provides filter context and manages filter state.
 *
 * @component
 * @example
 * ```tsx
 * <Filter.Root
 *   value={filter}
 *   onChange={setFilter}
 *   filterOptions={[
 *     {
 *       key: 'category',
 *       label: 'Category',
 *       type: 'single',
 *       displayType: 'text',
 *       fieldName: 'category.id'
 *     },
 *     {
 *       key: 'price',
 *       label: 'Price Range',
 *       type: 'range',
 *       displayType: 'range',
 *       fieldName: ['price.min', 'price.max']
 *     },
 *     {
 *       key: 'tags',
 *       label: 'Tags',
 *       type: 'multi',
 *       displayType: 'text',
 *       fieldName: 'tags',
 *       fieldType: 'array'
 *     }
 *   ]}
 * >
 *   <Filter.FilterOptions>
 *     <Filter.FilterOptionRepeater>
 *       <Filter.FilterOption.Label />
 *       <Filter.FilterOption.SingleFilter />
 *     </Filter.FilterOptionRepeater>
 *   </Filter.FilterOptions>
 * </Filter.Root>
 * ```
 */
export const Root = React.forwardRef((props, ref) => {
    const { value, onChange, onFilterChange, filterOptions, asChild, children, ...otherProps } = props;
    const hasFilters = hasActiveFilters(value, filterOptions);
    const clearFilters = () => {
        // Clear all filters except for category filter
        onChange({
            ...(value
                ? {
                    'allCategoriesInfo.categories': value['allCategoriesInfo.categories'],
                }
                : {}),
        });
    };
    const contextValue = {
        value,
        onChange,
        onFilterChange,
        filterOptions,
        hasFilters,
        clearFilters,
    };
    // Default div rendering with proper asChild pattern
    const Comp = asChild ? Slot : 'div';
    return (_jsx(FilterContext.Provider, { value: contextValue, children: _jsx(Comp, { ref: ref, "data-testid": TestIds.filterRoot, "data-has-filters": hasFilters, ...otherProps, children: typeof children === 'function' ? null : children }) }));
});
/**
 * Container that conditionally renders its children when filters are active.
 *
 * @component
 * @example
 * ```tsx
 * <Filter.Filtered>
 *   <div className="bg-surface-card border-surface-primary p-4 rounded">
 *     <p className="text-content-secondary">Active filters:</p>
 *     <Filter.Action.Clear label="Clear All" />
 *   </div>
 * </Filter.Filtered>
 * ```
 */
export const Filtered = ({ children, ...otherProps }) => {
    const { hasFilters } = useFilterContext();
    if (!hasFilters)
        return null;
    return (_jsx("div", { "data-testid": TestIds.filterFiltered, "data-has-filters": hasFilters, ...otherProps, children: children }));
};
/**
 * Container for filter option components.
 *
 * This component provides a wrapper for organizing filter controls and serves as
 * a semantic container for the FilterOptionRepeater and related components.
 *
 * @component
 * @example
 * ```tsx
 * <Filter.FilterOptions className="space-y-4">
 *   <Filter.FilterOptionRepeater>
 *     <div className="filter-group">
 *       <Filter.FilterOption.Label className="font-semibold mb-2" />
 *       <Filter.FilterOption.SingleFilter />
 *       <Filter.FilterOption.MultiFilter />
 *       <Filter.FilterOption.RangeFilter />
 *     </div>
 *   </Filter.FilterOptionRepeater>
 * </Filter.FilterOptions>
 * ```
 */
export const FilterOptions = ({ children, ...otherProps }) => {
    return (_jsx("div", { "data-testid": TestIds.filterOptions, ...otherProps, children: children }));
};
/**
 * Repeater component that renders a template for each filter option.
 *
 * This component maps over the filterOptions array provided to Filter.Root and renders
 * the children template for each option. It automatically provides FilterOptionContext
 * to each rendered template, enabling child components to access the current option
 * configuration and update functions.
 *
 * The component follows the List, Options, and Repeater pattern from the architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * <Filter.FilterOptionRepeater>
 *   <div className="mb-6">
 *     <Filter.FilterOption.Label className="block text-sm font-medium mb-2" />
 *     <Filter.FilterOption.SingleFilter className="w-full" />
 *     <Filter.FilterOption.MultiFilter className="flex flex-wrap gap-2" />
 *     <Filter.FilterOption.RangeFilter className="space-y-2" />
 *   </div>
 * </Filter.FilterOptionRepeater>
 * ```
 */
export const FilterOptionRepeater = ({ children, ...otherProps }) => {
    const { filterOptions, onFilterChange, onChange, value: filterValue, } = useFilterContext();
    return (_jsx("div", { "data-testid": TestIds.filterOptionRepeater, ...otherProps, children: filterOptions.map((option) => {
            // Fallback updateFilter - individual filter components handle their own conversion
            const updateFilter = (value) => {
                if (onFilterChange) {
                    const newFilter = onFilterChange({ value, key: option.key });
                    onChange(newFilter);
                }
                else {
                    // Fallback to direct assignment for simple cases
                    const newFilter = {
                        ...(filterValue || {}),
                        [option.key]: value,
                    };
                    onChange(newFilter);
                }
            };
            return (_jsx(FilterOptionContext.Provider, { value: { option, updateFilter }, children: _jsx("div", { "data-testid": TestIds.filterOption, "data-filter-key": option.key, children: children }) }, option.key));
        }) }));
};
/**
 * Button to clear all active filters.
 *
 * @component
 * @example
 * ```tsx
 * // Default usage
 * <Filter.Action.Clear
 *   label="Clear Filters"
 *   className="btn-secondary text-sm px-3 py-1"
 * />
 *
 * // Custom rendering with asChild
 * <Filter.Action.Clear label="Reset All" asChild>
 *   {({ onClick, disabled }) => (
 *     <button
 *       onClick={onClick}
 *       disabled={disabled}
 *       className="text-status-danger hover:text-status-danger-hover underline disabled:text-content-muted disabled:no-underline"
 *     >
 *       âœ• Reset All Filters
 *     </button>
 *   )}
 * </Filter.Action.Clear>
 * ```
 */
export const Clear = React.forwardRef((props, ref) => {
    const { label, asChild, children, ...otherProps } = props;
    const { hasFilters, clearFilters } = useFilterContext();
    // Use the same pattern as MediaGallery components
    const Comp = asChild ? Slot : 'button';
    return (_jsx(Comp, { ref: ref, onClick: clearFilters, disabled: !hasFilters, "data-testid": TestIds.filterActionClear, ...otherProps, children: children || label }));
});
/**
 * Label component for filter options.
 *
 * Displays the label for the current filter option from the FilterOptionContext.
 * This component automatically accesses the option.label property and renders it,
 * making it easy to display consistent filter labels.
 *
 * @component
 * @example
 * ```tsx
 * // Default label rendering
 * <Filter.FilterOption.Label className="block text-sm font-medium text-gray-700 mb-1" />
 *
 * // Custom label with asChild pattern
 * <Filter.FilterOption.Label asChild>
 *   <h3 className="text-lg font-semibold" />
 * </Filter.FilterOption.Label>
 *
 * // Custom content overriding the label
 * <Filter.FilterOption.Label>
 *   <span className="text-blue-600">Custom Label Text</span>
 * </Filter.FilterOption.Label>
 * ```
 */
export const FilterOptionLabel = React.forwardRef((props, ref) => {
    const { asChild, children, ...otherProps } = props;
    const { option } = useFilterOptionContext();
    // Use the same pattern as MediaGallery components
    const Comp = asChild ? Slot : 'div';
    return (_jsx(Comp, { ref: ref, "data-testid": TestIds.filterOptionLabel, ...otherProps, children: children || option.label }));
});
/**
 * Single selection filter component.
 *
 * Renders a single-selection filter that allows users to choose one value from
 * the available options. Only renders when the current option.type is 'single'.
 *
 * **Default Behavior:**
 * - Uses Radix ToggleGroup in single mode for better UX and accessibility
 * - Displays all validValues from the option configuration
 * - Applies valueFormatter if provided for custom value display
 *
 * **Fallback Behavior:**
 * - When asChild=false and children provided: renders native select element
 * - When asChild=true: delegates to child component via Slot pattern
 *
 * @component
 * @example
 * ```tsx
 * // Default ToggleGroup rendering
 * <Filter.FilterOption.SingleFilter className="flex gap-2" />
 *
 * // Custom select dropdown with asChild
 * <Filter.FilterOption.SingleFilter asChild>
 *   <select className="form-select" />
 * </Filter.FilterOption.SingleFilter>
 *
 * // Custom styling with children
 * <Filter.FilterOption.SingleFilter>
 *   <option value="">All Categories</option>
 * </Filter.FilterOption.SingleFilter>
 * ```
 */
export const SingleFilter = React.forwardRef((props, ref) => {
    const { asChild, children, ...otherProps } = props;
    const { option } = useFilterOptionContext();
    const { value: filterValue, onChange } = useFilterContext();
    if (option.type !== 'single')
        return null;
    // Single-specific updateFilter function that handles its own conversion
    const updateFilter = React.useCallback((uiValue) => {
        const newFilter = singleFilterUiValueToFilter(uiValue, option, filterValue || {});
        onChange(newFilter);
    }, [option, filterValue, onChange]);
    // Extract single value from search filter format
    let currentValue = '';
    if (filterValue) {
        currentValue = singleFilterGetUIValue(filterValue, option);
    }
    // Custom rendering with asChild/children
    if (asChild) {
        return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, "data-testid": TestIds.filterOptionSingle, "data-filter-type": "single", "data-display-type": option.displayType, customElement: children, customElementProps: {
                value: currentValue,
                validValues: option.validValues,
                valueFormatter: option.valueFormatter,
                onChange: updateFilter,
            }, ...otherProps, children: children }));
    }
    return (_jsx(ToggleGroup.Root, { type: "single", value: currentValue, onValueChange: (value) => updateFilter(value || ''), "data-testid": TestIds.filterOptionSingle, "data-filter-type": "single", "data-display-type": option.displayType, className: otherProps.className, children: option.validValues?.map((value) => (_jsx(ToggleGroup.Item, { value: String(value), children: option.valueFormatter
                ? option.valueFormatter(value)
                : String(value) }, String(value)))) }));
});
/**
 * Multi-selection filter component.
 *
 * Renders a multi-selection filter that allows users to choose multiple values from
 * the available options. Only renders when the current option.type is 'multi'.
 *
 * **Default Behavior:**
 * - Uses Radix ToggleGroup in multiple mode for better UX and accessibility
 * - Displays all validValues from the option configuration
 * - Applies valueFormatter if provided for custom value display
 * - Supports color swatches when displayType is 'color' with valueBgColorFormatter
 *
 * **Fallback Behavior:**
 * - When asChild=false and children provided: renders checkbox list
 * - When asChild=true: delegates to child component via Slot pattern
 *
 * **Field Type Handling:**
 * - fieldType='array': uses $hasSome operator (for array fields like product choices)
 * - fieldType='singular': uses $in operator (for single fields with multiple values)
 *
 * @component
 * @example
 * ```tsx
 * // Default ToggleGroup rendering
 * <Filter.FilterOption.MultiFilter className="flex flex-wrap gap-2" />
 *
 * // Color swatch display (when displayType='color')
 * <Filter.FilterOption.MultiFilter className="grid grid-cols-6 gap-2" />
 *
 * // Custom checkbox list with asChild
 * <Filter.FilterOption.MultiFilter asChild>
 *   <div className="space-y-2" />
 * </Filter.FilterOption.MultiFilter>
 *
 * // Custom rendering with children override
 * <Filter.FilterOption.MultiFilter>
 *   <div>Custom checkboxes here</div>
 * </Filter.FilterOption.MultiFilter>
 * ```
 */
export const MultiFilter = React.forwardRef((props, ref) => {
    const { asChild, children, ...otherProps } = props;
    const { option } = useFilterOptionContext();
    const { value: filterValue, onChange } = useFilterContext();
    if (option.type !== 'multi')
        return null;
    // Multi-specific updateFilter function that handles its own conversion
    const updateFilter = React.useCallback((uiValue) => {
        const newFilter = multiFilterUiValueToFilter(uiValue, option, filterValue || {});
        onChange(newFilter);
    }, [option, filterValue, onChange]);
    // Extract array value from search filter format
    let currentValue = [];
    if (filterValue) {
        currentValue = multiFilterGetUIValue(filterValue, option);
    }
    // Use the same pattern as MediaGallery components
    const Comp = asChild ? Slot : 'div';
    // Default rendering - Radix ToggleGroup for better UX
    if (!asChild && !children) {
        return (_jsx(ToggleGroup.Root, { type: "multiple", value: currentValue, onValueChange: updateFilter, "data-testid": TestIds.filterOptionMulti, "data-filter-type": "multi", "data-display-type": option.displayType, className: otherProps.className, children: option.validValues?.map((value) => {
                const formattedValue = option.valueFormatter
                    ? option.valueFormatter(value)
                    : String(value);
                return (_jsx(ToggleGroup.Item, { value: String(value), "data-color": option.displayType === 'color'
                        ? formattedValue.toLowerCase()
                        : undefined, style: {
                        backgroundColor: option.valueBgColorFormatter
                            ? option.valueBgColorFormatter(value)
                            : undefined,
                    }, "aria-label": formattedValue, children: formattedValue }, String(value)));
            }) }));
    }
    // Custom rendering with asChild/children
    return (_jsx(Comp, { ref: ref, "data-testid": TestIds.filterOptionMulti, "data-filter-type": "multi", "data-display-type": option.displayType, ...otherProps, children: children || (_jsx(_Fragment, { children: option.validValues?.map((value) => (_jsxs("label", { children: [_jsx("input", { type: "checkbox", checked: currentValue.includes(String(value)), onChange: (e) => {
                            const stringValue = String(value);
                            const newValue = e.target.checked
                                ? [...currentValue, stringValue]
                                : currentValue.filter((v) => v !== stringValue);
                            updateFilter(newValue);
                        } }), option.valueFormatter
                        ? option.valueFormatter(value)
                        : String(value)] }, String(value)))) })) }));
});
function rangeFilterGetUIValue(value, option) {
    if (!value || typeof value !== 'object') {
        return [];
    }
    let min;
    let max;
    if (Array.isArray(option.fieldName) && option.fieldName.length >= 2) {
        // Two separate fields for min and max
        const [minFieldName, maxFieldName] = option.fieldName;
        const minField = value[minFieldName];
        const maxField = value[maxFieldName];
        // Extract min value (typically stored as $gte)
        if (minField && typeof minField === 'object' && '$gte' in minField) {
            min = Number(minField.$gte);
        }
        else if (typeof minField === 'number') {
            min = minField;
        }
        // Extract max value (typically stored as $lte)
        if (maxField && typeof maxField === 'object' && '$lte' in maxField) {
            max = Number(maxField.$lte);
        }
        else if (typeof maxField === 'number') {
            max = maxField;
        }
    }
    else if (typeof option.fieldName === 'string') {
        // Single field with both $gte and $lte
        const fieldName = option.fieldName;
        const field = value[fieldName];
        if (field && typeof field === 'object') {
            if ('$gte' in field) {
                min = Number(field.$gte);
            }
            if ('$lte' in field) {
                max = Number(field.$lte);
            }
        }
        else if (typeof field === 'number') {
            min = max = field;
        }
    }
    const result = [];
    if (min !== undefined)
        result.push(min);
    if (max !== undefined)
        result.push(max);
    return result;
}
function rangeFilterUiValueToFilter(uiValue, option, currentFilter) {
    const newFilter = { ...currentFilter };
    if (!option.fieldName) {
        // If no fieldName provided, can't convert
        return newFilter;
    }
    if (Array.isArray(uiValue) && uiValue.length >= 2) {
        const [min, max] = uiValue;
        if (Array.isArray(option.fieldName) && option.fieldName.length >= 2) {
            // Two separate fields for min and max
            const [minFieldName, maxFieldName] = option.fieldName;
            // Set min value with $gte operator
            if (min !== undefined && min !== null) {
                newFilter[minFieldName] = { $gte: min };
            }
            else {
                delete newFilter[minFieldName];
            }
            // Set max value with $lte operator
            if (max !== undefined && max !== null) {
                newFilter[maxFieldName] = { $lte: max };
            }
            else {
                delete newFilter[maxFieldName];
            }
        }
        else if (typeof option.fieldName === 'string') {
            // Single field with both $gte and $lte
            const fieldName = option.fieldName;
            const rangeFilter = {};
            if (min !== undefined && min !== null) {
                rangeFilter.$gte = min;
            }
            if (max !== undefined && max !== null) {
                rangeFilter.$lte = max;
            }
            if (Object.keys(rangeFilter).length > 0) {
                newFilter[fieldName] = rangeFilter;
            }
            else {
                delete newFilter[fieldName];
            }
        }
    }
    else {
        // Clear range filter if no valid range
        if (Array.isArray(option.fieldName) && option.fieldName.length >= 2) {
            const [minFieldName, maxFieldName] = option.fieldName;
            delete newFilter[minFieldName];
            delete newFilter[maxFieldName];
        }
        else if (typeof option.fieldName === 'string') {
            delete newFilter[option.fieldName];
        }
    }
    return newFilter;
}
function singleFilterGetUIValue(value, option) {
    if (!value || typeof value !== 'object') {
        return '';
    }
    const fieldName = typeof option.fieldName === 'string' ? option.fieldName : option.key;
    const field = value[fieldName];
    if (field !== undefined && field !== null) {
        return String(field);
    }
    return '';
}
function singleFilterUiValueToFilter(uiValue, option, currentFilter) {
    const newFilter = { ...currentFilter };
    const fieldName = typeof option.fieldName === 'string' ? option.fieldName : option.key;
    if (uiValue && uiValue.trim() !== '') {
        // Find the valid value in validValues to preserve type (boolean, number, etc.)
        const validValueOption = option.validValues?.find((v) => String(v) === uiValue);
        newFilter[fieldName] =
            validValueOption !== undefined ? validValueOption : uiValue;
    }
    else {
        delete newFilter[fieldName];
    }
    return newFilter;
}
function extractArrayFromOperators(field, preferredOperator) {
    if (!field || typeof field !== 'object')
        return [];
    const operators = [preferredOperator, '$in', '$hasSome'].filter(Boolean);
    for (const op of operators) {
        if (op in field && Array.isArray(field[op])) {
            return field[op].map(String);
        }
    }
    return [];
}
function multiFilterGetUIValue(value, option) {
    if (!value || typeof value !== 'object') {
        return [];
    }
    const fieldName = typeof option.fieldName === 'string' ? option.fieldName : option.key;
    const field = value[fieldName];
    // Special handling for shared fields (like product options)
    if (fieldName === 'options.choicesSettings.choices.choiceId' &&
        option.validValues) {
        // This is a shared field that needs filtering by validValues
        if (field &&
            typeof field === 'object' &&
            '$hasSome' in field &&
            Array.isArray(field.$hasSome)) {
            const allSelectedChoices = field.$hasSome.map(String);
            // Filter to only include choices that belong to this specific option
            const choicesForThisOption = Array.isArray(option.validValues)
                ? option.validValues.map(String)
                : [];
            return allSelectedChoices.filter((choiceId) => choicesForThisOption.includes(choiceId));
        }
        return [];
    }
    // Standard logic for non-shared fields
    if (Array.isArray(field)) {
        return field.map(String);
    }
    else if (field && typeof field === 'object') {
        // Handle operators based on fieldType preference
        const preferredOperator = option.fieldType === 'array' ? '$hasSome' : '$in';
        const result = extractArrayFromOperators(field, preferredOperator);
        if (result.length > 0)
            return result;
    }
    else if (field !== undefined && field !== null) {
        return [String(field)];
    }
    return [];
}
function multiFilterUiValueToFilter(uiValue, option, currentFilter) {
    const newFilter = { ...currentFilter };
    const fieldName = typeof option.fieldName === 'string' ? option.fieldName : option.key;
    // Special handling for shared fields (like product options)
    if (fieldName === 'options.choicesSettings.choices.choiceId' &&
        option.validValues) {
        // This is a shared field that needs merging logic
        const existingField = newFilter[fieldName];
        let existingChoices = [];
        // Extract existing choices
        if (existingField &&
            typeof existingField === 'object' &&
            '$hasSome' in existingField) {
            existingChoices = Array.isArray(existingField.$hasSome)
                ? [...existingField.$hasSome]
                : [];
        }
        // Remove choices for this specific option (based on validValues)
        const choicesForThisOption = Array.isArray(option.validValues)
            ? option.validValues.map(String)
            : [];
        existingChoices = existingChoices.filter((choiceId) => !choicesForThisOption.includes(choiceId));
        // Add new choices for this option
        if (Array.isArray(uiValue) && uiValue.length > 0) {
            existingChoices.push(...uiValue);
        }
        // Update the filter
        if (existingChoices.length > 0) {
            newFilter[fieldName] = { $hasSome: existingChoices };
        }
        else {
            delete newFilter[fieldName];
        }
    }
    else {
        // Standard logic for non-shared fields
        if (Array.isArray(uiValue) && uiValue.length > 0) {
            // Convert to original types values (number, boolean, etc.)
            const valuesWithTypes = uiValue.map((stringVal) => {
                const validValueOption = option.validValues?.find((v) => String(v) === stringVal);
                return validValueOption !== undefined ? validValueOption : stringVal;
            });
            // Use operator based on fieldType
            if (option.fieldType === 'array') {
                newFilter[fieldName] = { $hasSome: valuesWithTypes };
            }
            else {
                // Default to $in for 'singular' or undefined fieldType
                newFilter[fieldName] = { $in: valuesWithTypes };
            }
        }
        else {
            delete newFilter[fieldName];
        }
    }
    return newFilter;
}
/**
 * Range filter component for numeric ranges.
 *
 * Renders a range filter that allows users to select a minimum and maximum value
 * from a numeric range. Only renders when the current option.type is 'range'.
 *
 * **Default Behavior:**
 * - Uses Radix Slider with dual thumbs for better UX and accessibility
 * - Features smooth slider interaction using local state during dragging
 * - Only commits changes when the user releases the handle (onValueCommit)
 * - Displays formatted values using valueFormatter if provided
 * - Shows current min/max values with data attributes for styling
 *
 * **Fallback Behavior:**
 * - When asChild=false and children provided: renders dual number inputs
 * - When asChild=true: delegates to child component via Slot pattern
 *
 * **Field Name Handling:**
 * - Single field: uses $gte/$lte operators (e.g., {price: {$gte: 10, $lte: 100}})
 * - Dual fields: separate min/max fields (e.g., {'price.min': {$gte: 10}, 'price.max': {$lte: 100}})
 *
 * @component
 * @example
 * ```tsx
 * // Default Radix Slider rendering
 * <Filter.FilterOption.RangeFilter className="w-full px-4 py-2" />
 *
 * // Custom dual number inputs with asChild
 * <Filter.FilterOption.RangeFilter asChild>
 *   <div className="flex items-center gap-2">
 *     <input type="number" placeholder="Min" className="form-input" />
 *     <span>to</span>
 *     <input type="number" placeholder="Max" className="form-input" />
 *   </div>
 * </Filter.FilterOption.RangeFilter>
 *
 * // Override with completely custom range component
 * <Filter.FilterOption.RangeFilter>
 *   <div>Custom range slider component</div>
 * </Filter.FilterOption.RangeFilter>
 * ```
 */
export const RangeFilter = React.forwardRef((props, ref) => {
    const { asChild, children, ...otherProps } = props;
    const { option } = useFilterOptionContext();
    const { value: filterValue, onChange } = useFilterContext();
    if (option.type !== 'range')
        return null;
    const numericValidValues = option.validValues || [];
    // Range-specific updateFilter function that handles its own conversion
    const updateFilter = React.useCallback((uiValue) => {
        const newFilter = rangeFilterUiValueToFilter(uiValue, option, filterValue || {});
        onChange(newFilter);
    }, [option, filterValue, onChange]);
    // Extract range value from search filter format
    let currentValue = [];
    if (filterValue) {
        currentValue = rangeFilterGetUIValue(filterValue, option);
    }
    // Ensure we have a valid range
    if (currentValue.length === 0) {
        currentValue = [
            numericValidValues[0] || 0,
            numericValidValues[numericValidValues.length - 1] || 100,
        ];
    }
    // Use the same pattern as MediaGallery components
    const Comp = asChild ? Slot : 'div';
    // Default rendering - Radix Slider for better UX
    const minBound = numericValidValues[0] || 0;
    const maxBound = numericValidValues[numericValidValues.length - 1] || 100;
    const minValue = currentValue[0] || minBound;
    const maxValue = currentValue[1] || maxBound;
    // Local state for smooth slider interaction
    const [localValue, setLocalValue] = React.useState([minValue, maxValue]);
    // Update local state when external value changes
    React.useEffect(() => {
        setLocalValue([minValue, maxValue]);
    }, [minValue, maxValue]);
    if (!asChild && !children) {
        return (_jsxs("div", { ref: ref, "data-testid": TestIds.filterOptionRange, "data-filter-type": "range", "data-display-type": option.displayType, className: otherProps.className, children: [_jsxs(Slider.Root, { value: localValue, onValueChange: setLocalValue, onValueCommit: updateFilter, min: minBound, max: maxBound, step: 1, children: [_jsx(Slider.Track, { children: _jsx(Slider.Range, {}) }), _jsx(Slider.Thumb, {}), _jsx(Slider.Thumb, {})] }), _jsxs("div", { children: [_jsx("span", { "data-range-value": "min", children: option.valueFormatter
                                ? option.valueFormatter(localValue[0] ?? minBound)
                                : (localValue[0] ?? minBound) }), _jsx("span", { "data-range-value": "max", children: option.valueFormatter
                                ? option.valueFormatter(localValue[1] ?? maxBound)
                                : (localValue[1] ?? maxBound) })] })] }));
    }
    // Custom rendering with asChild/children - fallback to inputs
    return (_jsx(Comp, { ref: ref, "data-testid": TestIds.filterOptionRange, "data-filter-type": "range", "data-display-type": option.displayType, ...otherProps, children: children || (_jsxs(_Fragment, { children: [_jsx("input", { type: "number", value: minValue, onChange: (e) => updateFilter([Number(e.target.value), maxValue]), placeholder: "Min" }), _jsx("span", { children: "to" }), _jsx("input", { type: "number", value: maxValue, onChange: (e) => updateFilter([minValue, Number(e.target.value)]), placeholder: "Max" })] })) }));
});
// ============================================================================
// EXPORTS WITH NAMESPACING
// ============================================================================
/**
 * Action components namespace
 */
export const Action = {
    Clear,
};
/**
 * FilterOption components namespace
 */
export const FilterOption = {
    Label: FilterOptionLabel,
    SingleFilter,
    MultiFilter,
    RangeFilter,
};
// Set display names for debugging
Root.displayName = 'Filter.Root';
Filtered.displayName = 'Filter.Filtered';
FilterOptions.displayName = 'Filter.FilterOptions';
FilterOptionRepeater.displayName = 'Filter.FilterOptionRepeater';
Clear.displayName = 'Filter.Action.Clear';
FilterOptionLabel.displayName = 'Filter.FilterOption.Label';
SingleFilter.displayName = 'Filter.FilterOption.SingleFilter';
MultiFilter.displayName = 'Filter.FilterOption.MultiFilter';
RangeFilter.displayName = 'Filter.FilterOption.RangeFilter';
