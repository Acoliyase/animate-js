import { Plugin, PluginKey } from "@tiptap/pm/state";
import { createRicosFunctionalExtension } from "./create-ricos-extension/create-ricos-functional-extension.js";
const MAX_TEXT_LENGTH = 5e5;
const characterCount = createRicosFunctionalExtension({
  type: "extension",
  groups: [],
  name: "characterCount",
  reconfigure: (config, _extensions, ricosProps) => ({
    ...config,
    addOptions() {
      return {
        maxTextLength: Math.min(ricosProps.maxTextLength || MAX_TEXT_LENGTH, MAX_TEXT_LENGTH),
        mode: "textSize"
      };
    }
  }),
  createExtensionConfig() {
    return {
      name: this.name,
      addStorage() {
        return {
          characters: () => 0,
          words: () => 0
        };
      },
      onBeforeCreate() {
        this.storage.characters = (options) => {
          const node = options?.node || this.editor.state.doc;
          const mode = options?.mode || this.options.mode;
          if (mode === "textSize") {
            const text = node.textBetween(0, node.content.size, void 0, " ");
            return text.length;
          }
          return node.nodeSize;
        };
        this.storage.words = (options) => {
          const node = options?.node || this.editor.state.doc;
          const text = node.textBetween(0, node.content.size, " ", " ");
          const words = text.split(" ").filter((word) => word !== "");
          return words.length;
        };
      },
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("characterCount"),
            filterTransaction: (transaction, state) => {
              const limit = this.options.maxTextLength;
              if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
                return true;
              }
              const oldSize = this.storage.characters({ node: state.doc, mode: this.options.mode });
              const newSize = this.storage.characters({
                node: transaction.doc,
                mode: this.options.mode
              });
              if (newSize <= limit) {
                return true;
              }
              if (oldSize > limit && newSize > limit && newSize <= oldSize) {
                return true;
              }
              if (oldSize > limit && newSize > limit && newSize > oldSize) {
                return false;
              }
              const isPaste = transaction.getMeta("paste");
              if (!isPaste) {
                return false;
              }
              const pos = transaction.selection.$head.pos;
              const over = newSize - limit;
              const from = pos - over;
              const to = pos;
              transaction.deleteRange(from, to);
              const updatedSize = this.storage.characters({
                node: transaction.doc,
                mode: this.options.mode
              });
              if (updatedSize > limit) {
                return false;
              }
              return true;
            }
          })
        ];
      }
    };
  }
});
export {
  characterCount
};
//# sourceMappingURL=character-count.js.map
