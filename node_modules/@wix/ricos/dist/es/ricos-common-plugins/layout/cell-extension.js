import { findParentNodeClosestToPos } from "@tiptap/core";
import { TIPTAP_LAYOUT_CELL_TYPE, TIPTAP_LAYOUT_TYPE } from "./../../ricos-content/index.js";
import { findNodeById } from "./../../tiptap-editor/helpers/index.js";
import { createRicosNodeExtension } from "./../../tiptap-extensions/index.js";
import { cellNodeView } from "./cell-node-view.js";
import { createEmptyCell, MAX_CELLS, MAX_COLUMNS } from "./shared.js";
const canAddCells = (tr) => {
  const layoutNode = findParentNodeClosestToPos(
    tr.selection.$from,
    (node) => node.type?.name === TIPTAP_LAYOUT_TYPE
  )?.node;
  if (!layoutNode) {
    return false;
  }
  return layoutNode.childCount < MAX_CELLS;
};
const getSiblingNode = (tr, nodeId, direction) => {
  const parentNodeId = getParentNodeId(tr, nodeId);
  const parentNodeWithPos = findNodeById(tr, parentNodeId)[0];
  if (!parentNodeWithPos || parentNodeWithPos.node.childCount === 1) {
    return null;
  }
  let currentNodeIndex = -1;
  parentNodeWithPos.node.forEach((node, _offset, index) => {
    if (node.attrs.id === nodeId) {
      currentNodeIndex = index;
    }
  });
  if (currentNodeIndex < 0) {
    return null;
  }
  if (direction === "left" && currentNodeIndex === 0) {
    return null;
  }
  if (direction === "right" && currentNodeIndex === parentNodeWithPos.node.childCount - 1) {
    return null;
  }
  return parentNodeWithPos.node.child(currentNodeIndex + (direction === "left" ? -1 : 1));
};
const getParentNodeId = (tr, nodeId) => {
  const nodeWithPos = findNodeById(tr, nodeId)[0];
  const $pos = tr.doc.resolve(nodeWithPos.pos);
  return $pos.parent.attrs.id;
};
const cellExtension = createRicosNodeExtension({
  groups: ["custom-styles"],
  type: "html-node",
  name: TIPTAP_LAYOUT_CELL_TYPE,
  reconfigure: (config, _extensions, _props, _settings, services) => {
    return {
      ...config,
      draggable: !services.context.isMobile
    };
  },
  createExtensionConfig() {
    return {
      name: this.name,
      group: "block",
      isolating: true,
      selectable: true,
      draggable: true,
      content: "(PARAGRAPH|layoutCellContent)*",
      parseHTML() {
        return [
          {
            tag: "div[data-layout-cell]",
            getAttrs: (node) => {
              const colSpan = Number(
                node.getAttribute("data-layout-cell-colspan") ?? MAX_COLUMNS / MAX_CELLS
              );
              return {
                colSpan: isNaN(colSpan) ? MAX_COLUMNS / MAX_CELLS : colSpan
              };
            }
          }
        ];
      },
      renderHTML({ node }) {
        return [
          "div",
          { "data-layout-cell": true, "data-layout-cell-colspan": node.attrs.colSpan },
          0
        ];
      },
      addNodeView() {
        return cellNodeView.bind(this);
      },
      addAttributes: () => ({
        colSpan: null
      }),
      addCommands() {
        return {
          selectCell: (nodeId) => ({ commands, tr }) => {
            const nodeWithPos = findNodeById(tr, nodeId)[0];
            return commands.setNodeSelection(nodeWithPos.pos);
          },
          deleteCell: (nodeId) => ({ tr, chain }) => {
            const nodeWithPos = findNodeById(tr, nodeId)[0];
            const parentNodeId = getParentNodeId(tr, nodeId);
            const parentNodeWithPos = findNodeById(tr, parentNodeId)[0];
            if (parentNodeWithPos.node.childCount === 1) {
              return chain().deleteRange({
                from: parentNodeWithPos.pos,
                to: parentNodeWithPos.pos + parentNodeWithPos.node.nodeSize
              }).run();
            }
            return chain().deleteRange({
              from: nodeWithPos.pos,
              to: nodeWithPos.pos + nodeWithPos.node.nodeSize
            }).balanceLayoutCells(parentNodeId).focus().run();
          },
          addCellLeft: (nodeId) => ({ tr, dispatch, chain }) => {
            if (!dispatch) {
              return canAddCells(tr);
            }
            const nodeWithPos = findNodeById(tr, nodeId)[0];
            const parentNodeId = getParentNodeId(tr, nodeId);
            return chain().focus().insertContentAt(nodeWithPos.pos, createEmptyCell(3)).balanceLayoutCells(parentNodeId).run();
          },
          addCellRight: (nodeId) => ({ tr, dispatch, chain }) => {
            if (!dispatch) {
              return canAddCells(tr);
            }
            const nodeWithPos = findNodeById(tr, nodeId)[0];
            const parentNodeId = getParentNodeId(tr, nodeId);
            return chain().focus().insertContentAt(nodeWithPos.pos + nodeWithPos.node.nodeSize, createEmptyCell(3)).balanceLayoutCells(parentNodeId).run();
          },
          moveCellLeft: (nodeId) => ({ tr, dispatch, chain }) => {
            const nodeWithPos = findNodeById(tr, nodeId)[0];
            const nodeBefore = getSiblingNode(tr, nodeId, "left");
            if (!nodeBefore) {
              return false;
            }
            const nodeBeforeWithPos = findNodeById(tr, nodeBefore.attrs.id)[0];
            if (dispatch) {
              return chain().focus().cut(
                { from: nodeWithPos.pos, to: nodeWithPos.pos + nodeWithPos.node.nodeSize },
                nodeBeforeWithPos.pos
              ).selectCell(nodeId).run();
            }
            return true;
          },
          moveCellRight: (nodeId) => ({ tr, dispatch, chain }) => {
            const nodeWithPos = findNodeById(tr, nodeId)[0];
            const nodeAfter = getSiblingNode(tr, nodeId, "right");
            if (!nodeAfter) {
              return false;
            }
            const nodeAfterWithPos = findNodeById(tr, nodeAfter.attrs.id)[0];
            if (dispatch) {
              return chain().focus().cut(
                { from: nodeWithPos.pos, to: nodeWithPos.pos + nodeWithPos.node.nodeSize },
                nodeAfterWithPos.pos + nodeAfterWithPos.node.nodeSize
              ).selectCell(nodeId).run();
            }
            return true;
          }
        };
      }
    };
  }
});
export {
  cellExtension
};
//# sourceMappingURL=cell-extension.js.map
