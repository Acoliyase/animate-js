"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var addImage_exports = {};
__export(addImage_exports, {
  addImage: () => addImage,
  createImageData: () => createImageData
});
module.exports = __toCommonJS(addImage_exports);
var import_lodash = __toESM(require("lodash"));
var import_fp_utils = require("../../fp-utils.js");
const imageElementRegex = /^wix:image:\/\/v1\/(.+)\/(.+)#originWidth=(\d+)&originHeight=(\d+)/i;
const urlRegex = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w.-]+)+[\w\-._~:/?#[\]@!$&'()*+,;=.]+$/g;
const parseImageElement = (data) => {
  const vars = imageElementRegex.exec(data.src);
  if (typeof data.src !== "string" || vars === null) {
    throw new Error("Source format is invalid. Received:\n" + JSON.stringify(data));
  }
  const { alt } = data;
  const [, uri, fileName, originWidth, originHeight] = vars;
  return { uri, fileName, width: parseInt(originWidth), height: parseInt(originHeight), alt };
};
function isImageElement(data) {
  return !!data && !import_lodash.default.isString(data) && !!Object.keys(data).includes("src");
}
const asPublicUrl = (data) => ({
  image: { src: { url: data } }
});
const asImageElement = (data) => {
  if (data.src.match(urlRegex)) {
    return { image: { src: { url: data.src } } };
  }
  const { width, height, uri: id, alt } = parseImageElement(data);
  return { altText: alt, image: { src: { id }, width, height } };
};
const toImageData = (data) => (0, import_fp_utils.firstRight)(data, data, [
  // @ts-ignore $TsFixMe
  [import_lodash.default.isString, asPublicUrl],
  // @ts-ignore $TsFixMe
  [isImageElement, asImageElement]
]);
const addImage = ({
  data,
  ...rest
} = {}) => ({
  data: toImageData(data),
  ...rest
});
const createImageData = (data) => toImageData(data);
//# sourceMappingURL=addImage.js.map
