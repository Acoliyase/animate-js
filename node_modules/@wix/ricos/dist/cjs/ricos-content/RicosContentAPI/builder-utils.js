"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var builder_utils_exports = {};
__export(builder_utils_exports, {
  addNode: () => addNode,
  toListDataArray: () => toListDataArray,
  toTextDataArray: () => toTextDataArray
});
module.exports = __toCommonJS(builder_utils_exports);
var A = __toESM(require("fp-ts-esm/Array"));
var import_function = require("fp-ts-esm/function");
var O = __toESM(require("fp-ts-esm/Option"));
var import_lodash = __toESM(require("lodash"));
var import_fp_utils = require("../fp-utils.js");
var import_modify = require("./modify.js");
const isIndexFound = (predicate) => (0, import_function.flow)(
  (content) => content.nodes,
  A.findIndex(predicate),
  O.fold(
    () => false,
    () => true
  )
);
const isIndexInRange = (index) => (content) => import_lodash.default.isNumber(index) && index >= 0 && index < (content.nodes?.length ?? 0);
const insertNode = (node, index) => (content) => ({
  ...content,
  nodes: [...content.nodes?.slice(0, index) ?? [], node, ...content.nodes?.slice(index) ?? []]
});
const insertNodeByKey = (node, nodeKey, isAfter = false) => (content) => (0, import_modify.modify)(content).filter(({ id }) => id === nodeKey).set((n) => isAfter ? [n, node] : [node, n]);
function addNode({
  node,
  index,
  before,
  after,
  content
}) {
  return (0, import_fp_utils.firstRight)(content, { ...content, nodes: [...content?.nodes ?? [], node] }, [
    [isIndexInRange(index), insertNode(node, index)],
    [isIndexFound(({ id }) => id === before), insertNodeByKey(node, before, false)],
    [isIndexFound(({ id }) => id === after), insertNodeByKey(node, after, true)]
  ]);
}
const isTextData = (text) => !!text?.text && !!text?.decorations;
const toTextData = (text) => ({ text, decorations: [] });
const isListItemData = (item) => import_lodash.default.isArray(item.text) && import_lodash.default.isObject(item.data);
const toListItemData = (data) => (text) => ({ data, text });
const emptyListItemData = { text: [], data: {} };
const toListDataArray = (items, data) => (0, import_fp_utils.firstRight)(
  // @ts-ignore $TSFixMe
  items,
  [],
  [
    [import_lodash.default.isString, (0, import_function.flow)(toTextData, A.of, toListItemData(data), A.of)],
    [isTextData, (0, import_function.flow)(A.of, toListItemData(data), A.of)],
    // @ts-ignore $TSFixMe
    [isListItemData, (i) => [i]],
    [
      import_lodash.default.isArray,
      (0, import_function.flow)(
        A.map(
          (item) => (
            // @ts-ignore $TSFixMe
            (0, import_fp_utils.firstRight)(item, emptyListItemData, [
              [import_lodash.default.isString, (0, import_function.flow)(toTextData, A.of, toListItemData(data))],
              [isTextData, (0, import_function.flow)(A.of, toListItemData(data))],
              // @ts-ignore $TSFixMe
              [isListItemData, (i) => i]
            ])
          )
        )
      )
    ]
  ]
);
const toTextDataArray = (text) => (0, import_fp_utils.firstRight)(
  // @ts-ignore $TSFixMe
  text,
  [],
  [
    [import_lodash.default.isString, (0, import_function.flow)(toTextData, A.of)],
    [isTextData, (t) => [t]],
    [
      import_lodash.default.isArray,
      // @ts-ignore $TSFixMe
      (0, import_function.flow)(A.map((t) => (0, import_fp_utils.firstRight)(t, t, [[import_lodash.default.isString, toTextData]])))
    ]
  ]
);
//# sourceMappingURL=builder-utils.js.map
