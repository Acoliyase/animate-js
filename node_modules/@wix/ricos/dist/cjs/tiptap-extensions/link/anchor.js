"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var anchor_exports = {};
__export(anchor_exports, {
  anchor: () => anchor
});
module.exports = __toCommonJS(anchor_exports);
var import_core = require("@tiptap/core");
var import_state = require("@tiptap/pm/state");
var import_classnames = __toESM(require("classnames"));
var import_v1 = require("./../../ricos-schema/legacy/wix/rich_content/v1/index.js");
var import_create_ricos_extension = require("../create-ricos-extension/index.js");
var import_styles_scss = __toESM(require("../statics/styles-scss.js"));
var import_data_hooks = require("./data-hooks.js");
var import_utils = require("./utils.js");
const scrollIntoViewWithOffset = (element) => {
  element.scrollIntoView({ behavior: "smooth", block: "nearest" });
};
const anchor = (0, import_create_ricos_extension.createRicosMarkExtension)({
  type: "mark",
  groups: [],
  name: import_v1.Decoration_Type.ANCHOR,
  createExtensionConfig() {
    return {
      name: this.name,
      keepOnSplit: false,
      priority: 1e3,
      addOptions: () => ({
        inclusive: false,
        HTMLAttributes: {}
      }),
      inclusive() {
        return this.options.inclusive;
      },
      addAttributes() {
        return {
          anchor: {
            default: ""
          }
        };
      },
      renderHTML({ HTMLAttributes }) {
        const { link, linkInViewer } = import_styles_scss.default;
        const classes = (0, import_classnames.default)(link, linkInViewer);
        const anchorAttributes = HTMLAttributes.anchor ? {
          "ricos-anchor": HTMLAttributes.anchor,
          href: `#${HTMLAttributes.anchor}`,
          target: "_self"
        } : {};
        return [
          "a",
          (0, import_core.mergeAttributes)(this.options.HTMLAttributes, {
            ...anchorAttributes,
            class: classes,
            "data-hook": import_data_hooks.ANCHOR_LINK
          }),
          0
        ];
      },
      parseHTML() {
        return [
          {
            tag: `a[data-hook~=${import_data_hooks.ANCHOR_LINK}][ricos-anchor]`,
            getAttrs: (node) => {
              const anchor2 = node.getAttribute("ricos-anchor") ?? "";
              return { anchor: anchor2 };
            }
          }
        ];
      },
      addCommands() {
        return {
          setAnchor: (data) => ({ commands, state, tr, chain }) => {
            (0, import_utils.cleanAndSetSelection)(
              this.name,
              import_v1.Decoration_Type.LINK,
              commands.unsetLink,
              state.schema,
              tr.selection,
              state.doc,
              commands,
              data.defaultName || ""
            );
            const setLinkChain = chain().setMark(this.name, { anchor: data.anchor });
            return setLinkChain.setUnderline().run();
          },
          unsetAnchor: () => ({ tr, state, chain }) => {
            const { from, to } = (0, import_utils.getSelectedMarkRangeByTypeNames)(
              [this.name],
              state.schema,
              tr.selection
            );
            const unsetLinkChain = chain().setTextSelection({ from, to }).unsetMark(this.name);
            return unsetLinkChain.unsetUnderline().run();
          },
          scrollToAnchor: (anchor2) => ({ editor, tr }) => {
            const { view } = editor;
            const foundNodes = (0, import_core.findChildren)(view.state.doc, (node) => {
              return node?.attrs?.id?.toString() === anchor2;
            });
            if (foundNodes.length === 0) {
              return false;
            }
            const targetNode = foundNodes[0];
            let targetDom = view.nodeDOM(targetNode.pos);
            if (targetDom && targetDom instanceof HTMLElement && !targetDom.scrollIntoView) {
              targetDom = targetDom.parentElement;
            }
            if (targetDom && targetDom instanceof HTMLElement) {
              scrollIntoViewWithOffset(targetDom);
              try {
                if (targetNode.node.isText || targetNode.node.isTextblock) {
                  tr.setSelection(
                    import_state.TextSelection.between(
                      tr.doc.resolve(targetNode.pos),
                      tr.doc.resolve(targetNode.pos)
                    )
                  );
                } else {
                  tr.setSelection(import_state.NodeSelection.create(tr.doc, targetNode.pos));
                }
              } catch (e) {
                console.error("Failed to set selection on anchor", e);
              }
              return true;
            } else {
              return false;
            }
          }
        };
      }
    };
  }
});
//# sourceMappingURL=anchor.js.map
