interface EventGuest {
    /**
     * Guest ID.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * RSVP ID. <br/> <br/> **Note:** Only applicable when `guestType` is `"RSVP"`.
     * @format GUID
     */
    rsvpId?: string | null;
    /**
     * Order number. <br/> <br/> **Note:** Only applicable when `guestType` is `"BUYER"` or `"TICKET_HOLDER"`.
     * @maxLength 36
     */
    orderNumber?: string | null;
    /**
     * Ticket number. <br/> <br/> **Note:** Only applicable when `guestType` is `"TICKET_HOLDER"`.
     * @maxLength 36
     */
    ticketNumber?: string | null;
    /**
     * List of names, numbers, and definition IDs for each ticket.
     * @maxSize 50
     */
    tickets?: TicketDetails[];
    /**
     * Guest's contact ID. See the Contacts API for more details.
     * @format GUID
     */
    contactId?: string | null;
    /** Guest details. <br/> <br/> Returned only when the `guestDetails` fieldset is sent in the request. */
    guestDetails?: GuestDetails;
    /**
     * Attendance status. The attendance status updates based on status values in an RSVP object (for RSVP events) or in an Order object (for ticketed events).
     * For more information, see [Guest Attendance Status Mapping](https://dev.wix.com/docs/api-reference/business-solutions/events/registration/event-guests/guest-attendance-status-mapping). <br/> <br/> **Note:** For `guestType` of `"BUYER"` or `"TICKET_HOLDER"` the `"IN_WAITLIST"` value is not applicable.
     */
    attendanceStatus?: AttendanceStatusWithLiterals;
    /**
     * Secondary language code in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. Used when the event ticket should be translated into another language.
     * @format LANGUAGE
     */
    secondaryLanguageCode?: string | null;
    /** Date and time the guest was created in `yyyy-mm-ddThh:mm:sssZ` format. */
    _createdDate?: Date | null;
    /** Date and time the guest was updated in `yyyy-mm-ddThh:mm:sssZ` format. */
    _updatedDate?: Date | null;
    /** Date and time of guest's latest attendance status update. */
    attendanceStatusUpdatedDate?: Date | null;
    /**
     * Site member ID.
     * @format GUID
     */
    memberId?: string | null;
    /** Guest type. */
    guestType?: GuestTypeWithLiterals;
    /**
     * Locale in [IETF BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) format. Used when the event date and time on a ticket should be formatted into another locale.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Number of total guests in an event (registered guests + additional ones).
     * @readonly
     */
    totalGuests?: number | null;
    /**
     * Revision number, which increments by 1 each time the guest is updated.
     * @readonly
     */
    revision?: string | null;
}
interface TicketDetails {
    /**
     * Ticket number.
     * @maxLength 36
     */
    number?: string;
    /**
     * Ticket definition ID.
     * @format GUID
     */
    definitionId?: string | null;
    /**
     * Ticket name.
     * @minLength 1
     * @maxLength 30
     */
    name?: string | null;
}
interface TicketGuestDetails {
    /** The login details for the guest to access the online conference event. */
    onlineConferencingLogin?: OnlineConferencingLogin;
    /**
     * First name.
     * @maxLength 255
     */
    firstName?: string | null;
    /**
     * Last name.
     * @maxLength 255
     */
    lastName?: string | null;
}
interface OnlineConferencingLogin {
    /**
     * Link URL to the online conference.
     * @format WEB_URL
     * @readonly
     */
    link?: string;
    /**
     * Password for the online conference.
     * @readonly
     */
    password?: string | null;
}
interface GuestDetails {
    /**
     * Email.
     * @format EMAIL
     */
    email?: string | null;
    /**
     * First name.
     * @maxLength 255
     */
    firstName?: string | null;
    /**
     * Last name.
     * @maxLength 255
     */
    lastName?: string | null;
    /** Form response. */
    formResponse?: FormResponse;
    /** Whether the guest has checked into the event. */
    checkedIn?: boolean;
    /** The login details for the guest to access the online conference event. */
    onlineConferencingLogin?: OnlineConferencingLogin;
    /**
     * Phone extracted from form response. If multiples phone inputs are present, first one is returned.
     * @maxLength 200
     */
    phone?: string | null;
    /**
     * Address extracted from form response. If multiples address inputs are present, first one is returned.
     * @maxLength 200
     */
    address?: string | null;
}
interface FormResponse {
    /**
     * Form field inputs.
     * @maxSize 200
     */
    inputValues?: InputValue[];
}
interface InputValue {
    /**
     * Form field input name.
     * @maxLength 100
     */
    inputName?: string;
    /**
     * Form field value.
     * @maxLength 5000
     */
    value?: string;
    /**
     * Form field values.
     * @maxSize 100
     * @maxLength 5000
     */
    values?: string[];
}
interface FormattedAddress {
    /**
     * 1-line address representation.
     * @maxLength 200
     */
    formatted?: string;
    /** Address components. */
    address?: Address;
}
/** Physical address */
interface Address extends AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
/** @oneof */
interface AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
}
interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
}
interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
interface Subdivision {
    /** Short subdivision code. */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
/** Subdivision Concordance values */
interface StandardDetails {
    /**
     * subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30
     * @maxLength 20
     */
    iso31662?: string | null;
}
declare enum AttendanceStatus {
    /** Not attending. */
    NOT_ATTENDING = "NOT_ATTENDING",
    /** Attending. */
    ATTENDING = "ATTENDING",
    /** In a waiting list. */
    IN_WAITLIST = "IN_WAITLIST"
}
/** @enumType */
type AttendanceStatusWithLiterals = AttendanceStatus | 'NOT_ATTENDING' | 'ATTENDING' | 'IN_WAITLIST';
declare enum GuestType {
    /** An invited guest, no ticket necessary. */
    RSVP = "RSVP",
    /** The guest who bought the ticket. */
    BUYER = "BUYER",
    /** The guest for whom the ticket was bought. */
    TICKET_HOLDER = "TICKET_HOLDER"
}
/** @enumType */
type GuestTypeWithLiterals = GuestType | 'RSVP' | 'BUYER' | 'TICKET_HOLDER';
interface GuestCountUpdated {
    /** Guest. */
    guest?: EventGuest;
    /**
     * Guest count updates.
     * @maxSize 2
     */
    guestCountUpdates?: GuestCountUpdate[];
}
interface GuestCountUpdate {
    /** Attendance status. */
    attendanceStatus?: AttendanceStatusWithLiterals;
    /** Total guest count change. */
    totalGuestsDelta?: number;
    /** Guest count change. */
    countDelta?: number;
}
interface MemberEventStatusUpdated {
    /**
     * Event id.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Member id.
     * @format GUID
     */
    memberId?: string | null;
    /** Member event status. */
    status?: MemberEventStatusUpdatedEventTypeWithLiterals;
}
declare enum MemberEventStatusUpdatedEventType {
    /**
     * Triggered every time a guest with a specified member ID is added to the event.
     * This event can also be triggered if an existing guest changed their member ID.
     */
    MEMBER_JOINED = "MEMBER_JOINED",
    /**
     * Triggered every time a guest with a specified member ID is removed from the event.
     * This event can also be triggered if an existing guest changed their member ID.
     */
    MEMBER_LEFT = "MEMBER_LEFT",
    /**
     * Triggered every time a guest with a specified member ID whose status is `"ATTENDING"` is added to the event.
     * This event can also be triggered if an existing guest changed their member ID or changed their status to `"ATTENDING"`.
     */
    ATTENDING_MEMBER_JOINED = "ATTENDING_MEMBER_JOINED",
    /**
     * Triggered when the last guest with a specified member ID is removed from the event or their status changes to `"NOT_ATTENDING"`.
     * Once triggered there are no more attending guests with a specified member ID in the event.
     * This event can also be triggered if the last existing guest changed their member ID or their status to `"NOT_ATTENDING"`.
     */
    LAST_ATTENDING_MEMBER_LEFT = "LAST_ATTENDING_MEMBER_LEFT"
}
/** @enumType */
type MemberEventStatusUpdatedEventTypeWithLiterals = MemberEventStatusUpdatedEventType | 'MEMBER_JOINED' | 'MEMBER_LEFT' | 'ATTENDING_MEMBER_JOINED' | 'LAST_ATTENDING_MEMBER_LEFT';
interface ContactEventStatusUpdated {
    /**
     * Event id.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Contact id.
     * @format GUID
     */
    contactId?: string | null;
    /** Contact event status. */
    status?: EventTypeWithLiterals;
}
declare enum EventType {
    /**
     * Triggered every time a guest with a specified contact ID is added to the event.
     * This event can also be triggered if an existing guest changed their contact ID.
     */
    CONTACT_JOINED = "CONTACT_JOINED",
    /**
     * Triggered every time a guest with a specified contact ID is removed from the event.
     * This event can also be triggered if an existing guest changed their contact ID.
     */
    CONTACT_LEFT = "CONTACT_LEFT",
    /**
     * Triggred when the last guest with a specified contact ID is removed from the event.
     * Once triggered there are no more guests with a specified contact ID in the event.
     * This event can also be triggered if the last existing guest changed their contact ID.
     */
    LAST_CONTACT_LEFT = "LAST_CONTACT_LEFT"
}
/** @enumType */
type EventTypeWithLiterals = EventType | 'CONTACT_JOINED' | 'CONTACT_LEFT' | 'LAST_CONTACT_LEFT';
interface GuestCheckedIn {
    /** Event guest */
    guest?: EventGuest;
    /** Event details */
    eventDetails?: EventDetails;
}
interface EventDetails {
    /**
     * Event title.
     * @minLength 1
     * @maxLength 120
     * @readonly
     */
    title?: string | null;
    /**
     * Event short description.
     * @maxLength 500
     * @readonly
     */
    shortDescription?: string | null;
    /**
     * Event location.
     * @readonly
     */
    location?: Location;
    /**
     * Event date  and time settings.
     * @readonly
     */
    dateAndTimeSettings?: DateAndTimeSettings;
    /**
     * Event page URL components.
     * @readonly
     */
    eventPageUrl?: string;
    /**
     * Event status.
     * @readonly
     */
    status?: StatusWithLiterals;
}
interface Location {
    /**
     * Location name. This value is displayed instead of the address when the location is defined as TBD by setting the `locationTbd` property to `true`.
     * @maxLength 50
     */
    name?: string | null;
    /** Location type. */
    type?: LocationTypeWithLiterals;
    /** Exact location address. */
    address?: CommonAddress;
    /** Whether the event location is TBD. */
    locationTbd?: boolean | null;
}
declare enum LocationType {
    /** Unknown location type. */
    UNKNOWN_LOCATION = "UNKNOWN_LOCATION",
    /** Event is on-site at a specific physical location. */
    VENUE = "VENUE",
    /** Event is online, such as a virtual video conference. */
    ONLINE = "ONLINE"
}
/** @enumType */
type LocationTypeWithLiterals = LocationType | 'UNKNOWN_LOCATION' | 'VENUE' | 'ONLINE';
/** Physical address */
interface CommonAddress extends CommonAddressStreetOneOf {
    /** Street address. */
    streetAddress?: CommonStreetAddress;
    /**
     * Primary address information (street and building number).
     * @maxLength 250
     */
    addressLine1?: string | null;
    /**
     * 2-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format.
     * @format COUNTRY
     */
    country?: string | null;
    /**
     * Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2).
     * @maxLength 20
     */
    subdivision?: string | null;
    /**
     * City name.
     * @maxLength 100
     */
    city?: string | null;
    /**
     * Zip or postal code.
     * @maxLength 100
     */
    postalCode?: string | null;
    /**
     * Secondary address information (suite or apartment number and room number).
     * @maxLength 250
     */
    addressLine2?: string | null;
}
/** @oneof */
interface CommonAddressStreetOneOf {
    /** Street address. */
    streetAddress?: CommonStreetAddress;
    /**
     * Primary address information (street and building number).
     * @maxLength 250
     */
    addressLine?: string | null;
}
interface CommonStreetAddress {
    /**
     * Street number.
     * @maxLength 100
     */
    number?: string;
    /**
     * Street name.
     * @maxLength 250
     */
    name?: string;
}
interface CommonAddressLocation {
    /**
     * Address latitude coordinates.
     * @min -90
     * @max 90
     */
    latitude?: number | null;
    /**
     * Address longitude coordinates.
     * @min -180
     * @max 180
     */
    longitude?: number | null;
}
interface CommonSubdivision {
    /**
     * Short subdivision code.
     * @maxLength 100
     */
    code?: string;
    /**
     * Subdivision full name.
     * @maxLength 250
     */
    name?: string;
}
declare enum SubdivisionSubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionSubdivisionTypeWithLiterals = SubdivisionSubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
interface DateAndTimeSettings {
    /** Whether the event date and time are TBD. */
    dateAndTimeTbd?: boolean | null;
    /**
     * Message that is displayed when time and date is TBD.
     *
     * **Note:** This field is only used when the `dateAndTimeTbd` field value is `true`.
     * @maxLength 100
     */
    dateAndTimeTbdMessage?: string | null;
    /**
     * Event start date.
     *
     * **Note:** This field is only returned when the `dateAndTimeTbd` field value is `false`.
     */
    startDate?: Date | null;
    /**
     * Event end date.
     *
     * **Note:** This field is only returned when the `dateAndTimeTbd` field value is `false`.
     */
    endDate?: Date | null;
    /**
     * Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format.
     *
     * **Note:** This field is only returned when the `dateAndTimeTbd` field value is `false`.
     * @maxLength 100
     */
    timeZoneId?: string | null;
    /** Whether the end date is hidden in the formatted date and time. */
    hideEndDate?: boolean | null;
    /** Whether the time zone is displayed in the formatted schedule. */
    showTimeZone?: boolean | null;
    /**
     * Repeating event status.
     * @readonly
     */
    recurrenceStatus?: RecurrenceStatusStatusWithLiterals;
    /** Event repetitions. */
    recurringEvents?: Recurrences;
    /** Formatted date and time settings. */
    formatted?: Formatted;
}
declare enum RecurrenceStatusStatus {
    /** Unknown recurrance status. */
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Event happens only once and can last multiple days. */
    ONE_TIME = "ONE_TIME",
    /** A series of events that repeat. */
    RECURRING = "RECURRING",
    /** Next event in a schedule of recurring events. */
    RECURRING_UPCOMING = "RECURRING_UPCOMING",
    /** Latest event that ended in a schedule of recurring events. */
    RECURRING_RECENTLY_ENDED = "RECURRING_RECENTLY_ENDED",
    /** Latest canceled event in a schedule of recurring events */
    RECURRING_RECENTLY_CANCELED = "RECURRING_RECENTLY_CANCELED"
}
/** @enumType */
type RecurrenceStatusStatusWithLiterals = RecurrenceStatusStatus | 'UNKNOWN_STATUS' | 'ONE_TIME' | 'RECURRING' | 'RECURRING_UPCOMING' | 'RECURRING_RECENTLY_ENDED' | 'RECURRING_RECENTLY_CANCELED';
interface Recurrences {
    /**
     * Individual event dates.
     * @maxSize 1000
     */
    individualEventDates?: Occurrence[];
    /**
     * Recurring event category ID.
     * @readonly
     * @maxLength 100
     */
    categoryId?: string | null;
}
interface Occurrence {
    /** Event start date. */
    startDate?: Date | null;
    /** Event end date. */
    endDate?: Date | null;
    /**
     * Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format.
     * @maxLength 100
     */
    timeZoneId?: string | null;
    /** Whether the time zone is displayed in a formatted schedule. */
    showTimeZone?: boolean;
}
interface Formatted {
    /**
     * Formatted date and time representation. <br>
     * Example of formatting when an event lasts multiple days and is in the UTC time zone: `September 1, 2015 at 10:20 AM – September 5, 2015 at 12:14 PM`. <br>
     * Example of formatting when an event lasts 1 day and is in the GMT+2 time zone: `February 1, 2018, 12:10 – 2:50 PM GMT+2`.
     * @readonly
     * @maxLength 500
     */
    dateAndTime?: string | null;
    /**
     * Formatted start date of the event. Empty for TBD schedules.
     * @readonly
     * @maxLength 500
     */
    startDate?: string | null;
    /**
     * Formatted start time of the event. Empty for TBD schedules.
     * @readonly
     * @maxLength 500
     */
    startTime?: string | null;
    /**
     * Formatted end date of the event. Empty for TBD schedules or when the end date is hidden.
     * @readonly
     * @maxLength 500
     */
    endDate?: string | null;
    /**
     * Formatted end time of the event. Empty for TBD schedules or when the end date is hidden.
     * @readonly
     * @maxLength 500
     */
    endTime?: string | null;
}
declare enum Status {
    /** Unknown event status. */
    UNKNOWN_EVENT_STATUS = "UNKNOWN_EVENT_STATUS",
    /** Event is published and scheduled to start. */
    UPCOMING = "UPCOMING",
    /** Event has started. */
    STARTED = "STARTED",
    /** Event has ended. */
    ENDED = "ENDED",
    /** Event is canceled. */
    CANCELED = "CANCELED",
    /** Event is not public. */
    DRAFT = "DRAFT"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNKNOWN_EVENT_STATUS' | 'UPCOMING' | 'STARTED' | 'ENDED' | 'CANCELED' | 'DRAFT';
interface NotifyGuestAction {
    /** Event guest. */
    guest?: EventGuest;
    /** Task context. */
    taskContext?: TaskContext;
}
interface TaskContext {
    /** Task id. */
    _id?: string | null;
    /** Notify action type. */
    type?: NotifyActionTypeWithLiterals;
    /** Timing. Used for EVENT_STARTS */
    timing?: TimingWithLiterals;
    /** Event context. */
    event?: EventDetails;
    /** Order context. */
    order?: OrderDetails;
}
declare enum NotifyActionType {
    UNKNOWN = "UNKNOWN",
    EMAIL = "EMAIL",
    AUTOMATION_TRIGGER = "AUTOMATION_TRIGGER",
    PUSH = "PUSH",
    EVENT_CANCELED = "EVENT_CANCELED",
    EVENT_STARTS = "EVENT_STARTS",
    ORDER_CANCELED = "ORDER_CANCELED"
}
/** @enumType */
type NotifyActionTypeWithLiterals = NotifyActionType | 'UNKNOWN' | 'EMAIL' | 'AUTOMATION_TRIGGER' | 'PUSH' | 'EVENT_CANCELED' | 'EVENT_STARTS' | 'ORDER_CANCELED';
declare enum Timing {
    /** Unknown event start time. */
    UNKNOWN_TIMING = "UNKNOWN_TIMING",
    /** Instant. */
    NOW = "NOW",
    /** 24 hours prior. */
    STARTS_IN_1_DAY = "STARTS_IN_1_DAY",
    /** 3 days prior. */
    STARTS_IN_3_DAYS = "STARTS_IN_3_DAYS",
    /** 7 days prior. */
    STARTS_IN_1_WEEK = "STARTS_IN_1_WEEK",
    /** 1 hour prior. */
    STARTS_IN_1_HOUR = "STARTS_IN_1_HOUR",
    /** 30 minutes prior. */
    STARTS_IN_30_MINUTES = "STARTS_IN_30_MINUTES",
    /** 2 hours prior. */
    STARTS_IN_2_HOURS = "STARTS_IN_2_HOURS"
}
/** @enumType */
type TimingWithLiterals = Timing | 'UNKNOWN_TIMING' | 'NOW' | 'STARTS_IN_1_DAY' | 'STARTS_IN_3_DAYS' | 'STARTS_IN_1_WEEK' | 'STARTS_IN_1_HOUR' | 'STARTS_IN_30_MINUTES' | 'STARTS_IN_2_HOURS';
interface OrderDetails {
    /** Order status */
    orderStatus?: OrderStatusWithLiterals;
    /** Invoice */
    invoice?: Invoice;
}
declare enum OrderStatus {
    /** Order status isn't available for this request fieldset. */
    NA_ORDER_STATUS = "NA_ORDER_STATUS",
    /** Order is confirmed, no payment is required. */
    FREE = "FREE",
    /** Order was paid, but the payment gateway suspended the payment. */
    PENDING = "PENDING",
    /** Order is paid. */
    PAID = "PAID",
    /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `"PAID"`. */
    OFFLINE_PENDING = "OFFLINE_PENDING",
    /** Order is waiting for payment at the cashier. */
    INITIATED = "INITIATED",
    /** Order is canceled. */
    CANCELED = "CANCELED",
    /** Order payment is declined. */
    DECLINED = "DECLINED",
    /** Order payment is authorized. */
    AUTHORIZED = "AUTHORIZED",
    /** Order payment is voided. */
    VOIDED = "VOIDED",
    /** Order is partially paid with less than the total amount. */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
/** @enumType */
type OrderStatusWithLiterals = OrderStatus | 'NA_ORDER_STATUS' | 'FREE' | 'PENDING' | 'PAID' | 'OFFLINE_PENDING' | 'INITIATED' | 'CANCELED' | 'DECLINED' | 'AUTHORIZED' | 'VOIDED' | 'PARTIALLY_PAID';
interface Invoice {
    items?: Item[];
    /**
     * Total cart amount.
     * @deprecated
     */
    total?: Money;
    /** Discount applied to a cart. */
    discount?: Discount;
    /** Tax applied to a cart. */
    tax?: Tax;
    /** Total cart amount before discount, tax, and fees. */
    subTotal?: Money;
    /**
     * Total amount of a cart after discount, tax, and fees.
     * Grand total is calculated in the following order:
     * 1. Total prices of all items in the cart are calculated.
     * 2. Discount is subtracted from the cart, if applicable.
     * 3. Tax is added, if applicable.
     * 4. Wix ticket service fee is added.
     */
    grandTotal?: Money;
    /**
     * Fees applied to the cart.
     * @readonly
     */
    fees?: Fee[];
    /** Total revenue, excluding fees. Taxes and payment provider fees aren't deducted. */
    revenue?: Money;
    /** Invoice preview URL. Only returned if the order is paid. */
    previewUrl?: string | null;
}
interface Item {
    /**
     * Unique line item ID.
     * @format GUID
     */
    _id?: string;
    /**
     * Line item quantity.
     * @min 1
     * @max 50
     */
    quantity?: number;
    /** Line item name. */
    name?: string;
    /** Line item price. */
    price?: Money;
    /** Total price for line items. Always equal to price * quantity. */
    total?: Money;
    /** Discount applied to the line item. */
    discount?: Discount;
    /** Tax applied to the item. */
    tax?: Tax;
    /**
     * Fees applied to the item.
     * @readonly
     */
    fees?: Fee[];
}
interface Money {
    /**
     * *Deprecated:** Use `value` instead.
     * @format DECIMAL_VALUE
     * @deprecated
     */
    amount?: string;
    /**
     * 3-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. For example, `USD`.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     */
    value?: string | null;
}
interface Discount {
    /** Total discount amount. */
    amount?: Money;
    /** Total sum after the discount. */
    afterDiscount?: Money;
    /**
     * Discount coupon code.
     * @deprecated
     */
    code?: string;
    /**
     * Discount coupon name.
     * @deprecated
     */
    name?: string;
    /**
     * Discount coupon ID.
     * @deprecated
     */
    couponId?: string;
    /** Discount items. */
    discounts?: DiscountItem[];
}
interface DiscountItem extends DiscountItemDiscountOneOf {
    /** Coupon discount. */
    coupon?: CouponDiscount;
    /** Pricing plan discount. */
    paidPlan?: PaidPlanDiscount;
    /** Total discount amount. */
    amount?: Money;
}
/** @oneof */
interface DiscountItemDiscountOneOf {
    /** Coupon discount. */
    coupon?: CouponDiscount;
    /** Pricing plan discount. */
    paidPlan?: PaidPlanDiscount;
}
interface CouponDiscount {
    /** Discount coupon name. **Deprecated:** Use `invoice.discounts.coupon.name` instead. */
    name?: string;
    /** Discount coupon code. **Deprecated:** Use `invoice.discounts.coupon.code` instead. */
    code?: string;
    /** Discount coupon ID. **Deprecated:** Use `invoice.discounts.coupon.couponId` instead. */
    couponId?: string;
}
interface PaidPlanDiscount extends PaidPlanDiscountDiscountOneOf {
    /** Discount by percentage applied to tickets. */
    percentDiscount?: PercentDiscount;
    /** Name of pricing plan. */
    name?: string;
}
/** @oneof */
interface PaidPlanDiscountDiscountOneOf {
    /** Discount by percentage applied to tickets. */
    percentDiscount?: PercentDiscount;
}
interface PercentDiscount {
    /**
     * Percent rate.
     * @decimalValue options { gte:0.01, lte:100, maxScale:2 }
     */
    rate?: string;
    /** Number of discounted tickets. */
    quantityDiscounted?: number;
}
interface Tax {
    /** Tax type. */
    type?: TaxTypeWithLiterals;
    /**
     * Tax name.
     * @readonly
     */
    name?: string;
    /**
     * Tax rate.
     * @format DECIMAL_VALUE
     */
    rate?: string;
    /** Taxable amount. */
    taxable?: Money;
    /** Total tax amount. */
    amount?: Money;
}
declare enum TaxType {
    /** Tax is included in the ticket price. */
    INCLUDED = "INCLUDED",
    /** Tax is added to the order at the checkout. */
    ADDED = "ADDED",
    /** Tax is added to the final total at the checkout. */
    ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
}
/** @enumType */
type TaxTypeWithLiterals = TaxType | 'INCLUDED' | 'ADDED' | 'ADDED_AT_CHECKOUT';
interface Fee {
    /** Fee identifier. */
    name?: FeeNameWithLiterals;
    /** How fee is calculated. */
    type?: FeeTypeWithLiterals;
    /**
     * Fee rate.
     * @format DECIMAL_VALUE
     * @readonly
     */
    rate?: string;
    /** Total amount of fee charges. */
    amount?: Money;
}
declare enum FeeName {
    /** Wix ticket service fee charges applied to the line item. */
    WIX_FEE = "WIX_FEE"
}
/** @enumType */
type FeeNameWithLiterals = FeeName | 'WIX_FEE';
declare enum FeeType {
    /** Fee is added to the ticket price at checkout. */
    FEE_ADDED = "FEE_ADDED",
    /** Seller absorbs the fee. It's deducted from the ticket price. */
    FEE_INCLUDED = "FEE_INCLUDED",
    /** Fee is added to the ticket price at checkout. */
    FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT"
}
/** @enumType */
type FeeTypeWithLiterals = FeeType | 'FEE_ADDED' | 'FEE_INCLUDED' | 'FEE_ADDED_AT_CHECKOUT';
interface GuestEventCanceled {
    /** Event guest. */
    guest?: EventGuest;
    /** Event context. */
    event?: EventDetails;
}
interface GuestEventStarts {
    /** Event guest. */
    guest?: EventGuest;
    /** Event context. */
    event?: EventDetails;
    /** Timing */
    timing?: TimingWithLiterals;
}
interface GuestOrderCanceled {
    /** Event guest. */
    guest?: EventGuest;
    /** Event context. */
    event?: EventDetails;
    /** Order context. */
    order?: OrderDetails;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface QueryEventGuestsRequest {
    /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
    query: QueryV2;
    /**
     * Predefined sets of fields to return.
     * @maxSize 3
     */
    fields?: RequestedFieldsEnumRequestedFieldsWithLiterals[];
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1", "fieldName2":{"$operator":"value2"} }`. <br/> <br/> **Example:** <br/> `"filter" : { "eventId": "sd3f-jhds-4fs77", "ticketNumber": {"$startsWith":"478"} }` <br/> <br/> See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort) for more information. */
    filter?: Record<string, any> | null;
    /** Sort object in the following format: <br/> `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]` <br/> <br/> **Example:** <br/> `[{"fieldName":"createdDate","direction":"DESC"}]` <br/> <br/> See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort) for more information. */
    sort?: Sorting[];
    /**
     * Currently the only supported fieldset is `guestDetails`. The `WIX_EVENTS.READ_GUESTS_DETAILS` permission is required to access the guest details. <br/> <br/> See [field projection](https://dev.wix.com/api/rest/getting-started/field-projection) for more information.
     * @deprecated Currently the only supported fieldset is `guestDetails`. The `WIX_EVENTS.READ_GUESTS_DETAILS` permission is required to access the guest details. <br/> <br/> See [field projection](https://dev.wix.com/api/rest/getting-started/field-projection) for more information.
     * @replacedBy fields
     * @targetRemovalDate 2024-06-30
     */
    fieldsets?: string[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /**
     * Number of items to load.
     * @max 1000
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 1000
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
declare enum RequestedFieldsEnumRequestedFields {
    /** Unknown requested field. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    /** Returns `guestDetails` and `tickets`. */
    GUEST_DETAILS = "GUEST_DETAILS",
    /** Returns `totalGuests`. */
    GUEST_TOTAL = "GUEST_TOTAL"
}
/** @enumType */
type RequestedFieldsEnumRequestedFieldsWithLiterals = RequestedFieldsEnumRequestedFields | 'UNKNOWN_REQUESTED_FIELD' | 'GUEST_DETAILS' | 'GUEST_TOTAL';
interface QueryEventGuestsResponse {
    /** List of guests. */
    guests?: EventGuest[];
    /** Metadata for the paginated results. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface StreamEventGuestsRequest {
    /** Filter. */
    filter?: Record<string, any> | null;
    /** Task context. */
    taskContext?: TaskContext;
}
interface Empty {
}
interface SecondaryLanguagesRequest {
    /**
     * Guest event id.
     * @format GUID
     */
    eventId?: string;
}
interface SecondaryLanguagesResponse {
    /**
     * Aggregated guests secondary languages.
     * @format LANGUAGE
     */
    secondaryLanguages?: string[];
    /** Aggregated guests languages. */
    languages?: Language[];
}
interface Language {
    /**
     * Guest language.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Guest locale.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
}
/** Triggered when an order is confirmed. */
interface OrderConfirmed {
    /** Date and time the order was confirmed. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Notifications silenced for this domain event. */
    silent?: boolean | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email address. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets (generated after payment). */
    tickets?: Ticket[];
    /** Invoice. */
    invoice?: Invoice;
    /** Reservation ID associated with the order. */
    reservationId?: string;
}
interface Ticket {
    /** Unique issued ticket number. */
    ticketNumber?: string;
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Ticket price. */
    price?: Money;
    /** Whether ticket is archived. */
    archived?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /** Guest email. */
    email?: string | null;
    /**
     * Contact ID associated with this ticket.
     * @format GUID
     */
    contactId?: string | null;
    /** Whether ticket is confirmed */
    confirmed?: boolean;
    /**
     * Member ID associated with this ticket.
     * @format GUID
     */
    memberId?: string | null;
    /** Ticket form response (only assigned tickets contain separate forms). */
    form?: FormResponse;
    /** Ticket name. */
    ticketName?: string;
    /** Anonymized tickets no longer contain personally identifiable information (PII). */
    anonymized?: boolean;
    /** URL and password to online conference */
    onlineConferencingLogin?: OnlineConferencingLogin;
    /**
     * Seat ID associated with this ticket.
     * @maxLength 36
     */
    seatId?: string | null;
    /** Whether ticket is canceled. */
    canceled?: boolean | null;
}
interface CheckIn {
    /** Time of a ticket's check-in. */
    created?: Date | null;
}
/** Triggered when an order is updated. */
interface OrderUpdated {
    /** Date and time the order was updated. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
    confirmed?: boolean;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
    /** Whether order was archived and excluded from results. */
    archived?: boolean;
    /** Whether event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
}
/** Triggered when an order is deleted. */
interface OrderDeleted {
    /** Date and time the order was deleted. */
    timestamp?: Date | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Whether the order was anonymized by GDPR delete. */
    anonymized?: boolean;
    /** Order type. */
    orderType?: OrderTypeWithLiterals;
    /** Whether the event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
}
declare enum OrderType {
    /** Buyer form is used for all tickets. */
    UNASSIGNED_TICKETS = "UNASSIGNED_TICKETS",
    /** Each order ticket has its own form. */
    ASSIGNED_TICKETS = "ASSIGNED_TICKETS"
}
/** @enumType */
type OrderTypeWithLiterals = OrderType | 'UNASSIGNED_TICKETS' | 'ASSIGNED_TICKETS';
interface EventDeleted {
    /** Event deleted timestamp in ISO UTC format. */
    timestamp?: Date | null;
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /** Event title. */
    title?: string;
    /**
     * Event creator user ID.
     * @format GUID
     */
    userId?: string | null;
}
interface Task {
    key?: TaskKey;
    executeAt?: Date | null;
    payload?: string | null;
}
interface TaskKey {
    appId?: string;
    instanceId?: string;
    subjectId?: string | null;
}
interface ListGuestListPreviewsRequest {
    /**
     * Event ids.
     * @format GUID
     * @maxSize 50
     */
    eventIds?: string[];
    /** Cursor paging. */
    cursorPaging?: CursorPaging;
    /**
     * Requested fields.
     * @maxSize 5
     */
    fields?: RequestedFieldsWithLiterals[];
}
declare enum RequestedFields {
    /** Unknown requested field. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    /** Member guests. */
    MEMBER_GUESTS = "MEMBER_GUESTS",
    /** Waitlist count. */
    WAITLIST_COUNT = "WAITLIST_COUNT"
}
/** @enumType */
type RequestedFieldsWithLiterals = RequestedFields | 'UNKNOWN_REQUESTED_FIELD' | 'MEMBER_GUESTS' | 'WAITLIST_COUNT';
interface ListGuestListPreviewsResponse {
    /**
     * List of guests.
     * @maxSize 50
     */
    previews?: GuestListPreview[];
    /** Metadata for the paginated results. */
    pagingMetadata?: PagingMetadataV2;
}
interface GuestListPreview {
    /**
     * Event id.
     * @format GUID
     */
    eventId?: string;
    /** Attending guests count. */
    attending?: GuestCount;
    /** Waiting guests count. */
    inWaitlist?: GuestCount;
    /** Not attending guests count. */
    notAttending?: GuestCount;
    /** Latest attending members. */
    latestAttendingMembers?: MemberGuests;
    /** If present, indicates that current member is attending. */
    currentMemberGuest?: MemberGuest;
}
interface GuestCount {
    /** Total guest count. For Rsvp Event every RSVP guest and additional guest count, for Ticketed Event count of TICKET_HOLDER */
    totalEventGuests?: number;
    /** EventGuest count (RSVP, TICKET_HOLDER, BUYER); */
    count?: number;
}
interface MemberGuests {
    /**
     * Member guests
     * @maxSize 8
     */
    guests?: MemberGuest[];
}
interface MemberGuest {
    /**
     * Member id
     * @format GUID
     */
    memberId?: string;
}
interface UpdateGuestRequest {
    /** Updated guest */
    guest?: EventGuest;
    /** Guest revision */
    revision?: string | null;
}
interface UpdateGuestResponse {
    /** Updated guest */
    guest?: EventGuest;
}
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface GuestCreatedEnvelope {
    entity: EventGuest;
    metadata: EventMetadata;
}
/**
 * Triggered when a guest is created.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-GUEST-LIST
 * @permissionScope Read Event Tickets and Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.READ-GUEST-LIST
 * @permissionId WIX_EVENTS.READ_GUESTS_DETAILS
 * @webhook
 * @eventType wix.events.guests.v1.guest_created
 * @slug created
 */
declare function onGuestCreated(handler: (event: GuestCreatedEnvelope) => void | Promise<void>): void;
interface GuestDeletedEnvelope {
    entity: EventGuest;
    metadata: EventMetadata;
}
/**
 * Triggered when a guest is deleted.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-GUEST-LIST
 * @permissionScope Read Event Tickets and Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.READ-GUEST-LIST
 * @permissionId WIX_EVENTS.READ_GUESTS_DETAILS
 * @webhook
 * @eventType wix.events.guests.v1.guest_deleted
 * @slug deleted
 */
declare function onGuestDeleted(handler: (event: GuestDeletedEnvelope) => void | Promise<void>): void;
interface GuestCheckedInEnvelope {
    data: GuestCheckedIn;
    metadata: EventMetadata;
}
/**
 * Triggered when a guest has checked in.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-GUEST-LIST
 * @permissionScope Read Event Tickets and Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.READ-GUEST-LIST
 * @permissionId WIX_EVENTS.READ_GUESTS_DETAILS
 * @webhook
 * @eventType wix.events.guests.v1.guest_guest_checked_in
 * @slug guest_checked_in
 */
declare function onGuestCheckedIn(handler: (event: GuestCheckedInEnvelope) => void | Promise<void>): void;
interface GuestEventCanceledEnvelope {
    data: GuestEventCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when an event is canceled.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-GUEST-LIST
 * @permissionScope Read Event Tickets and Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.READ-GUEST-LIST
 * @permissionId WIX_EVENTS.READ_GUESTS_DETAILS
 * @webhook
 * @eventType wix.events.guests.v1.guest_guest_event_canceled
 * @slug guest_event_canceled
 */
declare function onGuestEventCanceled(handler: (event: GuestEventCanceledEnvelope) => void | Promise<void>): void;
interface GuestEventStartsEnvelope {
    data: GuestEventStarts;
    metadata: EventMetadata;
}
/**
 * Triggered when an event has started.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-GUEST-LIST
 * @permissionScope Read Event Tickets and Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.READ-GUEST-LIST
 * @permissionId WIX_EVENTS.READ_GUESTS_DETAILS
 * @webhook
 * @eventType wix.events.guests.v1.guest_guest_event_starts
 * @slug guest_event_starts
 */
declare function onGuestEventStarts(handler: (event: GuestEventStartsEnvelope) => void | Promise<void>): void;
interface GuestOrderCanceledEnvelope {
    data: GuestOrderCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when a ticket order is canceled.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-GUEST-LIST
 * @permissionScope Read Event Tickets and Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.READ-GUEST-LIST
 * @permissionId WIX_EVENTS.READ_GUESTS_DETAILS
 * @webhook
 * @eventType wix.events.guests.v1.guest_guest_order_canceled
 * @slug guest_order_canceled
 */
declare function onGuestOrderCanceled(handler: (event: GuestOrderCanceledEnvelope) => void | Promise<void>): void;
interface GuestUpdatedEnvelope {
    entity: EventGuest;
    metadata: EventMetadata;
}
/**
 * Triggered when a guest is updated.
 *
 * This event always triggers together with the Guest Created and the Guest Deleted events.
 * > **Note:** Since this event may trigger twice, you should explicitly add code to ensure that the parts of your code that depend on this event run only once.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-GUEST-LIST
 * @permissionScope Read Event Tickets and Guest List
 * @permissionScopeId SCOPE.DC-EVENTS.READ-GUEST-LIST
 * @permissionId WIX_EVENTS.READ_GUESTS_DETAILS
 * @webhook
 * @eventType wix.events.guests.v1.guest_updated
 * @slug updated
 */
declare function onGuestUpdated(handler: (event: GuestUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a query to retrieve a list of guests.
 *
 *
 * The `queryGuests()` method builds a query to retrieve a list of guests and returns a [GuestsQueryBuilder](https://dev.wix.com/docs/sdk/backend-modules/events/guests/guests-query-builder/ascending) object.
 *
 * The returned object contains the query definition which is typically used to run the query using the [`find()`](https://dev.wix.com/docs/sdk/backend-modules/events/guests/guests-query-builder/find) method.
 *
 * You can refine the query by chaining `GuestsQueryBuilder` methods onto the query. `GuestsQueryBuilder` methods enable you to sort, filter, and control the results that `queryGuests.find()` returns.
 *
 * The query runs with the following `GuestsQueryBuilder` defaults that you can override:
 *
 * - [`skipTo(0)`](https://dev.wix.com/docs/sdk/backend-modules/events/guests/guests-query-builder/skip-to)
 * - [`limit(50)`](https://dev.wix.com/docs/sdk/backend-modules/events/guests/guests-query-builder/limit)
 * - [`descending("_createdDate")`](https://dev.wix.com/docs/sdk/backend-modules/events/guests/guests-query-builder/descending)
 *
 * The methods that are chained to `queryGuests()` are applied in the order they are called. For example, if you apply `ascending ('_createdDate')` and then `descending ('_updatedDate')`, the results are sorted first by the created date and then, if there are multiple results with the same date, the items are sorted by the updated date.
 *
 * The table below shows which `GuestsQueryBuilder` methods are supported for `queryGuests()`. You can only use one filter method for each property. Only the first filter will work if a property is used in more than one filter.
 * @public
 * @permissionId WIX_EVENTS.READ_GUESTS
 * @applicableIdentity APP
 * @fqn wix.events.guests.v1.EventGuestsService.QueryEventGuests
 */
declare function queryGuests(options?: QueryEventGuestsOptions): GuestsQueryBuilder;
interface QueryEventGuestsOptions {
    /**
     * Predefined sets of fields to return.
     * @maxSize 3
     */
    fields?: RequestedFieldsEnumRequestedFieldsWithLiterals[] | undefined;
}
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface GuestsQueryResult extends QueryCursorResult {
    items: EventGuest[];
    query: GuestsQueryBuilder;
    next: () => Promise<GuestsQueryResult>;
    prev: () => Promise<GuestsQueryResult>;
}
interface GuestsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'guestDetails.checkedIn' | 'attendanceStatus' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId' | 'guestType', value: any) => GuestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'guestDetails.checkedIn' | 'attendanceStatus' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId' | 'guestType', value: any) => GuestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId', value: any) => GuestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId', value: any) => GuestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId', value: any) => GuestsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId', value: any) => GuestsQueryBuilder;
    in: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'attendanceStatus' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId' | 'guestType', value: any) => GuestsQueryBuilder;
    exists: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'tickets' | 'contactId' | 'guestDetails.checkedIn' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId', value: boolean) => GuestsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate'>) => GuestsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate'>) => GuestsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => GuestsQueryBuilder;
    /** @param cursor - A pointer to specific record */
    skipTo: (cursor: string) => GuestsQueryBuilder;
    find: () => Promise<GuestsQueryResult>;
}

export { type ActionEvent, type Address, type AddressLocation, type AddressStreetOneOf, AttendanceStatus, type AttendanceStatusWithLiterals, type BaseEventMetadata, type CheckIn, type CommonAddress, type CommonAddressLocation, type CommonAddressStreetOneOf, type CommonStreetAddress, type CommonSubdivision, type ContactEventStatusUpdated, type CouponDiscount, type CursorPaging, type Cursors, type DateAndTimeSettings, type Discount, type DiscountItem, type DiscountItemDiscountOneOf, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventDeleted, type EventDetails, type EventGuest, type EventMetadata, EventType, type EventTypeWithLiterals, type Fee, FeeName, type FeeNameWithLiterals, FeeType, type FeeTypeWithLiterals, type FormResponse, type Formatted, type FormattedAddress, type GuestCheckedIn, type GuestCheckedInEnvelope, type GuestCount, type GuestCountUpdate, type GuestCountUpdated, type GuestCreatedEnvelope, type GuestDeletedEnvelope, type GuestDetails, type GuestEventCanceled, type GuestEventCanceledEnvelope, type GuestEventStarts, type GuestEventStartsEnvelope, type GuestListPreview, type GuestOrderCanceled, type GuestOrderCanceledEnvelope, GuestType, type GuestTypeWithLiterals, type GuestUpdatedEnvelope, type GuestsQueryBuilder, type GuestsQueryResult, type IdentificationData, type IdentificationDataIdOneOf, type InputValue, type Invoice, type Item, type Language, type ListGuestListPreviewsRequest, type ListGuestListPreviewsResponse, type Location, LocationType, type LocationTypeWithLiterals, type MemberEventStatusUpdated, MemberEventStatusUpdatedEventType, type MemberEventStatusUpdatedEventTypeWithLiterals, type MemberGuest, type MemberGuests, type MessageEnvelope, type Money, NotifyActionType, type NotifyActionTypeWithLiterals, type NotifyGuestAction, type Occurrence, type OnlineConferencingLogin, type OrderConfirmed, type OrderDeleted, type OrderDetails, OrderStatus, type OrderStatusWithLiterals, OrderType, type OrderTypeWithLiterals, type OrderUpdated, type Paging, type PagingMetadataV2, type PaidPlanDiscount, type PaidPlanDiscountDiscountOneOf, type PercentDiscount, type QueryEventGuestsOptions, type QueryEventGuestsRequest, type QueryEventGuestsResponse, type QueryV2, type QueryV2PagingMethodOneOf, RecurrenceStatusStatus, type RecurrenceStatusStatusWithLiterals, type Recurrences, RequestedFields, RequestedFieldsEnumRequestedFields, type RequestedFieldsEnumRequestedFieldsWithLiterals, type RequestedFieldsWithLiterals, type RestoreInfo, type SecondaryLanguagesRequest, type SecondaryLanguagesResponse, SortOrder, type SortOrderWithLiterals, type Sorting, type StandardDetails, Status, type StatusWithLiterals, type StreamEventGuestsRequest, type StreetAddress, type Subdivision, SubdivisionSubdivisionType, type SubdivisionSubdivisionTypeWithLiterals, SubdivisionType, type SubdivisionTypeWithLiterals, type Task, type TaskContext, type TaskKey, type Tax, TaxType, type TaxTypeWithLiterals, type Ticket, type TicketDetails, type TicketGuestDetails, Timing, type TimingWithLiterals, type UpdateGuestRequest, type UpdateGuestResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, onGuestCheckedIn, onGuestCreated, onGuestDeleted, onGuestEventCanceled, onGuestEventStarts, onGuestOrderCanceled, onGuestUpdated, queryGuests };
