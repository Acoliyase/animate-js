import { NonNullablePaths } from '@wix/sdk-types';

/**
 * Customers can use a discount to pay less. Can be an amount or a percentage.
 * You can read more about discounts in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Discount extends DiscountValueOneOf, DiscountApplyToFilterOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
    /**
     * Discount ID.
     * @readonly
     */
    _id?: string | null;
    /** Discount name. */
    name?: string | null;
    /** Discount description. */
    description?: string | null;
    /** Whether the discount is active. Defaults to `true`. */
    active?: boolean | null;
    /** Discount type. */
    type?: DiscountTypeWithLiterals;
    /**
     * Discount condition.
     * All conditions must be met so that a customer can apply the discount.
     */
    condition?: DiscountCondition;
}
/** @oneof */
interface DiscountValueOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
}
/** @oneof */
interface DiscountApplyToFilterOneOf {
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
}
declare enum DiscountType {
    UNSPECIFIED_TYPE = "UNSPECIFIED_TYPE",
    OFF_ITEM = "OFF_ITEM",
    OFF_ORDER = "OFF_ORDER"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNSPECIFIED_TYPE' | 'OFF_ITEM' | 'OFF_ORDER';
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
interface Money {
    /**
     * Monetary amount in decimal string format. For example, `3.99`, `6`, and `10.5` are all accepted values.
     * @format DECIMAL_VALUE
     */
    value?: string;
    /**
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     * @format CURRENCY
     * @readonly
     */
    currency?: string;
}
interface SectionIds {
    values?: string[];
}
interface ItemIds {
    values?: string[];
}
interface DiscountCondition {
    /**
     * Which fulfillment types the discount applies to.
     * @minSize 1
     * @maxSize 2
     */
    fulfillmentTypes?: FulfillmentTypeWithLiterals[];
    /**
     * Which ordering platforms the discount applies to.
     * @minSize 1
     * @maxSize 3
     */
    platforms?: DiscountPlatformWithLiterals[];
    /** List of times when the discount is available. */
    availability?: Availability;
    /** Minimum order price for the discount. */
    minOrderPrice?: Money;
    /**
     * Coupon associated with the discount.
     * @readonly
     */
    coupon?: Coupon;
}
declare enum FulfillmentType {
    UNSPECIFIED_FULFILLMENT_TYPE = "UNSPECIFIED_FULFILLMENT_TYPE",
    DELIVERY = "DELIVERY",
    PICKUP_OR_DINE_IN = "PICKUP_OR_DINE_IN"
}
/** @enumType */
type FulfillmentTypeWithLiterals = FulfillmentType | 'UNSPECIFIED_FULFILLMENT_TYPE' | 'DELIVERY' | 'PICKUP_OR_DINE_IN';
declare enum DiscountPlatform {
    UNSPECIFIED_PLATFORM = "UNSPECIFIED_PLATFORM",
    SITE = "SITE",
    MOBILE_SITE = "MOBILE_SITE",
    CALL_CENTER = "CALL_CENTER"
}
/** @enumType */
type DiscountPlatformWithLiterals = DiscountPlatform | 'UNSPECIFIED_PLATFORM' | 'SITE' | 'MOBILE_SITE' | 'CALL_CENTER';
interface Availability {
    /**
     * Weekly recurring time periods when the entity is available.
     * Limited to 100 time periods.
     */
    periods?: TimePeriod[];
    /** Exceptions to the entity's regular availability. The entity can be available or not available during the special hour period. */
    specialHourPeriods?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the entity is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
declare enum DayOfWeek {
    UNDEFINED = "UNDEFINED",
    SUN = "SUN",
    MON = "MON",
    TUE = "TUE",
    WED = "WED",
    THU = "THU",
    FRI = "FRI",
    SAT = "SAT"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'UNDEFINED' | 'SUN' | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /** Whether the item is available during the exception. Defaults to `true`. */
    available?: boolean;
    /** Name of the special hour period. In the dashboard, the special hour period is called event. */
    eventName?: string | null;
}
interface Coupon {
    /**
     * Whether the customer needs to enter the coupon code to receive the discount. Defaults to `true`.
     * @readonly
     */
    applied?: boolean | null;
    /**
     * Coupon code.
     * @readonly
     */
    code?: string | null;
}
interface GetDiscountRequest {
    /**
     * ID of the discount to retrieve.
     * @format GUID
     */
    discountId: string;
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
}
interface GetDiscountResponse {
    /** Retrieved discount. */
    discount?: Discount;
}
interface UpdateDiscountRequest {
    /** Discount to update. */
    discount?: Discount;
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
}
interface UpdateDiscountResponse {
    /** Updated discount. */
    discount?: Discount;
}
interface CreateDiscountRequest {
    /** Discount to create. */
    discount?: Discount;
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
}
interface CreateDiscountResponse {
    /** Created discount. */
    discount?: Discount;
}
interface ListDiscountsRequest {
    /** Filed mask path. */
    fieldMask?: string[];
    /** Whether only active discounts are returned. Defaults to `true`. */
    active?: boolean | null;
    /**
     * ID of the catalog the discounts belong to.
     * @format GUID
     */
    catalogId: string;
}
interface ListDiscountsResponse {
    /** Retrieved discounts. */
    discounts?: Discount[];
}
interface AddLoyaltyDiscount {
    /** @format GUID */
    locationId?: string | null;
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface DiscountCreatedEnvelope {
    entity: Discount;
    metadata: EventMetadata;
}
/** @webhook
 * @eventType wix.restaurants.catalogs.v3.discount_created
 * @serviceIdentifier com.wixpress.restaurants.catalogs.v3.DiscountsApi
 * @slug created
 * @documentationMaturity preview
 */
declare function onDiscountCreated(handler: (event: DiscountCreatedEnvelope) => void | Promise<void>): void;
interface DiscountUpdatedEnvelope {
    entity: Discount;
    metadata: EventMetadata;
}
/** @webhook
 * @eventType wix.restaurants.catalogs.v3.discount_updated
 * @serviceIdentifier com.wixpress.restaurants.catalogs.v3.DiscountsApi
 * @slug updated
 * @documentationMaturity preview
 */
declare function onDiscountUpdated(handler: (event: DiscountUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves a discount.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.discountId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @returns Retrieved discount.
 * @fqn com.wixpress.restaurants.catalogs.v3.DiscountsApi.GetDiscount
 * @deprecated
 * @replacedBy com.wix.ecom.discounts.DiscountRuleService.GetDiscountRule
 * @targetRemovalDate 2025-09-30
 */
declare function getDiscount(identifiers: NonNullablePaths<GetDiscountIdentifiers, `catalogId` | `discountId`, 2>): Promise<NonNullablePaths<Discount, `amount.value` | `amount.currency` | `sectionIds.values` | `itemIds.values` | `type` | `condition.fulfillmentTypes` | `condition.platforms` | `condition.availability.periods` | `condition.availability.periods.${number}.openDay` | `condition.availability.periods.${number}.openTime` | `condition.availability.periods.${number}.closeDay` | `condition.availability.periods.${number}.closeTime` | `condition.availability.specialHourPeriods` | `condition.availability.specialHourPeriods.${number}.startDate` | `condition.availability.specialHourPeriods.${number}.endDate` | `condition.availability.specialHourPeriods.${number}.available`, 6>>;
interface GetDiscountIdentifiers {
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
    /**
     * ID of the discount to retrieve.
     * @format GUID
     */
    discountId: string;
}
/**
 * Updates a discount.
 * A discount can belong to a catalog, section, or dish. You can't create a discount that applies to a menu.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.discountId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @returns Updated discount.
 * @fqn com.wixpress.restaurants.catalogs.v3.DiscountsApi.UpdateDiscount
 * @deprecated
 * @replacedBy com.wix.ecom.discounts.DiscountRuleService.UpdateDiscountRule
 * @targetRemovalDate 2025-09-30
 */
declare function updateDiscount(identifiers: NonNullablePaths<UpdateDiscountIdentifiers, `catalogId` | `discountId`, 2>, options?: UpdateDiscountOptions): Promise<NonNullablePaths<Discount, `amount.value` | `amount.currency` | `sectionIds.values` | `itemIds.values` | `type` | `condition.fulfillmentTypes` | `condition.platforms` | `condition.availability.periods` | `condition.availability.periods.${number}.openDay` | `condition.availability.periods.${number}.openTime` | `condition.availability.periods.${number}.closeDay` | `condition.availability.periods.${number}.closeTime` | `condition.availability.specialHourPeriods` | `condition.availability.specialHourPeriods.${number}.startDate` | `condition.availability.specialHourPeriods.${number}.endDate` | `condition.availability.specialHourPeriods.${number}.available`, 6>>;
interface UpdateDiscountIdentifiers {
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
    /**
     * Discount ID.
     * @readonly
     */
    discountId?: string | null;
}
interface UpdateDiscountOptions {
    discount: {
        /** Discount amount. */
        amount?: Money;
        /**
         * Discount percentage.
         * @decimalValue options { maxScale:3 }
         */
        percentage?: string | null;
        /** IDs of the sections the discount applies to. */
        sectionIds?: SectionIds;
        /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
        itemIds?: ItemIds;
        /**
         * Discount ID.
         * @readonly
         */
        _id?: string | null;
        /** Discount name. */
        name?: string | null;
        /** Discount description. */
        description?: string | null;
        /** Whether the discount is active. Defaults to `true`. */
        active?: boolean | null;
        /** Discount type. */
        type?: DiscountTypeWithLiterals;
        /**
         * Discount condition.
         * All conditions must be met so that a customer can apply the discount.
         */
        condition?: DiscountCondition;
    };
}
/**
 * Creates a discount.
 * You can create discounts for catalogs, sections, or dishes. You can't create a discount that applies to a menu.
 * @param catalogId - ID of the catalog the discount belongs to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @requiredField options.discount.active
 * @requiredField options.discount.condition.fulfillmentTypes
 * @requiredField options.discount.condition.minOrderPrice
 * @requiredField options.discount.condition.platforms
 * @requiredField options.discount.name
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @returns Created discount.
 * @fqn com.wixpress.restaurants.catalogs.v3.DiscountsApi.CreateDiscount
 * @deprecated
 * @replacedBy com.wix.ecom.discounts.DiscountRuleService.CreateDiscountRule
 * @targetRemovalDate 2025-09-30
 */
declare function createDiscount(catalogId: string, options?: NonNullablePaths<CreateDiscountOptions, `discount.active` | `discount.condition.fulfillmentTypes` | `discount.condition.minOrderPrice` | `discount.condition.platforms` | `discount.name`, 4>): Promise<NonNullablePaths<Discount, `amount.value` | `amount.currency` | `sectionIds.values` | `itemIds.values` | `type` | `condition.fulfillmentTypes` | `condition.platforms` | `condition.availability.periods` | `condition.availability.periods.${number}.openDay` | `condition.availability.periods.${number}.openTime` | `condition.availability.periods.${number}.closeDay` | `condition.availability.periods.${number}.closeTime` | `condition.availability.specialHourPeriods` | `condition.availability.specialHourPeriods.${number}.startDate` | `condition.availability.specialHourPeriods.${number}.endDate` | `condition.availability.specialHourPeriods.${number}.available`, 6>>;
interface CreateDiscountOptions {
    /** Discount to create. */
    discount?: Discount;
}
/**
 * Retrieves up to 1000 discounts.
 * @param catalogId - ID of the catalog the discounts belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DiscountsApi.ListDiscounts
 * @deprecated
 * @replacedBy com.wix.ecom.discounts.DiscountRuleService.QueryDiscountRules
 * @targetRemovalDate 2025-09-30
 */
declare function listDiscounts(catalogId: string, options?: ListDiscountsOptions): Promise<NonNullablePaths<ListDiscountsResponse, `discounts` | `discounts.${number}.amount.value` | `discounts.${number}.amount.currency` | `discounts.${number}.type`, 5>>;
interface ListDiscountsOptions {
    /** Filed mask path. */
    fieldMask?: string[];
    /** Whether only active discounts are returned. Defaults to `true`. */
    active?: boolean | null;
}

export { type ActionEvent, type AddLoyaltyDiscount, type Availability, type BaseEventMetadata, type Coupon, type CreateDiscountOptions, type CreateDiscountRequest, type CreateDiscountResponse, DayOfWeek, type DayOfWeekWithLiterals, type Discount, type DiscountApplyToFilterOneOf, type DiscountCondition, type DiscountCreatedEnvelope, DiscountPlatform, type DiscountPlatformWithLiterals, DiscountType, type DiscountTypeWithLiterals, type DiscountUpdatedEnvelope, type DiscountValueOneOf, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, FulfillmentType, type FulfillmentTypeWithLiterals, type GetDiscountIdentifiers, type GetDiscountRequest, type GetDiscountResponse, type IdentificationData, type IdentificationDataIdOneOf, type ItemIds, type ListDiscountsOptions, type ListDiscountsRequest, type ListDiscountsResponse, type MessageEnvelope, type Money, type RestoreInfo, type SectionIds, type SpecialHourPeriod, type TimePeriod, type UpdateDiscountIdentifiers, type UpdateDiscountOptions, type UpdateDiscountRequest, type UpdateDiscountResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, createDiscount, getDiscount, listDiscounts, onDiscountCreated, onDiscountUpdated, updateDiscount };
