import { GetDiscountRequest as GetDiscountRequest$1, GetDiscountResponse as GetDiscountResponse$1, UpdateDiscountRequest as UpdateDiscountRequest$1, UpdateDiscountResponse as UpdateDiscountResponse$1, CreateDiscountRequest as CreateDiscountRequest$1, CreateDiscountResponse as CreateDiscountResponse$1, ListDiscountsRequest as ListDiscountsRequest$1, ListDiscountsResponse as ListDiscountsResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

/**
 * Customers can use a discount to pay less. Can be an amount or a percentage.
 * You can read more about discounts in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Discount extends DiscountValueOneOf, DiscountApplyToFilterOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
    /**
     * Discount ID.
     * @readonly
     */
    id?: string | null;
    /** Discount name. */
    name?: string | null;
    /** Discount description. */
    description?: string | null;
    /** Whether the discount is active. Defaults to `true`. */
    active?: boolean | null;
    /** Discount type. */
    type?: DiscountTypeWithLiterals;
    /**
     * Discount condition.
     * All conditions must be met so that a customer can apply the discount.
     */
    condition?: DiscountCondition;
}
/** @oneof */
interface DiscountValueOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
}
/** @oneof */
interface DiscountApplyToFilterOneOf {
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
}
declare enum DiscountType {
    UNSPECIFIED_TYPE = "UNSPECIFIED_TYPE",
    OFF_ITEM = "OFF_ITEM",
    OFF_ORDER = "OFF_ORDER"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNSPECIFIED_TYPE' | 'OFF_ITEM' | 'OFF_ORDER';
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
interface Money {
    /**
     * Monetary amount in decimal string format. For example, `3.99`, `6`, and `10.5` are all accepted values.
     * @format DECIMAL_VALUE
     */
    value?: string;
    /**
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     * @format CURRENCY
     * @readonly
     */
    currency?: string;
}
interface SectionIds {
    values?: string[];
}
interface ItemIds {
    values?: string[];
}
interface DiscountCondition {
    /**
     * Which fulfillment types the discount applies to.
     * @minSize 1
     * @maxSize 2
     */
    fulfillmentTypes?: FulfillmentTypeWithLiterals[];
    /**
     * Which ordering platforms the discount applies to.
     * @minSize 1
     * @maxSize 3
     */
    platforms?: DiscountPlatformWithLiterals[];
    /** List of times when the discount is available. */
    availability?: Availability;
    /** Minimum order price for the discount. */
    minOrderPrice?: Money;
    /**
     * Coupon associated with the discount.
     * @readonly
     */
    coupon?: Coupon;
}
declare enum FulfillmentType {
    UNSPECIFIED_FULFILLMENT_TYPE = "UNSPECIFIED_FULFILLMENT_TYPE",
    DELIVERY = "DELIVERY",
    PICKUP_OR_DINE_IN = "PICKUP_OR_DINE_IN"
}
/** @enumType */
type FulfillmentTypeWithLiterals = FulfillmentType | 'UNSPECIFIED_FULFILLMENT_TYPE' | 'DELIVERY' | 'PICKUP_OR_DINE_IN';
declare enum DiscountPlatform {
    UNSPECIFIED_PLATFORM = "UNSPECIFIED_PLATFORM",
    SITE = "SITE",
    MOBILE_SITE = "MOBILE_SITE",
    CALL_CENTER = "CALL_CENTER"
}
/** @enumType */
type DiscountPlatformWithLiterals = DiscountPlatform | 'UNSPECIFIED_PLATFORM' | 'SITE' | 'MOBILE_SITE' | 'CALL_CENTER';
interface Availability {
    /**
     * Weekly recurring time periods when the entity is available.
     * Limited to 100 time periods.
     */
    periods?: TimePeriod[];
    /** Exceptions to the entity's regular availability. The entity can be available or not available during the special hour period. */
    specialHourPeriods?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the entity is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
declare enum DayOfWeek {
    UNDEFINED = "UNDEFINED",
    SUN = "SUN",
    MON = "MON",
    TUE = "TUE",
    WED = "WED",
    THU = "THU",
    FRI = "FRI",
    SAT = "SAT"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'UNDEFINED' | 'SUN' | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /** Whether the item is available during the exception. Defaults to `true`. */
    available?: boolean;
    /** Name of the special hour period. In the dashboard, the special hour period is called event. */
    eventName?: string | null;
}
interface Coupon {
    /**
     * Whether the customer needs to enter the coupon code to receive the discount. Defaults to `true`.
     * @readonly
     */
    applied?: boolean | null;
    /**
     * Coupon code.
     * @readonly
     */
    code?: string | null;
}
interface GetDiscountRequest {
    /**
     * ID of the discount to retrieve.
     * @format GUID
     */
    discountId: string;
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
}
interface GetDiscountResponse {
    /** Retrieved discount. */
    discount?: Discount;
}
interface UpdateDiscountRequest {
    /** Discount to update. */
    discount?: Discount;
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
}
interface UpdateDiscountResponse {
    /** Updated discount. */
    discount?: Discount;
}
interface CreateDiscountRequest {
    /** Discount to create. */
    discount?: Discount;
    /**
     * ID of the catalog the discount belongs to.
     * @format GUID
     */
    catalogId: string;
}
interface CreateDiscountResponse {
    /** Created discount. */
    discount?: Discount;
}
interface ListDiscountsRequest {
    /** Filed mask path. */
    fieldMask?: string[];
    /** Whether only active discounts are returned. Defaults to `true`. */
    active?: boolean | null;
    /**
     * ID of the catalog the discounts belong to.
     * @format GUID
     */
    catalogId: string;
}
interface ListDiscountsResponse {
    /** Retrieved discounts. */
    discounts?: Discount[];
}
interface AddLoyaltyDiscount {
    /** @format GUID */
    locationId?: string | null;
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function getDiscount(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
    discountId: string;
}, GetDiscountRequest$1, GetDiscountRequest, GetDiscountResponse$1, GetDiscountResponse>;
declare function updateDiscount(): __PublicMethodMetaInfo<'PATCH', {
    catalogId: string;
    discountId: string;
}, UpdateDiscountRequest$1, UpdateDiscountRequest, UpdateDiscountResponse$1, UpdateDiscountResponse>;
declare function createDiscount(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, CreateDiscountRequest$1, CreateDiscountRequest, CreateDiscountResponse$1, CreateDiscountResponse>;
declare function listDiscounts(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
}, ListDiscountsRequest$1, ListDiscountsRequest, ListDiscountsResponse$1, ListDiscountsResponse>;

export { type ActionEvent as ActionEventOriginal, type AddLoyaltyDiscount as AddLoyaltyDiscountOriginal, type Availability as AvailabilityOriginal, type Coupon as CouponOriginal, type CreateDiscountRequest as CreateDiscountRequestOriginal, type CreateDiscountResponse as CreateDiscountResponseOriginal, DayOfWeek as DayOfWeekOriginal, type DayOfWeekWithLiterals as DayOfWeekWithLiteralsOriginal, type DiscountApplyToFilterOneOf as DiscountApplyToFilterOneOfOriginal, type DiscountCondition as DiscountConditionOriginal, type Discount as DiscountOriginal, DiscountPlatform as DiscountPlatformOriginal, type DiscountPlatformWithLiterals as DiscountPlatformWithLiteralsOriginal, DiscountType as DiscountTypeOriginal, type DiscountTypeWithLiterals as DiscountTypeWithLiteralsOriginal, type DiscountValueOneOf as DiscountValueOneOfOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type Empty as EmptyOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, FulfillmentType as FulfillmentTypeOriginal, type FulfillmentTypeWithLiterals as FulfillmentTypeWithLiteralsOriginal, type GetDiscountRequest as GetDiscountRequestOriginal, type GetDiscountResponse as GetDiscountResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type ItemIds as ItemIdsOriginal, type ListDiscountsRequest as ListDiscountsRequestOriginal, type ListDiscountsResponse as ListDiscountsResponseOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type Money as MoneyOriginal, type RestoreInfo as RestoreInfoOriginal, type SectionIds as SectionIdsOriginal, type SpecialHourPeriod as SpecialHourPeriodOriginal, type TimePeriod as TimePeriodOriginal, type UpdateDiscountRequest as UpdateDiscountRequestOriginal, type UpdateDiscountResponse as UpdateDiscountResponseOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, createDiscount, getDiscount, listDiscounts, updateDiscount };
