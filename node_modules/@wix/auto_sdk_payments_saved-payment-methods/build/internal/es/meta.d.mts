import { UpsertSavedPaymentMethodRequest as UpsertSavedPaymentMethodRequest$1, UpsertSavedPaymentMethodResponse as UpsertSavedPaymentMethodResponse$1, GetSavedPaymentMethodRequest as GetSavedPaymentMethodRequest$1, GetSavedPaymentMethodResponse as GetSavedPaymentMethodResponse$1, DeleteSavedPaymentMethodRequest as DeleteSavedPaymentMethodRequest$1, DeleteSavedPaymentMethodResponse as DeleteSavedPaymentMethodResponse$1, ListSavedPaymentMethodsRequest as ListSavedPaymentMethodsRequest$1, ListSavedPaymentMethodsResponse as ListSavedPaymentMethodsResponse$1, UpdateSavedPaymentMethodRequest as UpdateSavedPaymentMethodRequest$1, UpdateSavedPaymentMethodResponse as UpdateSavedPaymentMethodResponse$1, MarkSavedPaymentMethodPrimaryRequest as MarkSavedPaymentMethodPrimaryRequest$1, MarkSavedPaymentMethodPrimaryResponse as MarkSavedPaymentMethodPrimaryResponse$1 } from './index.typings.mjs';
import '@wix/sdk-types';

interface SavedPaymentMethod {
    /**
     * Unique identifier of a saved payment method.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * Represents the current state of a saved payment method. Each time saved payment method is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     * @readonly
     */
    revision?: string | null;
    /**
     * SavedPaymentMethod creation time.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * SavedPaymentMethod last update time.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Saved payment method owner's member ID.
     * @format GUID
     * @immutable
     */
    siteMemberId?: string | null;
    /**
     * Defines whether this payment method is primary for the member. Member can only have at most one primary saved payment method.
     * @readonly
     */
    primary?: boolean;
    /** Payment method details. */
    paymentMethod?: PaymentMethod;
    /**
     * Defines whether this payment method can be used by the merchant for making unscheduled payments.
     * Even if it's set to `false` payment method still can be used for scheduled payments e.g. subscription renewal without the buyer being present.
     */
    merchantUseAllowed?: boolean | null;
    /**
     * Saved payment method sensitive information.
     * @readonly
     */
    sensitiveInfo?: SensitiveInfo;
    /** Data Extensions */
    extendedFields?: ExtendedFields;
}
interface CardInfo {
    /**
     * Credit card's last 4 digits.
     * @minLength 4
     * @maxLength 4
     * @readonly
     */
    lastFourDigits?: string | null;
    /**
     * Credit card's BIN (Bank Identification Number). It's first 4-6 digits of card's number.
     * @minLength 4
     * @maxLength 6
     * @readonly
     */
    bin?: string | null;
    /**
     * Credit card's expiration month.
     * @min 1
     * @max 12
     * @immutable
     */
    expirationMonth?: number | null;
    /**
     * Credit card's expiration year.
     * @min 2000
     * @max 2099
     * @immutable
     */
    expirationYear?: number | null;
    /**
     * Card holder's full name specified on the card.
     * @minLength 1
     * @maxLength 1000
     */
    cardholderName?: string | null;
}
interface PaymentMethod {
    /**
     * Legacy payment method type ID. Supported values are `creditCard`, `payPal`.
     * @minLength 1
     * @maxLength 100
     * @immutable
     */
    typeId?: string;
    /**
     * Payment method type ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    paymentMethodTypeId?: string;
    /**
     * Payment method brand ID.
     * @format GUID
     * @readonly
     * @immutable
     */
    paymentMethodBrandId?: string | null;
    /** Details of credit card. */
    cardInfo?: CardInfo;
}
interface SensitiveInfo {
    /** Sensitive details of credit card like card token. */
    cardSensitiveInfo?: CardSensitiveInfo;
}
interface CardSensitiveInfo {
    /**
     * Persistent token of credit card tokenized by Wix.
     * @format GUID
     */
    persistentToken?: string | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface UpsertSavedPaymentMethodRequest {
    /** Saved payment method. */
    savedPaymentMethod: SavedPaymentMethod;
    /**
     * Temporary token of credit card tokenized by Wix. This token is used to create a persistent token
     * @format GUID
     */
    temporaryCardToken: string | null;
}
interface UpsertSavedPaymentMethodResponse {
    /** Saved payment method. */
    savedPaymentMethod?: SavedPaymentMethod;
}
interface GetSavedPaymentMethodRequest {
    /**
     * Unique identifier of a saved payment method.
     * @format GUID
     */
    savedPaymentMethodId: string;
    /**
     * List of heeded fields that will be returned.
     * You should have additional permission in order to get them as described in HidedFields documentation.
     * @maxSize 1
     */
    fields?: RequestedFieldsWithLiterals[];
}
declare enum RequestedFields {
    /** Default value. This value is unused. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    SENSITIVE_INFO = "SENSITIVE_INFO"
}
/** @enumType */
type RequestedFieldsWithLiterals = RequestedFields | 'UNKNOWN_REQUESTED_FIELD' | 'SENSITIVE_INFO';
interface GetSavedPaymentMethodResponse {
    /** Saved payment method. */
    savedPaymentMethod?: SavedPaymentMethod;
}
interface DeleteSavedPaymentMethodRequest {
    /**
     * Unique identifier of a saved payment method.
     * @format GUID
     */
    savedPaymentMethodId: string;
}
interface DeleteSavedPaymentMethodResponse {
}
interface ListSavedPaymentMethodsRequest {
    /**
     * Site member that owns saved payment methods.
     * Pass `me` to list saved payment method of the current site member.
     * @minLength 2
     * @maxLength 36
     */
    siteMemberId?: string | null;
    /**
     * Payment method type id. Supported values are `creditCard`, `payPal`.
     * @minLength 1
     * @maxLength 100
     */
    paymentMethodTypeId?: string | null;
    /**
     * Defines whether this payment method can be used by the merchant for making unscheduled payments.
     * Even if it's set to `false` payment method still can be used for scheduled payments e.g. subscription renewal without the buyer being present.
     */
    merchantUseAllowed?: boolean | null;
    /**
     * List of requested fields that will be returned.
     * Supported values:
     * SENSITIVE_INFO - Sensitive information of a SavedPaymentMethod like credit card tokens that's needed to process payments with it.
     * In order to receive it you should have `PAYMENTS.SAVED_PAYMENT_METHOD_READ_SENSITIVE_INFO` permission
     * @maxSize 1
     */
    fields?: RequestedFieldsWithLiterals[];
    /**
     * Paging for limit the response size.
     * If no paging provider default response limit 100 will be used.
     */
    paging?: CursorPaging;
}
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface ListSavedPaymentMethodsResponse {
    /** List of saved payment methods. */
    savedPaymentMethods?: SavedPaymentMethod[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface UpdateSavedPaymentMethodRequest {
    /** Saved payment method to update. */
    savedPaymentMethod?: SavedPaymentMethod;
}
interface UpdateSavedPaymentMethodResponse {
    /** Updated saved payment method. */
    savedPaymentMethod?: SavedPaymentMethod;
}
interface MarkSavedPaymentMethodPrimaryRequest {
    /**
     * Unique identifier of a saved payment method.
     * @format GUID
     */
    savedPaymentMethodId: string;
}
interface MarkSavedPaymentMethodPrimaryResponse {
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function upsertSavedPaymentMethod(): __PublicMethodMetaInfo<'POST', {}, UpsertSavedPaymentMethodRequest$1, UpsertSavedPaymentMethodRequest, UpsertSavedPaymentMethodResponse$1, UpsertSavedPaymentMethodResponse>;
declare function getSavedPaymentMethod(): __PublicMethodMetaInfo<'GET', {
    savedPaymentMethodId: string;
}, GetSavedPaymentMethodRequest$1, GetSavedPaymentMethodRequest, GetSavedPaymentMethodResponse$1, GetSavedPaymentMethodResponse>;
declare function deleteSavedPaymentMethod(): __PublicMethodMetaInfo<'DELETE', {
    savedPaymentMethodId: string;
}, DeleteSavedPaymentMethodRequest$1, DeleteSavedPaymentMethodRequest, DeleteSavedPaymentMethodResponse$1, DeleteSavedPaymentMethodResponse>;
declare function listSavedPaymentMethods(): __PublicMethodMetaInfo<'GET', {}, ListSavedPaymentMethodsRequest$1, ListSavedPaymentMethodsRequest, ListSavedPaymentMethodsResponse$1, ListSavedPaymentMethodsResponse>;
declare function updateSavedPaymentMethod(): __PublicMethodMetaInfo<'PATCH', {
    savedPaymentMethodId: string;
}, UpdateSavedPaymentMethodRequest$1, UpdateSavedPaymentMethodRequest, UpdateSavedPaymentMethodResponse$1, UpdateSavedPaymentMethodResponse>;
declare function markSavedPaymentMethodPrimary(): __PublicMethodMetaInfo<'GET', {
    savedPaymentMethodId: string;
}, MarkSavedPaymentMethodPrimaryRequest$1, MarkSavedPaymentMethodPrimaryRequest, MarkSavedPaymentMethodPrimaryResponse$1, MarkSavedPaymentMethodPrimaryResponse>;

export { type __PublicMethodMetaInfo, deleteSavedPaymentMethod, getSavedPaymentMethod, listSavedPaymentMethods, markSavedPaymentMethodPrimary, updateSavedPaymentMethod, upsertSavedPaymentMethod };
