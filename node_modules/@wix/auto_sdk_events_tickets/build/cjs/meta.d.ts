import { ListTicketsRequest as ListTicketsRequest$1, ListTicketsResponse as ListTicketsResponse$1, GetTicketRequest as GetTicketRequest$1, GetTicketResponse as GetTicketResponse$1, CheckInTicketRequest as CheckInTicketRequest$1, CheckInTicketResponse as CheckInTicketResponse$1, DeleteTicketCheckInRequest as DeleteTicketCheckInRequest$1, DeleteTicketCheckInResponse as DeleteTicketCheckInResponse$1, UpdateTicketRequest as UpdateTicketRequest$1, UpdateTicketResponse as UpdateTicketResponse$1, BulkUpdateTicketsRequest as BulkUpdateTicketsRequest$1, BulkUpdateTicketsResponse as BulkUpdateTicketsResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

interface TicketingTicket {
    /** Unique ticket number which is assigned automatically when creating a ticket. */
    ticketNumber?: string;
    /** Associated order number. */
    orderNumber?: string;
    /**
     * Ticket definition ID. See the Ticket Definition API for additional information.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket type. */
    name?: string;
    /** Ticket price. */
    price?: Money;
    /**
     * Whether the ticket requires payment.
     * @readonly
     */
    free?: boolean;
    /** Ticket and event policies. */
    policy?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Associated order status. */
    orderStatus?: OrderStatusWithLiterals;
    /**
     * Whether the order and ticket are archived.
     * If set to `true`, they aren't visible in the order list.
     */
    orderArchived?: boolean;
    /** Buyer full name. */
    orderFullName?: string;
    /** Guest full name. */
    guestFullName?: string | null;
    /** Guest personal details. */
    guestDetails?: GuestDetails;
    /** Whether the ticket is visible in an order. */
    archived?: boolean;
    /**
     * Ticket owner member ID.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Whether ticket was anonymized by GDPR delete.
     * Anonymized tickets no longer contain personally identifiable information (PII).
     */
    anonymized?: boolean;
    /**
     * Ticket check-in URL.
     *
     * Shown as QR code image in PDF.  <br/>
     * Format: `"https://www.wixevents.com/check-in/{ticket number},{event id}"`  <br/>
     * Example: `"https://www.wixevents.com/check-in/AAAA-AAAA-BB021,00000000-0000-0000-0000-000000000000"`
     */
    checkInUrl?: string;
    /** URL for ticket PDF download. */
    ticketPdfUrl?: string;
    /** Associated order checkout channel type. */
    channel?: ChannelTypeWithLiterals;
    /**
     * URL to download a ticket in `.pkpass` format for Apple Wallet.
     * @format WEB_URL
     * @readonly
     */
    walletPassUrl?: string;
    /**
     * Whether ticket is canceled.
     * @readonly
     */
    canceled?: boolean | null;
}
interface Money {
    /**
     * *Deprecated:** Use `value` instead.
     * @format DECIMAL_VALUE
     * @deprecated
     */
    amount?: string;
    /**
     * 3-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. For example, `USD`.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     */
    value?: string | null;
}
interface CheckIn {
    /** Time of a ticket's check-in. */
    created?: Date | null;
}
declare enum OrderStatus {
    /** Order status isn't available for this request fieldset. */
    NA_ORDER_STATUS = "NA_ORDER_STATUS",
    /** Order is confirmed, no payment is required. */
    FREE = "FREE",
    /** Order was paid, but the payment gateway suspended the payment. */
    PENDING = "PENDING",
    /** Order is paid. */
    PAID = "PAID",
    /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `"PAID"`. */
    OFFLINE_PENDING = "OFFLINE_PENDING",
    /** Order is waiting for payment at the cashier. */
    INITIATED = "INITIATED",
    /** Order is canceled. */
    CANCELED = "CANCELED",
    /** Order payment is declined. */
    DECLINED = "DECLINED",
    /** Order payment is authorized. */
    AUTHORIZED = "AUTHORIZED",
    /** Order payment is voided. */
    VOIDED = "VOIDED",
    /** Order is partially paid with less than the total amount. */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
/** @enumType */
type OrderStatusWithLiterals = OrderStatus | 'NA_ORDER_STATUS' | 'FREE' | 'PENDING' | 'PAID' | 'OFFLINE_PENDING' | 'INITIATED' | 'CANCELED' | 'DECLINED' | 'AUTHORIZED' | 'VOIDED' | 'PARTIALLY_PAID';
interface GuestDetails {
    /** Whether ticket belongs to assigned guest. */
    guestAssigned?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /**
     * Guest email.
     * @format EMAIL
     */
    email?: string | null;
    /** Full form response. */
    form?: FormResponse;
    /**
     * Contact ID associated with this guest.
     * @format GUID
     */
    contactId?: string | null;
    /**
     * Guest phone number.
     * @format PHONE
     */
    phone?: string | null;
}
interface FormResponse {
    /**
     * Form field inputs.
     * @maxSize 200
     */
    inputValues?: InputValue[];
}
interface InputValue {
    /**
     * Form field input name.
     * @maxLength 100
     */
    inputName?: string;
    /**
     * Form field value.
     * @maxLength 5000
     */
    value?: string;
    /**
     * Form field values.
     * @maxSize 100
     * @maxLength 5000
     */
    values?: string[];
}
interface FormattedAddress {
    /**
     * 1-line address representation.
     * @maxLength 200
     */
    formatted?: string;
    /** Address components. */
    address?: Address;
}
/** Physical address */
interface Address extends AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
/** @oneof */
interface AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
}
interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
}
interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
interface Subdivision {
    /** Short subdivision code. */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
/** Subdivision Concordance values */
interface StandardDetails {
    /**
     * subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30
     * @maxLength 20
     */
    iso31662?: string | null;
}
declare enum ChannelType {
    /** Buyer created the order via an online channel, such as a website or mobile app. */
    ONLINE = "ONLINE",
    /** Sales person created the order and collected the money. */
    OFFLINE_POS = "OFFLINE_POS"
}
/** @enumType */
type ChannelTypeWithLiterals = ChannelType | 'ONLINE' | 'OFFLINE_POS';
interface TicketDetails {
    /**
     * Unique seat ID in the event venue.
     * @minLength 1
     * @maxLength 36
     */
    seatId?: string | null;
    /**
     * Section label.
     * @readonly
     */
    sectionLabel?: string | null;
    /**
     * Area label.
     * @readonly
     */
    areaLabel?: string | null;
    /**
     * Table label.
     * @readonly
     */
    tableLabel?: string | null;
    /**
     * Row label.
     * @readonly
     */
    rowLabel?: string | null;
    /**
     * Seat label in a row or table.
     * @readonly
     */
    seatLabel?: string | null;
    /**
     * Seating plan ID.
     * @format GUID
     * @readonly
     */
    planId?: string | null;
    /**
     * Number of places in the spot.
     *
     * Default: `1`.
     * @min 1
     * @max 50
     */
    capacity?: number | null;
    /**
     * Custom price of a ticket.
     * @format DECIMAL_VALUE
     */
    priceOverride?: string | null;
    /**
     * Pricing option ID.
     * @format GUID
     */
    pricingOptionId?: string | null;
    /**
     * Pricing option name.
     * @readonly
     */
    pricingOptionName?: string | null;
}
interface ListTicketsRequest {
    /**
     * Event IDs to which the tickets belong.
     * @format GUID
     */
    eventId: string[];
    /** Paging offset. */
    offset?: number;
    /**
     * Number of items to load per page.
     * @max 100
     */
    limit?: number;
    /**
     * Order numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 20
     */
    orderNumber?: string[];
    /**
     * Ticket numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 50
     */
    ticketNumber?: string[];
    /**
     * Textual search filter - search is performed on `"orderFullName"`, `"guestFullName"`, and `"ticketNumber"`.
     * @maxLength 200
     */
    searchPhrase?: string;
    /**
     * Order statuses.
     * @maxSize 20
     */
    orderStatus?: OrderStatusWithLiterals[];
    /**
     * Set of fields to return in the response. See [Fieldsets](https://dev.wix.com/api/rest/wix-events/wix-events/fieldset#wix-events_wix-events_fieldset_ticket-fieldset).
     * @maxSize 20
     */
    fieldset?: TicketFieldsetWithLiterals[];
    /**
     * Ticket states.
     * @maxSize 20
     */
    state?: StateWithLiterals[];
    /**
     * Site member IDs.
     * @format GUID
     * @maxSize 500
     */
    memberId?: string[];
    /**
     * Filter facets. For supported facets, see Events Schema for Wix Search ([SDK](https://dev.wix.com/docs/sdk/backend-modules/events/events-schema-for-wix-search) | [REST](https://dev.wix.com/docs/rest/business-solutions/events/tickets/list-tickets))
     * @maxLength 100
     * @maxSize 20
     */
    facet?: string[];
    /**
     * Sort order. Defaults to `ticketNumber` in ascending order.
     * @maxLength 100
     */
    sort?: string;
    /**
     * Guest contact IDs.
     * @format GUID
     * @maxSize 100
     */
    contactId?: string[];
    /**
     * Ticket definition IDs.
     * @format GUID
     * @maxSize 10
     */
    ticketDefinitionId?: string[];
    /**
     * Seat IDs.
     * @maxLength 36
     * @maxSize 50
     */
    seatId?: string[];
}
declare enum TicketFieldset {
    /** Include guest details in the ticket response. */
    GUEST_DETAILS = "GUEST_DETAILS",
    /** Include ticket details in the ticket response. */
    TICKET_DETAILS = "TICKET_DETAILS",
    /** Include individual guest form in the ticket response. */
    GUEST_FORM = "GUEST_FORM"
}
/** @enumType */
type TicketFieldsetWithLiterals = TicketFieldset | 'GUEST_DETAILS' | 'TICKET_DETAILS' | 'GUEST_FORM';
declare enum State {
    /** Returns only archived orders' tickets. */
    ORDER_ARCHIVED = "ORDER_ARCHIVED",
    /** Returns only non-archived orders' tickets. */
    ORDER_ACTIVE = "ORDER_ACTIVE",
    /** Returns only archived tickets. */
    TICKET_ARCHIVED = "TICKET_ARCHIVED",
    /** Returns only non-archived tickets. */
    TICKET_ACTIVE = "TICKET_ACTIVE",
    /** Returns only checked-in tickets. */
    CHECKED_IN = "CHECKED_IN",
    /** Returns only non-checked-in tickets. */
    NON_CHECKED_IN = "NON_CHECKED_IN",
    /** Returns only free tickets. */
    FREE = "FREE",
    /** Returns only paid tickets. */
    PAID = "PAID",
    /** Returns only member tickets. */
    MEMBER = "MEMBER"
}
/** @enumType */
type StateWithLiterals = State | 'ORDER_ARCHIVED' | 'ORDER_ACTIVE' | 'TICKET_ARCHIVED' | 'TICKET_ACTIVE' | 'CHECKED_IN' | 'NON_CHECKED_IN' | 'FREE' | 'PAID' | 'MEMBER';
interface ListTicketsResponse {
    /** Total tickets matching the specified filters. */
    total?: number;
    /** Paging offset. */
    offset?: number;
    /**
     * Limit.
     * @max 100
     */
    limit?: number;
    /** Tickets. */
    tickets?: TicketingTicket[];
    /** Facets. */
    facets?: Record<string, FacetCounts>;
}
interface FacetCounts {
    /** Facet counts aggregated per value. */
    counts?: Record<string, number>;
}
interface TicketFacets {
    /** Filter facets. */
    facets?: Record<string, TicketFacetCounts>;
}
interface TicketFacetCounts {
    /** Facet totals, aggregated per filter. */
    counts?: Record<string, Counts>;
}
interface Counts {
    /** Number of tickets. */
    count?: number;
    /** Number of checked in tickets. */
    checkedIn?: number;
}
interface GetTicketRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique ticket number.
     * @maxLength 36
     */
    ticketNumber: string;
    /**
     * Set of fields to return in the response. See [Fieldsets](https://dev.wix.com/api/rest/wix-events/wix-events/fieldset#wix-events_wix-events_fieldset_ticket-fieldset).
     * @maxSize 20
     */
    fieldset?: TicketFieldsetWithLiterals[];
}
interface GetTicketResponse {
    /** Ticket. */
    ticket?: TicketingTicket;
}
interface CheckInTicketRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Tickets to check-in.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
}
interface CheckInTicketResponse {
    /** Updated tickets. */
    tickets?: TicketingTicket[];
}
/** Triggered when an order is updated. */
interface OrderUpdated {
    /** Date and time the order was updated. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
    confirmed?: boolean;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
    /** Whether order was archived and excluded from results. */
    archived?: boolean;
    /** Whether event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
}
interface Ticket {
    /** Unique issued ticket number. */
    ticketNumber?: string;
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Ticket price. */
    price?: Money;
    /** Whether ticket is archived. */
    archived?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /** Guest email. */
    email?: string | null;
    /**
     * Contact ID associated with this ticket.
     * @format GUID
     */
    contactId?: string | null;
    /** Whether ticket is confirmed */
    confirmed?: boolean;
    /**
     * Member ID associated with this ticket.
     * @format GUID
     */
    memberId?: string | null;
    /** Ticket form response (only assigned tickets contain separate forms). */
    form?: FormResponse;
    /** Ticket name. */
    ticketName?: string;
    /** Anonymized tickets no longer contain personally identifiable information (PII). */
    anonymized?: boolean;
    /** URL and password to online conference */
    onlineConferencingLogin?: OnlineConferencingLogin;
    /**
     * Seat ID associated with this ticket.
     * @maxLength 36
     */
    seatId?: string | null;
    /** Whether ticket is canceled. */
    canceled?: boolean | null;
}
interface OnlineConferencingLogin {
    /**
     * Link URL to the online conference.
     * @format WEB_URL
     * @readonly
     */
    link?: string;
    /**
     * Password for the online conference.
     * @readonly
     */
    password?: string | null;
}
interface DeleteTicketCheckInRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Ticket numbers to delete check-ins for.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
}
interface DeleteTicketCheckInResponse {
    /** Updated tickets. */
    tickets?: TicketingTicket[];
}
interface UpdateTicketRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique ticket number.
     * @minLength 1
     * @maxLength 36
     */
    ticketNumber: string;
    /**
     * Set of field paths, specifying which parts of this resource to update.
     * When `fields` is empty, the request is interpreted as a full update.
     * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
     */
    fields?: string[];
    /** Whether to archive the ticket. */
    archived?: boolean;
    /** Assigned guest details. */
    guestDetails?: GuestDetailsUpdate;
}
interface GuestDetailsUpdate {
    /**
     * Form of a guest assigned to a ticket.
     *
     * To update the form of a guest not assigned to a ticket, call Update Order.
     *
     * Doesn't support partial updates, the entire form object will be replaced when `guestDetails.form` is masked.
     */
    form?: FormResponse;
}
interface UpdateTicketResponse {
    /** Updated ticket. */
    ticket?: TicketingTicket;
}
interface BulkUpdateTicketsRequest {
    /**
     * Event ID to which the tickets belong.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique ticket numbers.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
    /** Whether tickets are archived. */
    archived?: boolean;
}
interface BulkUpdateTicketsResponse {
    /** Updated tickets. */
    tickets?: TicketingTicket[];
}
interface GetDemoTicketRequest {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    definitionId?: string;
}
interface GetDemoTicketResponse {
    /** Ticket. */
    ticket?: TicketingTicket;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function listTickets(): __PublicMethodMetaInfo<'GET', {
    eventId: string;
}, ListTicketsRequest$1, ListTicketsRequest, ListTicketsResponse$1, ListTicketsResponse>;
declare function getTicket(): __PublicMethodMetaInfo<'GET', {
    eventId: string;
    ticketNumber: string;
}, GetTicketRequest$1, GetTicketRequest, GetTicketResponse$1, GetTicketResponse>;
declare function checkInTickets(): __PublicMethodMetaInfo<'POST', {}, CheckInTicketRequest$1, CheckInTicketRequest, CheckInTicketResponse$1, CheckInTicketResponse>;
declare function deleteTicketCheckIns(): __PublicMethodMetaInfo<'DELETE', {}, DeleteTicketCheckInRequest$1, DeleteTicketCheckInRequest, DeleteTicketCheckInResponse$1, DeleteTicketCheckInResponse>;
declare function updateTicket(): __PublicMethodMetaInfo<'PATCH', {
    eventId: string;
    ticketNumber: string;
}, UpdateTicketRequest$1, UpdateTicketRequest, UpdateTicketResponse$1, UpdateTicketResponse>;
declare function bulkUpdateTickets(): __PublicMethodMetaInfo<'PATCH', {
    eventId: string;
}, BulkUpdateTicketsRequest$1, BulkUpdateTicketsRequest, BulkUpdateTicketsResponse$1, BulkUpdateTicketsResponse>;

export { type AddressLocation as AddressLocationOriginal, type Address as AddressOriginal, type AddressStreetOneOf as AddressStreetOneOfOriginal, type BulkUpdateTicketsRequest as BulkUpdateTicketsRequestOriginal, type BulkUpdateTicketsResponse as BulkUpdateTicketsResponseOriginal, ChannelType as ChannelTypeOriginal, type ChannelTypeWithLiterals as ChannelTypeWithLiteralsOriginal, type CheckIn as CheckInOriginal, type CheckInTicketRequest as CheckInTicketRequestOriginal, type CheckInTicketResponse as CheckInTicketResponseOriginal, type Counts as CountsOriginal, type DeleteTicketCheckInRequest as DeleteTicketCheckInRequestOriginal, type DeleteTicketCheckInResponse as DeleteTicketCheckInResponseOriginal, type FacetCounts as FacetCountsOriginal, type FormResponse as FormResponseOriginal, type FormattedAddress as FormattedAddressOriginal, type GetDemoTicketRequest as GetDemoTicketRequestOriginal, type GetDemoTicketResponse as GetDemoTicketResponseOriginal, type GetTicketRequest as GetTicketRequestOriginal, type GetTicketResponse as GetTicketResponseOriginal, type GuestDetails as GuestDetailsOriginal, type GuestDetailsUpdate as GuestDetailsUpdateOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type InputValue as InputValueOriginal, type ListTicketsRequest as ListTicketsRequestOriginal, type ListTicketsResponse as ListTicketsResponseOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type Money as MoneyOriginal, type OnlineConferencingLogin as OnlineConferencingLoginOriginal, OrderStatus as OrderStatusOriginal, type OrderStatusWithLiterals as OrderStatusWithLiteralsOriginal, type OrderUpdated as OrderUpdatedOriginal, type StandardDetails as StandardDetailsOriginal, State as StateOriginal, type StateWithLiterals as StateWithLiteralsOriginal, type StreetAddress as StreetAddressOriginal, type Subdivision as SubdivisionOriginal, SubdivisionType as SubdivisionTypeOriginal, type SubdivisionTypeWithLiterals as SubdivisionTypeWithLiteralsOriginal, type TicketDetails as TicketDetailsOriginal, type TicketFacetCounts as TicketFacetCountsOriginal, type TicketFacets as TicketFacetsOriginal, TicketFieldset as TicketFieldsetOriginal, type TicketFieldsetWithLiterals as TicketFieldsetWithLiteralsOriginal, type Ticket as TicketOriginal, type TicketingTicket as TicketingTicketOriginal, type UpdateTicketRequest as UpdateTicketRequestOriginal, type UpdateTicketResponse as UpdateTicketResponseOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, bulkUpdateTickets, checkInTickets, deleteTicketCheckIns, getTicket, listTickets, updateTicket };
