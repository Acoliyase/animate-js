import { NonNullablePaths } from '@wix/sdk-types';

interface TicketingTicket {
    /** A unique ticket number which is assigned automatically when creating a ticket. */
    ticketNumber?: string;
    /** Associated order number. */
    orderNumber?: string;
    /**
     * Ticket definition ID. See the Ticket Definition API for additional information.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket type. */
    name?: string;
    /** Ticket price. */
    price?: Money;
    /**
     * Whether the ticket requires payment.
     * @readonly
     */
    free?: boolean;
    /** Ticket and event policies. */
    policy?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /**
     * Associated order status. Possible values:
     * - `FREE`: The order is confirmed, no payment is required.
     * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
     * - `PAID`: The order is paid.
     * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
     * - `INITIATED`: The order is awaiting for payment.
     * - `CANCELED`: The order is canceled.
     * - `DECLINED`: The order is declined.
     */
    orderStatus?: OrderStatusWithLiterals;
    /**
     * Whether the order and ticket are archived.
     * If set to `true`, they aren't visible in the order list.
     */
    orderArchived?: boolean;
    /** Buyer full name. */
    orderFullName?: string;
    /** Guest full name. */
    guestFullName?: string | null;
    /** Guest personal details. */
    guestDetails?: GuestDetails;
    /** Whether the ticket is visible in an order. */
    archived?: boolean;
    /**
     * Ticket owner member ID.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Whether ticket was anonymized by GDPR delete.
     * Anonymized tickets no longer contain personally identifiable information (PII).
     */
    anonymized?: boolean;
    /**
     * Ticket check-in URL.
     * Shown as QR code image in PDF.
     *
     * Format: `https://www.wixevents.com/check-in/{ticket number},{event id}`
     *
     * Example: `https://www.wixevents.com/check-in/AAAA-AAAA-BB021,00000000-0000-0000-0000-000000000000`
     */
    checkInUrl?: string;
    /** URL for ticket PDF download. */
    ticketPdfUrl?: string;
    /** Associated order checkout channel type. */
    channel?: ChannelTypeWithLiterals;
    /**
     * An URL to download a ticket in the `.pkpass` format for Apple Wallet.
     * @format WEB_URL
     * @readonly
     */
    walletPassUrl?: string;
    /**
     * Whether ticket is canceled.
     * @readonly
     */
    canceled?: boolean | null;
}
interface Money {
    /**
     * *Deprecated:** Use `value` instead.
     * @format DECIMAL_VALUE
     * @deprecated
     */
    amount?: string;
    /**
     * Currency in the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) format. For example, `USD`.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     */
    value?: string | null;
}
interface CheckIn {
    /** Time of a ticket check-in. */
    created?: Date | null;
}
declare enum OrderStatus {
    /** Order status isn't available for this request fieldset. */
    NA_ORDER_STATUS = "NA_ORDER_STATUS",
    /** Order is confirmed, no payment is required. */
    FREE = "FREE",
    /** Order was paid, but the payment gateway suspended the payment. */
    PENDING = "PENDING",
    /** Order is paid. */
    PAID = "PAID",
    /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `"PAID"`. */
    OFFLINE_PENDING = "OFFLINE_PENDING",
    /** Order is waiting for payment at the cashier. */
    INITIATED = "INITIATED",
    /** Order is canceled. */
    CANCELED = "CANCELED",
    /** Order payment is declined. */
    DECLINED = "DECLINED",
    /** Order payment is authorized. */
    AUTHORIZED = "AUTHORIZED",
    /** Order payment is voided. */
    VOIDED = "VOIDED",
    /** Order is partially paid with less than the total amount. */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
/** @enumType */
type OrderStatusWithLiterals = OrderStatus | 'NA_ORDER_STATUS' | 'FREE' | 'PENDING' | 'PAID' | 'OFFLINE_PENDING' | 'INITIATED' | 'CANCELED' | 'DECLINED' | 'AUTHORIZED' | 'VOIDED' | 'PARTIALLY_PAID';
interface GuestDetails {
    /** Whether ticket belongs to assigned guest. */
    guestAssigned?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /**
     * Guest email.
     * @format EMAIL
     */
    email?: string | null;
    /** Full form response. */
    form?: FormResponse;
    /**
     * Contact ID associated with this guest.
     * @format GUID
     */
    contactId?: string | null;
    /**
     * Guest phone number.
     * @format PHONE
     */
    phone?: string | null;
}
interface FormResponse {
    /**
     * Form field inputs.
     * @maxSize 200
     */
    inputValues?: InputValue[];
}
interface InputValue {
    /**
     * Form field input name.
     * @maxLength 100
     */
    inputName?: string;
    /**
     * Form field value.
     * @maxLength 5000
     */
    value?: string;
    /**
     * Form field values.
     * @maxSize 100
     * @maxLength 5000
     */
    values?: string[];
}
interface FormattedAddress {
    /**
     * 1-line address representation.
     * @maxLength 200
     */
    formatted?: string;
    /** Address components. */
    address?: Address;
}
/** Physical address */
interface Address extends AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
/** @oneof */
interface AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
}
interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
}
interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
interface Subdivision {
    /** Short subdivision code. */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
/** Subdivision Concordance values */
interface StandardDetails {
    /**
     * subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30
     * @maxLength 20
     */
    iso31662?: string | null;
}
declare enum ChannelType {
    /** Buyer created the order via an online channel, such as a website or mobile app. */
    ONLINE = "ONLINE",
    /** Sales person created the order and collected the money. */
    OFFLINE_POS = "OFFLINE_POS"
}
/** @enumType */
type ChannelTypeWithLiterals = ChannelType | 'ONLINE' | 'OFFLINE_POS';
interface TicketDetails {
    /**
     * Unique seat ID in the event venue.
     * @minLength 1
     * @maxLength 36
     */
    seatId?: string | null;
    /**
     * Section label.
     * @readonly
     */
    sectionLabel?: string | null;
    /**
     * Area label.
     * @readonly
     */
    areaLabel?: string | null;
    /**
     * Table label.
     * @readonly
     */
    tableLabel?: string | null;
    /**
     * Row label.
     * @readonly
     */
    rowLabel?: string | null;
    /**
     * Seat label in a row or table.
     * @readonly
     */
    seatLabel?: string | null;
    /**
     * Seating plan ID.
     * @format GUID
     * @readonly
     */
    planId?: string | null;
    /**
     * Number of places in the spot.
     *
     * Default: `1`.
     * @min 1
     * @max 50
     */
    capacity?: number | null;
    /**
     * Custom price of a ticket.
     * @format DECIMAL_VALUE
     */
    priceOverride?: string | null;
    /**
     * Pricing option ID.
     * @format GUID
     */
    pricingOptionId?: string | null;
    /**
     * Pricing option name.
     * @readonly
     */
    pricingOptionName?: string | null;
}
interface ListTicketsRequest {
    /**
     * Event IDs to which the tickets belong.
     * @format GUID
     */
    eventId: string[];
    /** Offset. See [Pagination](/wix-events-v2/pagination). */
    offset?: number;
    /**
     * Number of items to load per page.
     * @max 100
     */
    limit?: number;
    /**
     * Order numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 20
     */
    orderNumber?: string[];
    /**
     * Ticket numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 50
     */
    ticketNumber?: string[];
    /**
     * Searches in the `orderFullName`, `guestFullName`, and `ticketNumber` fields.
     * @maxLength 200
     */
    searchPhrase?: string;
    /**
     * Order statuses.
     * @maxSize 20
     */
    orderStatus?: OrderStatusWithLiterals[];
    /**
     * Predefined sets of fields to return.
     * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
     * - `GUEST_DETAILS`: Returns `guestDetails`.
     * - `GUEST_FORM`: Returns `guestDetails.form`.
     *
     * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
     * @maxSize 20
     */
    fieldset?: TicketFieldsetWithLiterals[];
    /**
     * Ticket states. Possible values:
     * - `ORDER_ARCHIVED`: Returns tickets of the archived orders.
     * - `ORDER_ACTIVE`: Returns tickets of the non-archived orders.
     * - `TICKET_ARCHIVED`: Returns archived tickets.
     * - `TICKET_ACTIVE`: Returns non-archived tickets.
     * - `CHECKED_IN`: Returns checked-in tickets.
     * - `NON_CHECKED_IN`: Returns tickets that are not checked in.
     * - `FREE`: Returns free tickets.
     * - `PAID`: Return paid tickets.
     * - `MEMBER`: Return members' tickets.
     * @maxSize 20
     */
    state?: StateWithLiterals[];
    /**
     * Site member IDs.
     * @format GUID
     * @maxSize 500
     */
    memberId?: string[];
    /**
     * Filter facets.
     * @maxLength 100
     * @maxSize 20
     */
    facet?: string[];
    /**
     * Sort order. Defaults to "ticket_number:asc".
     * @maxLength 100
     */
    sort?: string;
    /**
     * Guest contact IDs.
     * @format GUID
     * @maxSize 100
     */
    contactId?: string[];
    /**
     * Ticket definition IDs.
     * @format GUID
     * @maxSize 10
     */
    ticketDefinitionId?: string[];
    /**
     * Seat IDs.
     * @maxLength 36
     * @maxSize 50
     */
    seatId?: string[];
}
declare enum TicketFieldset {
    /** Include guest details in the ticket response. */
    GUEST_DETAILS = "GUEST_DETAILS",
    /** Include ticket details in the ticket response. */
    TICKET_DETAILS = "TICKET_DETAILS",
    /** Include individual guest form in the ticket response. */
    GUEST_FORM = "GUEST_FORM"
}
/** @enumType */
type TicketFieldsetWithLiterals = TicketFieldset | 'GUEST_DETAILS' | 'TICKET_DETAILS' | 'GUEST_FORM';
declare enum State {
    /** Returns only archived orders' tickets. */
    ORDER_ARCHIVED = "ORDER_ARCHIVED",
    /** Returns only non-archived orders' tickets. */
    ORDER_ACTIVE = "ORDER_ACTIVE",
    /** Returns only archived tickets. */
    TICKET_ARCHIVED = "TICKET_ARCHIVED",
    /** Returns only non-archived tickets. */
    TICKET_ACTIVE = "TICKET_ACTIVE",
    /** Returns only checked-in tickets. */
    CHECKED_IN = "CHECKED_IN",
    /** Returns only non-checked-in tickets. */
    NON_CHECKED_IN = "NON_CHECKED_IN",
    /** Returns only free tickets. */
    FREE = "FREE",
    /** Returns only paid tickets. */
    PAID = "PAID",
    /** Returns only member tickets. */
    MEMBER = "MEMBER"
}
/** @enumType */
type StateWithLiterals = State | 'ORDER_ARCHIVED' | 'ORDER_ACTIVE' | 'TICKET_ARCHIVED' | 'TICKET_ACTIVE' | 'CHECKED_IN' | 'NON_CHECKED_IN' | 'FREE' | 'PAID' | 'MEMBER';
interface ListTicketsResponse {
    /** Total tickets matching the specified filters. */
    total?: number;
    /** Paging offset. */
    offset?: number;
    /**
     * Limit.
     * @max 100
     */
    limit?: number;
    /** Tickets. */
    tickets?: TicketingTicket[];
    /** Facets. */
    facets?: Record<string, FacetCounts>;
}
interface FacetCounts {
    /** Facet counts aggregated per value. */
    counts?: Record<string, number>;
}
interface TicketFacets {
    /** Filter facets. */
    facets?: Record<string, TicketFacetCounts>;
}
interface TicketFacetCounts {
    /** Facet totals, aggregated per filter. */
    counts?: Record<string, Counts>;
}
interface Counts {
    /** Number of tickets. */
    count?: number;
    /** Number of checked in tickets. */
    checkedIn?: number;
}
interface GetTicketRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * A unique ticket number which is assigned automatically when creating a ticket.
     * @maxLength 36
     */
    ticketNumber: string;
    /**
     * Predefined sets of fields to return.
     * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
     * - `GUEST_DETAILS`: Returns `guestDetails`.
     * - `GUEST_FORM`: Returns `guestDetails.form`.
     *
     * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
     * @maxSize 20
     */
    fieldset?: TicketFieldsetWithLiterals[];
}
interface GetTicketResponse {
    /** Ticket. */
    ticket?: TicketingTicket;
}
interface CheckInTicketRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Tickets to check-in.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
}
interface CheckInTicketResponse {
    /** Updated tickets. */
    tickets?: TicketingTicket[];
}
/** Triggered when an order is updated. */
interface OrderUpdated {
    /** Date and time the order was updated. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
    confirmed?: boolean;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
    /** Whether order was archived and excluded from results. */
    archived?: boolean;
    /** Whether event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
}
interface Ticket {
    /** Unique issued ticket number. */
    ticketNumber?: string;
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Ticket price. */
    price?: Money;
    /** Whether ticket is archived. */
    archived?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /** Guest email. */
    email?: string | null;
    /**
     * Contact ID associated with this ticket.
     * @format GUID
     */
    contactId?: string | null;
    /** Whether ticket is confirmed */
    confirmed?: boolean;
    /**
     * Member ID associated with this ticket.
     * @format GUID
     */
    memberId?: string | null;
    /** Ticket form response (only assigned tickets contain separate forms). */
    form?: FormResponse;
    /** Ticket name. */
    ticketName?: string;
    /** Anonymized tickets no longer contain personally identifiable information (PII). */
    anonymized?: boolean;
    /** URL and password to online conference */
    onlineConferencingLogin?: OnlineConferencingLogin;
    /**
     * Seat ID associated with this ticket.
     * @maxLength 36
     */
    seatId?: string | null;
    /** Whether ticket is canceled. */
    canceled?: boolean | null;
}
interface OnlineConferencingLogin {
    /**
     * Link URL to the online conference.
     * @format WEB_URL
     * @readonly
     */
    link?: string;
    /**
     * Password for the online conference.
     * @readonly
     */
    password?: string | null;
}
interface DeleteTicketCheckInRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Ticket numbers which check-ins to delete.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
}
interface DeleteTicketCheckInResponse {
    /** Updated tickets. */
    tickets?: TicketingTicket[];
}
interface UpdateTicketRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * A unique ticket number which is assigned automatically when creating a ticket.
     * @minLength 1
     * @maxLength 36
     */
    ticketNumber: string;
    /**
     * Set of field paths, specifying which parts of this resource to update.
     * When `fields` is empty, the request is interpreted as a full update.
     * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
     */
    fields?: string[];
    /** Whether to archive the tickets. */
    archived?: boolean;
    /** Assigned guest details. */
    guestDetails?: GuestDetailsUpdate;
}
interface GuestDetailsUpdate {
    /** Form of a guest assigned to a ticket. */
    form?: FormResponse;
}
interface UpdateTicketResponse {
    /** Updated ticket. */
    ticket?: TicketingTicket;
}
interface BulkUpdateTicketsRequest {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * A unique ticket number which is assigned automatically when creating a ticket.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
    /** Whether tickets are archived. */
    archived?: boolean;
}
interface BulkUpdateTicketsResponse {
    /** Updated tickets. */
    tickets?: TicketingTicket[];
}
interface GetDemoTicketRequest {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    definitionId?: string;
}
interface GetDemoTicketResponse {
    /** Ticket. */
    ticket?: TicketingTicket;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface TicketOrderUpdatedEnvelope {
    data: OrderUpdated;
    metadata: BaseEventMetadata;
}
/** @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Basic Events Order Info
 * @permissionScopeId SCOPE.DC-EVENTS.READ-BASIC-ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-ORDERS
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @webhook
 * @eventType wix.events.ticketing.events.OrderUpdated
 * @serviceIdentifier wix.events.ticketing.TicketManagement
 * @slug order_updated
 */
declare function onTicketOrderUpdated(handler: (event: TicketOrderUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves a list of up to 100 tickets.
 *
 * <!--
 * >**Note:** This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 * @param eventId - Event IDs to which the tickets belong.
 * @public
 * @requiredField eventId
 * @param options - Options for defining the returned list of tickets.
 * @permissionId WIX_EVENTS.READ_TICKETS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.TicketManagement.ListTickets
 */
declare function listTickets(eventId: string[], options?: ListTicketsOptions): Promise<NonNullablePaths<ListTicketsResponse, `total` | `offset` | `limit` | `tickets` | `tickets.${number}.ticketNumber` | `tickets.${number}.orderNumber` | `tickets.${number}.ticketDefinitionId` | `tickets.${number}.name` | `tickets.${number}.price.amount` | `tickets.${number}.price.currency` | `tickets.${number}.free` | `tickets.${number}.policy` | `tickets.${number}.orderStatus` | `tickets.${number}.orderArchived` | `tickets.${number}.orderFullName` | `tickets.${number}.guestDetails.guestAssigned` | `tickets.${number}.archived` | `tickets.${number}.anonymized` | `tickets.${number}.checkInUrl` | `tickets.${number}.ticketPdfUrl` | `tickets.${number}.channel` | `tickets.${number}.walletPassUrl`, 5>>;
interface ListTicketsOptions {
    /**
     *
     * Offset. See [Pagination](/wix-events-v2/pagination).
     */
    offset?: number;
    /**
     * Number of items to load per page. See [Pagination](/wix-events-v2/pagination).
     * @max 100
     */
    limit?: number;
    /**
     * Order numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 20
     */
    orderNumber?: string[];
    /**
     * Ticket numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 50
     */
    ticketNumber?: string[];
    /**
     * Textual search filter - search is performed on `"orderFullName"`, `"guestFullName"`, and `"ticketNumber"`.
     * @maxLength 200
     */
    searchPhrase?: string;
    /**
     * Order statuses.
     * @maxSize 20
     */
    orderStatus?: OrderStatusWithLiterals[];
    /**
     * Predefined sets of fields to return.
     * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
     * - `GUEST_DETAILS`: Returns `guestDetails`.
     * - `GUEST_FORM`: Returns `guestDetails.form`.
     *
     * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
     * @maxSize 20
     */
    fieldset?: TicketFieldsetWithLiterals[];
    /**
     * Ticket states. Possible values:
     * - `ORDER_ARCHIVED`: Returns tickets of the archived orders.
     * - `ORDER_ACTIVE`: Returns tickets of the non-archived orders.
     * - `TICKET_ARCHIVED`: Returns archived tickets.
     * - `TICKET_ACTIVE`: Returns non-archived tickets.
     * - `CHECKED_IN`: Returns checked-in tickets.
     * - `NON_CHECKED_IN`: Returns tickets that are not checked in.
     * - `FREE`: Returns free tickets.
     * - `PAID`: Return paid tickets.
     * - `MEMBER`: Return members' tickets.
     * @maxSize 20
     */
    state?: StateWithLiterals[];
    /**
     * Site member IDs.
     * @format GUID
     * @maxSize 500
     */
    memberId?: string[];
    /**
     * Filter facets.
     * @maxLength 100
     * @maxSize 20
     */
    facet?: string[];
    /**
     * Sort order.
     *
     * Default: `"ticketNumber"`:`"asc"`.
     * @maxLength 100
     */
    sort?: string;
    /**
     * Guest contact IDs.
     * @format GUID
     * @maxSize 100
     */
    contactId?: string[];
    /**
     * Ticket definition IDs.
     * @format GUID
     * @maxSize 10
     */
    ticketDefinitionId?: string[];
    /**
     * Seat IDs.
     * @maxLength 36
     * @maxSize 50
     */
    seatId?: string[];
}
/**
 * Retrieves a ticket by the unique ticket number.
 * @public
 * @requiredField identifiers
 * @requiredField identifiers.eventId
 * @requiredField identifiers.ticketNumber
 * @param identifiers - Details for the ticket to retrieve.
 * @param options - Options for the returned ticket data.
 * @permissionId WIX_EVENTS.READ_TICKET_DETAILS
 * @applicableIdentity APP
 * @returns Ticket.
 * @fqn wix.events.ticketing.TicketManagement.GetTicket
 */
declare function getTicket(identifiers: NonNullablePaths<GetTicketIdentifiers, `eventId` | `ticketNumber`, 2>, options?: GetTicketOptions): Promise<NonNullablePaths<TicketingTicket, `ticketNumber` | `orderNumber` | `ticketDefinitionId` | `name` | `price.amount` | `price.currency` | `free` | `policy` | `orderStatus` | `orderArchived` | `orderFullName` | `guestDetails.guestAssigned` | `guestDetails.form.inputValues` | `guestDetails.form.inputValues.${number}.inputName` | `guestDetails.form.inputValues.${number}.value` | `archived` | `anonymized` | `checkInUrl` | `ticketPdfUrl` | `channel` | `walletPassUrl`, 6>>;
interface GetTicketIdentifiers {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * A unique ticket number which is assigned automatically when creating a ticket.
     * @maxLength 36
     */
    ticketNumber: string;
}
interface GetTicketOptions {
    /**
     * Predefined sets of fields to return.
     * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
     * - `GUEST_DETAILS`: Returns `guestDetails`.
     * - `GUEST_FORM`: Returns `guestDetails.form`.
     *
     * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
     * @maxSize 20
     */
    fieldset?: TicketFieldsetWithLiterals[];
}
/**
 * Checks in 1 or more tickets.
 * @public
 * @requiredField eventId
 * @param eventId - Event ID to which the ticket belongs.
 * @param options - Options for tickets to check-in.
 * @permissionId WIX_EVENTS.CHECK-IN
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.TicketManagement.CheckInTicket
 */
declare function checkInTickets(eventId: string, options?: CheckInTicketsOptions): Promise<NonNullablePaths<CheckInTicketResponse, `tickets` | `tickets.${number}.ticketNumber` | `tickets.${number}.orderNumber` | `tickets.${number}.ticketDefinitionId` | `tickets.${number}.name` | `tickets.${number}.price.amount` | `tickets.${number}.price.currency` | `tickets.${number}.free` | `tickets.${number}.policy` | `tickets.${number}.orderStatus` | `tickets.${number}.orderArchived` | `tickets.${number}.orderFullName` | `tickets.${number}.guestDetails.guestAssigned` | `tickets.${number}.archived` | `tickets.${number}.anonymized` | `tickets.${number}.checkInUrl` | `tickets.${number}.ticketPdfUrl` | `tickets.${number}.channel` | `tickets.${number}.walletPassUrl`, 5>>;
interface CheckInTicketsOptions {
    /**
     * Tickets to check-in.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
}
/**
 * Deletes check-ins for 1 or more tickets.
 * @public
 * @requiredField eventId
 * @param eventId - Event ID to which the ticket belongs.
 * @param options - Options for tickets to delete.
 * @permissionId WIX_EVENTS.CHECK-IN
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.TicketManagement.DeleteTicketCheckIn
 */
declare function deleteTicketCheckIns(eventId: string, options?: DeleteTicketCheckInsOptions): Promise<NonNullablePaths<DeleteTicketCheckInResponse, `tickets` | `tickets.${number}.ticketNumber` | `tickets.${number}.orderNumber` | `tickets.${number}.ticketDefinitionId` | `tickets.${number}.name` | `tickets.${number}.price.amount` | `tickets.${number}.price.currency` | `tickets.${number}.free` | `tickets.${number}.policy` | `tickets.${number}.orderStatus` | `tickets.${number}.orderArchived` | `tickets.${number}.orderFullName` | `tickets.${number}.guestDetails.guestAssigned` | `tickets.${number}.archived` | `tickets.${number}.anonymized` | `tickets.${number}.checkInUrl` | `tickets.${number}.ticketPdfUrl` | `tickets.${number}.channel` | `tickets.${number}.walletPassUrl`, 5>>;
interface DeleteTicketCheckInsOptions {
    /**
     * Ticket numbers which check-ins to delete.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
}
/**
 * Updates a ticket.
 * @public
 * @requiredField identifiers
 * @requiredField identifiers.eventId
 * @requiredField identifiers.ticketNumber
 * @param identifiers - Details for the ticket to update.
 * @param options - Ticket details to update.
 * @permissionId WIX_EVENTS.MANAGE_TICKETS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.TicketManagement.UpdateTicket
 */
declare function updateTicket(identifiers: NonNullablePaths<UpdateTicketIdentifiers, `eventId` | `ticketNumber`, 2>, options?: UpdateTicketOptions): Promise<NonNullablePaths<UpdateTicketResponse, `ticket.ticketNumber` | `ticket.orderNumber` | `ticket.ticketDefinitionId` | `ticket.name` | `ticket.price.amount` | `ticket.price.currency` | `ticket.free` | `ticket.policy` | `ticket.orderStatus` | `ticket.orderArchived` | `ticket.orderFullName` | `ticket.guestDetails.guestAssigned` | `ticket.guestDetails.form.inputValues` | `ticket.guestDetails.form.inputValues.${number}.inputName` | `ticket.guestDetails.form.inputValues.${number}.value` | `ticket.archived` | `ticket.anonymized` | `ticket.checkInUrl` | `ticket.ticketPdfUrl` | `ticket.channel` | `ticket.walletPassUrl`, 7>>;
interface UpdateTicketIdentifiers {
    /**
     * Event ID to which the ticket belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * A unique ticket number which is assigned automatically when creating a ticket.
     * @minLength 1
     * @maxLength 36
     */
    ticketNumber: string;
}
interface UpdateTicketOptions {
    /**
     * Set of field paths, specifying which parts of this resource to update.
     * When `fields` is empty, the request is interpreted as a full update.
     * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
     */
    fields?: string[];
    /** Whether to archive the ticket. */
    archived?: boolean;
    /** Assigned guest details. */
    guestDetails?: GuestDetailsUpdate;
}
/**
 * Archives multiple tickets.
 * @public
 * @requiredField eventId
 * @param options - Options for updating the tickets.
 * @param eventId - Event ID to which the ticket belongs.
 * @permissionId WIX_EVENTS.MANAGE_TICKETS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.TicketManagement.BulkUpdateTickets
 */
declare function bulkUpdateTickets(eventId: string, options?: BulkUpdateTicketsOptions): Promise<NonNullablePaths<BulkUpdateTicketsResponse, `tickets` | `tickets.${number}.ticketNumber` | `tickets.${number}.orderNumber` | `tickets.${number}.ticketDefinitionId` | `tickets.${number}.name` | `tickets.${number}.price.amount` | `tickets.${number}.price.currency` | `tickets.${number}.free` | `tickets.${number}.policy` | `tickets.${number}.orderStatus` | `tickets.${number}.orderArchived` | `tickets.${number}.orderFullName` | `tickets.${number}.guestDetails.guestAssigned` | `tickets.${number}.archived` | `tickets.${number}.anonymized` | `tickets.${number}.checkInUrl` | `tickets.${number}.ticketPdfUrl` | `tickets.${number}.channel` | `tickets.${number}.walletPassUrl`, 5>>;
interface BulkUpdateTicketsOptions {
    /**
     * A unique ticket number which is assigned automatically when creating a ticket.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    ticketNumber?: string[];
    /** Whether tickets are archived. */
    archived?: boolean;
}

export { type Address, type AddressLocation, type AddressStreetOneOf, type BaseEventMetadata, type BulkUpdateTicketsOptions, type BulkUpdateTicketsRequest, type BulkUpdateTicketsResponse, ChannelType, type ChannelTypeWithLiterals, type CheckIn, type CheckInTicketRequest, type CheckInTicketResponse, type CheckInTicketsOptions, type Counts, type DeleteTicketCheckInRequest, type DeleteTicketCheckInResponse, type DeleteTicketCheckInsOptions, type FacetCounts, type FormResponse, type FormattedAddress, type GetDemoTicketRequest, type GetDemoTicketResponse, type GetTicketIdentifiers, type GetTicketOptions, type GetTicketRequest, type GetTicketResponse, type GuestDetails, type GuestDetailsUpdate, type IdentificationData, type IdentificationDataIdOneOf, type InputValue, type ListTicketsOptions, type ListTicketsRequest, type ListTicketsResponse, type MessageEnvelope, type Money, type OnlineConferencingLogin, OrderStatus, type OrderStatusWithLiterals, type OrderUpdated, type StandardDetails, State, type StateWithLiterals, type StreetAddress, type Subdivision, SubdivisionType, type SubdivisionTypeWithLiterals, type Ticket, type TicketDetails, type TicketFacetCounts, type TicketFacets, TicketFieldset, type TicketFieldsetWithLiterals, type TicketOrderUpdatedEnvelope, type TicketingTicket, type UpdateTicketIdentifiers, type UpdateTicketOptions, type UpdateTicketRequest, type UpdateTicketResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, bulkUpdateTickets, checkInTickets, deleteTicketCheckIns, getTicket, listTickets, onTicketOrderUpdated, updateTicket };
