import { NonNullablePaths } from '@wix/sdk-types';

/** Events Settings reads the settings and state of a site's [Wix Events & Tickets](https://www.wix.com/app-market/web-solution/events) app. */
interface EventsSettings {
    /**
     * Events Settings ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Date and time the Events Settings were created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the Events Settings were last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Revision number, which increments by 1 each time the Events Settings are updated. To prevent conflicting changes, the current revision must be passed when updating the Events Settings.
     * @readonly
     */
    revision?: string | null;
    /**
     * Site information including locale, language, and available premium features.
     * @readonly
     */
    siteInfo?: SiteInfo;
    /**
     * Global information about the site's events, including whether any events have been created and current ticket sales status.
     * @readonly
     */
    eventsInfo?: EventsInfo;
    /**
     * Settings for Wix service fees applied to paid ticket sales.
     * @readonly
     */
    serviceFeeSettings?: ServiceFeeSettings;
    /** Payment configuration including available payment methods, coupon acceptance, and delayed capture settings. */
    paymentSettings?: PaymentSettings;
}
/** Events settings state */
interface AppState {
    /**
     * Current state of the Events app.
     * @readonly
     */
    state?: AppStateStateWithLiterals;
    /**
     * Date and time when the app state was last changed. Updated whenever the Events app is enabled or disabled.
     * @readonly
     */
    stateUpdatedDate?: Date | null;
}
/** Events app state options. */
declare enum AppStateState {
    /** Unknown state. This value isn't used. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** Events app is active and functional. */
    ENABLED = "ENABLED",
    /** Events app is inactive. */
    DISABLED = "DISABLED"
}
/** @enumType */
type AppStateStateWithLiterals = AppStateState | 'UNKNOWN_STATE' | 'ENABLED' | 'DISABLED';
/** Site info */
interface SiteInfo {
    /**
     * Site locale in IETF BCP 47 language tag format. For example, `en-US` for U.S. English.
     * @readonly
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Site language in ISO 639-1 alpha-2 format. For example, `en`.
     * @readonly
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Premium features available to the site. These features control access to advanced events capabilities. Use this array to determine which functionality to enable in your integration. For example, check for `SELL_TICKETS` before showing payment options.
     * @readonly
     * @maxSize 20
     */
    premiumFeatures?: PremiumFeatureWithLiterals[];
}
/** Premium features that can be enabled for Events. */
declare enum PremiumFeature {
    /** Unknown premium feature. This value isn't used. */
    UNKNOWN_PREMIUM_FEATURE = "UNKNOWN_PREMIUM_FEATURE",
    /** Enables paid ticket sales for events. When present, the site can create paid ticket definitions and process payments through configured payment providers. */
    SELL_TICKETS = "SELL_TICKETS",
    /** Allows including custom URLs in event notification emails sent to attendees. Useful for adding registration links, additional information, or branded content in emails. */
    INCLUDE_URL_IN_EMAIL = "INCLUDE_URL_IN_EMAIL",
    /** Removes Wix branding from event notification emails. Provides a fully customized email without Wix attribution in the footer. */
    HIDE_FOOTER_IN_EMAIL = "HIDE_FOOTER_IN_EMAIL"
}
/** @enumType */
type PremiumFeatureWithLiterals = PremiumFeature | 'UNKNOWN_PREMIUM_FEATURE' | 'SELL_TICKETS' | 'INCLUDE_URL_IN_EMAIL' | 'HIDE_FOOTER_IN_EMAIL';
interface EventsInfo {
    /**
     * Whether the site has created its first event.
     * @readonly
     */
    firstEventCreated?: boolean | null;
    /**
     * Whether any events on the site sell tickets, including both free and paid tickets.
     * @readonly
     */
    sellingTickets?: boolean | null;
    /**
     * Whether any events on the site sell paid tickets specifically. Requires both ticket definitions with non-zero prices and the `SELL_TICKETS` premium feature.
     * @readonly
     */
    sellingPaidTickets?: boolean | null;
}
interface ServiceFeeSettings {
    /**
     * Whether Wix service fees are applied to paid ticket sales.
     * @readonly
     */
    serviceFeeEnabled?: boolean | null;
}
interface PaymentSettings {
    /**
     * Whether ticket sales are enabled for the site. Free ticket sales are always available; paid ticket sales require the `SELL_TICKETS` premium feature and configured payment providers.
     * @readonly
     */
    ticketSalesEnabled?: boolean | null;
    /**
     * Payment methods currently available for ticket checkout. Automatically populated based on the site's payment provider configuration. Common methods include credit cards, PayPal, and digital wallets.
     * @readonly
     * @maxSize 100
     */
    activePaymentMethods?: PaymentMethod[];
    /**
     * Whether discount coupons can be used during ticket checkout. Automatically enabled when at least one coupon exists on the site.
     * @readonly
     */
    couponsAccepted?: boolean | null;
    /**
     * Whether gift cards can be used during ticket checkout. Requires gift card functionality to be enabled at the site level.
     * @readonly
     */
    giftCardsAccepted?: boolean | null;
    /** Configuration for delayed payment capture, allowing payments to be authorized at purchase but captured later. This setting applies to all events on the site and can be updated through the API. */
    delayedPaymentCaptureSettings?: DelayedPaymentCaptureSettings;
}
interface PaymentMethod {
    /**
     * Payment method identifier indicating the type of payment accepted. For example, `creditCard`, `payPal`, `applePay`, or `googlePay`. Use this to determine which payment options to display in checkout.
     * @readonly
     * @maxLength 20
     */
    methodId?: string;
}
interface DelayedPaymentCaptureSettings {
    /** Whether delayed payment capture is enabled for all ticket sales on the site. When enabled, payments are authorized at purchase but captured later. */
    enabled?: boolean | null;
}
/** Actions available for delayed payment processing. */
declare enum Action {
    /** Unknown action. This value isn't used. */
    UNKNOWN_ACTION = "UNKNOWN_ACTION",
    /** Capture the authorized payment automatically after the delay period expires. This completes the transaction and charges the customer. */
    CAPTURE = "CAPTURE",
    /** Cancel the authorized payment automatically after the delay period expires, releasing the held funds back to the customer without charge. */
    VOID = "VOID"
}
/** @enumType */
type ActionWithLiterals = Action | 'UNKNOWN_ACTION' | 'CAPTURE' | 'VOID';
interface SiteSettings {
    /** Whether the initial Events setup has been completed. Set to `true` after the site owner completes the app configuration wizard. */
    firstTimeCompleted?: boolean | null;
    /** Configuration for Events pages on the site. Determines whether Events pages are accessible to site visitors. */
    pagesType?: TypeWithLiterals;
    /**
     * Custom path for the event details page. For example, `/events` or `/my-events`. Used to generate URLs for individual event pages.
     * @maxLength 100
     */
    detailsPagePath?: string | null;
}
declare enum Type {
    /** Unknown type. This value isn't used. */
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    /** Events pages are enabled and accessible to site visitors. */
    ENABLED = "ENABLED",
    /** Events pages are disabled and not accessible to site visitors. */
    DISABLED = "DISABLED"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNKNOWN_TYPE' | 'ENABLED' | 'DISABLED';
interface EventBadgesSettings {
    /**
     * Whether event badges functionality is available. Returns `true` when at least one event badges service provider integration (SPI) implementer exists on the site.
     * @readonly
     */
    hasEventBadges?: boolean | null;
}
interface EventPages {
    /**
     * URL for the main Events page where visitors can view and browse all events. Use this for navigation or linking to the Events section.
     * @readonly
     */
    eventPageUrl?: string;
    /**
     * URL for the Events schedule page showing upcoming events in calendar format. Use this for calendar-based event navigation.
     * @readonly
     */
    schedulePageUrl?: string;
}
declare enum CheckoutType {
    UNKNOWN_CHECKOUT_TYPE = "UNKNOWN_CHECKOUT_TYPE",
    /** Checkout using Events App. */
    EVENTS_APP = "EVENTS_APP",
    /** Checkout using Ecomm Platform. */
    ECOMM_PLATFORM = "ECOMM_PLATFORM"
}
/** @enumType */
type CheckoutTypeWithLiterals = CheckoutType | 'UNKNOWN_CHECKOUT_TYPE' | 'EVENTS_APP' | 'ECOMM_PLATFORM';
interface GetEventsSettingsRequest {
    /**
     * Settings categories to include in the response. If omitted, returns only basic settings for performance optimization. Use this to request specific information like premium features or payment settings.
     * @maxSize 9
     */
    fields?: RequestedFieldsWithLiterals[];
}
/** Categories of events settings that can be selectively retrieved for performance optimization. */
declare enum RequestedFields {
    /** Unknown requested field. This value isn't used. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    /** Returns site information including locale, language, and available premium features that determine Events capabilities. */
    SITE_INFO = "SITE_INFO",
    /** Returns Events-related information like first event creation status and current ticket sales flags. */
    EVENTS_INFO = "EVENTS_INFO",
    /** Returns Wix service fee configuration, activation status, and agreement dates. */
    SERVICE_FEE_SETTINGS = "SERVICE_FEE_SETTINGS",
    /** Returns available payment methods, delayed capture settings, and payment acceptance configuration. */
    PAYMENT_SETTINGS = "PAYMENT_SETTINGS"
}
/** @enumType */
type RequestedFieldsWithLiterals = RequestedFields | 'UNKNOWN_REQUESTED_FIELD' | 'SITE_INFO' | 'EVENTS_INFO' | 'SERVICE_FEE_SETTINGS' | 'PAYMENT_SETTINGS';
interface GetEventsSettingsResponse {
    /** The Events Settings object containing the requested configuration and status information. */
    eventsSettings?: EventsSettings;
}
interface UpdateEventsSettingsRequest {
    /** Events Settings object containing the fields to update. Must include the current `revision` number to prevent conflicting changes. */
    eventsSettings: EventsSettings;
    /**
     * Settings categories to return in the response. Use this to optimize the response size by requesting only needed information.
     * @maxSize 6
     */
    fields?: RequestedFieldsWithLiterals[];
}
interface UpdateEventsSettingsResponse {
    /** The updated Events Settings object reflecting the applied changes. */
    eventsSettings?: EventsSettings;
}
interface MetaSiteSpecialEvent extends MetaSiteSpecialEventPayloadOneOf {
    /** Emitted on a meta site creation. */
    siteCreated?: SiteCreated;
    /** Emitted on a meta site transfer completion. */
    siteTransferred?: SiteTransferred;
    /** Emitted on a meta site deletion. */
    siteDeleted?: SiteDeleted;
    /** Emitted on a meta site restoration. */
    siteUndeleted?: SiteUndeleted;
    /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
    sitePublished?: SitePublished;
    /** Emitted on a meta site unpublish. */
    siteUnpublished?: SiteUnpublished;
    /** Emitted when meta site is marked as template. */
    siteMarkedAsTemplate?: SiteMarkedAsTemplate;
    /** Emitted when meta site is marked as a WixSite. */
    siteMarkedAsWixSite?: SiteMarkedAsWixSite;
    /** Emitted when an application is provisioned (installed). */
    serviceProvisioned?: ServiceProvisioned;
    /** Emitted when an application is removed (uninstalled). */
    serviceRemoved?: ServiceRemoved;
    /** Emitted when meta site name (URL slug) is changed. */
    siteRenamedPayload?: SiteRenamed;
    /** Emitted when meta site was permanently deleted. */
    hardDeleted?: SiteHardDeleted;
    /** Emitted on a namespace change. */
    namespaceChanged?: NamespaceChanged;
    /** Emitted when Studio is attached. */
    studioAssigned?: StudioAssigned;
    /** Emitted when Studio is detached. */
    studioUnassigned?: StudioUnassigned;
    /**
     * Emitted when one of the URLs is changed. After this event you may call `urls-server` to fetch
     * the actual URL.
     *
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1732520791210559?thread_ts=1732027914.294059&cid=C0UHEBPFT
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1744115197619459
     */
    urlChanged?: SiteUrlChanged;
    /** Site is marked as PurgedExternally */
    sitePurgedExternally?: SitePurgedExternally;
    /** Emitted when Odeditor is attached. */
    odeditorAssigned?: OdeditorAssigned;
    /** Emitted when Odeditor is detached. */
    odeditorUnassigned?: OdeditorUnassigned;
    /** Emitted when Picasso is attached. */
    picassoAssigned?: PicassoAssigned;
    /** Emitted when Picasso is detached. */
    picassoUnassigned?: PicassoUnassigned;
    /** Emitted when Wixel is attached. */
    wixelAssigned?: WixelAssigned;
    /** Emitted when Wixel is detached. */
    wixelUnassigned?: WixelUnassigned;
    /** Emitted when StudioTwo is attached. */
    studioTwoAssigned?: StudioTwoAssigned;
    /** Emitted when StudioTwo is detached. */
    studioTwoUnassigned?: StudioTwoUnassigned;
    /**
     * A meta site id.
     * @format GUID
     */
    metaSiteId?: string;
    /** A meta site version. Monotonically increasing. */
    version?: string;
    /** A timestamp of the event. */
    timestamp?: string;
    /**
     * TODO(meta-site): Change validation once validations are disabled for consumers
     * More context: https://wix.slack.com/archives/C0UHEBPFT/p1720957844413149 and https://wix.slack.com/archives/CFWKX325T/p1728892152855659
     * @maxSize 4000
     */
    assets?: Asset[];
}
/** @oneof */
interface MetaSiteSpecialEventPayloadOneOf {
    /** Emitted on a meta site creation. */
    siteCreated?: SiteCreated;
    /** Emitted on a meta site transfer completion. */
    siteTransferred?: SiteTransferred;
    /** Emitted on a meta site deletion. */
    siteDeleted?: SiteDeleted;
    /** Emitted on a meta site restoration. */
    siteUndeleted?: SiteUndeleted;
    /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
    sitePublished?: SitePublished;
    /** Emitted on a meta site unpublish. */
    siteUnpublished?: SiteUnpublished;
    /** Emitted when meta site is marked as template. */
    siteMarkedAsTemplate?: SiteMarkedAsTemplate;
    /** Emitted when meta site is marked as a WixSite. */
    siteMarkedAsWixSite?: SiteMarkedAsWixSite;
    /** Emitted when an application is provisioned (installed). */
    serviceProvisioned?: ServiceProvisioned;
    /** Emitted when an application is removed (uninstalled). */
    serviceRemoved?: ServiceRemoved;
    /** Emitted when meta site name (URL slug) is changed. */
    siteRenamedPayload?: SiteRenamed;
    /** Emitted when meta site was permanently deleted. */
    hardDeleted?: SiteHardDeleted;
    /** Emitted on a namespace change. */
    namespaceChanged?: NamespaceChanged;
    /** Emitted when Studio is attached. */
    studioAssigned?: StudioAssigned;
    /** Emitted when Studio is detached. */
    studioUnassigned?: StudioUnassigned;
    /**
     * Emitted when one of the URLs is changed. After this event you may call `urls-server` to fetch
     * the actual URL.
     *
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1732520791210559?thread_ts=1732027914.294059&cid=C0UHEBPFT
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1744115197619459
     */
    urlChanged?: SiteUrlChanged;
    /** Site is marked as PurgedExternally */
    sitePurgedExternally?: SitePurgedExternally;
    /** Emitted when Odeditor is attached. */
    odeditorAssigned?: OdeditorAssigned;
    /** Emitted when Odeditor is detached. */
    odeditorUnassigned?: OdeditorUnassigned;
    /** Emitted when Picasso is attached. */
    picassoAssigned?: PicassoAssigned;
    /** Emitted when Picasso is detached. */
    picassoUnassigned?: PicassoUnassigned;
    /** Emitted when Wixel is attached. */
    wixelAssigned?: WixelAssigned;
    /** Emitted when Wixel is detached. */
    wixelUnassigned?: WixelUnassigned;
    /** Emitted when StudioTwo is attached. */
    studioTwoAssigned?: StudioTwoAssigned;
    /** Emitted when StudioTwo is detached. */
    studioTwoUnassigned?: StudioTwoUnassigned;
}
interface Asset {
    /**
     * An application definition id (app_id in dev-center). For legacy reasons may be UUID or a string (from Java Enum).
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * An instance id. For legacy reasons may be UUID or a string.
     * @maxLength 200
     */
    instanceId?: string;
    /** An application state. */
    state?: StateWithLiterals;
}
declare enum State {
    UNKNOWN = "UNKNOWN",
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    PENDING = "PENDING",
    DEMO = "DEMO"
}
/** @enumType */
type StateWithLiterals = State | 'UNKNOWN' | 'ENABLED' | 'DISABLED' | 'PENDING' | 'DEMO';
interface SiteCreated {
    /**
     * A template identifier (empty if not created from a template).
     * @maxLength 36
     */
    originTemplateId?: string;
    /**
     * An account id of the owner.
     * @format GUID
     */
    ownerId?: string;
    /** A context in which meta site was created. */
    context?: SiteCreatedContextWithLiterals;
    /**
     * A meta site id from which this site was created.
     *
     * In case of a creation from a template it's a template id.
     * In case of a site duplication ("Save As" in dashboard or duplicate in UM) it's an id of a source site.
     * @format GUID
     */
    originMetaSiteId?: string | null;
    /**
     * A meta site name (URL slug).
     * @maxLength 20
     */
    siteName?: string;
    /** A namespace. */
    namespace?: NamespaceWithLiterals;
}
declare enum SiteCreatedContext {
    /** A valid option, we don't expose all reasons why site might be created. */
    OTHER = "OTHER",
    /** A meta site was created from template. */
    FROM_TEMPLATE = "FROM_TEMPLATE",
    /** A meta site was created by copying of the transfferred meta site. */
    DUPLICATE_BY_SITE_TRANSFER = "DUPLICATE_BY_SITE_TRANSFER",
    /** A copy of existing meta site. */
    DUPLICATE = "DUPLICATE",
    /** A meta site was created as a transfferred site (copy of the original), old flow, should die soon. */
    OLD_SITE_TRANSFER = "OLD_SITE_TRANSFER",
    /** deprecated A meta site was created for Flash editor. */
    FLASH = "FLASH"
}
/** @enumType */
type SiteCreatedContextWithLiterals = SiteCreatedContext | 'OTHER' | 'FROM_TEMPLATE' | 'DUPLICATE_BY_SITE_TRANSFER' | 'DUPLICATE' | 'OLD_SITE_TRANSFER' | 'FLASH';
declare enum Namespace {
    UNKNOWN_NAMESPACE = "UNKNOWN_NAMESPACE",
    /** Default namespace for UGC sites. MetaSites with this namespace will be shown in a user's site list by default. */
    WIX = "WIX",
    /** ShoutOut stand alone product. These are siteless (no actual Wix site, no HtmlWeb). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    SHOUT_OUT = "SHOUT_OUT",
    /** MetaSites created by the Albums product, they appear as part of the Albums app. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    ALBUMS = "ALBUMS",
    /** Part of the WixStores migration flow, a user tries to migrate and gets this site to view and if the user likes it then stores removes this namespace and deletes the old site with the old stores. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    WIX_STORES_TEST_DRIVE = "WIX_STORES_TEST_DRIVE",
    /** Hotels standalone (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    HOTELS = "HOTELS",
    /** Clubs siteless MetaSites, a club without a wix website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    CLUBS = "CLUBS",
    /** A partially created ADI website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    ONBOARDING_DRAFT = "ONBOARDING_DRAFT",
    /** AppBuilder for AppStudio / shmite (c). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    DEV_SITE = "DEV_SITE",
    /** LogoMaker websites offered to the user after logo purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    LOGOS = "LOGOS",
    /** VideoMaker websites offered to the user after video purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    VIDEO_MAKER = "VIDEO_MAKER",
    /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
    PARTNER_DASHBOARD = "PARTNER_DASHBOARD",
    /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
    DEV_CENTER_COMPANY = "DEV_CENTER_COMPANY",
    /**
     * A draft created by HTML editor on open. Upon "first save" it will be moved to be of WIX domain.
     *
     * Meta site with this namespace will *not* be shown in a user's site list by default.
     */
    HTML_DRAFT = "HTML_DRAFT",
    /**
     * the user-journey for Fitness users who want to start from managing their business instead of designing their website.
     * Will be accessible from Site List and will not have a website app.
     * Once the user attaches a site, the site will become a regular wixsite.
     */
    SITELESS_BUSINESS = "SITELESS_BUSINESS",
    /** Belongs to "strategic products" company. Supports new product in the creator's economy space. */
    CREATOR_ECONOMY = "CREATOR_ECONOMY",
    /** It is to be used in the Business First efforts. */
    DASHBOARD_FIRST = "DASHBOARD_FIRST",
    /** Bookings business flow with no site. */
    ANYWHERE = "ANYWHERE",
    /** Namespace for Headless Backoffice with no editor */
    HEADLESS = "HEADLESS",
    /**
     * Namespace for master site that will exist in parent account that will be referenced by subaccounts
     * The site will be used for account level CSM feature for enterprise
     */
    ACCOUNT_MASTER_CMS = "ACCOUNT_MASTER_CMS",
    /** Rise.ai Siteless account management for Gift Cards and Store Credit. */
    RISE = "RISE",
    /**
     * As part of the branded app new funnel, users now can create a meta site that will be branded app first.
     * There's a blank site behind the scene but it's blank).
     * The Mobile company will be the owner of this namespace.
     */
    BRANDED_FIRST = "BRANDED_FIRST",
    /** Nownia.com Siteless account management for Ai Scheduling Assistant. */
    NOWNIA = "NOWNIA",
    /**
     * UGC Templates are templates that are created by users for personal use and to sale to other users.
     * The Partners company owns this namespace.
     */
    UGC_TEMPLATE = "UGC_TEMPLATE",
    /** Codux Headless Sites */
    CODUX = "CODUX",
    /** Bobb - AI Design Creator. */
    MEDIA_DESIGN_CREATOR = "MEDIA_DESIGN_CREATOR",
    /**
     * Shared Blog Site is a unique single site across Enterprise account,
     * This site will hold all Blog posts related to the Marketing product.
     */
    SHARED_BLOG_ENTERPRISE = "SHARED_BLOG_ENTERPRISE",
    /** Standalone forms (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    STANDALONE_FORMS = "STANDALONE_FORMS",
    /** Standalone events (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    STANDALONE_EVENTS = "STANDALONE_EVENTS",
    /** MIMIR - Siteless account for MIMIR Ai Job runner. */
    MIMIR = "MIMIR",
    /** Wix Twins platform. */
    TWINS = "TWINS",
    /** Wix Nano. */
    NANO = "NANO"
}
/** @enumType */
type NamespaceWithLiterals = Namespace | 'UNKNOWN_NAMESPACE' | 'WIX' | 'SHOUT_OUT' | 'ALBUMS' | 'WIX_STORES_TEST_DRIVE' | 'HOTELS' | 'CLUBS' | 'ONBOARDING_DRAFT' | 'DEV_SITE' | 'LOGOS' | 'VIDEO_MAKER' | 'PARTNER_DASHBOARD' | 'DEV_CENTER_COMPANY' | 'HTML_DRAFT' | 'SITELESS_BUSINESS' | 'CREATOR_ECONOMY' | 'DASHBOARD_FIRST' | 'ANYWHERE' | 'HEADLESS' | 'ACCOUNT_MASTER_CMS' | 'RISE' | 'BRANDED_FIRST' | 'NOWNIA' | 'UGC_TEMPLATE' | 'CODUX' | 'MEDIA_DESIGN_CREATOR' | 'SHARED_BLOG_ENTERPRISE' | 'STANDALONE_FORMS' | 'STANDALONE_EVENTS' | 'MIMIR' | 'TWINS' | 'NANO';
/** Site transferred to another user. */
interface SiteTransferred {
    /**
     * A previous owner id (user that transfers meta site).
     * @format GUID
     */
    oldOwnerId?: string;
    /**
     * A new owner id (user that accepts meta site).
     * @format GUID
     */
    newOwnerId?: string;
}
/** Soft deletion of the meta site. Could be restored. */
interface SiteDeleted {
    /** A deletion context. */
    deleteContext?: DeleteContext;
}
interface DeleteContext {
    /** When the meta site was deleted. */
    dateDeleted?: Date | null;
    /** A status. */
    deleteStatus?: DeleteStatusWithLiterals;
    /**
     * A reason (flow).
     * @maxLength 255
     */
    deleteOrigin?: string;
    /**
     * A service that deleted it.
     * @maxLength 255
     */
    initiatorId?: string | null;
}
declare enum DeleteStatus {
    UNKNOWN = "UNKNOWN",
    TRASH = "TRASH",
    DELETED = "DELETED",
    PENDING_PURGE = "PENDING_PURGE",
    PURGED_EXTERNALLY = "PURGED_EXTERNALLY"
}
/** @enumType */
type DeleteStatusWithLiterals = DeleteStatus | 'UNKNOWN' | 'TRASH' | 'DELETED' | 'PENDING_PURGE' | 'PURGED_EXTERNALLY';
/** Restoration of the meta site. */
interface SiteUndeleted {
}
/** First publish of a meta site. Or subsequent publish after unpublish. */
interface SitePublished {
}
interface SiteUnpublished {
    /**
     * A list of URLs previously associated with the meta site.
     * @maxLength 4000
     * @maxSize 10000
     */
    urls?: string[];
}
interface SiteMarkedAsTemplate {
}
interface SiteMarkedAsWixSite {
}
/**
 * Represents a service provisioned a site.
 *
 * Note on `origin_instance_id`:
 * There is no guarantee that you will be able to find a meta site using `origin_instance_id`.
 * This is because of the following scenario:
 *
 * Imagine you have a template where a third-party application (TPA) includes some stub data,
 * such as a product catalog. When you create a site from this template, you inherit this
 * default product catalog. However, if the template's product catalog is modified,
 * your site will retain the catalog as it was at the time of site creation. This ensures that
 * your site remains consistent with what you initially received and does not include any
 * changes made to the original template afterward.
 * To ensure this, the TPA on the template gets a new instance_id.
 */
interface ServiceProvisioned {
    /**
     * Either UUID or EmbeddedServiceType.
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * Not only UUID. Something here could be something weird.
     * @maxLength 36
     */
    instanceId?: string;
    /**
     * An instance id from which this instance is originated.
     * @maxLength 36
     */
    originInstanceId?: string;
    /**
     * A version.
     * @maxLength 500
     */
    version?: string | null;
    /**
     * The origin meta site id
     * @format GUID
     */
    originMetaSiteId?: string | null;
}
interface ServiceRemoved {
    /**
     * Either UUID or EmbeddedServiceType.
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * Not only UUID. Something here could be something weird.
     * @maxLength 36
     */
    instanceId?: string;
    /**
     * A version.
     * @maxLength 500
     */
    version?: string | null;
}
/** Rename of the site. Meaning, free public url has been changed as well. */
interface SiteRenamed {
    /**
     * A new meta site name (URL slug).
     * @maxLength 20
     */
    newSiteName?: string;
    /**
     * A previous meta site name (URL slug).
     * @maxLength 255
     */
    oldSiteName?: string;
}
/**
 * Hard deletion of the meta site.
 *
 * Could not be restored. Therefore it's desirable to cleanup data.
 */
interface SiteHardDeleted {
    /** A deletion context. */
    deleteContext?: DeleteContext;
}
interface NamespaceChanged {
    /** A previous namespace. */
    oldNamespace?: NamespaceWithLiterals;
    /** A new namespace. */
    newNamespace?: NamespaceWithLiterals;
}
/** Assigned Studio editor */
interface StudioAssigned {
}
/** Unassigned Studio editor */
interface StudioUnassigned {
}
/**
 * Fired in case site URLs were changed in any way: new secondary domain, published, account slug rename, site rename etc.
 *
 * This is an internal event, it's not propagated in special events, because it's non-actionable. If you need to keep up
 * with sites and its urls, you need to listen to another topic/event. Read about it:
 *
 * https://bo.wix.com/wix-docs/rest/meta-site/meta-site---urls-service
 */
interface SiteUrlChanged {
}
/**
 * Used at the end of the deletion flow for both draft sites and when a user deletes a site.
 * Consumed by other teams to remove relevant data.
 */
interface SitePurgedExternally {
    /**
     * @maxLength 2048
     * @maxSize 100
     * @deprecated
     * @targetRemovalDate 2025-04-15
     */
    appDefId?: string[];
}
/** Assigned Odeditor */
interface OdeditorAssigned {
}
/** Unassigned Odeditor */
interface OdeditorUnassigned {
}
/** Assigned Picasso editor */
interface PicassoAssigned {
}
/** Unassigned Picasso */
interface PicassoUnassigned {
}
/** Assigned Wixel */
interface WixelAssigned {
}
/** Unassigned Wixel */
interface WixelUnassigned {
}
/** Assigned StudioTwo */
interface StudioTwoAssigned {
}
/** Unassigned StudioTwo */
interface StudioTwoUnassigned {
}
interface Empty {
}
/** Encapsulates all changes when site properties are updated */
interface SitePropertiesUpdated {
    /** ID of the Wix site that has been updated. */
    metasiteId?: string;
    /** Update details. */
    event?: SitePropertiesEvent;
}
/** The actual update event for a particular notification. */
interface SitePropertiesEvent {
    /** Version of the site's properties represented by this update. */
    version?: number;
    /** Set of properties that were updated - corresponds to the fields in "properties". */
    fields?: string[];
    /** Updated properties. */
    properties?: Properties;
}
interface Properties {
    /** Site categories. */
    categories?: Categories;
    /** Site locale. */
    locale?: Locale;
    /**
     * Site language.
     *
     * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
     */
    language?: string | null;
    /**
     * Site currency format used to bill customers.
     *
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    paymentCurrency?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Fax number. */
    fax?: string | null;
    /** Address. */
    address?: Address;
    /** Site display name. */
    siteDisplayName?: string | null;
    /** Business name. */
    businessName?: string | null;
    /** Path to the site's logo in Wix Media (without Wix Media base URL). */
    logo?: string | null;
    /** Site description. */
    description?: string | null;
    /**
     * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /** Supported languages of a site and the primary language. */
    multilingual?: Multilingual;
    /** Cookie policy the Wix user defined for their site (before the site visitor interacts with/limits it). */
    consentPolicy?: ConsentPolicy;
    /**
     * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
     *
     * Site business type.
     */
    businessConfig?: string | null;
    /** External site URL that uses Wix as its headless business solution. */
    externalSiteUrl?: string | null;
    /** Track clicks analytics. */
    trackClicksAnalytics?: boolean;
}
interface Categories {
    /** Primary site category. */
    primary?: string;
    /**
     * Secondary site category.
     * @maxSize 50
     */
    secondary?: string[];
    /** Business Term Id */
    businessTermId?: string | null;
}
interface Locale {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
    country?: string;
}
interface Address {
    /** Street name. */
    street?: string;
    /** City name. */
    city?: string;
    /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
    country?: string;
    /** State. */
    state?: string;
    /**
     * Zip or postal code.
     * @maxLength 20
     */
    zip?: string;
    /** Extra information to be displayed in the address. */
    hint?: AddressHint;
    /** Whether this address represents a physical location. */
    isPhysical?: boolean;
    /** Google-formatted version of this address. */
    googleFormattedAddress?: string;
    /** Street number. */
    streetNumber?: string;
    /** Apartment number. */
    apartmentNumber?: string;
    /** Geographic coordinates of location. */
    coordinates?: GeoCoordinates;
}
/**
 * Extra information on displayed addresses.
 * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
 * Free text. In addition, the user can state where to display the additional description - before, after, or instead of the address string.
 */
interface AddressHint {
    /** Extra text displayed next to, or instead of, the actual address. */
    text?: string;
    /** Where the extra text should be displayed. */
    placement?: PlacementTypeWithLiterals;
}
/** Where the extra text should be displayed: before, after or instead of the actual address. */
declare enum PlacementType {
    BEFORE = "BEFORE",
    AFTER = "AFTER",
    REPLACE = "REPLACE"
}
/** @enumType */
type PlacementTypeWithLiterals = PlacementType | 'BEFORE' | 'AFTER' | 'REPLACE';
/** Geocoordinates for a particular address. */
interface GeoCoordinates {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number;
}
/** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
interface BusinessSchedule {
    /**
     * Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods.
     * @maxSize 100
     */
    periods?: TimePeriod[];
    /**
     * Exceptions to the business's regular hours. The business can be open or closed during the exception.
     * @maxSize 100
     */
    specialHourPeriod?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the business is regularly open or the service is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     *
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
/** Enumerates the days of the week. */
declare enum DayOfWeek {
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY",
    SUNDAY = "SUNDAY"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /**
     * Whether the business is closed (or the service is not available) during the exception.
     *
     * Default: `true`.
     */
    isClosed?: boolean;
    /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
    comment?: string;
}
interface Multilingual {
    /**
     * Supported languages list.
     * @maxSize 200
     */
    supportedLanguages?: SupportedLanguage[];
    /** Whether to redirect to user language. */
    autoRedirect?: boolean;
}
interface SupportedLanguage {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Locale. */
    locale?: Locale;
    /** Whether the supported language is the primary language for the site. */
    isPrimary?: boolean;
    /** Language icon. */
    countryCode?: string;
    /** How the language will be resolved. For internal use. */
    resolutionMethod?: ResolutionMethodWithLiterals;
    /** Whether the supported language is the primary language for site visitors. */
    isVisitorPrimary?: boolean | null;
}
declare enum ResolutionMethod {
    QUERY_PARAM = "QUERY_PARAM",
    SUBDOMAIN = "SUBDOMAIN",
    SUBDIRECTORY = "SUBDIRECTORY"
}
/** @enumType */
type ResolutionMethodWithLiterals = ResolutionMethod | 'QUERY_PARAM' | 'SUBDOMAIN' | 'SUBDIRECTORY';
interface ConsentPolicy {
    /** Whether the site uses cookies that are essential to site operation. Always `true`. */
    essential?: boolean | null;
    /** Whether the site uses cookies that affect site performance and other functional measurements. */
    functional?: boolean | null;
    /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
    analytics?: boolean | null;
    /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
    advertising?: boolean | null;
    /** CCPA compliance flag. */
    dataToThirdParty?: boolean | null;
}
interface NewNotificationMessage {
    /** payload */
    payload?: NotificationInfo;
    /** template_topic_params */
    templateTopicParams?: Record<string, string>;
}
interface NotificationInfo {
    /** recipient identifier */
    recipient?: NotificationRecipient;
    /** notification id, unique per notification per recipient */
    notificationId?: string;
    /** correlation id. will be the same id for all the notifications that were created from the same notify request */
    correlationId?: string;
    /** the spout who sent this notification */
    spout?: NotificationsSpout;
    /** who initiated this notification */
    initiator?: NotificationInitiator;
    /** identifier of the template that the notification is based on. if you don't know what notification templates are, RTFM */
    templateId?: string;
    /** The context of the notification, used to determine recipient settings, aggregating notifications, etc.  Please use the topic builder in order to create topics. */
    topic?: string;
    /** when the notification was sent */
    sentAt?: Date | null;
    /** strings that will be replaced when translating the notification */
    translationParams?: Record<string, string>;
    /** data that will be sent to the channels */
    data?: Record<string, any> | null;
    /** the link of the notification */
    actionTarget?: ActionTarget;
    /** the link of the notification */
    actionTargetWhenGrouped?: ActionTarget;
}
/** Notification Recipient represents a user that receives notifications from Ping */
interface NotificationRecipient extends NotificationRecipientRecipientTypeOneOf {
    /**
     * test recipient id
     * @format GUID
     */
    testRecipient?: string;
    /**
     * Wix user id
     * @format GUID
     */
    wixUser?: string;
    /** contact identifier */
    contact?: Contact;
    /** Incognito (unidentified recipient) */
    incognito?: IncognitoDetails;
    /** DeviantArt user */
    deviantArtUser?: string;
}
/** @oneof */
interface NotificationRecipientRecipientTypeOneOf {
    /**
     * test recipient id
     * @format GUID
     */
    testRecipient?: string;
    /**
     * Wix user id
     * @format GUID
     */
    wixUser?: string;
    /** contact identifier */
    contact?: Contact;
    /** Incognito (unidentified recipient) */
    incognito?: IncognitoDetails;
    /** DeviantArt user */
    deviantArtUser?: string;
}
interface Contact {
    /**
     * meta site id
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * contact id
     * @format GUID
     */
    contactId?: string;
}
interface IncognitoDetails {
    /**
     * name
     * @format EMAIL
     */
    name?: string | null;
    /**
     * email
     * @format EMAIL
     */
    email?: string | null;
    /**
     * phone
     * @format PHONE
     */
    phone?: string | null;
    /** locale */
    locale?: string | null;
    /** language */
    language?: string | null;
}
interface NotificationsSpout extends NotificationsSpoutSpoutTypeOneOf {
    /** wix app */
    wixApp?: string;
    /** internal service */
    internalService?: string;
}
/** @oneof */
interface NotificationsSpoutSpoutTypeOneOf {
    /** wix app */
    wixApp?: string;
    /** internal service */
    internalService?: string;
}
interface NotificationInitiator extends NotificationInitiatorInitiatorOneOf {
    /**
     * wix user id
     * @format GUID
     */
    wixUser?: string;
    /**
     * wix app def id (for TPAs)
     * @format GUID
     */
    wixApp?: string;
    /** contact identifier */
    contact?: Contact;
    /** Site member identifier */
    siteMember?: SiteMember;
    /** Anonymous (free string) */
    anonymous?: string;
    /** Business (as metaSiteId) */
    business?: string;
}
/** @oneof */
interface NotificationInitiatorInitiatorOneOf {
    /**
     * wix user id
     * @format GUID
     */
    wixUser?: string;
    /**
     * wix app def id (for TPAs)
     * @format GUID
     */
    wixApp?: string;
    /** contact identifier */
    contact?: Contact;
    /** Site member identifier */
    siteMember?: SiteMember;
    /** Anonymous (free string) */
    anonymous?: string;
    /** Business (as metaSiteId) */
    business?: string;
}
interface SiteMember {
    /**
     * site member id
     * @format GUID
     */
    siteMemberId?: string;
    /**
     * meta site id
     * @format GUID
     */
    metaSiteId?: string;
}
/** DB */
interface ActionTarget extends ActionTargetOfOneOf {
    /** url */
    url?: string;
    /** backoffice app */
    backofficeApp?: BackofficeActionTarget;
    /** live site */
    liveSite?: LiveSiteActionTarget;
    /** dashboard page */
    dashboardPage?: DashboardPageActionTarget;
}
/** @oneof */
interface ActionTargetOfOneOf {
    /** url */
    url?: string;
    /** backoffice app */
    backofficeApp?: BackofficeActionTarget;
    /** live site */
    liveSite?: LiveSiteActionTarget;
    /** dashboard page */
    dashboardPage?: DashboardPageActionTarget;
}
interface BackofficeActionTarget {
    /** app id */
    appId?: string;
    /**
     * meta site id
     * @format GUID
     */
    metaSiteId?: string;
    /** params */
    params?: Record<string, string>;
}
interface LiveSiteActionTarget {
    /**
     * meta site id
     * @format GUID
     */
    metaSiteId?: string;
    /** app page id */
    appPageId?: string | null;
    /** params */
    params?: Record<string, string>;
}
interface DashboardPageActionTarget {
    /** @format GUID */
    pageId?: string;
    /** @maxLength 300 */
    relativeUrl?: string | null;
}
interface AgreeToServiceFeeRequest {
    /**
     * Settings categories to return after recording the service fee agreement.
     * @maxSize 6
     */
    fields?: RequestedFieldsWithLiterals[];
}
interface AgreeToServiceFeeResponse {
    /** Events Settings after recording the service fee agreement. */
    eventsSettings?: EventsSettings;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface FeatureEvent extends FeatureEventEventOneOf {
    /**
     * Information about an event that makes a feature eligible to the user.
     * Triggered for example, for new features or when a feature is reassigned
     * to an account or a site.
     */
    enabled?: FeatureEnabled;
    /**
     * Information about an event that disables a feature for the user.
     * Triggered for example, when a feature is unassigned from a site,
     * reassigned to a different site, or the user switched to a different contract.
     */
    disabled?: FeatureDisabled;
    /**
     * Information about an event that updates a feature. An `updated` event
     * is triggered for example by the
     * [Report Quota Usage](https://bo.wix.com/wix-docs/rest/premium/premium-features-manager/report-quota-usage)
     * and [Reset Usage Counter](https://bo.wix.com/wix-docs/rest/premium/premium-features-manager/reset-usage-counter)
     * endpoints.
     */
    updated?: FeatureUpdated;
    /**
     * Information about an event that cancels a feature for the user.
     * Triggered for example, when a feature is canceled, transferred to
     * another account, or the user switched to a different contract.
     */
    cancelled?: FeatureCancelled;
    /**
     * Timestamp of the event in
     * [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
     */
    timestamp?: Date | null;
}
/** @oneof */
interface FeatureEventEventOneOf {
    /**
     * Information about an event that makes a feature eligible to the user.
     * Triggered for example, for new features or when a feature is reassigned
     * to an account or a site.
     */
    enabled?: FeatureEnabled;
    /**
     * Information about an event that disables a feature for the user.
     * Triggered for example, when a feature is unassigned from a site,
     * reassigned to a different site, or the user switched to a different contract.
     */
    disabled?: FeatureDisabled;
    /**
     * Information about an event that updates a feature. An `updated` event
     * is triggered for example by the
     * [Report Quota Usage](https://bo.wix.com/wix-docs/rest/premium/premium-features-manager/report-quota-usage)
     * and [Reset Usage Counter](https://bo.wix.com/wix-docs/rest/premium/premium-features-manager/reset-usage-counter)
     * endpoints.
     */
    updated?: FeatureUpdated;
    /**
     * Information about an event that cancels a feature for the user.
     * Triggered for example, when a feature is canceled, transferred to
     * another account, or the user switched to a different contract.
     */
    cancelled?: FeatureCancelled;
}
/** Feature created or enabled after disabled state */
interface FeatureEnabled extends FeatureEnabledReasonOneOf {
    /** Information about a transfer from another account. */
    transferredFromAnotherAccount?: TransferredFromAnotherAccountReason;
    /** Information about a transfer from another site. */
    reassignedFromSite?: ReassignedFromSiteReason;
    /** Information about a feature that hadn't been assigned to site. */
    assignedFromFloating?: AssignedFromFloatingReason;
    /** Information about the new feature. */
    newFeature?: NewFeatureReason;
    /** Information about the contract switch. */
    contractSwitched?: ContractSwitchedReason;
    /** Information about the manually created features. */
    manualFeatureCreation?: ManualFeatureCreationReason;
    /** Information about a feature that was migrated from legacy. */
    migratedFromLegacy?: MigratedFromLegacyReason;
    /** Enabled feature. */
    feature?: Feature;
    /**
     * Information about a transfer from another account.
     * __Deprecated__. Use `reason.transferred_from_another_account` instead.
     * @format GUID
     */
    transferredFromAccount?: string | null;
    /**
     * Information about a transfer from another site.
     * __Deprecated__. Use `reason.reassigned_from_site` instead.
     * @format GUID
     */
    reassignedFromMetasite?: string | null;
}
/** @oneof */
interface FeatureEnabledReasonOneOf {
    /** Information about a transfer from another account. */
    transferredFromAnotherAccount?: TransferredFromAnotherAccountReason;
    /** Information about a transfer from another site. */
    reassignedFromSite?: ReassignedFromSiteReason;
    /** Information about a feature that hadn't been assigned to site. */
    assignedFromFloating?: AssignedFromFloatingReason;
    /** Information about the new feature. */
    newFeature?: NewFeatureReason;
    /** Information about the contract switch. */
    contractSwitched?: ContractSwitchedReason;
    /** Information about the manually created features. */
    manualFeatureCreation?: ManualFeatureCreationReason;
    /** Information about a feature that was migrated from legacy. */
    migratedFromLegacy?: MigratedFromLegacyReason;
}
interface Feature extends FeatureQuantityInfoOneOf {
    /**
     * Deprecated. Use `enabled` instead.
     * @deprecated
     */
    booleanFeature?: BooleanFeature;
    /**
     * Deprecated. Use `quotaInfo` instead.
     * @deprecated
     */
    quotaFeature?: QuotaFeature;
    /**
     * ID of the feature. __Note:__ Isn't unique. For example, all features that
     * are available to free Wix accounts or site in some capacity have
     * `{"id": "DEFAULT"}`. Use `uniqueName` as unique identifier for a feature.
     * @readonly
     */
    _id?: string;
    /**
     * Unique name of the feature. Only lower case letters, numbers, and dashes
     * `-` are supported. Used in the endpoints of the
     * [Features Manager API](https://bo.wix.com/wix-docs/rest/premium/premium-features-manager/introduction)
     * to specify the feature. Not visible to customers. We recommend to start
     * the unique name with a prefix describing your organization or Wix company.
     * For example, `bookings` or `crm`.
     *
     * Min: 2 characters
     * Max: 50 characters
     * @minLength 2
     * @maxLength 50
     */
    uniqueName?: string;
    /**
     * Information about whether the feature belongs to a Wix account or site.
     * Account features have `context.userId`. Site features have `context.metaSiteId` in case
     * they're assigned to a specific site. Site features that aren't assigned to
     * a specific site have neither ID.
     */
    context?: FeatureContext;
    /**
     * Deprecated.
     * @readonly
     * @deprecated
     */
    createdAt?: Date | null;
    /**
     * Deprecated.
     * @readonly
     * @deprecated
     */
    updatedAt?: Date | null;
    /**
     * Aggregated information about how often customers can use the feature.
     * Available only for quota features.
     */
    quotaInfo?: QuotaInfo;
    /**
     * Whether the customer is currently allowed to use the feature.
     * `true` means that the customer can use the feature. This means a boolean
     * feature is active or a quota feature has remaining usage.
     * `false` means that the customer can't use the feature.
     * This means a boolean feature isn't active or a quota feature doesn't
     * have remaining usage.
     */
    enabled?: boolean;
    /**
     * ID of the [subscription](https://bo.wix.com/wix-docs/rest/premium/premium-subscriptions-manager/subscription-object)
     * to which the feature instance belongs.
     * @format GUID
     */
    subscriptionId?: string | null;
    /**
     * Metadata of the feature. Wix Premium uses the metadata object to indicate
     * that customers who purchase a product with the feature also get
     * access to an additional product. For these bundled products `metadata`
     * looks like this: `{"tpa": "{"appDefId": "sample-app-def-id-1234567890", "vendorProductId": "sample-productId"}}"`.
     * But you can use the `metadata` property for other purposes, too.
     */
    metadata?: Record<string, string>;
}
/** @oneof */
interface FeatureQuantityInfoOneOf {
    /**
     * Deprecated. Use `enabled` instead.
     * @deprecated
     */
    booleanFeature?: BooleanFeature;
    /**
     * Deprecated. Use `quotaInfo` instead.
     * @deprecated
     */
    quotaFeature?: QuotaFeature;
}
/**
 * Context this feature is currently connected to.
 * Note: Do not confuse with feature scope which is configured in the product catalog
 * and defines in which context the product can be used
 */
interface FeatureContext {
    /**
     * ID of the Wix account that the feature instance belongs to.
     * Available for both site and account level feature instances.
     * @format GUID
     */
    userId?: string;
    /**
     * ID of the meta site that the feature instance is assigned to.
     * Only available for site level feature instances that are assigned to a Wix
     * site. Not available for account level and unassigned site level feature
     * instances.
     * @format GUID
     */
    metaSiteId?: string | null;
}
/**
 * A feature that can be either "enabled" or "disabled". The default/freemium setting is always OFF, and the premium setting is always ON (meaning, unlimited usage without tracking).
 * A boolean feature is similar to a quantitive feature with a default limit of 0 and UNLIMITED premium limit (although a bit simplified).
 */
interface BooleanFeature {
}
/** A feature with a periodic usage limitation. The default limit is defined in the Feature Spec, the Premium limits are defined in the respective ProductFeature. */
interface QuotaFeature {
    /** Default (or Freemium) quota limitation. if left undefined the free feature has unlimited amount. */
    limit?: string | null;
    /** Periodic time-frame to reset the usage counter. You may use NO_PERIOD if counter shouldn't be reset. */
    period?: FeaturePeriodWithLiterals;
    /** Usage measurement units (seconds? MBs? unitless?). Usage reported will be counted in multiples of this basic unit. */
    units?: string | null;
}
/** Determines the reset cycle of the feature usage. */
declare enum FeaturePeriod {
    NO_PERIOD = "NO_PERIOD",
    MILLISECOND = "MILLISECOND",
    SECOND = "SECOND",
    MINUTE = "MINUTE",
    HOUR = "HOUR",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
/** @enumType */
type FeaturePeriodWithLiterals = FeaturePeriod | 'NO_PERIOD' | 'MILLISECOND' | 'SECOND' | 'MINUTE' | 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
interface QuotaInfo {
    /**
     * Aggregation of how often the customer is allowed to use the feature at the time of the request.
     * `null` means that the customer has unlimited access to the feature.
     */
    limit?: string | null;
    /**
     * Deprecated because a feature can have multiple periods defined. Use `period` in `breakdown` entries instead.
     * Time frame for the usage limitation. `NO_PERIOD` means that `remainingUsage`
     * isn't automatically reset to the feature's `limit` after a specific period.
     * You may still manually call
     * [Reset Usage Counter](https://bo.wix.com/wix-docs/rest/premium/premium-features-manager/reset-usage-counter).
     * @deprecated
     * @replacedBy breakdown.period
     * @targetRemovalDate 2026-03-31
     */
    period?: FeaturePeriodWithLiterals;
    /**
     * Aggregation of how often the customer has used the feature.
     * This value is retrieved from the Quota Manager/Rate Limiter system. If the
     * `exclude_quota_usage` field in the `ListFeaturesRequest` was set to `true`,
     * this field will contain the value `-1`.
     */
    currentUsage?: string;
    /**
     * Aggregation of how often the customer can still use the feature.
     * `null` means that the customer has unlimited access to the feature.
     * This value is retrieved from the Quota Manager/Rate Limiter system. If the
     * `exclude_quota_usage` field in the `ListFeaturesRequest` was set to `true`,
     * this field will not be populated.
     */
    remainingUsage?: string | null;
    /**
     * Breakdown of quota information entries, entry per feature instance.
     * @maxSize 100
     */
    breakdown?: QuotaInfoEntry[];
}
interface QuotaInfoEntry {
    /**
     * If quota is of free feature, the id would be empty (None).
     * If quota is of premium feature, this is the ID of the feature instance.
     * @format GUID
     */
    featureInstanceId?: string | null;
    /**
     * How often the customer is allowed to use the feature during the specified
     * period. `null` means that the customer has unlimited access to the feature.
     */
    limit?: string | null;
    /**
     * Time frame for the usage limitation. `NO_PERIOD` means that `remainingUsage`
     * isn't automatically reset to the feature's `limit` after a specific period.
     * You may still manually call
     * [Reset Usage Counter](https://bo.wix.com/wix-docs/rest/premium/premium-features-manager/reset-usage-counter).
     */
    period?: FeaturePeriodWithLiterals;
    /**
     * How often the customer has used the feature during the current
     * period.
     * This value is retrieved from the Quota Manager/Rate Limiter system. If the
     * `exclude_quota_usage` field in the `ListFeaturesRequest` was set to `true`,
     * this field will contain the value `-1`.
     */
    currentUsage?: string;
    /**
     * How often the customer can still use the feature during the current
     * period. `null` means that the customer has unlimited access to the feature.
     * This value is retrieved from the Quota Manager/Rate Limiter system. If the
     * `exclude_quota_usage` field in the `ListFeaturesRequest` was set to `true`,
     * this field will not be populated.
     */
    remainingUsage?: string | null;
    /**
     * ID of the subscription to which the feature instance belongs.
     * @format GUID
     */
    subscriptionId?: string | null;
}
/** Subscription transferred from another account, features on the current account were enabled. */
interface TransferredFromAnotherAccountReason {
    /**
     * Information about a transfer from another account.
     * @format GUID
     */
    transferredFromAccount?: string;
}
/** Subscription moved from one site to another in the same account, features enabled on the target site */
interface ReassignedFromSiteReason {
    /**
     * Information about a transfer from another site.
     * @format GUID
     */
    reassignedFromMetasite?: string;
}
/** Subscription was floating and assigned to site, features enabled on the target site */
interface AssignedFromFloatingReason {
}
/** New subscription created and features created as enabled */
interface NewFeatureReason {
}
/** Subscription was upgraded or downgraded, as a result new features enabled, missing features disabled , quantities are updated */
interface ContractSwitchedReason {
}
/** a call to CreateFeature in features-writer, creates feature that is not attached to subscription */
interface ManualFeatureCreationReason {
}
/** Subscription created due to migration from old premium model */
interface MigratedFromLegacyReason {
}
/** Feature disabled and can be enabled in the future */
interface FeatureDisabled extends FeatureDisabledReasonOneOf {
    /** Information about a feature that's no longer assigned to a site. */
    unassingedToFloating?: UnAssingedToFloatingReason;
    /**
     * Information about a feature that's been replaced by a feature from a
     * different subscription.
     */
    replacedByAnotherSubscription?: ReplacedByAnotherSubscriptionReason;
    /**
     * Information about a feature that's been reassigned to a different
     * site.
     */
    reassignedToAnotherSite?: ReassignedToAnotherSiteReason;
    /**
     * Disabled feature. Includes information about the feature's new state,
     * possibly its new context.
     */
    feature?: Feature;
    /**
     * ID of the meta site for which the feature has been disabled.
     * @format GUID
     */
    metaSiteId?: string | null;
}
/** @oneof */
interface FeatureDisabledReasonOneOf {
    /** Information about a feature that's no longer assigned to a site. */
    unassingedToFloating?: UnAssingedToFloatingReason;
    /**
     * Information about a feature that's been replaced by a feature from a
     * different subscription.
     */
    replacedByAnotherSubscription?: ReplacedByAnotherSubscriptionReason;
    /**
     * Information about a feature that's been reassigned to a different
     * site.
     */
    reassignedToAnotherSite?: ReassignedToAnotherSiteReason;
}
/** Subscription was unassigned from the site and moved into floating state */
interface UnAssingedToFloatingReason {
}
/** Another subscription was assigned to the site, causing existing features on this site to be disabled */
interface ReplacedByAnotherSubscriptionReason {
}
/** Subscription was assigned to another site, causing  features on the origin  site to be disabled. */
interface ReassignedToAnotherSiteReason {
    /**
     * Information about a transfer to the site.
     * @format GUID
     */
    reassignedToMetasite?: string;
}
/** Feature updated, for example Quota was increased due to upgrade */
interface FeatureUpdated extends FeatureUpdatedPreviousQuantityInfoOneOf, FeatureUpdatedReasonOneOf {
    /** Information about a feature that doesn't have a usage quota. */
    booleanFeature?: BooleanFeature;
    /** Information about a feature that has a usage quota. */
    quotaFeature?: QuotaFeature;
    /** Information about the contract switch. */
    contractSwitched?: ContractSwitchedReason;
    /**
     * Updated feature. Includes information about the feature's new state and
     * possibly its new context.
     */
    feature?: Feature;
}
/** @oneof */
interface FeatureUpdatedPreviousQuantityInfoOneOf {
    /** Information about a feature that doesn't have a usage quota. */
    booleanFeature?: BooleanFeature;
    /** Information about a feature that has a usage quota. */
    quotaFeature?: QuotaFeature;
}
/** @oneof */
interface FeatureUpdatedReasonOneOf {
    /** Information about the contract switch. */
    contractSwitched?: ContractSwitchedReason;
}
/** Feature was permanently cancelled */
interface FeatureCancelled extends FeatureCancelledReasonOneOf {
    /** Information about a transfer to the account. */
    transferredToAnotherAccount?: TransferredToAnotherAccountReason;
    /** Information about the contract switch. */
    contractSwitched?: ContractSwitchedReason;
    /** Information about the feature cancellation. */
    cancelRequest?: CancelRequestedReason;
    /** Canceled feature. */
    feature?: Feature;
    /**
     * Information about a transfer to the account.
     * __Deprecated__. Use `reason.transferred_to_account` instead.
     * @format GUID
     */
    transferredToAccount?: string | null;
}
/** @oneof */
interface FeatureCancelledReasonOneOf {
    /** Information about a transfer to the account. */
    transferredToAnotherAccount?: TransferredToAnotherAccountReason;
    /** Information about the contract switch. */
    contractSwitched?: ContractSwitchedReason;
    /** Information about the feature cancellation. */
    cancelRequest?: CancelRequestedReason;
}
/** Subscription was transferred to another account, features in the origin account were cancelled */
interface TransferredToAnotherAccountReason {
    /**
     * Information about a transfer to the account.
     * @format GUID
     */
    transferredToAccount?: string;
}
/** Cancellation was requested from the subscription manager api, might be a result of billing event, or direct call */
interface CancelRequestedReason {
}
interface RefreshTicketsFlagsRequest {
}
interface RefreshTicketsFlagsResponse {
    /** Whether any events on the site sell tickets (free or paid). */
    sellingTickets?: boolean | null;
    /** Whether any events on the site sell paid tickets. */
    sellingPaidTickets?: boolean | null;
}
interface UpdateEventsFeeSettingsRequest {
    /** Whether Wix service fees should be applied to paid ticket sales on this site. */
    serviceFeeEnabled?: boolean | null;
    /** Date when service fees should become active. Used for sites that are enabling fees for the first time. */
    serviceFeeActivationDate?: Date | null;
    /** Date when the site owner agreed to service fee terms. Required for fee activation on older sites. */
    serviceFeeActivationAgreementDate?: Date | null;
    /**
     * Specific fields to update in the service fee settings. Use this to control which fee-related properties are modified.
     * @maxSize 3
     */
    patchFields?: PatchFieldWithLiterals[];
}
/** Fields that can be updated in service fee settings. */
declare enum PatchField {
    UNKNOWN_PATCH_FIELD = "UNKNOWN_PATCH_FIELD",
    /** Update whether service fees are enabled for paid ticket sales. */
    FEE_ENABLED = "FEE_ENABLED",
    /** Update the date when service fees became active on the site. */
    FEE_ACTIVATION_DATE = "FEE_ACTIVATION_DATE",
    /** Update the date when the site owner agreed to service fee terms. */
    FEE_ACTIVATION_AGREEMENT_DATE = "FEE_ACTIVATION_AGREEMENT_DATE"
}
/** @enumType */
type PatchFieldWithLiterals = PatchField | 'UNKNOWN_PATCH_FIELD' | 'FEE_ENABLED' | 'FEE_ACTIVATION_DATE' | 'FEE_ACTIVATION_AGREEMENT_DATE';
interface UpdateEventsFeeSettingsResponse {
    /** Updated Events Settings. */
    eventsSettings?: EventsSettings;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface EventsSettingsUpdatedEnvelope {
    entity: EventsSettings;
    metadata: EventMetadata;
}
/**
 * Triggered when Events Settings are updated.
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-EVENTS
 * @permissionId WIX_EVENTS.READ_EVENTS_SETTINGS
 * @webhook
 * @eventType wix.events.v1.events_settings_updated
 * @slug updated
 * @documentationMaturity preview
 */
declare function onEventsSettingsUpdated(handler: (event: EventsSettingsUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves the current events settings for a site.
 * @public
 * @documentationMaturity preview
 * @permissionId WIX_EVENTS.READ_EVENTS_SETTINGS
 * @applicableIdentity APP
 * @fqn wix.events.settings.v1.EventsSettingsService.GetEventsSettings
 */
declare function getEventsSettings(options?: GetEventsSettingsOptions): Promise<NonNullablePaths<GetEventsSettingsResponse, `eventsSettings.siteInfo.premiumFeatures` | `eventsSettings.paymentSettings.activePaymentMethods` | `eventsSettings.paymentSettings.activePaymentMethods.${number}.methodId`, 6>>;
interface GetEventsSettingsOptions {
    /**
     * Settings categories to include in the response. If omitted, returns only basic settings for performance optimization. Use this to request specific information like premium features or payment settings.
     * @maxSize 9
     */
    fields?: RequestedFieldsWithLiterals[];
}
/**
 * Updates Events Settings.
 * @param _id - Events Settings ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField eventsSettings
 * @requiredField eventsSettings.revision
 * @permissionId WIX_EVENTS.UPDATE_EVENTS_SETTINGS
 * @applicableIdentity APP
 * @returns The updated Events Settings object reflecting the applied changes.
 * @fqn wix.events.settings.v1.EventsSettingsService.UpdateEventsSettings
 */
declare function updateEventsSettings(_id: string, eventsSettings: NonNullablePaths<UpdateEventsSettings, `revision`, 2>, options?: UpdateEventsSettingsOptions): Promise<NonNullablePaths<EventsSettings, `siteInfo.premiumFeatures` | `paymentSettings.activePaymentMethods` | `paymentSettings.activePaymentMethods.${number}.methodId`, 5>>;
interface UpdateEventsSettings {
    /**
     * Events Settings ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Date and time the Events Settings were created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the Events Settings were last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Revision number, which increments by 1 each time the Events Settings are updated. To prevent conflicting changes, the current revision must be passed when updating the Events Settings.
     * @readonly
     */
    revision?: string | null;
    /**
     * Site information including locale, language, and available premium features.
     * @readonly
     */
    siteInfo?: SiteInfo;
    /**
     * Global information about the site's events, including whether any events have been created and current ticket sales status.
     * @readonly
     */
    eventsInfo?: EventsInfo;
    /**
     * Settings for Wix service fees applied to paid ticket sales.
     * @readonly
     */
    serviceFeeSettings?: ServiceFeeSettings;
    /** Payment configuration including available payment methods, coupon acceptance, and delayed capture settings. */
    paymentSettings?: PaymentSettings;
}
interface UpdateEventsSettingsOptions {
    /**
     * Settings categories to return in the response. Use this to optimize the response size by requesting only needed information.
     * @maxSize 6
     */
    fields?: RequestedFieldsWithLiterals[];
}

export { Action, type ActionEvent, type ActionTarget, type ActionTargetOfOneOf, type ActionWithLiterals, type Address, type AddressHint, type AgreeToServiceFeeRequest, type AgreeToServiceFeeResponse, type AppState, AppStateState, type AppStateStateWithLiterals, type Asset, type AssignedFromFloatingReason, type BackofficeActionTarget, type BaseEventMetadata, type BooleanFeature, type BusinessSchedule, type CancelRequestedReason, type Categories, CheckoutType, type CheckoutTypeWithLiterals, type ConsentPolicy, type Contact, type ContractSwitchedReason, type DashboardPageActionTarget, DayOfWeek, type DayOfWeekWithLiterals, type DelayedPaymentCaptureSettings, type DeleteContext, DeleteStatus, type DeleteStatusWithLiterals, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventBadgesSettings, type EventMetadata, type EventPages, type EventsInfo, type EventsSettings, type EventsSettingsUpdatedEnvelope, type Feature, type FeatureCancelled, type FeatureCancelledReasonOneOf, type FeatureContext, type FeatureDisabled, type FeatureDisabledReasonOneOf, type FeatureEnabled, type FeatureEnabledReasonOneOf, type FeatureEvent, type FeatureEventEventOneOf, FeaturePeriod, type FeaturePeriodWithLiterals, type FeatureQuantityInfoOneOf, type FeatureUpdated, type FeatureUpdatedPreviousQuantityInfoOneOf, type FeatureUpdatedReasonOneOf, type GeoCoordinates, type GetEventsSettingsOptions, type GetEventsSettingsRequest, type GetEventsSettingsResponse, type IdentificationData, type IdentificationDataIdOneOf, type IncognitoDetails, type LiveSiteActionTarget, type Locale, type ManualFeatureCreationReason, type MessageEnvelope, type MetaSiteSpecialEvent, type MetaSiteSpecialEventPayloadOneOf, type MigratedFromLegacyReason, type Multilingual, Namespace, type NamespaceChanged, type NamespaceWithLiterals, type NewFeatureReason, type NewNotificationMessage, type NotificationInfo, type NotificationInitiator, type NotificationInitiatorInitiatorOneOf, type NotificationRecipient, type NotificationRecipientRecipientTypeOneOf, type NotificationsSpout, type NotificationsSpoutSpoutTypeOneOf, type OdeditorAssigned, type OdeditorUnassigned, PatchField, type PatchFieldWithLiterals, type PaymentMethod, type PaymentSettings, type PicassoAssigned, type PicassoUnassigned, PlacementType, type PlacementTypeWithLiterals, PremiumFeature, type PremiumFeatureWithLiterals, type Properties, type QuotaFeature, type QuotaInfo, type QuotaInfoEntry, type ReassignedFromSiteReason, type ReassignedToAnotherSiteReason, type RefreshTicketsFlagsRequest, type RefreshTicketsFlagsResponse, type ReplacedByAnotherSubscriptionReason, RequestedFields, type RequestedFieldsWithLiterals, ResolutionMethod, type ResolutionMethodWithLiterals, type RestoreInfo, type ServiceFeeSettings, type ServiceProvisioned, type ServiceRemoved, type SiteCreated, SiteCreatedContext, type SiteCreatedContextWithLiterals, type SiteDeleted, type SiteHardDeleted, type SiteInfo, type SiteMarkedAsTemplate, type SiteMarkedAsWixSite, type SiteMember, type SitePropertiesEvent, type SitePropertiesUpdated, type SitePublished, type SitePurgedExternally, type SiteRenamed, type SiteSettings, type SiteTransferred, type SiteUndeleted, type SiteUnpublished, type SiteUrlChanged, type SpecialHourPeriod, State, type StateWithLiterals, type StudioAssigned, type StudioTwoAssigned, type StudioTwoUnassigned, type StudioUnassigned, type SupportedLanguage, type TimePeriod, type TransferredFromAnotherAccountReason, type TransferredToAnotherAccountReason, Type, type TypeWithLiterals, type UnAssingedToFloatingReason, type UpdateEventsFeeSettingsRequest, type UpdateEventsFeeSettingsResponse, type UpdateEventsSettings, type UpdateEventsSettingsOptions, type UpdateEventsSettingsRequest, type UpdateEventsSettingsResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, type WixelAssigned, type WixelUnassigned, getEventsSettings, onEventsSettingsUpdated, updateEventsSettings };
