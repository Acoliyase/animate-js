import { NonNullablePaths } from '@wix/sdk-types';

interface EnterpriseCategory {
    /**
     * Id of the category
     * @maxLength 100
     * @readonly
     */
    _id?: string;
    /**
     * The display name that will be shown for the category
     * @maxLength 100
     * @minLength 2
     */
    displayName?: string | null;
    /**
     * Id of the parent category, will default to the account master category
     * @maxLength 100
     */
    parentCategoryId?: string | null;
    /** Sort order number of the category, will determine the order of the category with other categories under the same parent category */
    sortOrder?: number | null;
    /** Publish status of the category */
    publishStatus?: PublishStatusWithLiterals;
    /**
     * Date and time the category was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the category was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
}
declare enum PublishStatus {
    UNDEFINED = "UNDEFINED",
    UNPUBLISHED = "UNPUBLISHED",
    PUBLISHED = "PUBLISHED",
    WIX_ONLY = "WIX_ONLY"
}
/** @enumType */
type PublishStatusWithLiterals = PublishStatus | 'UNDEFINED' | 'UNPUBLISHED' | 'PUBLISHED' | 'WIX_ONLY';
declare enum MediaType {
    MIXED = "MIXED",
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
    AUDIO = "AUDIO",
    DOCUMENT = "DOCUMENT",
    VECTOR = "VECTOR",
    ARCHIVE = "ARCHIVE",
    MODEL3D = "MODEL3D"
}
/** @enumType */
type MediaTypeWithLiterals = MediaType | 'MIXED' | 'IMAGE' | 'VIDEO' | 'AUDIO' | 'DOCUMENT' | 'VECTOR' | 'ARCHIVE' | 'MODEL3D';
interface CreateCategoryRequest {
    /** The category object that will be created */
    category: EnterpriseCategory;
}
interface CreateCategoryResponse {
    /** A list of items matching the request */
    category?: EnterpriseCategory;
}
interface DeleteCategoryRequest {
    /**
     * Category id
     * @maxLength 100
     */
    categoryId: string;
}
interface DeleteCategoryResponse {
}
interface UpdateCategoryRequest {
    /** The category object that will be created */
    category: EnterpriseCategory;
}
interface UpdateCategoryResponse {
    /** The updated category */
    category?: EnterpriseCategory;
}
interface GetCategoryRequest {
    /**
     * Category id
     * @maxLength 100
     */
    categoryId: string;
    /** number of sub category levels */
    levels?: number | null;
    /** filter categories by publish statuses. When empty will return PUBLISHED and UNPUBLISHED */
    publishStatus?: PublishStatusWithLiterals;
}
interface GetCategoryResponse {
    /** The category details */
    category?: EnterpriseCategoryTree;
}
interface EnterpriseCategoryTree {
    /** Category information */
    category?: EnterpriseCategory;
    /**
     * Information about the sub categories
     * @maxSize 100
     */
    subCategories?: EnterpriseCategoryTree[];
}
interface EnterpriseOnboardingRequest {
    /**
     * The account id of the organization - will be used as the organization category id
     * @format GUID
     */
    accountId: string;
    /**
     * The account name of the organization - will be used as the organization category name
     * @maxLength 50
     */
    accountName?: string;
}
interface EnterpriseOnboardingResponse {
    /** The enterprise category */
    category?: EnterpriseCategory;
}
interface LinkItemsToCategoryRequest {
    /**
     * The category to link to
     * @maxLength 100
     */
    categoryId?: string;
    /**
     * The item ids that will be added to the category
     * @maxLength 100
     * @maxSize 50
     */
    itemIds?: string[];
}
interface LinkItemsToCategoryResponse {
}
interface UnlinkItemsFromCategoryRequest {
    /**
     * The category to link to
     * @maxLength 100
     */
    categoryId?: string;
    /**
     * The item ids that will be added to the category
     * @maxLength 100
     * @maxSize 50
     */
    itemIds?: string[];
}
interface UnlinkItemsFromCategoryResponse {
}
interface GetMediaManagerCategoriesRequest {
}
interface GetMediaManagerCategoriesResponse {
    /** The category details */
    category?: EnterpriseCategoryTree;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface EnterpriseCategoryCreatedEnvelope {
    entity: EnterpriseCategory;
    metadata: EventMetadata;
}
/** @webhook
 * @eventType wix.media.enterprise_public_media.v1.enterprise_category_created
 * @serviceIdentifier com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService
 * @slug created
 */
declare function onEnterpriseCategoryCreated(handler: (event: EnterpriseCategoryCreatedEnvelope) => void | Promise<void>): void;
interface EnterpriseCategoryDeletedEnvelope {
    entity: EnterpriseCategory;
    metadata: EventMetadata;
}
/** @webhook
 * @eventType wix.media.enterprise_public_media.v1.enterprise_category_deleted
 * @serviceIdentifier com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService
 * @slug deleted
 */
declare function onEnterpriseCategoryDeleted(handler: (event: EnterpriseCategoryDeletedEnvelope) => void | Promise<void>): void;
interface EnterpriseCategoryUpdatedEnvelope {
    entity: EnterpriseCategory;
    metadata: EventMetadata;
}
/** @webhook
 * @eventType wix.media.enterprise_public_media.v1.enterprise_category_updated
 * @serviceIdentifier com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService
 * @slug updated
 */
declare function onEnterpriseCategoryUpdated(handler: (event: EnterpriseCategoryUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Fetch a list of random media from different providers, using site information to customize results when available
 * @param category - The category object that will be created
 * @public
 * @requiredField category
 * @requiredField category.displayName
 * @permissionId MEDIA.ENTERPRISE_MEDIA_CATEGORIES_CREATE
 * @returns A list of items matching the request
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService.CreateCategory
 */
declare function createCategory(category: NonNullablePaths<EnterpriseCategory, `displayName`, 2>): Promise<NonNullablePaths<EnterpriseCategory, `_id` | `publishStatus`, 2>>;
/**
 * Delete a category including all its subcategories - but not the items
 * @param categoryId - Category id
 * @public
 * @requiredField categoryId
 * @permissionId MEDIA.ENTERPRISE_MEDIA_CATEGORIES_DELETE
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService.DeleteCategory
 */
declare function deleteCategory(categoryId: string): Promise<void>;
/**
 * Update category details
 * @param _id - Id of the category
 * @public
 * @requiredField _id
 * @requiredField category
 * @permissionId MEDIA.ENTERPRISE_MEDIA_CATEGORIES_UPDATE
 * @returns The updated category
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService.UpdateCategory
 */
declare function updateCategory(_id: string, category: UpdateCategory): Promise<NonNullablePaths<EnterpriseCategory, `_id` | `publishStatus`, 2>>;
interface UpdateCategory {
    /**
     * Id of the category
     * @maxLength 100
     * @readonly
     */
    _id?: string;
    /**
     * The display name that will be shown for the category
     * @maxLength 100
     * @minLength 2
     */
    displayName?: string | null;
    /**
     * Id of the parent category, will default to the account master category
     * @maxLength 100
     */
    parentCategoryId?: string | null;
    /** Sort order number of the category, will determine the order of the category with other categories under the same parent category */
    sortOrder?: number | null;
    /** Publish status of the category */
    publishStatus?: PublishStatusWithLiterals;
    /**
     * Date and time the category was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the category was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
}
/**
 * Get information about a specific category
 * @param categoryId - Category id
 * @public
 * @requiredField categoryId
 * @permissionId MEDIA.ENTERPRISE_MEDIA_CATEGORIES_READ
 * @returns The category details
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService.GetCategory
 */
declare function getCategory(categoryId: string, options?: GetCategoryOptions): Promise<NonNullablePaths<EnterpriseCategoryTree, `category._id` | `category.publishStatus` | `subCategories`, 3>>;
interface GetCategoryOptions {
    /** number of sub category levels */
    levels?: number | null;
    /** filter categories by publish statuses. When empty will return PUBLISHED and UNPUBLISHED */
    publishStatus?: PublishStatusWithLiterals;
}
/**
 * Create the enterprise category under "enterprise-media" main category
 * the caller identity must be have the same accountId of the request
 * @param accountId - The account id of the organization - will be used as the organization category id
 * @public
 * @requiredField accountId
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService.EnterpriseOnboarding
 */
declare function enterpriseOnboarding(accountId: string, options?: EnterpriseOnboardingOptions): Promise<NonNullablePaths<EnterpriseOnboardingResponse, `category._id` | `category.publishStatus`, 3>>;
interface EnterpriseOnboardingOptions {
    /**
     * The account name of the organization - will be used as the organization category name
     * @maxLength 50
     */
    accountName?: string;
}
/**
 * Get the account category tree details
 * @public
 * @fqn com.wix.media.enterprise_public_media.v1.EnterpriseCategoriesService.GetMediaManagerCategories
 */
declare function getMediaManagerCategories(): Promise<NonNullablePaths<GetMediaManagerCategoriesResponse, `category.category._id` | `category.category.publishStatus` | `category.subCategories`, 4>>;

export { type ActionEvent, type BaseEventMetadata, type CreateCategoryRequest, type CreateCategoryResponse, type DeleteCategoryRequest, type DeleteCategoryResponse, type DomainEvent, type DomainEventBodyOneOf, type EnterpriseCategory, type EnterpriseCategoryCreatedEnvelope, type EnterpriseCategoryDeletedEnvelope, type EnterpriseCategoryTree, type EnterpriseCategoryUpdatedEnvelope, type EnterpriseOnboardingOptions, type EnterpriseOnboardingRequest, type EnterpriseOnboardingResponse, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type GetCategoryOptions, type GetCategoryRequest, type GetCategoryResponse, type GetMediaManagerCategoriesRequest, type GetMediaManagerCategoriesResponse, type IdentificationData, type IdentificationDataIdOneOf, type LinkItemsToCategoryRequest, type LinkItemsToCategoryResponse, MediaType, type MediaTypeWithLiterals, type MessageEnvelope, PublishStatus, type PublishStatusWithLiterals, type RestoreInfo, type UnlinkItemsFromCategoryRequest, type UnlinkItemsFromCategoryResponse, type UpdateCategory, type UpdateCategoryRequest, type UpdateCategoryResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, createCategory, deleteCategory, enterpriseOnboarding, getCategory, getMediaManagerCategories, onEnterpriseCategoryCreated, onEnterpriseCategoryDeleted, onEnterpriseCategoryUpdated, updateCategory };
