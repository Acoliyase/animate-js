"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.DroppableTableContext = DroppableTableContext;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _reactDom = require("react-dom");
var _core = require("@dnd-kit/core");
var _sortable = require("@dnd-kit/sortable");
var _utilities = require("@dnd-kit/utilities");
var _sensors = require("./sensors");
var _DroppableTableContextStCss = require("./DroppableTableContext.st.css.js");
var _TestWrappers = require("./TestWrappers");
var _DragAndDropContext = require("./DragAndDropContext");
var _TableRowDragOverlay = require("./TableRowDragOverlay");
var _TableRowHorizontalScrollDragOverlay = require("./TableRowHorizontalScrollDragOverlay");
var _restrictKeyboardToVerticalAxis = require("./restrictKeyboardToVerticalAxis");
require("../../styles.global.css");
var _jsxFileName = "/home/builduser/work/b60d7defec63c7cc/packages/wix-style-react-incubator/dist/cjs/drag-and-drop/table/DroppableTableContext.tsx";
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function DroppableTableContext(props) {
  const {
    children,
    items,
    className,
    style,
    onDragEnd,
    onDragStart,
    onDragCancel,
    isDragAndDropDisabled,
    horizontalScroll,
    renderRow,
    renderTableContainer
  } = props;
  const {
    type: Table,
    props: tableProps,
    ref
  } = children;
  const {
    cancelDrop,
    announcements,
    onDragOver,
    onDragMove,
    a11yContainer,
    keyboardCodes,
    consumers,
    restoreFocus,
    autoScrollOptions,
    closestCenterOnViewPort
  } = (0, _DragAndDropContext.useDragAndDropContext)();
  const [activeIndex, setActiveIndex] = _react.default.useState(null);
  const pointerSensor = (0, _core.useSensor)(_sensors.PointerSensor, {
    activationConstraint: {
      distance: 1
    }
  });
  const keyboardSensor = (0, _core.useSensor)(_sensors.KeyboardSensor, {
    coordinateGetter: _sortable.sortableKeyboardCoordinates,
    keyboardCodes
  });
  const uniqueSortableId = (0, _utilities.useUniqueId)('Sortable');
  const onDragStartHandler = (0, _react.useCallback)(event => {
    if ((0, _sortable.hasSortableData)(event.active)) {
      setActiveIndex(event.active.data.current.sortable.index);
    }
    onDragStart == null || onDragStart(event);
  }, [onDragStart]);
  const onDragEndHandler = (0, _react.useCallback)(event => {
    setActiveIndex(null);
    onDragEnd == null || onDragEnd(event);
  }, [onDragEnd]);
  const onDragCancelHandler = (0, _react.useCallback)(event => {
    setActiveIndex(null);
    onDragCancel == null || onDragCancel(event);
  }, [onDragCancel]);
  const sensors = (0, _core.useSensors)(...(process.env.NODE_ENV === 'test' ? [] : [pointerSensor, keyboardSensor]));
  const calcClosestCenterOnViewPort = params => {
    if (ref) {
      const filteredDroppableContainers = params.droppableContainers.filter(item => {
        if (!item.node.current || !ref.current) {
          return false;
        }
        const itemRect = item.node.current.getBoundingClientRect();
        return itemRect.top >= 0 && itemRect.bottom <= window.innerHeight;
      });
      return (0, _core.closestCenter)({
        ...params,
        droppableContainers: filteredDroppableContainers
      });
    }
    return (0, _core.closestCenter)(params);
  };
  const renderTableOverlay = () => {
    if (activeIndex === null) {
      return null;
    }
    let child = /*#__PURE__*/_react.default.createElement("table", {
      className: className,
      style: style,
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 158,
        columnNumber: 7
      }
    }, /*#__PURE__*/_react.default.createElement("tbody", {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 159,
        columnNumber: 9
      }
    }, renderRow == null ? void 0 : renderRow({
      rowNum: activeIndex,
      rowData: items[activeIndex],
      isDragOverlay: true
    })));
    if (renderTableContainer) {
      child = renderTableContainer(child);
    }
    return child;
  };
  const autoScroll = (0, _react.useMemo)(() => ({
    activator: _core.AutoScrollActivator.DraggableRect,
    acceleration: 4,
    canScroll: element => {
      if (Array.from(element.classList).some(className => className.includes('tableBodyScrollContent'))) {
        return false;
      }
      return true;
    },
    freeze: true,
    threshold: {
      y: 0.1,
      x: 0
    },
    ...autoScrollOptions
  }), []);
  const DragOverlayType = horizontalScroll ? _TableRowHorizontalScrollDragOverlay.TableRowHorizontalScrollDragOverlay : _TableRowDragOverlay.TableRowDragOverlay;
  const modifiers = (0, _react.useMemo)(() => horizontalScroll ? [_restrictKeyboardToVerticalAxis.restrictKeyboardToVerticalAxis] : [], [horizontalScroll]);
  let dndContext = /*#__PURE__*/_react.default.createElement(_core.DndContext, {
    sensors: sensors,
    accessibility: {
      container: a11yContainer,
      announcements,
      screenReaderInstructions: {
        draggable: ''
      },
      restoreFocus
    },
    autoScroll: autoScroll,
    collisionDetection: closestCenterOnViewPort ? calcClosestCenterOnViewPort : _core.closestCenter,
    onDragStart: onDragStartHandler,
    onDragCancel: onDragCancelHandler,
    onDragEnd: onDragEndHandler,
    onDragOver: onDragOver,
    onDragMove: onDragMove,
    cancelDrop: cancelDrop,
    modifiers: modifiers,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 211,
      columnNumber: 5
    }
  }, /*#__PURE__*/_react.default.createElement(_sortable.SortableContext, {
    id: uniqueSortableId,
    items: items,
    strategy: _sortable.verticalListSortingStrategy,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 233,
      columnNumber: 7
    }
  }, /*#__PURE__*/_react.default.createElement(Table, (0, _extends2.default)({}, tableProps, {
    ref: ref,
    className: (0, _DroppableTableContextStCss.st)(_DroppableTableContextStCss.classes.root, {
      droppable: !isDragAndDropDisabled
    }, tableProps.className)
  }, announcements == null || announcements.listAttributes == null ? void 0 : announcements.listAttributes(), {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 238,
      columnNumber: 9
    }
  })), consumers), /*#__PURE__*/(0, _reactDom.createPortal)(/*#__PURE__*/_react.default.createElement(DragOverlayType, {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 253,
      columnNumber: 9
    }
  }, renderTableOverlay()), a11yContainer ?? document.body));
  if (process.env.NODE_ENV === 'test') {
    dndContext = /*#__PURE__*/_react.default.createElement(_TestWrappers.TableTestWrapper, {
      sortableId: uniqueSortableId,
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 261,
        columnNumber: 7
      }
    }, dndContext);
  }
  return dndContext;
}
//# sourceMappingURL=DroppableTableContext.js.map