"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.PointerSensor = exports.KeyboardSensor = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _core = require("@dnd-kit/core");
var _DragHandle = require("./DragHandle");
const allowedTags = new Set(['tr', 'td']);
const blockedTags = new Set(['button', 'a', 'select', 'input', 'option', 'textarea', 'img', 'label']);
const blockedRoles = new Set(['button', 'listbox']);
const shouldAllowDrag = node => {
  while (node) {
    const tagName = node.tagName.toLowerCase();
    const role = node.getAttribute('role');
    if (allowedTags.has(tagName)) {
      return true;
    }
    if ((0, _DragHandle.isDragHandleNode)(node)) {
      return true;
    }
    if (blockedTags.has(tagName)) {
      return false;
    }
    if (role && blockedRoles.has(role)) {
      return false;
    }
    node = node.parentElement;
  }
  return false;
};
class PointerSensor extends _core.PointerSensor {}
exports.PointerSensor = PointerSensor;
(0, _defineProperty2.default)(PointerSensor, "activators", [{
  eventName: 'onPointerDown',
  handler: ({
    nativeEvent: event
  }) => {
    return shouldAllowDrag(event.target);
  }
}]);
class KeyboardSensor extends _core.KeyboardSensor {}
exports.KeyboardSensor = KeyboardSensor;
(0, _defineProperty2.default)(KeyboardSensor, "activators", [{
  eventName: 'onKeyDown',
  handler: (event, options, context) => {
    return shouldAllowDrag(event.nativeEvent.target) && _core.KeyboardSensor.activators.every(activator => activator.handler(event, options, context));
  }
}]);
//# sourceMappingURL=sensors.js.map