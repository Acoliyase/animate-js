import _extends from "@babel/runtime/helpers/extends";
import React, { useCallback, useMemo } from 'react';
import { createPortal } from 'react-dom';
import { AutoScrollActivator, closestCenter, DndContext, useSensor, useSensors } from '@dnd-kit/core';
import { hasSortableData, SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { useUniqueId } from '@dnd-kit/utilities';
import { KeyboardSensor, PointerSensor } from './sensors';
import { classes, st } from './DroppableTableContext.st.css.js';
import { TableTestWrapper } from './TestWrappers';
import { useDragAndDropContext } from './DragAndDropContext';
import { TableRowDragOverlay } from './TableRowDragOverlay';
import { TableRowHorizontalScrollDragOverlay } from './TableRowHorizontalScrollDragOverlay';
import { restrictKeyboardToVerticalAxis } from './restrictKeyboardToVerticalAxis';
import '../../styles.global.css';
export function DroppableTableContext(props) {
  const {
    children,
    items,
    className,
    style,
    onDragEnd,
    onDragStart,
    onDragCancel,
    isDragAndDropDisabled,
    horizontalScroll,
    renderRow,
    renderTableContainer
  } = props;
  const {
    type: Table,
    props: tableProps,
    ref
  } = children;
  const {
    cancelDrop,
    announcements,
    onDragOver,
    onDragMove,
    a11yContainer,
    keyboardCodes,
    consumers,
    restoreFocus,
    autoScrollOptions,
    closestCenterOnViewPort
  } = useDragAndDropContext();
  const [activeIndex, setActiveIndex] = React.useState(null);
  const pointerSensor = useSensor(PointerSensor, {
    activationConstraint: {
      distance: 1
    }
  });
  const keyboardSensor = useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates,
    keyboardCodes
  });
  const uniqueSortableId = useUniqueId('Sortable');
  const onDragStartHandler = useCallback(event => {
    if (hasSortableData(event.active)) {
      setActiveIndex(event.active.data.current.sortable.index);
    }
    onDragStart == null || onDragStart(event);
  }, [onDragStart]);
  const onDragEndHandler = useCallback(event => {
    setActiveIndex(null);
    onDragEnd == null || onDragEnd(event);
  }, [onDragEnd]);
  const onDragCancelHandler = useCallback(event => {
    setActiveIndex(null);
    onDragCancel == null || onDragCancel(event);
  }, [onDragCancel]);
  const sensors = useSensors(...(process.env.NODE_ENV === 'test' ? [] : [pointerSensor, keyboardSensor]));
  const calcClosestCenterOnViewPort = params => {
    if (ref) {
      const filteredDroppableContainers = params.droppableContainers.filter(item => {
        if (!item.node.current || !ref.current) {
          return false;
        }
        const itemRect = item.node.current.getBoundingClientRect();
        return itemRect.top >= 0 && itemRect.bottom <= window.innerHeight;
      });
      return closestCenter({
        ...params,
        droppableContainers: filteredDroppableContainers
      });
    }
    return closestCenter(params);
  };
  const renderTableOverlay = () => {
    if (activeIndex === null) {
      return null;
    }
    let child = /*#__PURE__*/React.createElement("table", {
      className: className,
      style: style
    }, /*#__PURE__*/React.createElement("tbody", null, renderRow == null ? void 0 : renderRow({
      rowNum: activeIndex,
      rowData: items[activeIndex],
      isDragOverlay: true
    })));
    if (renderTableContainer) {
      child = renderTableContainer(child);
    }
    return child;
  };
  const autoScroll = useMemo(() => ({
    activator: AutoScrollActivator.DraggableRect,
    acceleration: 4,
    canScroll: element => {
      if (Array.from(element.classList).some(className => className.includes('tableBodyScrollContent'))) {
        return false;
      }
      return true;
    },
    freeze: true,
    threshold: {
      y: 0.1,
      x: 0
    },
    ...autoScrollOptions
  }), []);
  const DragOverlayType = horizontalScroll ? TableRowHorizontalScrollDragOverlay : TableRowDragOverlay;
  const modifiers = useMemo(() => horizontalScroll ? [restrictKeyboardToVerticalAxis] : [], [horizontalScroll]);
  let dndContext = /*#__PURE__*/React.createElement(DndContext, {
    sensors: sensors,
    accessibility: {
      container: a11yContainer,
      announcements,
      screenReaderInstructions: {
        draggable: ''
      },
      restoreFocus
    },
    autoScroll: autoScroll,
    collisionDetection: closestCenterOnViewPort ? calcClosestCenterOnViewPort : closestCenter,
    onDragStart: onDragStartHandler,
    onDragCancel: onDragCancelHandler,
    onDragEnd: onDragEndHandler,
    onDragOver: onDragOver,
    onDragMove: onDragMove,
    cancelDrop: cancelDrop,
    modifiers: modifiers
  }, /*#__PURE__*/React.createElement(SortableContext, {
    id: uniqueSortableId,
    items: items,
    strategy: verticalListSortingStrategy
  }, /*#__PURE__*/React.createElement(Table, _extends({}, tableProps, {
    ref: ref,
    className: st(classes.root, {
      droppable: !isDragAndDropDisabled
    }, tableProps.className)
  }, announcements == null || announcements.listAttributes == null ? void 0 : announcements.listAttributes())), consumers), /*#__PURE__*/createPortal(/*#__PURE__*/React.createElement(DragOverlayType, null, renderTableOverlay()), a11yContainer ?? document.body));
  if (process.env.NODE_ENV === 'test') {
    dndContext = /*#__PURE__*/React.createElement(TableTestWrapper, {
      sortableId: uniqueSortableId
    }, dndContext);
  }
  return dndContext;
}
//# sourceMappingURL=DroppableTableContext.js.map