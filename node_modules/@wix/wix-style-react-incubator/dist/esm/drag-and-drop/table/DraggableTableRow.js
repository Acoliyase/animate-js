import _extends from "@babel/runtime/helpers/extends";
import React, { useCallback, useEffect, useMemo, useRef } from 'react';
import { CSS } from '@dnd-kit/utilities';
import { TableRowTestWrapper } from './TestWrappers';
import { classes, st } from './DraggableTableRow.st.css.js';
import { useDragAndDropContext } from './DragAndDropContext';
import { useSortableTableRow } from './useSortableTableRow';
import { DraggableRowContext } from './DraggableRowContext';
export const DraggableTableRow = /*#__PURE__*/React.memo(function _DraggableTableRow(props) {
  const {
    children,
    id,
    index,
    isDragOverlay,
    isDragAndDropDisabled,
    forwardedRef
  } = props;
  const {
    type: Tr,
    key,
    props: trProps
  } = children;
  const {
    onDragAndDropDisabledRowPointerDown,
    eventHandlers,
    onDropAnimationEnd,
    hideOverlayBottomShadow,
    useIsDropDisabled
  } = useDragAndDropContext();
  const dragHandleRef = useRef();
  useEffect(() => {
    if (onDropAnimationEnd) {
      return onDropAnimationEnd(id, dragHandleRef);
    }
    return;
  }, [id, onDropAnimationEnd]);
  const isDropDisabled = useIsDropDisabled == null ? void 0 : useIsDropDisabled(id);
  const disabled = {
    draggable: false,
    droppable: isDropDisabled
  };
  const {
    attributes,
    listeners,
    transform,
    transition,
    setNodeRef,
    isDragging
  } = useSortableTableRow({
    id,
    disabled
  });
  const draggableRowContextValue = useMemo(() => ({
    isDragOverlay
  }), [isDragOverlay]);
  const ref = useCallback(el => {
    forwardedRef == null || forwardedRef(el);
    setNodeRef(el);
  }, [forwardedRef, setNodeRef]);
  if (isDragAndDropDisabled) {
    return /*#__PURE__*/React.createElement(Tr, _extends({
      key: key
    }, trProps, {
      onPointerDown: e => {
        trProps.onPointerDown == null || trProps.onPointerDown(e);
        onDragAndDropDisabledRowPointerDown == null || onDragAndDropDisabledRowPointerDown(id, e.nativeEvent);
      },
      ref: el => {
        forwardedRef == null || forwardedRef(el);
      }
    }));
  }
  const style = {
    transform: CSS.Transform.toString(transform),
    transition
  };
  const rowEvents = eventHandlers == null || eventHandlers.row == null ? void 0 : eventHandlers.row({
    id
  });
  let tr = /*#__PURE__*/React.createElement(Tr, _extends({
    key: key
  }, trProps, {
    className: st(classes.root, {
      dragging: isDragging,
      overlay: isDragOverlay,
      hideOverlayBottomShadow
    }, trProps.className),
    style: {
      ...trProps.style,
      ...style
    }
  }, attributes, listeners, {
    ref: ref,
    tabIndex: undefined
  }, rowEvents, {
    onPointerDown: e => {
      trProps == null || trProps.onPointerDown == null || trProps.onPointerDown(e);
      listeners == null || listeners.onPointerDown == null || listeners.onPointerDown(e);
      rowEvents == null || rowEvents.onPointerDown == null || rowEvents.onPointerDown(e);
    }
  }));
  if (process.env.NODE_ENV === 'test') {
    tr = /*#__PURE__*/React.createElement(TableRowTestWrapper, _extends({}, eventHandlers == null || eventHandlers.row == null ? void 0 : eventHandlers.row({
      id,
      disabled
    }), {
      id: id,
      index: index
    }), tr);
  }
  return /*#__PURE__*/React.createElement(DraggableRowContext.Provider, {
    value: draggableRowContextValue
  }, tr);
});
//# sourceMappingURL=DraggableTableRow.js.map