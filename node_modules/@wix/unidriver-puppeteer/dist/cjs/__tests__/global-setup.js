"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = setup;
const internal_1 = require("@wix/unidriver-core/internal");
const unidriver_common_1 = require("@wix/unidriver-common");
const node_child_process_1 = require("node:child_process");
const ci_info_1 = require("ci-info");
const DOCKER_CONTAINER_NAME = `puppeteerRunner_${Date.now().toString()}`;
const CHROME_PORT = '9222';
// We don't need teardown because --rm is used in the docker command
async function setup() {
    if (ci_info_1.isCI) {
        try {
            await startDockerChrome();
        }
        catch (e) {
            console.error('setup failed:', e);
            stopDockerChrome();
            throw e;
        }
    }
}
function runCommand(command) {
    console.log(`Running command: ${command}`);
    return (0, node_child_process_1.execSync)(command, { stdio: 'inherit' });
}
async function waitForChrome() {
    await (0, internal_1.eventually)(async () => {
        // Wait 1 second before first attempt, need some time to start the server / wait between attempts
        await (0, unidriver_common_1.delay)(1_000);
        const response = await fetch(`http://localhost:${CHROME_PORT}/json/version`);
        if (!response.ok) {
            throw new Error('Chrome failed to start');
        }
    }, {
        timeout: 20_000,
    });
    console.log('Chrome is ready!');
}
async function startDockerChrome() {
    runCommand(`docker run --detach --init --rm ` +
        `--network host ` +
        `--name ${DOCKER_CONTAINER_NAME} ` +
        `zenika/alpine-chrome:latest ` +
        `--remote-debugging-port=${CHROME_PORT} ` +
        `--no-sandbox ` +
        `--disable-dev-shm-usage ` +
        `--headless`);
    await waitForChrome();
}
function stopDockerChrome() {
    try {
        runCommand(`docker stop ${DOCKER_CONTAINER_NAME}`);
    }
    catch (e) {
        console.log('Failed to stop Docker runner:', e);
    }
}
//# sourceMappingURL=global-setup.js.map