import { puppeteerUniDriver } from '../../puppeteerUniDriver';
import { pupUniDriver } from '../../pupUniDriver';
import { runTest } from '@wix/unidriver-common/testing';
import { setup } from '../setup';
import { eventually } from '@wix/unidriver-core/internal';
describe('Adapter Specific', () => {
    describe('Adapter params', () => {
        const getHasDelayedItemAppeared = async (driver) => {
            expect(await driver.exists()).toBe(false);
            await eventually(async () => {
                expect(await driver.exists()).toBe(true);
            }, 2_000);
            return true;
        };
        it(`should work if ElementHandle`, async () => {
            await runTest(setup, undefined, { story: 'with-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver(page.$('.count'));
                expect(await driver.text()).toBe('1');
            });
        });
        it(`should work if () => ElementHandle`, async () => {
            await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver(() => page.$('.delayed-item'));
                expect(await getHasDelayedItemAppeared(driver)).toBe(true);
            });
        });
        it(`should work if () => Promise<ElementHandle>`, async () => {
            await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver(async () => page.$('.delayed-item'));
                expect(await getHasDelayedItemAppeared(driver)).toBe(true);
            });
        });
        it(`should work if {page, selector} and nested driver`, async () => {
            await runTest(setup, undefined, { story: 'with-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver({
                    page,
                    selector: 'body',
                });
                const nested = driver.$('.count');
                const native = await nested.getNative();
                expect(native.page).toBeDefined();
                expect(await nested.text()).toBe('1');
            });
        });
        it(`should work if {page, selector}`, async () => {
            await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver({
                    page,
                    selector: '.delayed-item',
                });
                expect(await getHasDelayedItemAppeared(driver)).toBe(true);
            });
        });
        it(`should work if {root, selector}`, async () => {
            await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver({
                    root: page,
                    selector: '.delayed-item',
                });
                expect(await getHasDelayedItemAppeared(driver)).toBe(true);
            });
        });
        it(`should work if async function when {page, selector}`, async () => {
            await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver(async () => {
                    return {
                        page,
                        selector: '.delayed-item',
                    };
                });
                expect(await getHasDelayedItemAppeared(driver)).toBe(true);
            });
        });
        // TODO uncomment in one of upcoming releases, we give some time for users with just a warning for now
        // eslint-disable-next-line vitest/no-commented-out-tests
        // it(`should throw if async function when {page, element, selector}`, async () => {
        //   await runTest<{page: Page}>(setup, undefined, {story: 'with-item'}, async ({page}) => {
        //     const driver = puppeteerUniDriver(async () => {
        //       return {
        //         page,
        //         element: await page.$('.count'),
        //         selector: '.count',
        //       };
        //     });
        //
        //     let error: unknown;
        //
        //     try {
        //       await driver.text();
        //     } catch (e) {
        //       error = e;
        //     }
        //
        //     expect(error).toBeInstanceOf(Error);
        //     expect((error as Error).message).toContain(`'element' is deprecated`);
        //   });
        // });
        it(`should work if async function when {page, element}`, async () => {
            await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver(async () => {
                    return {
                        page,
                        element: await page.$('.delayed-item'),
                    };
                });
                expect(await getHasDelayedItemAppeared(driver)).toBe(true);
            });
        });
        it(`should work if async function when {page, root}`, async () => {
            await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                const driver = puppeteerUniDriver(async () => {
                    return {
                        page,
                        root: await page.$('.delayed-item'),
                    };
                });
                expect(await getHasDelayedItemAppeared(driver)).toBe(true);
            });
        });
        describe('pupUniDriver', () => {
            it(`should work if async function when {page, element, selector}`, async () => {
                await runTest(setup, undefined, { story: 'with-delayed-item' }, async ({ page }) => {
                    const driver = pupUniDriver(async () => {
                        return {
                            page,
                            element: await page.$('.delayed-item'),
                            selector: '.delayed-item',
                        };
                    });
                    expect(await getHasDelayedItemAppeared(driver)).toBe(true);
                });
            });
        });
    });
});
//# sourceMappingURL=adapterParams.sled.spec.js.map