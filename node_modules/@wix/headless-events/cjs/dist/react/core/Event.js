import { jsx as _jsx } from "react/jsx-runtime";
import { rsvpV2 } from '@wix/events';
import { useService, WixServices } from '@wix/services-manager-react';
import { createServicesMap } from '@wix/services-manager';
import { EventService, EventServiceDefinition, } from '../../services/event-service.js';
import { EventListServiceDefinition } from '../../services/event-list-service.js';
import { hasDescription } from '../../utils/event.js';
import { formatFullDate, formatShortDate } from '../../utils/date.js';
import { getErrorMessage } from '../../utils/errors.js';
import { getFormResponse, getRequiredRsvpData } from '../../utils/form.js';
/**
 * Event Root core component that provides event service context.
 *
 * @component
 */
export function Root(props) {
    const { children, event } = props;
    const eventServiceConfig = {
        event,
    };
    return (_jsx(WixServices, { servicesMap: createServicesMap().addService(EventServiceDefinition, EventService, eventServiceConfig), children: children }));
}
/**
 * Event Raw core component that provides event.
 *
 * @component
 */
export function Raw(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    return props.children({ event });
}
/**
 * Event Slug core component that provides event slug.
 *
 * @component
 */
export function Slug(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const slug = event.slug;
    return props.children({ slug });
}
/**
 * Event Type core component that provides event type.
 *
 * @component
 */
export function Type(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const ticketed = event.registration?.type === 'TICKETING';
    const rsvp = event.registration?.type === 'RSVP';
    const external = event.registration?.type === 'EXTERNAL';
    return props.children({ ticketed, rsvp, external });
}
/**
 * Event Image core component that provides event image.
 *
 * @component
 */
export function Image(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const image = event.mainImage;
    return props.children({ image });
}
/**
 * Event Title core component that provides event title.
 *
 * @component
 */
export function Title(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const title = event.title;
    return props.children({ title });
}
/**
 * Event Date core component that provides event date.
 *
 * @component
 */
export function DateCore(props) {
    const { format = 'short', locale } = props;
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const { startDate, endDate, timeZoneId, dateAndTimeTbd, dateAndTimeTbdMessage, hideEndDate, showTimeZone, } = event.dateAndTimeSettings;
    const formattedDate = dateAndTimeTbd
        ? dateAndTimeTbdMessage
        : format === 'short'
            ? formatShortDate(startDate, timeZoneId, locale)
            : hideEndDate
                ? formatFullDate(startDate, timeZoneId, showTimeZone, locale)
                : `${formatFullDate(startDate, timeZoneId, false, locale)} - ${formatFullDate(endDate, timeZoneId, showTimeZone, locale)}`;
    return props.children({
        startDate: dateAndTimeTbd ? null : new Date(startDate),
        endDate: dateAndTimeTbd ? null : new Date(endDate),
        timeZoneId: dateAndTimeTbd ? null : timeZoneId,
        dateAndTimeTbd: dateAndTimeTbd,
        dateAndTimeTbdMessage: dateAndTimeTbd ? dateAndTimeTbdMessage : null,
        hideEndDate: hideEndDate,
        showTimeZone: showTimeZone,
        formattedDate: formattedDate,
    });
}
/**
 * Event Location core component that provides event location.
 *
 * @component
 */
export function Location(props) {
    const { format = 'short' } = props;
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const formattedLocation = event.location.locationTbd || format === 'short'
        ? event.location.name
        : // @ts-expect-error
            `${event.location.name}, ${event.location.address.formatted}`;
    // @ts-expect-error
    const latitude = event.location.address?.location?.latitude;
    // @ts-expect-error
    const longitude = event.location.address?.location?.longitude;
    return props.children({ formattedLocation, latitude, longitude });
}
/**
 * Event ShortDescription core component that provides event short description. Not rendered if there is no short description.
 *
 * @component
 */
export function ShortDescription(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const shortDescription = event.shortDescription;
    if (!shortDescription) {
        return null;
    }
    return props.children({ shortDescription });
}
/**
 * Event Description core component that provides event description. Not rendered if there is no description.
 *
 * @component
 */
export function Description(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const description = event.description;
    if (!hasDescription(event)) {
        return null;
    }
    return props.children({ description: description });
}
/**
 * Event RsvpButton core component that provides event slug and ticketed status.
 *
 * @component
 */
export function RsvpButton(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const slug = event.slug;
    const ticketed = event.registration?.type === 'TICKETING';
    return props.children({ slug, ticketed });
}
/**
 * Event AddToGoogleCalendar core component that provides calendar URL.
 *
 * @component
 */
export function AddToGoogleCalendar(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const url = event.calendarUrls?.google;
    if (!url) {
        return null;
    }
    return props.children({ url });
}
/**
 * Event AddToIcsCalendar core component that provides calendar URL.
 *
 * @component
 */
export function AddToIcsCalendar(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    const url = event.calendarUrls?.ics;
    if (!url) {
        return null;
    }
    return props.children({ url });
}
/**
 * Event OtherEvents core component that provides other events.
 *
 * @component
 */
export function OtherEvents(props) {
    const { count } = props;
    const eventService = useService(EventServiceDefinition);
    const eventListService = useService(EventListServiceDefinition);
    const event = eventService.event.get();
    const events = eventListService.events.get();
    const otherEvents = events
        .filter((item) => item._id !== event._id)
        .slice(0, count);
    if (!otherEvents.length) {
        return null;
    }
    return props.children({ events: otherEvents });
}
/**
 * Event Form core component that provides form ID.
 *
 * @component
 */
export function Form(props) {
    const eventService = useService(EventServiceDefinition);
    const event = eventService.event.get();
    // @ts-expect-error
    const formId = event.registration.rsvp.formId;
    const onSubmit = async (_formId, formValues) => {
        try {
            await rsvpV2.createRsvp({
                eventId: event._id,
                status: 'YES',
                form: getFormResponse(event, formValues),
                ...getRequiredRsvpData(event, formValues),
            });
            if (props.thankYouPageUrl) {
                window.location.href = props.thankYouPageUrl;
            }
            return { type: 'success' };
        }
        catch (err) {
            return { type: 'error', message: getErrorMessage(err) };
        }
    };
    return props.children({ formId, onSubmit });
}
