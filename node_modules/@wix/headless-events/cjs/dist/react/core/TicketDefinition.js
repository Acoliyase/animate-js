import { jsx as _jsx } from "react/jsx-runtime";
import { useService, WixServices } from '@wix/services-manager-react';
import { createServicesMap } from '@wix/services-manager';
import { TicketDefinitionService, TicketDefinitionServiceDefinition, } from '../../services/ticket-definition-service.js';
import { TicketDefinitionListServiceDefinition } from '../../services/ticket-definition-list-service.js';
import { EventServiceDefinition } from '../../services/event-service.js';
import { getTicketDefinitionCurrency, getTicketDefinitionFee, getTicketDefinitionTax, isTicketDefinitionAvailable, } from '../../utils/ticket-definition.js';
import { formatFullDate } from '../../utils/date.js';
import { formatPrice } from '../../utils/price.js';
/**
 * TicketDefinition Root core component that provides ticket definition service context.
 *
 * @component
 */
export function Root(props) {
    const { children, ticketDefinition } = props;
    const ticketDefinitionServiceConfig = {
        ticketDefinition,
    };
    return (_jsx(WixServices, { servicesMap: createServicesMap().addService(TicketDefinitionServiceDefinition, TicketDefinitionService, ticketDefinitionServiceConfig), children: children }));
}
/**
 * TicketDefinition Name core component that provides ticket definition name.
 *
 * @component
 */
export function Name(props) {
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const name = ticketDefinition.name;
    return props.children({ name });
}
/**
 * TicketDefinition Description core component that provides ticket definition description. Not rendered if there is no description.
 *
 * @component
 */
export function Description(props) {
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const description = ticketDefinition.description;
    if (!description) {
        return null;
    }
    return props.children({ description });
}
/**
 * TicketDefinition FixedPricing core component that provides fixed pricing data. Not rendered if ticket definition doesn't have fixed pricing.
 *
 * @component
 */
export function FixedPricing(props) {
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const fixedPrice = ticketDefinition.pricingMethod?.fixedPrice;
    if (!fixedPrice) {
        return null;
    }
    const value = Number(fixedPrice.value);
    const currency = getTicketDefinitionCurrency(ticketDefinition);
    const formattedValue = formatPrice(value, currency, props.locale);
    return props.children({
        value,
        currency,
        formattedValue,
        free: ticketDefinition.pricingMethod.free,
    });
}
/**
 * TicketDefinition GuestPricing core component that provides guest pricing data. Not rendered if ticket definition doesn't have guest pricing.
 *
 * @component
 */
export function GuestPricing(props) {
    const ticketDefinitionListService = useService(TicketDefinitionListServiceDefinition);
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const ticketDefinitionId = ticketDefinition._id;
    const guestPrice = ticketDefinition.pricingMethod?.guestPrice;
    if (!guestPrice) {
        return null;
    }
    const setPrice = (price) => {
        ticketDefinitionListService.setQuantity({
            ticketDefinitionId,
            priceOverride: price,
        });
    };
    const price = ticketDefinitionListService.getCurrentPriceOverride(ticketDefinitionId);
    const minPrice = Number(guestPrice.value);
    const currency = getTicketDefinitionCurrency(ticketDefinition);
    const formattedMinPrice = formatPrice(minPrice, currency, props.locale);
    return props.children({
        price,
        minPrice,
        currency,
        formattedMinPrice,
        setPrice,
    });
}
/**
 * TicketDefinition PricingRange core component that provides pricing range data. Not rendered if ticket definition doesn't have pricing options.
 *
 * @component
 */
export function PricingRange(props) {
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const pricingOptions = ticketDefinition.pricingMethod?.pricingOptions?.optionDetails ?? [];
    if (!pricingOptions.length) {
        return null;
    }
    const prices = pricingOptions.map((option) => Number(option.price.value));
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const currency = getTicketDefinitionCurrency(ticketDefinition);
    const formattedMinPrice = formatPrice(minPrice, currency, props.locale);
    const formattedMaxPrice = formatPrice(maxPrice, currency, props.locale);
    const formattedPriceRange = minPrice === maxPrice
        ? formattedMinPrice
        : `${formattedMinPrice} - ${formattedMaxPrice}`;
    return props.children({
        minPrice,
        maxPrice,
        currency,
        formattedMinPrice,
        formattedMaxPrice,
        formattedPriceRange,
    });
}
/**
 * TicketDefinition Tax core component that provides tax data. Not rendered when event has no tax settings, or when ticket definition is free or has pricing options, or when ticket definition has guest pricing and tax is not applied to donations.
 *
 * @component
 */
export function Tax(props) {
    const eventService = useService(EventServiceDefinition);
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinitionListService = useService(TicketDefinitionListServiceDefinition);
    const event = eventService.event.get();
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const taxSettings = event.registration?.tickets?.taxSettings;
    const fixedPrice = ticketDefinition.pricingMethod?.fixedPrice;
    const guestPrice = ticketDefinition.pricingMethod?.guestPrice;
    const pricingOptions = ticketDefinition.pricingMethod?.pricingOptions?.optionDetails ?? [];
    if (!taxSettings ||
        ticketDefinition.pricingMethod.free ||
        pricingOptions.length ||
        (guestPrice && !taxSettings.appliedToDonations)) {
        return null;
    }
    const priceOverride = ticketDefinitionListService.getCurrentPriceOverride(ticketDefinition._id);
    const price = Number(guestPrice ? priceOverride || '0' : fixedPrice.value);
    const currency = getTicketDefinitionCurrency(ticketDefinition);
    const { name, rate, included, taxableValue, taxValue, formattedTaxValue } = getTicketDefinitionTax(taxSettings, price, currency, props.locale);
    return props.children({
        name,
        rate,
        included,
        taxableValue,
        taxValue,
        currency,
        formattedTaxValue,
    });
}
/**
 * TicketDefinition Fee core component that provides fee data. Not rendered when ticket definition has no fee enabled, or when ticket definition is free or has pricing options, or when fee is included in the price.
 *
 * @component
 */
export function Fee(props) {
    const eventService = useService(EventServiceDefinition);
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinitionListService = useService(TicketDefinitionListServiceDefinition);
    const event = eventService.event.get();
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const taxSettings = event.registration?.tickets?.taxSettings;
    const fixedPrice = ticketDefinition.pricingMethod?.fixedPrice;
    const guestPrice = ticketDefinition.pricingMethod?.guestPrice;
    const pricingOptions = ticketDefinition.pricingMethod?.pricingOptions?.optionDetails ?? [];
    if (ticketDefinition.feeType !== 'FEE_ADDED_AT_CHECKOUT' ||
        ticketDefinition.pricingMethod.free ||
        pricingOptions.length) {
        return null;
    }
    const priceOverride = ticketDefinitionListService.getCurrentPriceOverride(ticketDefinition._id);
    const price = Number(guestPrice ? priceOverride || '0' : fixedPrice.value);
    const currency = getTicketDefinitionCurrency(ticketDefinition);
    const { rate, value, formattedValue } = getTicketDefinitionFee(taxSettings, price, currency, !!guestPrice, props.locale);
    return props.children({
        rate,
        value,
        currency,
        formattedValue,
    });
}
/**
 * TicketDefinition Remaining core component that provides remaining tickets count.
 *
 * @component
 */
export function Remaining(props) {
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const remaining = ticketDefinition.limitPerCheckout || 0;
    return props.children({ remaining });
}
/**
 * TicketDefinition SaleStartDate core component that provides sale start date. Not rendered if sale isn't scheduled.
 *
 * @component
 */
export function SaleStartDate(props) {
    const eventService = useService(EventServiceDefinition);
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const event = eventService.event.get();
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const saleScheduled = ticketDefinition.saleStatus === 'SALE_SCHEDULED';
    const timeZoneId = event.dateAndTimeSettings.timeZoneId;
    if (!saleScheduled) {
        return null;
    }
    const startDate = new Date(ticketDefinition.salePeriod.startDate);
    const startDateFormatted = formatFullDate(startDate, timeZoneId, false, props.locale);
    return props.children({ startDate, startDateFormatted });
}
/**
 * TicketDefinition SaleEndDate core component that provides sale end date. Not rendered if sale is scheduled or there is no sale period.
 *
 * @component
 */
export function SaleEndDate(props) {
    const eventService = useService(EventServiceDefinition);
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const event = eventService.event.get();
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const saleScheduled = ticketDefinition.saleStatus === 'SALE_SCHEDULED';
    const saleEnded = ticketDefinition.saleStatus === 'SALE_ENDED';
    const timeZoneId = event.dateAndTimeSettings.timeZoneId;
    if (saleScheduled || !ticketDefinition.salePeriod) {
        return null;
    }
    const endDate = new Date(ticketDefinition.salePeriod.endDate);
    const endDateFormatted = formatFullDate(endDate, timeZoneId, false, props.locale);
    return props.children({ endDate, endDateFormatted, saleEnded });
}
/**
 * TicketDefinition Quantity core component that provides quantity controls. Not rendered for ticket definitions with pricing options, or if ticket definition is not available (is sold out or sale hasn't started).
 *
 * @component
 */
export function Quantity(props) {
    const ticketDefinitionListService = useService(TicketDefinitionListServiceDefinition);
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const ticketDefinitionId = ticketDefinition._id;
    const pricingOptions = ticketDefinition.pricingMethod?.pricingOptions?.optionDetails ?? [];
    if (!isTicketDefinitionAvailable(ticketDefinition) || pricingOptions.length) {
        return null;
    }
    const quantity = ticketDefinitionListService.getCurrentQuantity(ticketDefinitionId);
    const maxQuantity = ticketDefinitionListService.getMaxQuantity(ticketDefinitionId);
    const options = Array.from({ length: maxQuantity + 1 }, (_, index) => index);
    const increment = () => ticketDefinitionListService.setQuantity({
        ticketDefinitionId,
        quantity: quantity + 1,
    });
    const decrement = () => ticketDefinitionListService.setQuantity({
        ticketDefinitionId,
        quantity: quantity - 1,
    });
    const setQuantity = (quantity) => ticketDefinitionListService.setQuantity({
        ticketDefinitionId,
        quantity,
    });
    return props.children({
        options,
        quantity,
        maxQuantity,
        increment,
        decrement,
        setQuantity,
    });
}
/**
 * TicketDefinition PricingOptions core component that provides pricing options. Not rendered if there are no pricing options.
 *
 * @component
 */
export function PricingOptions(props) {
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const pricingOptions = ticketDefinition.pricingMethod?.pricingOptions?.optionDetails ?? [];
    if (!pricingOptions.length) {
        return null;
    }
    return props.children({ pricingOptions });
}
/**
 * TicketDefinition PricingOptionRepeater core component that provides pricing options. Not rendered if there are no pricing options.
 *
 * @component
 */
export function PricingOptionRepeater(props) {
    const ticketDefinitionService = useService(TicketDefinitionServiceDefinition);
    const ticketDefinition = ticketDefinitionService.ticketDefinition.get();
    const pricingOptions = ticketDefinition.pricingMethod?.pricingOptions?.optionDetails ?? [];
    if (!pricingOptions.length) {
        return null;
    }
    return props.children({ pricingOptions });
}
