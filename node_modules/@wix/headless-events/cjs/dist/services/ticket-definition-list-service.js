import { defineService, implementService } from '@wix/services-definitions';
import { SignalsServiceDefinition, } from '@wix/services-definitions/core-services/signals';
import { ticketDefinitionsV2 } from '@wix/events';
import { CheckoutServiceDefinition } from './checkout-service.js';
import { getTicketDefinitionTax, getTicketDefinitionFee, getTicketDefinitionCurrency, } from '../utils/ticket-definition.js';
import { formatPrice, roundPrice } from '../utils/price.js';
export const TicketDefinitionListServiceDefinition = defineService('ticketDefinitionList');
export const TicketDefinitionListService = implementService.withConfig()(TicketDefinitionListServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(SignalsServiceDefinition);
    const checkoutService = getService(CheckoutServiceDefinition);
    const ticketDefinitions = signalsService.signal(config.ticketDefinitions);
    const selectedQuantities = signalsService.signal([]);
    const findTicketDefinition = (ticketDefinitionId) => ticketDefinitions
        .get()
        .find((ticketDefinition) => ticketDefinition._id === ticketDefinitionId);
    const findTicketReservation = (ticketDefinitionId, pricingOptionId) => selectedQuantities
        .get()
        .find((selectedQuantity) => selectedQuantity.ticketDefinitionId === ticketDefinitionId &&
        (!pricingOptionId ||
            selectedQuantity.pricingOptionId === pricingOptionId));
    const getMaxQuantity = (ticketDefinitionId) => {
        const ticketDefinition = findTicketDefinition(ticketDefinitionId);
        return ticketDefinition?.limitPerCheckout || 0;
    };
    const getCurrentQuantity = (ticketDefinitionId, pricingOptionId) => {
        const selectedQuantity = findTicketReservation(ticketDefinitionId, pricingOptionId);
        return selectedQuantity?.quantity || 0;
    };
    const getCurrentPriceOverride = (ticketDefinitionId) => {
        const selectedQuantity = findTicketReservation(ticketDefinitionId);
        return selectedQuantity?.priceOverride;
    };
    const isSoldOut = (ticketDefinitionId) => getMaxQuantity(ticketDefinitionId) === 0;
    const setQuantity = ({ ticketDefinitionId, pricingOptionId, priceOverride = getCurrentPriceOverride(ticketDefinitionId), quantity = getCurrentQuantity(ticketDefinitionId, pricingOptionId), }) => {
        const maxQuantity = getMaxQuantity(ticketDefinitionId);
        const newQuantity = Math.max(0, Math.min(quantity, maxQuantity));
        const newSelectedQuantity = {
            ticketDefinitionId,
            pricingOptionId,
            quantity: newQuantity,
            priceOverride: priceOverride ? priceOverride : undefined,
        };
        const newSelectedQuantities = selectedQuantities
            .get()
            .filter((selectedQuantity) => selectedQuantity.ticketDefinitionId !== ticketDefinitionId ||
            selectedQuantity.pricingOptionId !== pricingOptionId)
            .concat(newSelectedQuantity);
        checkoutService.error.set(null);
        selectedQuantities.set(newSelectedQuantities);
    };
    return {
        ticketDefinitions,
        selectedQuantities,
        setQuantity,
        getMaxQuantity,
        getCurrentQuantity,
        getCurrentPriceOverride,
        isSoldOut,
    };
});
export async function loadTicketDefinitionListServiceConfig({ eventId, }) {
    // @ts-expect-error
    const response = await ticketDefinitionsV2.queryAvailableTicketDefinitions({
        filter: {
            eventId,
        },
        sort: [
            {
                fieldName: 'sortIndex',
                direction: 'ASC',
            },
        ],
    });
    const ticketDefinitions = response.ticketDefinitions ?? [];
    return { ticketDefinitions };
}
export function getTicketReservationTotals(event, ticketDefinitions, selectedQuantities, locale) {
    const taxSettings = event.registration?.tickets?.taxSettings;
    const currency = ticketDefinitions[0]
        ? getTicketDefinitionCurrency(ticketDefinitions[0])
        : 'USD';
    if (!ticketDefinitions.length || !selectedQuantities.length) {
        return {
            currency,
            subtotal: 0,
            tax: 0,
            fee: 0,
            total: 0,
            formattedSubtotal: formatPrice(0, currency, locale),
            formattedTax: formatPrice(0, currency, locale),
            formattedFee: formatPrice(0, currency, locale),
            formattedTotal: formatPrice(0, currency, locale),
        };
    }
    let subtotal = 0;
    let tax = 0;
    let fee = 0;
    let total = 0;
    selectedQuantities.forEach(({ ticketDefinitionId, quantity, priceOverride, pricingOptionId }) => {
        if (!quantity) {
            return;
        }
        const ticketDefinition = ticketDefinitions.find((ticketDefinition) => ticketDefinition._id === ticketDefinitionId);
        const { fixedPrice, guestPrice, pricingOptions, free } = ticketDefinition.pricingMethod;
        const guestPricing = !!guestPrice;
        const price = guestPrice
            ? Number(priceOverride || '0')
            : pricingOptionId
                ? Number(pricingOptions.optionDetails.find((option) => option.optionId === pricingOptionId).price.value)
                : Number(fixedPrice.value);
        subtotal = roundPrice(subtotal + price * quantity, currency);
        total = roundPrice(total + price * quantity, currency);
        if (taxSettings &&
            !free &&
            (!guestPricing || taxSettings.appliedToDonations)) {
            const { taxValue } = getTicketDefinitionTax(taxSettings, price, currency, locale);
            tax = roundPrice(tax + taxValue * quantity, currency);
        }
        if (ticketDefinition.feeType === 'FEE_ADDED_AT_CHECKOUT' && !free) {
            const { value } = getTicketDefinitionFee(taxSettings, price, currency, guestPricing, locale);
            fee = roundPrice(fee + value * quantity, currency);
        }
    });
    if (taxSettings?.type === 'ADDED_AT_CHECKOUT') {
        total = roundPrice(total + tax, currency);
    }
    else if (taxSettings?.type === 'INCLUDED_IN_PRICE') {
        subtotal = roundPrice(subtotal - tax, currency);
    }
    total = roundPrice(total + fee, currency);
    return {
        currency,
        subtotal,
        tax,
        fee,
        total,
        formattedSubtotal: formatPrice(subtotal, currency, locale),
        formattedTax: formatPrice(tax, currency, locale),
        formattedFee: formatPrice(fee, currency, locale),
        formattedTotal: formatPrice(total, currency, locale),
    };
}
