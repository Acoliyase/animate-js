import { schedule } from '@wix/events';
import { defineService, implementService } from '@wix/services-definitions';
import { SignalsServiceDefinition, } from '@wix/services-definitions/core-services/signals';
var StateFilter;
(function (StateFilter) {
    StateFilter["PUBLISHED"] = "PUBLISHED";
    StateFilter["VISIBLE"] = "VISIBLE";
})(StateFilter || (StateFilter = {}));
export const ScheduleListServiceDefinition = defineService('scheduleList');
export const ScheduleListService = implementService.withConfig()(ScheduleListServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(SignalsServiceDefinition);
    const items = signalsService.signal(config.items);
    const error = signalsService.signal(null);
    const stageFilter = signalsService.signal(null);
    const tagFilters = signalsService.signal([]);
    const itemsGroups = signalsService.computed(() => {
        const currentItems = items.get();
        const currentStageFilter = stageFilter.get();
        const currentTagFilters = tagFilters.get();
        const filteredItems = filterScheduleItems(currentItems, currentStageFilter, currentTagFilters);
        return groupScheduleItemsByDate(filteredItems);
    });
    const stageNames = signalsService.computed(() => {
        const currentItems = items.get();
        return getAvailableStageNames(currentItems);
    });
    const tags = signalsService.computed(() => {
        const currentItems = items.get();
        return getAvailableTags(currentItems);
    });
    const setStageFilter = (stageName) => {
        stageFilter.set(stageName);
    };
    const setTagFilters = (tags) => {
        tagFilters.set(tags);
    };
    return {
        items,
        itemsGroups,
        error,
        stageFilter,
        tagFilters,
        stageNames,
        tags,
        setStageFilter,
        setTagFilters,
    };
});
export async function loadScheduleListServiceConfig({ eventId, limit, }) {
    const loadAll = !limit;
    const pageSize = limit ?? 100;
    const response = await listScheduleItems({ eventId, limit: pageSize });
    const totalItems = response.pagingMetadata.total;
    const itemsCount = response.items.length;
    const responses = [response];
    if (itemsCount < totalItems && loadAll) {
        const requestCount = Math.ceil(totalItems / pageSize) - 1;
        const moreResponses = await Promise.all(new Array(requestCount).fill(null).map((_, index) => listScheduleItems({
            eventId,
            limit: pageSize,
            offset: (index + 1) * pageSize,
        })));
        responses.push(...moreResponses);
    }
    const allItems = responses.flatMap((response) => response.items || []);
    return { items: allItems };
}
function listScheduleItems({ eventId, limit, offset = 0, }) {
    return schedule.listScheduleItems({
        eventId: [eventId],
        state: [StateFilter.PUBLISHED, StateFilter.VISIBLE],
        paging: {
            limit,
            offset,
        },
    });
}
function filterScheduleItems(items, stageFilter, tagFilters) {
    return items.filter((item) => {
        if (stageFilter && item.stageName !== stageFilter) {
            return false;
        }
        if (tagFilters.length > 0) {
            const itemTags = item.tags || [];
            const hasAnyTag = tagFilters.some((filterTag) => itemTags.includes(filterTag));
            if (!hasAnyTag) {
                return false;
            }
        }
        return true;
    });
}
function groupScheduleItemsByDate(items) {
    const grouped = new Map();
    items.forEach((item) => {
        const startDate = new Date(item.timeSlot.start);
        const dateKey = startDate.toDateString();
        if (!grouped.has(dateKey)) {
            grouped.set(dateKey, {
                id: Math.random().toString(36).substring(2, 11),
                date: startDate,
                timeZoneId: item.timeSlot.timeZoneId,
                items: [],
            });
        }
        grouped.get(dateKey).items.push(item);
    });
    const groupsArray = Array.from(grouped.values());
    return groupsArray.sort((a, b) => a.date.getTime() - b.date.getTime());
}
function getAvailableStageNames(items) {
    const stageNames = new Set();
    items.forEach((item) => {
        if (item.stageName) {
            stageNames.add(item.stageName);
        }
    });
    return Array.from(stageNames).sort();
}
function getAvailableTags(items) {
    const tags = new Set();
    items.forEach((item) => {
        if (item.tags) {
            item.tags.forEach((tag) => tags.add(tag));
        }
    });
    return Array.from(tags).sort();
}
