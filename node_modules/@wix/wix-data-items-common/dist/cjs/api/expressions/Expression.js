"use strict";

exports.__esModule = true;
exports.ToUpperExpressionImpl = exports.ToLowerExpressionImpl = exports.TextExpressionImpl = exports.SumExpressionImpl = exports.SubtractExpressionImpl = exports.SubstringExpressionImpl = exports.StringifyExpressionImpl = exports.NumericExpressionImpl = exports.MultiplyExpressionImpl = exports.ModExpressionImpl = exports.LengthExpressionImpl = exports.FloorExpressionImpl = exports.FieldExpressionImpl = exports.DivideExpressionImpl = exports.ConcatExpressionImpl = exports.CeilExpressionImpl = exports.AddExpressionImpl = exports.AbsExpressionImpl = void 0;
/**
 * @builder
 */

class FieldExpressionImpl {
  constructor(fieldPath) {
    this.fieldPath = fieldPath;
  }
  /** @private */
  build() {
    return {
      fieldPath: this.fieldPath
    };
  }
}

/**
 * @builder
 */
exports.FieldExpressionImpl = FieldExpressionImpl;
class TextExpressionImpl {
  constructor(value) {
    this.value = value;
  }
  /** @private */
  build() {
    return {
      text: this.value
    };
  }
}

/**
 * @builder
 */
exports.TextExpressionImpl = TextExpressionImpl;
class NumericExpressionImpl {
  constructor(value) {
    this.value = value;
  }
  /** @private */
  build() {
    return {
      numeric: this.value
    };
  }
}

/**
 * @builder
 */
exports.NumericExpressionImpl = NumericExpressionImpl;
class AddExpressionImpl {
  constructor(expressions) {
    this.expressions = expressions;
  }
  /** @private */
  build() {
    return {
      add: {
        expressions: this.expressions.map(e => e.build())
      }
    };
  }
}

/**
 * @builder
 */
exports.AddExpressionImpl = AddExpressionImpl;
class SubtractExpressionImpl {
  constructor(firstExpression, secondExpression) {
    this.firstExpression = firstExpression;
    this.secondExpression = secondExpression;
  }
  /** @private */
  build() {
    return {
      subtract: {
        firstExpression: this.firstExpression.build(),
        secondExpression: this.secondExpression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.SubtractExpressionImpl = SubtractExpressionImpl;
class MultiplyExpressionImpl {
  constructor(expressions) {
    this.expressions = expressions;
  }
  /** @private */
  build() {
    return {
      multiply: {
        expressions: this.expressions.map(e => e.build())
      }
    };
  }
}

/**
 * @builder
 */
exports.MultiplyExpressionImpl = MultiplyExpressionImpl;
class DivideExpressionImpl {
  constructor(firstExpression, secondExpression) {
    this.firstExpression = firstExpression;
    this.secondExpression = secondExpression;
  }
  /** @private */
  build() {
    return {
      divide: {
        firstExpression: this.firstExpression.build(),
        secondExpression: this.secondExpression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.DivideExpressionImpl = DivideExpressionImpl;
class SumExpressionImpl {
  constructor(expressions) {
    this.expressions = expressions;
  }
  /** @private */
  build() {
    return {
      sum: {
        expressions: this.expressions.map(e => e.build())
      }
    };
  }
}

/**
 * @builder
 */
exports.SumExpressionImpl = SumExpressionImpl;
class AbsExpressionImpl {
  constructor(expression) {
    this.expression = expression;
  }
  /** @private */
  build() {
    return {
      abs: {
        expression: this.expression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.AbsExpressionImpl = AbsExpressionImpl;
class ModExpressionImpl {
  constructor(firstExpression, secondExpression) {
    this.firstExpression = firstExpression;
    this.secondExpression = secondExpression;
  }
  /** @private */
  build() {
    return {
      mod: {
        firstExpression: this.firstExpression.build(),
        secondExpression: this.secondExpression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.ModExpressionImpl = ModExpressionImpl;
class FloorExpressionImpl {
  constructor(expression) {
    this.expression = expression;
  }
  /** @private */
  build() {
    return {
      floor: {
        expression: this.expression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.FloorExpressionImpl = FloorExpressionImpl;
class CeilExpressionImpl {
  constructor(expression) {
    this.expression = expression;
  }
  /** @private */
  build() {
    return {
      ceil: {
        expression: this.expression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.CeilExpressionImpl = CeilExpressionImpl;
class ConcatExpressionImpl {
  constructor(expressions) {
    this.expressions = expressions;
  }
  /** @private */
  build() {
    return {
      concat: {
        expressions: this.expressions.map(e => e.build())
      }
    };
  }
}

/**
 * @builder
 */
exports.ConcatExpressionImpl = ConcatExpressionImpl;
class StringifyExpressionImpl {
  constructor(expression) {
    this.expression = expression;
  }
  /** @private */
  build() {
    return {
      stringify: {
        expression: this.expression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.StringifyExpressionImpl = StringifyExpressionImpl;
class ToLowerExpressionImpl {
  constructor(expression) {
    this.expression = expression;
  }
  /** @private */
  build() {
    return {
      toLower: {
        expression: this.expression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.ToLowerExpressionImpl = ToLowerExpressionImpl;
class ToUpperExpressionImpl {
  constructor(expression) {
    this.expression = expression;
  }
  /** @private */
  build() {
    return {
      toUpper: {
        expression: this.expression.build()
      }
    };
  }
}

/**
 * @builder
 */
exports.ToUpperExpressionImpl = ToUpperExpressionImpl;
class SubstringExpressionImpl {
  constructor(expression, startExpression, lengthExpression) {
    this.expression = expression;
    this.startExpression = startExpression;
    this.lengthExpression = lengthExpression;
  }
  /** @private */
  build() {
    const proto = {
      substring: {
        expression: this.expression.build(),
        startExpression: this.startExpression.build()
      }
    };
    if (this.lengthExpression) {
      proto.substring.lengthExpression = this.lengthExpression.build();
    }
    return proto;
  }
}

/**
 * @builder
 */
exports.SubstringExpressionImpl = SubstringExpressionImpl;
class LengthExpressionImpl {
  constructor(expression) {
    this.expression = expression;
  }
  /** @private */
  build() {
    return {
      length: {
        expression: this.expression.build()
      }
    };
  }
}
exports.LengthExpressionImpl = LengthExpressionImpl;
//# sourceMappingURL=Expression.js.map