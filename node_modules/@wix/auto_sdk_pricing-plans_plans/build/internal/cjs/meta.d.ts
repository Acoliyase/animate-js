import { ListPublicPlansRequest as ListPublicPlansRequest$1, ListPublicPlansResponse as ListPublicPlansResponse$1, QueryPublicPlansRequest as QueryPublicPlansRequest$1, QueryPublicPlansResponse as QueryPublicPlansResponse$1, GetPlanRequest as GetPlanRequest$1, GetPlanResponse as GetPlanResponse$1, ListPlansRequest as ListPlansRequest$1, ListPlansResponse as ListPlansResponse$1, GetPlanStatsRequest as GetPlanStatsRequest$1, GetPlanStatsResponse as GetPlanStatsResponse$1, CreatePlanRequest as CreatePlanRequest$1, CreatePlanResponse as CreatePlanResponse$1, UpdatePlanRequest as UpdatePlanRequest$1, UpdatePlanResponse as UpdatePlanResponse$1, SetPlanVisibilityRequest as SetPlanVisibilityRequest$1, SetPlanVisibilityResponse as SetPlanVisibilityResponse$1, MakePlanPrimaryRequest as MakePlanPrimaryRequest$1, MakePlanPrimaryResponse as MakePlanPrimaryResponse$1, ClearPrimaryRequest as ClearPrimaryRequest$1, ClearPrimaryResponse as ClearPrimaryResponse$1, ArchivePlanRequest as ArchivePlanRequest$1, ArchivePlanResponse as ArchivePlanResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

/** Information about the pricing plan. */
interface Plan {
    /**
     * Plan ID.
     * @format GUID
     * @readonly
     */
    id?: string;
    /**
     * Plan name.
     * @minLength 1
     * @maxLength 50
     */
    name?: string | null;
    /**
     * Plan description.
     * @maxLength 450
     */
    description?: string | null;
    /** List of text strings that promote what is included with this plan. For example, "Plenty of parking" or "Free gift on your birthday." */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is public (visible to site visitors and members). */
    public?: boolean | null;
    /**
     * Whether the plan is archived. Archived plans are not visible and can't be purchased anymore, but existing purchases remain in effect.
     * @readonly
     */
    archived?: boolean;
    /**
     * Whether the plan is marked as primary.
     * @readonly
     */
    primary?: boolean;
    /**
     * Whether the plan has any orders (including pending and unpaid orders).
     * @readonly
     */
    hasOrders?: boolean;
    /**
     * Date plan was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date plan was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @minLength 1
     * @readonly
     * @format URL_SLUG
     */
    slug?: string | null;
    /**
     * Number of times the same buyer can purchase the plan. Currently limited to support:
     * - Empty value or a value of `0`, meaning no limitation.
     * - Value of `1`, meaning limited to 1 purchase per buyer.
     * @max 1
     */
    maxPurchasesPerBuyer?: number | null;
    /** Whether the buyer can start the plan at a later date. Defaults to false. */
    allowFutureStartDate?: boolean | null;
    /**
     * Whether the buyer is allowed to cancel their plan. Defaults to false.
     * If false, calling Request Cancellation returns an error.
     */
    buyerCanCancel?: boolean | null;
    /**
     * Any terms and conditions that apply to the plan. This information is displayed during checkout.
     * @maxLength 3000
     */
    termsAndConditions?: string | null;
    /**
     * ID of the form associated with the plan at checkout.
     *
     * Learn more about [forms](https://support.wix.com/en/article/wix-forms-an-overview).
     * @format GUID
     */
    formId?: string | null;
}
/** This wrapper type exists to distinguish an empty string list from no list at all in update requests. */
interface StringList {
    /**
     * @minLength 1
     * @maxLength 1400
     * @maxSize 500
     */
    values?: string[];
}
/** Plan pricing information. Includes the price of the plan and payment details. */
interface Pricing extends PricingPricingModelOneOf {
    /** Pricing model indicating that the plan has recurring payments. This type of subscription is not a "Wix subscription," which encompasses various types of subscriptions, such as Wix Stores subscriptions, Wix invoice subscriptions, and all pricing plan models. */
    subscription?: Recurrence;
    /** Pricing model indicating a single payment per cycle and the length of the cycle. The cycle is the duration of the plan, not a payment cycle. */
    singlePaymentForDuration?: Duration;
    /** Pricing model indicating the plan is paid in a single payment. The plan is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Amount for a single payment. For subscriptions, this is the amount to pay each payment cycle and it is required. For plans that are not recurring plans, it is the single payment amount for the whole subscription. */
    price?: Money;
    /**
     * Free trial period for the plan in days. Available only for recurring plans, meaning plans whose pricing model is `subscription`. Set to `0` to remove the free trial.
     * @max 999
     */
    freeTrialDays?: number | null;
}
/** @oneof */
interface PricingPricingModelOneOf {
    /** Pricing model indicating that the plan has recurring payments. This type of subscription is not a "Wix subscription," which encompasses various types of subscriptions, such as Wix Stores subscriptions, Wix invoice subscriptions, and all pricing plan models. */
    subscription?: Recurrence;
    /** Pricing model indicating a single payment per cycle and the length of the cycle. The cycle is the duration of the plan, not a payment cycle. */
    singlePaymentForDuration?: Duration;
    /** Pricing model indicating the plan is paid in a single payment. The plan is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence {
    /**
     * Number of payment cycles the subscription is valid for.
     * `0` for unlimited plans or for plans that are valid until canceled.
     */
    cycleDuration?: Duration;
    /**
     * Length of a payment cycle. For example, 1 month to have monthly payments.
     * Multiply `cycleDuration`'s `count` by `cycleCount` to get the subscription duration.
     * Currently, only a value of `1` is supported.
     * @max 2000
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration {
    /**
     * Number of days, months, weeks, or years in a single payment cycle. Currently limited to support only `1`.
     * @min 1
     */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnitWithLiterals;
}
declare enum PeriodUnit {
    /** Not defined. */
    UNDEFINED = "UNDEFINED",
    /** Time unit is a day. */
    DAY = "DAY",
    /** Time unit is a week. */
    WEEK = "WEEK",
    /** Time unit is a month. */
    MONTH = "MONTH",
    /** Time unit is a year. */
    YEAR = "YEAR"
}
/** @enumType */
type PeriodUnitWithLiterals = PeriodUnit | 'UNDEFINED' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
interface Money {
    /**
     * Monetary amount. Decimal string with a period as a decimal separator. For example, `'3.99'`. Can't be negative.
     * @decimalValue options { lt:1000000000000, gte:0.000, maxScale:3 }
     */
    value?: string;
    /**
     * Currency code. Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. For example, `'USD'`.
     * @format CURRENCY
     */
    currency?: string;
}
interface FeeConfig {
    /** Fee configuration. */
    fee?: Fee;
    /** The time this fee will be charged. */
    appliedAt?: AppliedAtWithLiterals;
}
interface Fee {
    /**
     * Fee name
     * @minLength 1
     * @maxLength 40
     */
    name?: string;
    /**
     * Amount of fee to be charged
     * @decimalValue options { lt:1000000000000, gt:0.000, maxScale:3 }
     */
    amount?: string;
}
declare enum AppliedAt {
    UNKNOWN_CHARGE_EVENT = "UNKNOWN_CHARGE_EVENT",
    /** Will charge the fee on the first payment. If the order has a free trial, it will charge after the free trial. */
    FIRST_PAYMENT = "FIRST_PAYMENT"
}
/** @enumType */
type AppliedAtWithLiterals = AppliedAt | 'UNKNOWN_CHARGE_EVENT' | 'FIRST_PAYMENT';
interface ListPublicPlansRequest {
    /**
     * Number of items to list. Defaults to `75`. See limits ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/list-public-plans) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#paging)).
     * @min 1
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip. Defaults to `0`. See paging ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/list-public-plans) |[REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#paging)). */
    offset?: number | null;
    /**
     * IDs of plans to list. Non-existent IDs are ignored and don't cause errors. You can specify a maximum of 100 IDs.
     * @format GUID
     * @maxSize 100
     */
    planIds?: string[];
}
interface ListPublicPlansResponse {
    /** List of public pricing plans. */
    plans?: PublicPlan[];
    /** Object containing paging-related data (such as the number of plans returned, the offset, and so on). */
    pagingMetadata?: PagingMetadataV2;
}
/** Public plan entity containing information about the pricing plan. Can be read by any site member or visitor. */
interface PublicPlan {
    /**
     * Plan ID.
     * @format GUID
     */
    id?: string;
    /**
     * Plan name.
     * @minLength 1
     * @maxLength 50
     */
    name?: string | null;
    /**
     * Plan description.
     * @maxLength 450
     */
    description?: string | null;
    /** What is included with this plan (for example, 1 weekly entrance to a specific class). */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is marked as primary. */
    primary?: boolean;
    /** Date plan was created. */
    createdDate?: Date | null;
    /** Date plan was last updated. */
    updatedDate?: Date | null;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @minLength 1
     */
    slug?: string | null;
    /** Number of times the same buyer can purchase the plan. An empty value or a value of 0 means no limitation. */
    maxPurchasesPerBuyer?: number | null;
    /** Whether the buyer can start the plan at a later date. Defaults to false. */
    allowFutureStartDate?: boolean | null;
    /** Whether the buyer is allowed to cancel their plan. Defaults to false. */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information is displayed during checkout. */
    termsAndConditions?: string | null;
    /**
     * ID of the form associated with the plan at checkout.
     *
     * Learn more about [forms](https://support.wix.com/en/article/wix-forms-an-overview).
     * @format GUID
     */
    formId?: string | null;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface QueryPublicPlansRequest {
    /** Query options. */
    query?: QueryV2;
}
interface QueryV2 {
    /** A filter object. See supported fields and operators ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/query-public-plans) | [REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/filter-and-sort#wix-pricing-plans_pricing-plans_plans_filter-and-sort_query-public-plans)). */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]. */
    sort?: Sorting[];
    /** Pointer to page of results using offset. Can't be used together with 'cursorPaging'. */
    paging?: Paging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface QueryPublicPlansResponse {
    /** List of public pricing plans that match the specified query. */
    plans?: PublicPlan[];
    /** Object containing paging-related data (such as the number of plans returned, the offset, and so on). */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanRequest {
    /**
     * Plan ID.
     * @format GUID
     */
    id: string;
}
interface GetPlanResponse {
    /** Pricing plan. */
    plan?: Plan;
}
interface ListPlansRequest {
    /** Archived filter. Defaults to `ACTIVE` (not archived) only. */
    archived?: ArchivedFilterWithLiterals;
    /** Visibility filter. Defaults to `PUBLIC_AND_HIDDEN` (meaning, both are listed). */
    public?: PublicFilterWithLiterals;
    /**
     * Number of pricing plans to list. Defaults to `75`.
     * @min 1
     * @max 100
     */
    limit?: number | null;
    /** Number of pricing plans to skip. Defaults to `0`. */
    offset?: number | null;
    /**
     * IDs of plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public and hidden plans are listed according to the order displayed in a site's dashboard (which you can set with Arrange Plans). You can specify a maximum of 100 IDs.
     * @format GUID
     * @maxSize 100
     */
    planIds?: string[];
}
declare enum ArchivedFilter {
    /** Returns all plans that are active. */
    ACTIVE = "ACTIVE",
    /** Returns all plans that are archived. */
    ARCHIVED = "ARCHIVED",
    /** Returns all plans that are active and archived. */
    ARCHIVED_AND_ACTIVE = "ARCHIVED_AND_ACTIVE"
}
/** @enumType */
type ArchivedFilterWithLiterals = ArchivedFilter | 'ACTIVE' | 'ARCHIVED' | 'ARCHIVED_AND_ACTIVE';
declare enum PublicFilter {
    /** Returns all public and hidden plans. */
    PUBLIC_AND_HIDDEN = "PUBLIC_AND_HIDDEN",
    /** Returns only public plans. */
    PUBLIC = "PUBLIC",
    /** Returns only hidden plans. */
    HIDDEN = "HIDDEN"
}
/** @enumType */
type PublicFilterWithLiterals = PublicFilter | 'PUBLIC_AND_HIDDEN' | 'PUBLIC' | 'HIDDEN';
interface ListPlansResponse {
    /** List of all public and hidden pricing plans. */
    plans?: Plan[];
    /** Object containing paging-related data (such as the number of plans returned, the offset, and so on). */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanStatsRequest {
}
interface GetPlanStatsResponse {
    /** Total number of plans created, including active plans (both public and hidden) and archived plans. */
    totalPlans?: number;
}
interface CreatePlanRequest {
    /** Plan details. */
    plan: Plan;
}
interface CreatePlanResponse {
    /** Created plan. */
    plan?: Plan;
}
interface UpdatePlanRequest {
    /** ID of the plan to update. */
    plan: Plan;
}
interface UpdatePlanResponse {
    /** Updated plan. */
    plan?: Plan;
}
interface BuyerCanCancelUpdated {
    /** Pricing plan. */
    plan?: Plan;
}
interface SetPlanVisibilityRequest {
    /**
     * The ID of the plan to either display or hide on a site page.
     * @format GUID
     */
    id: string;
    /** Whether a plan is visible to members and site visitors. Updates the `public` field. */
    visible: boolean;
}
interface SetPlanVisibilityResponse {
    /** Pricing plan. */
    plan?: Plan;
}
interface MakePlanPrimaryRequest {
    /**
     * Pricing plan ID.
     * @format GUID
     */
    id: string;
}
interface MakePlanPrimaryResponse {
    /** Pricing plan. */
    plan?: Plan;
}
interface ClearPrimaryRequest {
}
interface ClearPrimaryResponse {
}
interface ArchivePlanRequest {
    /**
     * ID of the active plan to archive.
     * @format GUID
     */
    id: string;
}
interface ArchivePlanResponse {
    /** Archived plan. */
    plan?: Plan;
}
interface PlanArchived {
    /** Pricing plan. */
    plan?: Plan;
}
interface BulkArchivePlanRequest {
    /**
     * List of Plan IDs to archive.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    ids?: string[];
    /** Set to `true` to return the `Plan` entity in the response. */
    returnFullEntity?: boolean;
}
interface BulkArchivePlanResponse {
    /** Plans to be archived. */
    results?: BulkPlanResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkPlanResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Pricing plan. */
    plan?: Plan;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface ArrangePlansRequest {
    /**
     * IDs of all non-archived plans in the order you want them arranged.
     * @format GUID
     * @minSize 1
     */
    ids?: string[];
}
interface ArrangePlansResponse {
}
interface CountPlansRequest {
    /** The filter. */
    filter?: Record<string, any> | null;
    /** If true, counts only visible plans (visible and not archived). If no value is specified, all plans are counted. */
    visibility?: boolean | null;
}
interface CountPlansResponse {
    /** Number of plans in the response. */
    count?: number;
}
interface GetPlansPremiumStatusRequest {
}
interface GetPlansPremiumStatusResponse {
    /** True if a site has non-free, non-template plans. */
    hasPaidPlans?: boolean;
    /** True if a site has plans that were created before Pricing Plans became a premium app. */
    hasOldPlans?: boolean;
}
interface SearchPlansRequest {
    /** Query options. */
    query?: QueryV2;
    /**
     * Search phrase for the plan name.
     * @maxLength 50
     */
    searchPhrase?: string | null;
}
interface SearchPlansResponse {
    /** List of pricing plans that match the specified filter and search phrase. */
    plans?: Plan[];
    /** Object containing paging-related data (such as the number of plans returned, the offset, and so on). */
    pagingMetadata?: PagingMetadataV2;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type ListPublicPlansApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type QueryPublicPlansApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type QueryPublicPlansValidationErrors = {
    ruleName?: 'PAGING_LIMIT_OUT_OF_RANGE';
};
/** @docsIgnore */
type GetPlanApplicationErrors = {
    code?: 'plan_not_found';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ListPlansApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ListPlansValidationErrors = {
    ruleName?: 'INVALID_ARCHIVE_FILTER';
} | {
    ruleName?: 'INVALID_VISIBLE_FILTER';
};
/** @docsIgnore */
type GetPlanStatsApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CreatePlanApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CreatePlanValidationErrors = {
    ruleName?: 'PLAN_NAME_BLANK';
} | {
    ruleName?: 'PLAN_FEE_NAME_BLANK';
} | {
    ruleName?: 'PERIOD_AMOUNT_OUT_OF_RANGE';
} | {
    ruleName?: 'RECURRING_PLAN_PAYMENT_PRICE_MISSING';
} | {
    ruleName?: 'RECURRING_PLAN_CYCLE_DURATION_TOO_SHORT';
} | {
    ruleName?: 'RECURRING_PLAN_CYCLE_COUNT_INVALID';
} | {
    ruleName?: 'SINGLE_PAYMENT_DURATION_TOO_SHORT';
} | {
    ruleName?: 'SINGLE_PAYMENT_CYCLE_COUNT_INVALID';
} | {
    ruleName?: 'SINGLE_PAYMENT_FREE_TRIAL_UNSUPPORTED';
} | {
    ruleName?: 'INVALID_SINGLE_PAYMENT_WITHOUT_DURATION';
} | {
    ruleName?: 'invalid_duration_unit';
} | {
    ruleName?: 'client_data_is_invalid';
};
/** @docsIgnore */
type UpdatePlanApplicationErrors = {
    code?: 'plan_not_found';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type UpdatePlanValidationErrors = {
    ruleName?: 'MISSING_PLAN_ID';
} | {
    ruleName?: 'PLAN_NAME_BLANK';
} | {
    ruleName?: 'PLAN_FEE_NAME_BLANK';
} | {
    ruleName?: 'PERIOD_AMOUNT_OUT_OF_RANGE';
} | {
    ruleName?: 'RECURRING_PLAN_PAYMENT_PRICE_MISSING';
} | {
    ruleName?: 'RECURRING_PLAN_CYCLE_DURATION_TOO_SHORT';
} | {
    ruleName?: 'RECURRING_PLAN_CYCLE_COUNT_INVALID';
} | {
    ruleName?: 'SINGLE_PAYMENT_CYCLE_COUNT_INVALID';
} | {
    ruleName?: 'SINGLE_PAYMENT_FREE_TRIAL_UNSUPPORTED';
} | {
    ruleName?: 'INVALID_SINGLE_PAYMENT_WITHOUT_DURATION';
} | {
    ruleName?: 'INVALID_DURATION_UNIT';
} | {
    ruleName?: 'update_not_supported';
} | {
    ruleName?: 'invalid_period_amount';
} | {
    ruleName?: 'price_missing';
} | {
    ruleName?: 'duration_missing';
} | {
    ruleName?: 'free_trial_not_supported';
} | {
    ruleName?: 'client_data_is_invalid';
};
/** @docsIgnore */
type SetPlanVisibilityApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'plan_not_found';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'set_visibility_not_supported';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type MakePlanPrimaryApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'plan_not_found';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'set_primary_not_supported';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ClearPrimaryApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ArchivePlanApplicationErrors = {
    code?: 'PRICING_PLANS_NOT_INSTALLED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'plan_not_found';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'already_archived';
    description?: string;
    data?: Record<string, any>;
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function listPublicPlans(): __PublicMethodMetaInfo<'GET', {}, ListPublicPlansRequest$1, ListPublicPlansRequest, ListPublicPlansResponse$1, ListPublicPlansResponse>;
declare function queryPublicPlans(): __PublicMethodMetaInfo<'POST', {}, QueryPublicPlansRequest$1, QueryPublicPlansRequest, QueryPublicPlansResponse$1, QueryPublicPlansResponse>;
declare function getPlan(): __PublicMethodMetaInfo<'GET', {
    id: string;
}, GetPlanRequest$1, GetPlanRequest, GetPlanResponse$1, GetPlanResponse>;
declare function listPlans(): __PublicMethodMetaInfo<'GET', {}, ListPlansRequest$1, ListPlansRequest, ListPlansResponse$1, ListPlansResponse>;
declare function getPlanStats(): __PublicMethodMetaInfo<'GET', {}, GetPlanStatsRequest$1, GetPlanStatsRequest, GetPlanStatsResponse$1, GetPlanStatsResponse>;
declare function createPlan(): __PublicMethodMetaInfo<'POST', {}, CreatePlanRequest$1, CreatePlanRequest, CreatePlanResponse$1, CreatePlanResponse>;
declare function updatePlan(): __PublicMethodMetaInfo<'PATCH', {
    planId: string;
}, UpdatePlanRequest$1, UpdatePlanRequest, UpdatePlanResponse$1, UpdatePlanResponse>;
declare function setPlanVisibility(): __PublicMethodMetaInfo<'PUT', {
    id: string;
}, SetPlanVisibilityRequest$1, SetPlanVisibilityRequest, SetPlanVisibilityResponse$1, SetPlanVisibilityResponse>;
declare function makePlanPrimary(): __PublicMethodMetaInfo<'POST', {
    id: string;
}, MakePlanPrimaryRequest$1, MakePlanPrimaryRequest, MakePlanPrimaryResponse$1, MakePlanPrimaryResponse>;
declare function clearPrimary(): __PublicMethodMetaInfo<'POST', {}, ClearPrimaryRequest$1, ClearPrimaryRequest, ClearPrimaryResponse$1, ClearPrimaryResponse>;
declare function archivePlan(): __PublicMethodMetaInfo<'POST', {
    id: string;
}, ArchivePlanRequest$1, ArchivePlanRequest, ArchivePlanResponse$1, ArchivePlanResponse>;

export { type ActionEvent as ActionEventOriginal, type ApplicationError as ApplicationErrorOriginal, AppliedAt as AppliedAtOriginal, type AppliedAtWithLiterals as AppliedAtWithLiteralsOriginal, type ArchivePlanApplicationErrors as ArchivePlanApplicationErrorsOriginal, type ArchivePlanRequest as ArchivePlanRequestOriginal, type ArchivePlanResponse as ArchivePlanResponseOriginal, ArchivedFilter as ArchivedFilterOriginal, type ArchivedFilterWithLiterals as ArchivedFilterWithLiteralsOriginal, type ArrangePlansRequest as ArrangePlansRequestOriginal, type ArrangePlansResponse as ArrangePlansResponseOriginal, type BulkActionMetadata as BulkActionMetadataOriginal, type BulkArchivePlanRequest as BulkArchivePlanRequestOriginal, type BulkArchivePlanResponse as BulkArchivePlanResponseOriginal, type BulkPlanResult as BulkPlanResultOriginal, type BuyerCanCancelUpdated as BuyerCanCancelUpdatedOriginal, type ClearPrimaryApplicationErrors as ClearPrimaryApplicationErrorsOriginal, type ClearPrimaryRequest as ClearPrimaryRequestOriginal, type ClearPrimaryResponse as ClearPrimaryResponseOriginal, type CountPlansRequest as CountPlansRequestOriginal, type CountPlansResponse as CountPlansResponseOriginal, type CreatePlanApplicationErrors as CreatePlanApplicationErrorsOriginal, type CreatePlanRequest as CreatePlanRequestOriginal, type CreatePlanResponse as CreatePlanResponseOriginal, type CreatePlanValidationErrors as CreatePlanValidationErrorsOriginal, type Cursors as CursorsOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type Duration as DurationOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type FeeConfig as FeeConfigOriginal, type Fee as FeeOriginal, type GetPlanApplicationErrors as GetPlanApplicationErrorsOriginal, type GetPlanRequest as GetPlanRequestOriginal, type GetPlanResponse as GetPlanResponseOriginal, type GetPlanStatsApplicationErrors as GetPlanStatsApplicationErrorsOriginal, type GetPlanStatsRequest as GetPlanStatsRequestOriginal, type GetPlanStatsResponse as GetPlanStatsResponseOriginal, type GetPlansPremiumStatusRequest as GetPlansPremiumStatusRequestOriginal, type GetPlansPremiumStatusResponse as GetPlansPremiumStatusResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type ItemMetadata as ItemMetadataOriginal, type ListPlansApplicationErrors as ListPlansApplicationErrorsOriginal, type ListPlansRequest as ListPlansRequestOriginal, type ListPlansResponse as ListPlansResponseOriginal, type ListPlansValidationErrors as ListPlansValidationErrorsOriginal, type ListPublicPlansApplicationErrors as ListPublicPlansApplicationErrorsOriginal, type ListPublicPlansRequest as ListPublicPlansRequestOriginal, type ListPublicPlansResponse as ListPublicPlansResponseOriginal, type MakePlanPrimaryApplicationErrors as MakePlanPrimaryApplicationErrorsOriginal, type MakePlanPrimaryRequest as MakePlanPrimaryRequestOriginal, type MakePlanPrimaryResponse as MakePlanPrimaryResponseOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type Money as MoneyOriginal, type PagingMetadataV2 as PagingMetadataV2Original, type Paging as PagingOriginal, PeriodUnit as PeriodUnitOriginal, type PeriodUnitWithLiterals as PeriodUnitWithLiteralsOriginal, type PlanArchived as PlanArchivedOriginal, type Plan as PlanOriginal, type Pricing as PricingOriginal, type PricingPricingModelOneOf as PricingPricingModelOneOfOriginal, PublicFilter as PublicFilterOriginal, type PublicFilterWithLiterals as PublicFilterWithLiteralsOriginal, type PublicPlan as PublicPlanOriginal, type QueryPublicPlansApplicationErrors as QueryPublicPlansApplicationErrorsOriginal, type QueryPublicPlansRequest as QueryPublicPlansRequestOriginal, type QueryPublicPlansResponse as QueryPublicPlansResponseOriginal, type QueryPublicPlansValidationErrors as QueryPublicPlansValidationErrorsOriginal, type QueryV2 as QueryV2Original, type Recurrence as RecurrenceOriginal, type RestoreInfo as RestoreInfoOriginal, type SearchPlansRequest as SearchPlansRequestOriginal, type SearchPlansResponse as SearchPlansResponseOriginal, type SetPlanVisibilityApplicationErrors as SetPlanVisibilityApplicationErrorsOriginal, type SetPlanVisibilityRequest as SetPlanVisibilityRequestOriginal, type SetPlanVisibilityResponse as SetPlanVisibilityResponseOriginal, SortOrder as SortOrderOriginal, type SortOrderWithLiterals as SortOrderWithLiteralsOriginal, type Sorting as SortingOriginal, type StringList as StringListOriginal, type UpdatePlanApplicationErrors as UpdatePlanApplicationErrorsOriginal, type UpdatePlanRequest as UpdatePlanRequestOriginal, type UpdatePlanResponse as UpdatePlanResponseOriginal, type UpdatePlanValidationErrors as UpdatePlanValidationErrorsOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, archivePlan, clearPrimary, createPlan, getPlan, getPlanStats, listPlans, listPublicPlans, makePlanPrimary, queryPublicPlans, setPlanVisibility, updatePlan };
