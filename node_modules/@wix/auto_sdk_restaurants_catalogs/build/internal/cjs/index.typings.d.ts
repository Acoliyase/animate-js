import { NonNullablePaths } from '@wix/sdk-types';

/**
 * Collection of menus and discounts available in a specific location.
 * Use a [draft catalog](https://dev.wix.com/api/rest/wix-restaurants/catalogs/draft-catalogs) to publish multiple changes to a catalog at the same time.
 * You can read more about catalogs in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Catalog {
    /**
     * Catalog ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * ID of the location the catalog belongs to. See the [Locations API](https://dev.wix.com/api/rest/business-info/locations/introduction) for more details.
     * @readonly
     * @format GUID
     */
    locationId?: string | null;
    /**
     * Whether the catalog is archived.
     * __Note:__ Archived catalogs can't be updated.
     * @readonly
     */
    archived?: boolean;
    /**
     * Date and time the last time a draft catalog has been published in `yyyy-mm-ddThh:mm:sssZ` format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
     * @readonly
     */
    draftPublishedDate?: Date | null;
}
interface CreateDraftCatalogRequest {
    /**
     * ID of the catalog to create a draft version for.
     * @format GUID
     */
    catalogId: string;
}
interface CreateDraftCatalogResponse {
    /** Created draft catalog. */
    catalog?: Catalog;
}
interface PublishDraftCatalogRequest {
    /**
     * ID of the draft catalog to publish.
     * @format GUID
     */
    catalogId: string;
}
interface PublishDraftCatalogResponse {
    /** Published catalog. */
    catalog?: Catalog;
}
interface DiscardDraftCatalogRequest {
    /**
     * ID of the draft catalog to discard.
     * @format GUID
     */
    catalogId: string;
}
interface DiscardDraftCatalogResponse {
}
interface BulkCreateVariationsRequest {
    /** ID of the catalog the variations will belong to. */
    catalogId: string;
    /**
     * Variations to create. Limited to 20 variations.
     * @minSize 1
     * @maxSize 20
     */
    variations?: NewVariation[];
    /** Whether the full variation entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface NewVariation {
    /**
     * Variation name.
     * @minLength 1
     */
    name?: string;
}
interface BulkCreateVariationsResponse {
    /** Information about the created variations. */
    results?: BulkItemResult[];
    /** Bulk Create Variations metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkItemResult {
    /** Metadata of the item. */
    entityMetadata?: ItemMetadata;
    /** Item. */
    entity?: Item;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * Anything that customers can buy in the restaurant. Items can be of type `DISH` or `VARIATION`.
 * You can read more about items in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Item {
    /**
     * Item ID.
     * @readonly
     */
    _id?: string | null;
    /** Item name. */
    name?: string | null;
    /** Item description. */
    description?: string | null;
    /** Item price. */
    price?: Money;
    /** URL of the item's image file. */
    imageUrl?: string | null;
    /** Item labels. For example spicy, hot, vegan, gluten-free, or organic. */
    labels?: Labels;
    /** Whether the item is in stock. */
    inStock?: boolean | null;
    /**
     * Tax rate of the item in percent.
     * @decimalValue options { maxScale:3 }
     */
    taxRate?: string | null;
    /**
     * Whether the item is archived. Defaults to `false`. **Note:** Archived items can't be updated.
     * @readonly
     */
    archived?: boolean | null;
    /**
     * Visibility criteria that must be met for the item to appear in the live site.
     * In case of multiple visibility criteria, every criterion must be fulfilled.
     */
    visibilityCriteria?: VisibilityCriteria;
    /** Items customers can choose to modify a dish. Can be an extra, selection, or deselection. */
    dishOptions?: DishOptions;
    /** Whether a customer can add a special request when ordering this item. Defaults to `true`. */
    acceptSpecialRequest?: boolean | null;
    /**
     * Item type.
     * @readonly
     */
    type?: ItemTypeWithLiterals;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
interface Money {
    /**
     * Monetary amount in decimal string format. For example, `3.99`, `6`, and `10.5` are all accepted values.
     * @format DECIMAL_VALUE
     */
    value?: string;
    /**
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     * @format CURRENCY
     * @readonly
     */
    currency?: string;
}
interface Labels {
    values?: string[];
}
interface VisibilityCriteria {
    /**
     * Whether the entity appears in the live site. Defaults to `true`.
     * If `false`, the entity isn't rendered in the live site, even if each visibility criterion is fulfilled.
     */
    visible?: boolean | null;
    /**
     * Fulfillment types.
     * @minSize 1
     * @maxSize 2
     */
    fulfillmentTypes?: FulfillmentTypeWithLiterals[];
    /**
     * Ordering platforms.
     * @minSize 1
     * @maxSize 5
     */
    platforms?: PlatformWithLiterals[];
    /** Time periods when the entity is available. */
    availability?: Availability;
}
declare enum FulfillmentType {
    UNSPECIFIED_FULFILLMENT_TYPE = "UNSPECIFIED_FULFILLMENT_TYPE",
    DELIVERY = "DELIVERY",
    PICKUP_OR_DINE_IN = "PICKUP_OR_DINE_IN"
}
/** @enumType */
type FulfillmentTypeWithLiterals = FulfillmentType | 'UNSPECIFIED_FULFILLMENT_TYPE' | 'DELIVERY' | 'PICKUP_OR_DINE_IN';
declare enum Platform {
    UNSPECIFIED_PLATFORM = "UNSPECIFIED_PLATFORM",
    SITE = "SITE",
    MOBILE_SITE = "MOBILE_SITE",
    WIX_APP = "WIX_APP",
    CALL_CENTER = "CALL_CENTER",
    CHAT_BOT = "CHAT_BOT"
}
/** @enumType */
type PlatformWithLiterals = Platform | 'UNSPECIFIED_PLATFORM' | 'SITE' | 'MOBILE_SITE' | 'WIX_APP' | 'CALL_CENTER' | 'CHAT_BOT';
interface Availability {
    /**
     * Weekly recurring time periods when the entity is available.
     * Limited to 100 time periods.
     */
    periods?: TimePeriod[];
    /** Exceptions to the entity's regular availability. The entity can be available or not available during the special hour period. */
    specialHourPeriods?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the entity is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
declare enum DayOfWeek {
    UNDEFINED = "UNDEFINED",
    SUN = "SUN",
    MON = "MON",
    TUE = "TUE",
    WED = "WED",
    THU = "THU",
    FRI = "FRI",
    SAT = "SAT"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'UNDEFINED' | 'SUN' | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /** Whether the item is available during the exception. Defaults to `true`. */
    available?: boolean;
    /** Name of the special hour period. In the dashboard, the special hour period is called event. */
    eventName?: string | null;
}
interface DishOptions {
    values?: DishOption[];
}
interface DishOption extends DishOptionMethodOneOf {
    /** Item of type `DISH` or `VARIATION` that customers can select. For example a dish size. Customers can choose only a single selection per dish. */
    selection?: Selection;
    /** Item of type `DISH` or `VARIATION` that customers can add to a dish. For example a topping. Customers can add multiple extras per dish. */
    extras?: Extras;
    /** Item of type `DISH` or `VARIATION` that customers can remove from a dish. For example a specific ingredient. Customers can remove multiple deselections per dish. */
    deselection?: Deselection;
    /** Dish option name. */
    name?: string;
    /** @readonly */
    type?: TypeWithLiterals;
}
/** @oneof */
interface DishOptionMethodOneOf {
    /** Item of type `DISH` or `VARIATION` that customers can select. For example a dish size. Customers can choose only a single selection per dish. */
    selection?: Selection;
    /** Item of type `DISH` or `VARIATION` that customers can add to a dish. For example a topping. Customers can add multiple extras per dish. */
    extras?: Extras;
    /** Item of type `DISH` or `VARIATION` that customers can remove from a dish. For example a specific ingredient. Customers can remove multiple deselections per dish. */
    deselection?: Deselection;
}
interface DishOptionItem {
    /** Item ID of the dish option. */
    itemId?: string;
    /** Dish option price. `0` for free choices that are included in the dish's price. */
    price?: Money;
}
interface Selection {
    /** Item ID of the default choice. */
    defaultChoice?: string | null;
    /** Item IDs of the available choices. */
    availableChoices?: DishOptionItem[];
}
interface Extras {
    /** Item IDs of the default choices. */
    defaultChoices?: string[];
    /**
     * Minimum number of extras a customer must choose. Defaults to `0`. Must be lower than or equal to the value of `availableChoices`.
     * @max 2147483647
     */
    minChoices?: number | null;
    /**
     * Maximum number of extras a customer can choose. Defaults to the value of `availableChoices`. Must be greater than or equal to the value of `minChoices`.
     * @max 2147483647
     */
    maxChoices?: number | null;
    /** Item IDs of the available choices. */
    availableChoices?: DishOptionItem[];
}
interface Deselection {
    /** Item IDs of the available choices. */
    availableChoices?: DishOptionItem[];
}
declare enum Type {
    UNSPECIFIED_DISH_OPTION_TYPE = "UNSPECIFIED_DISH_OPTION_TYPE",
    SELECTION = "SELECTION",
    EXTRAS = "EXTRAS",
    DESELECTION = "DESELECTION"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNSPECIFIED_DISH_OPTION_TYPE' | 'SELECTION' | 'EXTRAS' | 'DESELECTION';
declare enum ItemType {
    UNSPECIFIED_ITEM_TYPE = "UNSPECIFIED_ITEM_TYPE",
    DISH = "DISH",
    VARIATION = "VARIATION"
}
/** @enumType */
type ItemTypeWithLiterals = ItemType | 'UNSPECIFIED_ITEM_TYPE' | 'DISH' | 'VARIATION';
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateItemsRequest {
    /** ID of the catalog the items belong to. */
    catalogId: string;
    /**
     * Items to update. Limited to 20 items.
     * @minSize 1
     * @maxSize 20
     */
    items?: Item[];
    /** Whether the full item entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkUpdateItemsResponse {
    /** Information about the updated items. */
    results?: BulkItemResult[];
    /** Bulk Update Items metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCreateDishesRequest {
    /** ID of the catalog the dishes will belong to. */
    catalogId: string;
    /**
     * Information about the dishes to create. Limited to 20 dishes.
     * @minSize 1
     * @maxSize 20
     */
    createDishRequests?: CreateDishRequest[];
    /** Whether the full item entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface CreateDishRequest {
    /** ID of the menu the dish will belong to. */
    menuId?: string;
    /** ID of the section the dish will belong to. */
    sectionId?: string;
    /** Dish to create. */
    dish?: Item;
}
interface BulkCreateDishesResponse {
    /** Information about the created dishes. */
    results?: BulkItemResult[];
    /** Bulk Create Dishes metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCreateMenusRequest {
    /** ID of the catalog the menus will belong to. */
    catalogId: string;
    /**
     * Information about the menus to create. Limited to 20 menus.
     * @minSize 1
     * @maxSize 20
     */
    menus?: Menu[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Collection of sections that show what customers can buy in the restaurant.
 * You can read more about menus in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Menu {
    /**
     * Menu ID.
     * @readonly
     */
    _id?: string | null;
    /** Menu name. */
    name?: string | null;
    /** Menu description. */
    description?: string | null;
    /** URL of the menu's image file. */
    imageUrl?: string | null;
    /**
     * Visibility criteria that must be met for the menu to appear in the live site.
     * In case of multiple visibility criteria, every criterion must be fulfilled.
     */
    visibilityCriteria?: VisibilityCriteria;
    /** IDs of the sections that are included in the menu. */
    sectionIds?: MenuSectionIds;
    /**
     * Whether the menu is archived. Defaults to `false`. **Note:** Archived menus can't be updated.
     * @readonly
     */
    archived?: boolean | null;
}
interface MenuSectionIds {
    values?: string[];
}
interface BulkCreateMenusResponse {
    /** Information about the created menus. */
    results?: BulkMenuResult[];
    /** Bulk Create Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkMenuResult {
    /** Menu metadata. */
    entityMetadata?: ItemMetadata;
    /** Menu. */
    entity?: Menu;
}
interface BulkUpdateMenusRequest {
    /** ID of the catalog the menus belong to. */
    catalogId: string;
    /**
     * Menus to update.
     * @minSize 1
     * @maxSize 20
     */
    menus?: Menu[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkUpdateMenusResponse {
    /** Information about the updated menus. */
    results?: BulkMenuResult[];
    /** Bulk Update Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCreateSectionsRequest {
    /** ID of the catalog the sections will belong to. */
    catalogId: string;
    /**
     * Information about the sections to create. Limited to 20 sections.
     * @minSize 1
     * @maxSize 20
     */
    createSectionRequests?: CreateSectionRequest[];
    /** Whether the full section entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Collection of dishes that customers can buy in the restaurant.
 * You can read more about sections in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Section {
    /**
     * Section ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * ID of the menu the section belongs to.
     * @readonly
     */
    menuId?: string | null;
    /** Section name. */
    name?: string | null;
    /** Section description. */
    description?: string | null;
    /** URL of the section's image file. */
    imageUrl?: string | null;
    /** IDs of the items that belong to the section. */
    itemIds?: SectionItemIds;
    /**
     * Visibility criteria that must be met for the section to appear in the live site.
     * In case of multiple visibility criteria, every criterion must be fulfilled.
     */
    visibilityCriteria?: VisibilityCriteria;
    /**
     * Whether the section is archived. Defaults to `false`. **Note:** Archived sections can't be updated.
     * @readonly
     */
    archived?: boolean | null;
}
/** Item IDs of the dishes that belong to this section. */
interface SectionItemIds {
    values?: string[];
}
interface CreateSectionRequest {
    /** ID of the menu the section will belong to. */
    menuId?: string;
    /** Section to create. */
    section?: Section;
}
interface BulkCreateSectionsResponse {
    /** Information about the created sections. */
    results?: BulkSectionResult[];
    /** Bulk Create Sections metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkSectionResult {
    /** Section metadata. */
    entityMetadata?: ItemMetadata;
    /** Section. */
    entity?: Section;
}
interface BulkUpdateSectionsRequest {
    /** ID of the catalog the sections belong to. */
    catalogId: string;
    /**
     * Information about the sections to update. Limited to 20 sections.
     * @minSize 1
     * @maxSize 20
     */
    updateSectionsRequests?: UpdateSectionRequest[];
    /** Whether the full section entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface UpdateSectionRequest {
    /** ID of the menu the section will belong to. */
    menuId?: string;
    /** Section to update. */
    section?: Section;
}
interface BulkUpdateSectionsResponse {
    /** Information about the updated sections. */
    results?: BulkSectionResult[];
    /** Bulk Update Sections metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkArchiveMenusRequest {
    /** ID of the catalog the menus belong to. */
    catalogId: string;
    /**
     * IDs of the menus to archive.
     * @minSize 1
     * @maxSize 20
     */
    ids?: string[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkArchiveMenusResponse {
    /** Information about the archived menus. */
    results?: BulkMenuResult[];
    /** Bulk Archive Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkUnarchiveMenusRequest {
    /** ID of the catalog the menus belong to. */
    catalogId: string;
    /**
     * IDs of the menus to unarchive.
     * @minSize 1
     * @maxSize 20
     */
    ids?: string[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkUnarchiveMenusResponse {
    /** Information about the unarchived menus. */
    results?: BulkMenuResult[];
    /** Bulk Unarchive Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
    /**
     * tell us why you're invalidating the cache. You don't need to add your app name
     * @maxLength 256
     */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
}
interface App {
    /**
     * The AppDefId
     * @minLength 1
     */
    appDefId?: string;
    /**
     * The instance Id
     * @format GUID
     */
    instanceId?: string;
}
interface Page {
    /**
     * the msid the page is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Page ID
     * @minLength 1
     */
    pageId?: string;
}
interface URI {
    /**
     * the msid the URI is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes
     * @minLength 1
     */
    uriPath?: string;
}
interface File {
    /**
     * the msid the file is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by filename (for media files such as PDFs)
     * @minLength 1
     * @maxLength 256
     */
    fileName?: string;
}
interface CustomTag {
    /**
     * the msid the tag is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Tag to invalidate by
     * @minLength 1
     * @maxLength 256
     */
    tag?: string;
}
interface CatalogUpdated {
    /** @format GUID */
    metaSiteId?: string;
    /** @format GUID */
    locationId?: string | null;
    /** @format GUID */
    catalogId?: string | null;
    archived?: boolean;
    catalogItems?: Item[];
    catalogSections?: Section[];
    catalogMenus?: Menu[];
    catalogDiscounts?: Discount[];
}
/**
 * Customers can use a discount to pay less. Can be an amount or a percentage.
 * You can read more about discounts in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Discount extends DiscountValueOneOf, DiscountApplyToFilterOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
    /**
     * Discount ID.
     * @readonly
     */
    _id?: string | null;
    /** Discount name. */
    name?: string | null;
    /** Discount description. */
    description?: string | null;
    /** Whether the discount is active. Defaults to `true`. */
    active?: boolean | null;
    /** Discount type. */
    type?: DiscountTypeWithLiterals;
    /**
     * Discount condition.
     * All conditions must be met so that a customer can apply the discount.
     */
    condition?: DiscountCondition;
}
/** @oneof */
interface DiscountValueOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
}
/** @oneof */
interface DiscountApplyToFilterOneOf {
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
}
declare enum DiscountType {
    UNSPECIFIED_TYPE = "UNSPECIFIED_TYPE",
    OFF_ITEM = "OFF_ITEM",
    OFF_ORDER = "OFF_ORDER"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNSPECIFIED_TYPE' | 'OFF_ITEM' | 'OFF_ORDER';
interface SectionIds {
    values?: string[];
}
interface ItemIds {
    values?: string[];
}
interface DiscountCondition {
    /**
     * Which fulfillment types the discount applies to.
     * @minSize 1
     * @maxSize 2
     */
    fulfillmentTypes?: FulfillmentTypeWithLiterals[];
    /**
     * Which ordering platforms the discount applies to.
     * @minSize 1
     * @maxSize 3
     */
    platforms?: DiscountPlatformWithLiterals[];
    /** List of times when the discount is available. */
    availability?: Availability;
    /** Minimum order price for the discount. */
    minOrderPrice?: Money;
    /**
     * Coupon associated with the discount.
     * @readonly
     */
    coupon?: Coupon;
}
declare enum DiscountPlatform {
    UNSPECIFIED_PLATFORM = "UNSPECIFIED_PLATFORM",
    SITE = "SITE",
    MOBILE_SITE = "MOBILE_SITE",
    CALL_CENTER = "CALL_CENTER"
}
/** @enumType */
type DiscountPlatformWithLiterals = DiscountPlatform | 'UNSPECIFIED_PLATFORM' | 'SITE' | 'MOBILE_SITE' | 'CALL_CENTER';
interface Coupon {
    /**
     * Whether the customer needs to enter the coupon code to receive the discount. Defaults to `true`.
     * @readonly
     */
    applied?: boolean | null;
    /**
     * Coupon code.
     * @readonly
     */
    code?: string | null;
}
interface PublishCatalogUpdated {
    /** @format GUID */
    metaSiteId?: string;
    /** @format GUID */
    locationId?: string | null;
    /** @format GUID */
    catalogId?: string | null;
    archived?: boolean;
}
interface IndexCacheCmd {
    /** @format GUID */
    catalogId?: string;
    orgId?: string;
    orgLocale?: string;
    /** @format GUID */
    metaSiteId?: string | null;
}
interface CatalogChanged {
    /** Changed Catalog. */
    catalog?: Catalog;
}
interface ListCatalogsRequest {
    /** Sort order. Defaults to `ASC`. */
    sort?: Sorting;
    /** Paging information. `offset` defaults to `0` and `limit` defaults to `50`. The maximum for limit is `1,000`. */
    paging?: Paging;
    /** Whether archived catalogs are returned. Defaults to `false`. */
    archived?: boolean;
    /**
     * IDs of the locations for which the catalog will be returned. See the [Locations API](https://dev.wix.com/api/rest/business-info/locations/introduction) for more details.
     * @format GUID
     */
    locationIds?: string[];
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface ListCatalogsResponse {
    /** Retrieved catalogs. */
    catalogs?: Catalog[];
}
interface GetMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
interface GetMenuResponse {
    /** Retrieved menu. */
    menu?: Menu;
}
interface GetSectionRequest {
    /**
     * ID of the catalog the section belongs to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the catalog belongs to. */
    menuId: string;
    /** Section ID. */
    sectionId: string;
}
interface GetSectionResponse {
    /** Retrieved section. */
    section?: Section;
}
interface UpdateMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu to update. */
    menu?: Menu;
}
interface UpdateMenuResponse {
    /** Updated Menu. */
    menu?: Menu;
}
interface V3UpdateSectionRequest {
    /**
     * ID of the catalog the section belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
    /** Section to update. */
    section?: Section;
}
interface UpdateSectionResponse {
    /** Updated section. */
    section?: Section;
}
interface ListMenusRequest {
    /**
     * ID of the catalog the menus belong to.
     * @format GUID
     */
    catalogId: string;
    /** Field mask path. */
    fieldMask?: string[];
    /** Whether archived menus are returned. Defaults to `false`. */
    archived?: boolean;
}
interface ListMenusResponse {
    /** Retrieved menus. */
    menus?: Menu[];
}
interface ListSectionsRequest {
    /**
     * ID of the catalog the sections belong to.
     * @format GUID
     */
    catalogId: string;
    /** Field mask path. */
    fieldMask?: string[];
    /** Whether archived sections are returned. Defaults to `false`. */
    archived?: boolean;
}
interface ListSectionsResponse {
    /** Sections list. */
    sections?: Section[];
}
interface CreateMenuRequest {
    /**
     * ID of the catalog the menu will belong to.
     * @format GUID
     */
    catalogId: string;
    /** Menu to create. */
    menu: Menu;
}
interface CreateMenuResponse {
    /** Created Menu. */
    menu?: Menu;
}
interface ArchiveMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
interface ArchiveMenuResponse {
    /** Archived menu. */
    menu?: Menu;
}
interface UnarchiveMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
interface UnarchiveMenuResponse {
    /** Unarchived menu. */
    menu?: Menu;
}
interface ArchiveSectionRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId?: string;
    /** Menu ID. */
    menuId?: string;
    /** Section ID. */
    sectionId?: string;
}
interface ArchiveSectionResponse {
    /** Archived section. */
    section?: Section;
}
interface RemoveDishFromSectionRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId?: string;
    /** Menu ID. */
    menuId?: string;
    /** Section ID. */
    sectionId?: string;
    /** Item ID. */
    itemId?: string;
}
interface RemoveDishFromSectionResponse {
}
interface V3CreateSectionRequest {
    /**
     * ID of the catalog the section will belong to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the section will belong to. */
    menuId: string;
    /** Section to create. */
    section: Section;
}
interface CreateSectionResponse {
    /** Created section. */
    section?: Section;
}
interface GetItemRequest {
    /**
     * ID of the catalog the item belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Item ID. */
    itemId: string;
    /** Whether `visibilityCriteria` is returned. Defaults to `false`. */
    includeVisibilityCriteria?: boolean;
}
interface GetItemResponse {
    /** Retrieved item. */
    item?: Item;
}
interface ListItemsRequest {
    /** Field mask path. */
    fieldMask?: string[];
    /**
     * ID of the catalog the items belong to.
     * @format GUID
     */
    catalogId: string;
    /** Whether archived items are returned. Defaults to `false`. */
    archived?: boolean;
}
interface ListItemsResponse {
    /** Retrieved items. */
    items?: Item[];
}
interface UpdateItemRequest {
    /**
     * ID of the catalog the item belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Item to update. */
    item?: Item;
}
interface UpdateItemResponse {
    /** Updated Item. */
    item?: Item;
}
interface V3CreateDishRequest {
    /**
     * ID of the catalog the dish will belong to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the dish will belong to. */
    menuId: string;
    /** ID of the section the dish will belong to. */
    sectionId: string;
    /** Item of type `dish` to create. */
    dish: Item;
}
interface CreateDishResponse {
    /** Created Dish. */
    dish?: Item;
}
interface CreateVariationRequest {
    /**
     * ID of the catalog the variation will belong to.
     * @format GUID
     */
    catalogId: string;
    /** Variation name. */
    name: string;
}
interface CreateVariationResponse {
    /** Created Variation. */
    variation?: Item;
}
interface MenuUpdated {
    /** @format GUID */
    metaSiteId?: string;
    organizationId?: string;
    /** @format GUID */
    locationId?: string | null;
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface CatalogChangedEnvelope {
    data: CatalogChanged;
    metadata: EventMetadata;
}
/**
 * Triggered when a catalog is changed.
 *
 * > __Note:__ The webhook doesn't return information about what has changed. In order to update an external POS upon changes to a Wix Restaurants catalog you may need to create your own logic to identify the changes.
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Restaurant Catalogs
 * @permissionScopeId SCOPE.DC-RESTAURANTS.MANAGE-CATALOGS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope View SEO Settings
 * @permissionScopeId SCOPE.PROMOTE.VIEW-SEO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @permissionScope Read Restaurant Catalogs
 * @permissionScopeId SCOPE.DC-RESTAURANTS.READ-CATALOGS
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @webhook
 * @eventType wix.restaurants.catalogs.v3.catalog_catalog_changed
 * @serviceIdentifier com.wixpress.restaurants.catalogs.v3.CatalogsApi
 * @slug catalog_changed
 * @documentationMaturity preview
 * @deprecated
 * @replacedBy wix.restaurants.menus.v1.menu_updated
 * @targetRemovalDate 2025-09-30
 */
declare function onCatalogChanged(handler: (event: CatalogChangedEnvelope) => void | Promise<void>): void;
interface CatalogCreatedEnvelope {
    entity: Catalog;
    metadata: EventMetadata;
}
/**
 * Triggered when a catalog is created.
 *
 * > __Note:__ The webhook doesn't return information about the entities belonging to the catalog. You may need to create your own logic to retrieve the catalog's content.
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Restaurant Catalogs
 * @permissionScopeId SCOPE.DC-RESTAURANTS.MANAGE-CATALOGS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope View SEO Settings
 * @permissionScopeId SCOPE.PROMOTE.VIEW-SEO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @permissionScope Read Restaurant Catalogs
 * @permissionScopeId SCOPE.DC-RESTAURANTS.READ-CATALOGS
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @webhook
 * @eventType wix.restaurants.catalogs.v3.catalog_created
 * @serviceIdentifier com.wixpress.restaurants.catalogs.v3.CatalogsApi
 * @slug created
 * @documentationMaturity preview
 * @deprecated
 * @replacedBy wix.restaurants.menus.v1.menu_created
 * @targetRemovalDate 2025-09-30
 */
declare function onCatalogCreated(handler: (event: CatalogCreatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a draft version of the specified catalog.
 * Then you can update and publish the draft catalog by using the endpoints in the [Draft Catalogs category](https://dev.wix.com/api/rest/wix-restaurants/catalogs/draft-catalogs).
 *
 * > **Note:** You can't create more than one draft catalog per location.
 * @param catalogId - ID of the catalog to create a draft version for.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.CreateDraftCatalog
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function createDraftCatalog(catalogId: string): Promise<NonNullablePaths<CreateDraftCatalogResponse, `catalog.archived`, 3>>;
/**
 * Publishes a draft catalog to the live site by replacing the existing catalog.
 * @param catalogId - ID of the draft catalog to publish.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.PublishDraftCatalog
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function publishDraftCatalog(catalogId: string): Promise<NonNullablePaths<PublishDraftCatalogResponse, `catalog.archived`, 3>>;
/**
 * Discards a draft catalog. If you want to continue using [Bulk endpoints](https://dev.wix.com/api/rest/wix-restaurants/catalogs/draft-catalogs) for this catalog, you must first call the [Create Draft Catalog](https://dev.wix.com/api/rest/wix-restaurants/catalogs/draft-catalogs/create-draft-catalog) endpoint again.
 * @param catalogId - ID of the draft catalog to discard.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.DiscardDraftCatalog
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function discardDraftCatalog(catalogId: string): Promise<void>;
/**
 * Adds multiple variations to a draft catalog.
 * @param catalogId - ID of the catalog the variations will belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkCreateVariations
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkCreateVariations(catalogId: string, options?: BulkCreateVariationsOptions): Promise<NonNullablePaths<BulkCreateVariationsResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `results.${number}.entity.price.value` | `results.${number}.entity.price.currency` | `results.${number}.entity.type` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkCreateVariationsOptions {
    /**
     * Variations to create. Limited to 20 variations.
     * @minSize 1
     * @maxSize 20
     */
    variations?: NewVariation[];
    /** Whether the full variation entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Updates multiple items in a draft catalog.
 * You can't update archived items.
 * @param catalogId - ID of the catalog the items belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkUpdateItems
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkUpdateItems(catalogId: string, options?: BulkUpdateItemsOptions): Promise<NonNullablePaths<BulkUpdateItemsResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `results.${number}.entity.price.value` | `results.${number}.entity.price.currency` | `results.${number}.entity.type` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUpdateItemsOptions {
    /**
     * Items to update. Limited to 20 items.
     * @minSize 1
     * @maxSize 20
     */
    items?: Item[];
    /** Whether the full item entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Adds multiple dishes to a draft catalog.
 * @param catalogId - ID of the catalog the dishes will belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkCreateDishes
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkCreateDishes(catalogId: string, options?: BulkCreateDishesOptions): Promise<NonNullablePaths<BulkCreateDishesResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `results.${number}.entity.price.value` | `results.${number}.entity.price.currency` | `results.${number}.entity.type` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkCreateDishesOptions {
    /**
     * Information about the dishes to create. Limited to 20 dishes.
     * @minSize 1
     * @maxSize 20
     */
    createDishRequests?: CreateDishRequest[];
    /** Whether the full item entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Adds multiple menus to a draft catalog.
 * @param catalogId - ID of the catalog the menus will belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkCreateMenus
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkCreateMenus(catalogId: string, options?: BulkCreateMenusOptions): Promise<NonNullablePaths<BulkCreateMenusResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkCreateMenusOptions {
    /**
     * Information about the menus to create. Limited to 20 menus.
     * @minSize 1
     * @maxSize 20
     */
    menus?: Menu[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Updates multiple menus in a draft catalog.
 * You can't update archived menus.
 * @param catalogId - ID of the catalog the menus belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkUpdateMenus
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkUpdateMenus(catalogId: string, options?: BulkUpdateMenusOptions): Promise<NonNullablePaths<BulkUpdateMenusResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUpdateMenusOptions {
    /**
     * Menus to update.
     * @minSize 1
     * @maxSize 20
     */
    menus?: Menu[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Adds multiple sections to a draft catalog.
 * @param catalogId - ID of the catalog the sections will belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkCreateSections
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkCreateSections(catalogId: string, options?: BulkCreateSectionsOptions): Promise<NonNullablePaths<BulkCreateSectionsResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkCreateSectionsOptions {
    /**
     * Information about the sections to create. Limited to 20 sections.
     * @minSize 1
     * @maxSize 20
     */
    createSectionRequests?: CreateSectionRequest[];
    /** Whether the full section entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Updates multiple sections in a draft catalog.
 * You can't update archived sections.
 * @param catalogId - ID of the catalog the sections belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkUpdateSections
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkUpdateSections(catalogId: string, options?: BulkUpdateSectionsOptions): Promise<NonNullablePaths<BulkUpdateSectionsResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUpdateSectionsOptions {
    /**
     * Information about the sections to update. Limited to 20 sections.
     * @minSize 1
     * @maxSize 20
     */
    updateSectionsRequests?: UpdateSectionRequest[];
    /** Whether the full section entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Changes the `archived` boolean to `true` for multiple menus in a draft catalog.
 * @param catalogId - ID of the catalog the menus belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkArchiveMenus
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkArchiveMenus(catalogId: string, options?: BulkArchiveMenusOptions): Promise<NonNullablePaths<BulkArchiveMenusResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkArchiveMenusOptions {
    /**
     * IDs of the menus to archive.
     * @minSize 1
     * @maxSize 20
     */
    ids?: string[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Changes the `archived` boolean to `false` for multiple menus in a draft catalog.
 * @param catalogId - ID of the catalog the menus belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.DraftCatalogsApi.BulkUnarchiveMenus
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function bulkUnarchiveMenus(catalogId: string, options?: BulkUnarchiveMenusOptions): Promise<NonNullablePaths<BulkUnarchiveMenusResponse, `results` | `results.${number}.entityMetadata.originalIndex` | `results.${number}.entityMetadata.success` | `results.${number}.entityMetadata.error.code` | `results.${number}.entityMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
interface BulkUnarchiveMenusOptions {
    /**
     * IDs of the menus to unarchive.
     * @minSize 1
     * @maxSize 20
     */
    ids?: string[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Retrieves catalogs, given the provided filtering, sorting and paging.
 * Note that there is a single catalog per location.
 * @public
 * @documentationMaturity preview
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.ListCatalogs
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_menu.v1.RestaurantsMenusMenu.ListMenus
 * @targetRemovalDate 2025-09-30
 */
declare function listCatalogs(options?: ListCatalogsOptions): Promise<NonNullablePaths<ListCatalogsResponse, `catalogs` | `catalogs.${number}.archived`, 4>>;
interface ListCatalogsOptions {
    /** Sort order. Defaults to `ASC`. */
    sort?: Sorting;
    /** Paging information. `offset` defaults to `0` and `limit` defaults to `50`. The maximum for limit is `1,000`. */
    paging?: Paging;
    /** Whether archived catalogs are returned. Defaults to `false`. */
    archived?: boolean;
    /**
     * IDs of the locations for which the catalog will be returned. See the [Locations API](https://dev.wix.com/api/rest/business-info/locations/introduction) for more details.
     * @format GUID
     */
    locationIds?: string[];
}
/**
 * Retrieves a menu.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.GetMenu
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_menu.v1.RestaurantsMenusMenu.GetMenu
 * @targetRemovalDate 2025-09-30
 */
declare function getMenu(identifiers: NonNullablePaths<GetMenuIdentifiers, `catalogId` | `menuId`, 2>): Promise<NonNullablePaths<GetMenuResponse, `menu.visibilityCriteria.fulfillmentTypes` | `menu.visibilityCriteria.platforms` | `menu.visibilityCriteria.availability.periods` | `menu.visibilityCriteria.availability.periods.${number}.openDay` | `menu.visibilityCriteria.availability.periods.${number}.openTime` | `menu.visibilityCriteria.availability.periods.${number}.closeDay` | `menu.visibilityCriteria.availability.periods.${number}.closeTime` | `menu.visibilityCriteria.availability.specialHourPeriods` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `menu.sectionIds.values`, 7>>;
interface GetMenuIdentifiers {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
/**
 * Retrieves a section.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @requiredField identifiers.sectionId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.GetSection
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_section.v1.RestaurantsMenusSection.GetSection
 * @targetRemovalDate 2025-09-30
 */
declare function getSection(identifiers: NonNullablePaths<GetSectionIdentifiers, `catalogId` | `menuId` | `sectionId`, 2>): Promise<NonNullablePaths<GetSectionResponse, `section.itemIds.values` | `section.visibilityCriteria.fulfillmentTypes` | `section.visibilityCriteria.platforms` | `section.visibilityCriteria.availability.periods` | `section.visibilityCriteria.availability.periods.${number}.openDay` | `section.visibilityCriteria.availability.periods.${number}.openTime` | `section.visibilityCriteria.availability.periods.${number}.closeDay` | `section.visibilityCriteria.availability.periods.${number}.closeTime` | `section.visibilityCriteria.availability.specialHourPeriods` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.available`, 7>>;
interface GetSectionIdentifiers {
    /**
     * ID of the catalog the section belongs to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the catalog belongs to. */
    menuId: string;
    /** Section ID. */
    sectionId: string;
}
/**
 * Updates a menu.
 * You can't update archived menus.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.UpdateMenu
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_section.v1.RestaurantsMenusSection.GetSection
 * @targetRemovalDate 2025-09-30
 */
declare function updateMenu(identifiers: NonNullablePaths<UpdateMenuIdentifiers, `catalogId` | `menuId`, 2>, options?: UpdateMenuOptions): Promise<NonNullablePaths<UpdateMenuResponse, `menu.visibilityCriteria.fulfillmentTypes` | `menu.visibilityCriteria.platforms` | `menu.visibilityCriteria.availability.periods` | `menu.visibilityCriteria.availability.periods.${number}.openDay` | `menu.visibilityCriteria.availability.periods.${number}.openTime` | `menu.visibilityCriteria.availability.periods.${number}.closeDay` | `menu.visibilityCriteria.availability.periods.${number}.closeTime` | `menu.visibilityCriteria.availability.specialHourPeriods` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `menu.sectionIds.values`, 7>>;
interface UpdateMenuIdentifiers {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /**
     * Menu ID.
     * @readonly
     */
    menuId?: string | null;
}
interface UpdateMenuOptions {
    menu: {
        /**
         * Menu ID.
         * @readonly
         */
        _id?: string | null;
        /** Menu name. */
        name?: string | null;
        /** Menu description. */
        description?: string | null;
        /** URL of the menu's image file. */
        imageUrl?: string | null;
        /**
         * Visibility criteria that must be met for the menu to appear in the live site.
         * In case of multiple visibility criteria, every criterion must be fulfilled.
         */
        visibilityCriteria?: VisibilityCriteria;
        /** IDs of the sections that are included in the menu. */
        sectionIds?: MenuSectionIds;
        /**
         * Whether the menu is archived. Defaults to `false`. **Note:** Archived menus can't be updated.
         * @readonly
         */
        archived?: boolean | null;
    };
}
/**
 * Updates a section.
 * You can't update archived sections. Note that every section belongs to a single menu, you can't add it to another menu.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @requiredField identifiers.sectionId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.UpdateSection
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_section.v1.RestaurantsMenusSection.UpdateSection
 * @targetRemovalDate 2025-09-30
 */
declare function updateSection(identifiers: NonNullablePaths<UpdateSectionIdentifiers, `catalogId` | `menuId` | `sectionId`, 2>, options?: UpdateSectionOptions): Promise<NonNullablePaths<UpdateSectionResponse, `section.itemIds.values` | `section.visibilityCriteria.fulfillmentTypes` | `section.visibilityCriteria.platforms` | `section.visibilityCriteria.availability.periods` | `section.visibilityCriteria.availability.periods.${number}.openDay` | `section.visibilityCriteria.availability.periods.${number}.openTime` | `section.visibilityCriteria.availability.periods.${number}.closeDay` | `section.visibilityCriteria.availability.periods.${number}.closeTime` | `section.visibilityCriteria.availability.specialHourPeriods` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.available`, 7>>;
interface UpdateSectionIdentifiers {
    /**
     * ID of the catalog the section belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
    /**
     * Section ID.
     * @readonly
     */
    sectionId?: string | null;
}
interface UpdateSectionOptions {
    section: {
        /**
         * Section ID.
         * @readonly
         */
        _id?: string | null;
        /**
         * ID of the menu the section belongs to.
         * @readonly
         */
        menuId?: string | null;
        /** Section name. */
        name?: string | null;
        /** Section description. */
        description?: string | null;
        /** URL of the section's image file. */
        imageUrl?: string | null;
        /** IDs of the items that belong to the section. */
        itemIds?: SectionItemIds;
        /**
         * Visibility criteria that must be met for the section to appear in the live site.
         * In case of multiple visibility criteria, every criterion must be fulfilled.
         */
        visibilityCriteria?: VisibilityCriteria;
        /**
         * Whether the section is archived. Defaults to `false`. **Note:** Archived sections can't be updated.
         * @readonly
         */
        archived?: boolean | null;
    };
}
/**
 * Retrieves menus, given the provided filtering, sorting and paging.
 * @param catalogId - ID of the catalog the menus belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.ListMenus
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_menu.v1.RestaurantsMenusMenu.ListMenus
 * @targetRemovalDate 2025-09-30
 */
declare function listMenus(catalogId: string, options?: ListMenusOptions): Promise<NonNullablePaths<ListMenusResponse, `menus`, 2>>;
interface ListMenusOptions {
    /** Field mask path. */
    fieldMask?: string[];
    /** Whether archived menus are returned. Defaults to `false`. */
    archived?: boolean;
}
/**
 * Retrieves sections, given the provided filtering, sorting and paging.
 * @param catalogId - ID of the catalog the sections belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.ListSections
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_section.v1.RestaurantsMenusSection.ListSections
 * @targetRemovalDate 2025-09-30
 */
declare function listSections(catalogId: string, options?: ListSectionsOptions): Promise<NonNullablePaths<ListSectionsResponse, `sections`, 2>>;
interface ListSectionsOptions {
    /** Field mask path. */
    fieldMask?: string[];
    /** Whether archived sections are returned. Defaults to `false`. */
    archived?: boolean;
}
/**
 * Creates a menu.
 * @param catalogId - ID of the catalog the menu will belong to.
 * @param menu - Menu to create.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @requiredField menu
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.CreateMenu
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_menu.v1.RestaurantsMenusMenu.CreateMenu
 * @targetRemovalDate 2025-09-30
 */
declare function createMenu(catalogId: string, menu: Menu): Promise<NonNullablePaths<CreateMenuResponse, `menu.visibilityCriteria.fulfillmentTypes` | `menu.visibilityCriteria.platforms` | `menu.visibilityCriteria.availability.periods` | `menu.visibilityCriteria.availability.periods.${number}.openDay` | `menu.visibilityCriteria.availability.periods.${number}.openTime` | `menu.visibilityCriteria.availability.periods.${number}.closeDay` | `menu.visibilityCriteria.availability.periods.${number}.closeTime` | `menu.visibilityCriteria.availability.specialHourPeriods` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `menu.sectionIds.values`, 7>>;
/**
 * Archives a menu. You can't update archived menus.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.ArchiveMenu
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function archiveMenu(identifiers: NonNullablePaths<ArchiveMenuIdentifiers, `catalogId` | `menuId`, 2>): Promise<NonNullablePaths<ArchiveMenuResponse, `menu.visibilityCriteria.fulfillmentTypes` | `menu.visibilityCriteria.platforms` | `menu.visibilityCriteria.availability.periods` | `menu.visibilityCriteria.availability.periods.${number}.openDay` | `menu.visibilityCriteria.availability.periods.${number}.openTime` | `menu.visibilityCriteria.availability.periods.${number}.closeDay` | `menu.visibilityCriteria.availability.periods.${number}.closeTime` | `menu.visibilityCriteria.availability.specialHourPeriods` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `menu.sectionIds.values`, 7>>;
interface ArchiveMenuIdentifiers {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
/**
 * Unarchives a menu.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.UnarchiveMenu
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function unarchiveMenu(identifiers: NonNullablePaths<UnarchiveMenuIdentifiers, `catalogId` | `menuId`, 2>): Promise<NonNullablePaths<UnarchiveMenuResponse, `menu.visibilityCriteria.fulfillmentTypes` | `menu.visibilityCriteria.platforms` | `menu.visibilityCriteria.availability.periods` | `menu.visibilityCriteria.availability.periods.${number}.openDay` | `menu.visibilityCriteria.availability.periods.${number}.openTime` | `menu.visibilityCriteria.availability.periods.${number}.closeDay` | `menu.visibilityCriteria.availability.periods.${number}.closeTime` | `menu.visibilityCriteria.availability.specialHourPeriods` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `menu.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `menu.sectionIds.values`, 7>>;
interface UnarchiveMenuIdentifiers {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
/**
 * Creates a section.
 * You can't add the section to multiple menus, since every section belongs to a single menu.
 * @param section - Section to create.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @requiredField section
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.CreateSection
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_section.v1.RestaurantsMenusSection.CreateSection
 * @targetRemovalDate 2025-09-30
 */
declare function createSection(identifiers: NonNullablePaths<CreateSectionIdentifiers, `catalogId` | `menuId`, 2>, section: Section): Promise<NonNullablePaths<CreateSectionResponse, `section.itemIds.values` | `section.visibilityCriteria.fulfillmentTypes` | `section.visibilityCriteria.platforms` | `section.visibilityCriteria.availability.periods` | `section.visibilityCriteria.availability.periods.${number}.openDay` | `section.visibilityCriteria.availability.periods.${number}.openTime` | `section.visibilityCriteria.availability.periods.${number}.closeDay` | `section.visibilityCriteria.availability.periods.${number}.closeTime` | `section.visibilityCriteria.availability.specialHourPeriods` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `section.visibilityCriteria.availability.specialHourPeriods.${number}.available`, 7>>;
interface CreateSectionIdentifiers {
    /**
     * ID of the catalog the section will belong to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the section will belong to. */
    menuId: string;
}
/**
 * Retrieves an item.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.itemId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.GetItem
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.GetItem
 * @targetRemovalDate 2025-09-30
 */
declare function getItem(identifiers: NonNullablePaths<GetItemIdentifiers, `catalogId` | `itemId`, 2>, options?: GetItemOptions): Promise<NonNullablePaths<GetItemResponse, `item.price.value` | `item.price.currency` | `item.labels.values` | `item.visibilityCriteria.fulfillmentTypes` | `item.visibilityCriteria.platforms` | `item.visibilityCriteria.availability.periods` | `item.visibilityCriteria.availability.periods.${number}.openDay` | `item.visibilityCriteria.availability.periods.${number}.openTime` | `item.visibilityCriteria.availability.periods.${number}.closeDay` | `item.visibilityCriteria.availability.periods.${number}.closeTime` | `item.visibilityCriteria.availability.specialHourPeriods` | `item.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `item.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `item.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `item.dishOptions.values` | `item.dishOptions.values.${number}.name` | `item.dishOptions.values.${number}.type` | `item.type`, 7>>;
interface GetItemIdentifiers {
    /**
     * ID of the catalog the item belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Item ID. */
    itemId: string;
}
interface GetItemOptions {
    /** Whether `visibilityCriteria` is returned. Defaults to `false`. */
    includeVisibilityCriteria?: boolean;
}
/**
 * Retrieves items, given the provided filtering, sorting and paging.
 * @param catalogId - ID of the catalog the items belong to.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @permissionId WIX_RESTAURANTS.READ_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.ListItems
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.ListItems
 * @targetRemovalDate 2025-09-30
 */
declare function listItems(catalogId: string, options?: ListItemsOptions): Promise<NonNullablePaths<ListItemsResponse, `items` | `items.${number}.price.value` | `items.${number}.price.currency` | `items.${number}.type`, 5>>;
interface ListItemsOptions {
    /** Field mask path. */
    fieldMask?: string[];
    /** Whether archived items are returned. Defaults to `false`. */
    archived?: boolean;
}
/**
 * Updates an item.
 * You can't update archived items.
 * @public
 * @documentationMaturity preview
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.itemId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.UpdateItem
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.UpdateItem
 * @targetRemovalDate 2025-09-30
 */
declare function updateItem(identifiers: NonNullablePaths<UpdateItemIdentifiers, `catalogId` | `itemId`, 2>, options?: UpdateItemOptions): Promise<NonNullablePaths<UpdateItemResponse, `item.price.value` | `item.price.currency` | `item.labels.values` | `item.visibilityCriteria.fulfillmentTypes` | `item.visibilityCriteria.platforms` | `item.visibilityCriteria.availability.periods` | `item.visibilityCriteria.availability.periods.${number}.openDay` | `item.visibilityCriteria.availability.periods.${number}.openTime` | `item.visibilityCriteria.availability.periods.${number}.closeDay` | `item.visibilityCriteria.availability.periods.${number}.closeTime` | `item.visibilityCriteria.availability.specialHourPeriods` | `item.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `item.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `item.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `item.dishOptions.values` | `item.dishOptions.values.${number}.name` | `item.dishOptions.values.${number}.type` | `item.type`, 7>>;
interface UpdateItemIdentifiers {
    /**
     * ID of the catalog the item belongs to.
     * @format GUID
     */
    catalogId: string;
    /**
     * Item ID.
     * @readonly
     */
    itemId?: string | null;
}
interface UpdateItemOptions {
    item: {
        /**
         * Item ID.
         * @readonly
         */
        _id?: string | null;
        /** Item name. */
        name?: string | null;
        /** Item description. */
        description?: string | null;
        /** Item price. */
        price?: Money;
        /** URL of the item's image file. */
        imageUrl?: string | null;
        /** Item labels. For example spicy, hot, vegan, gluten-free, or organic. */
        labels?: Labels;
        /** Whether the item is in stock. */
        inStock?: boolean | null;
        /**
         * Tax rate of the item in percent.
         * @decimalValue options { maxScale:3 }
         */
        taxRate?: string | null;
        /**
         * Whether the item is archived. Defaults to `false`. **Note:** Archived items can't be updated.
         * @readonly
         */
        archived?: boolean | null;
        /**
         * Visibility criteria that must be met for the item to appear in the live site.
         * In case of multiple visibility criteria, every criterion must be fulfilled.
         */
        visibilityCriteria?: VisibilityCriteria;
        /** Items customers can choose to modify a dish. Can be an extra, selection, or deselection. */
        dishOptions?: DishOptions;
        /** Whether a customer can add a special request when ordering this item. Defaults to `true`. */
        acceptSpecialRequest?: boolean | null;
        /**
         * Item type.
         * @readonly
         */
        type?: ItemTypeWithLiterals;
    };
}
/**
 * Creates a dish.
 * @param dish - Item of type `dish` to create.
 * @public
 * @documentationMaturity preview
 * @requiredField dish
 * @requiredField identifiers
 * @requiredField identifiers.catalogId
 * @requiredField identifiers.menuId
 * @requiredField identifiers.sectionId
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.CreateDish
 * @deprecated
 * @replacedBy com.wixpress.restaurants.menus_item.v1.RestaurantsMenusItem.CreateItem
 * @targetRemovalDate 2025-09-30
 */
declare function createDish(identifiers: NonNullablePaths<CreateDishIdentifiers, `catalogId` | `menuId` | `sectionId`, 2>, dish: Item): Promise<NonNullablePaths<CreateDishResponse, `dish.price.value` | `dish.price.currency` | `dish.labels.values` | `dish.visibilityCriteria.fulfillmentTypes` | `dish.visibilityCriteria.platforms` | `dish.visibilityCriteria.availability.periods` | `dish.visibilityCriteria.availability.periods.${number}.openDay` | `dish.visibilityCriteria.availability.periods.${number}.openTime` | `dish.visibilityCriteria.availability.periods.${number}.closeDay` | `dish.visibilityCriteria.availability.periods.${number}.closeTime` | `dish.visibilityCriteria.availability.specialHourPeriods` | `dish.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `dish.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `dish.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `dish.dishOptions.values` | `dish.dishOptions.values.${number}.name` | `dish.dishOptions.values.${number}.type` | `dish.type`, 7>>;
interface CreateDishIdentifiers {
    /**
     * ID of the catalog the dish will belong to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the dish will belong to. */
    menuId: string;
    /** ID of the section the dish will belong to. */
    sectionId: string;
}
/**
 * Creates a variation.
 * @param catalogId - ID of the catalog the variation will belong to.
 * @param name - Variation name.
 * @public
 * @documentationMaturity preview
 * @requiredField catalogId
 * @requiredField name
 * @permissionId WIX_RESTAURANTS.MANAGE_CATALOGS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.catalogs.v3.CatalogsApi.CreateVariation
 * @deprecated
 * @replacedBy wix.restaurants.menus_item_variant.v1.VariantsService.CreateVariant
 * @targetRemovalDate 2025-09-30
 */
declare function createVariation(catalogId: string, name: string): Promise<NonNullablePaths<CreateVariationResponse, `variation.price.value` | `variation.price.currency` | `variation.labels.values` | `variation.visibilityCriteria.fulfillmentTypes` | `variation.visibilityCriteria.platforms` | `variation.visibilityCriteria.availability.periods` | `variation.visibilityCriteria.availability.periods.${number}.openDay` | `variation.visibilityCriteria.availability.periods.${number}.openTime` | `variation.visibilityCriteria.availability.periods.${number}.closeDay` | `variation.visibilityCriteria.availability.periods.${number}.closeTime` | `variation.visibilityCriteria.availability.specialHourPeriods` | `variation.visibilityCriteria.availability.specialHourPeriods.${number}.startDate` | `variation.visibilityCriteria.availability.specialHourPeriods.${number}.endDate` | `variation.visibilityCriteria.availability.specialHourPeriods.${number}.available` | `variation.dishOptions.values` | `variation.dishOptions.values.${number}.name` | `variation.dishOptions.values.${number}.type` | `variation.type`, 7>>;

export { type ActionEvent, type App, type ApplicationError, type ArchiveMenuIdentifiers, type ArchiveMenuRequest, type ArchiveMenuResponse, type ArchiveSectionRequest, type ArchiveSectionResponse, type Availability, type BaseEventMetadata, type BulkActionMetadata, type BulkArchiveMenusOptions, type BulkArchiveMenusRequest, type BulkArchiveMenusResponse, type BulkCreateDishesOptions, type BulkCreateDishesRequest, type BulkCreateDishesResponse, type BulkCreateMenusOptions, type BulkCreateMenusRequest, type BulkCreateMenusResponse, type BulkCreateSectionsOptions, type BulkCreateSectionsRequest, type BulkCreateSectionsResponse, type BulkCreateVariationsOptions, type BulkCreateVariationsRequest, type BulkCreateVariationsResponse, type BulkItemResult, type BulkMenuResult, type BulkSectionResult, type BulkUnarchiveMenusOptions, type BulkUnarchiveMenusRequest, type BulkUnarchiveMenusResponse, type BulkUpdateItemsOptions, type BulkUpdateItemsRequest, type BulkUpdateItemsResponse, type BulkUpdateMenusOptions, type BulkUpdateMenusRequest, type BulkUpdateMenusResponse, type BulkUpdateSectionsOptions, type BulkUpdateSectionsRequest, type BulkUpdateSectionsResponse, type Catalog, type CatalogChanged, type CatalogChangedEnvelope, type CatalogCreatedEnvelope, type CatalogUpdated, type Coupon, type CreateDishIdentifiers, type CreateDishRequest, type CreateDishResponse, type CreateDraftCatalogRequest, type CreateDraftCatalogResponse, type CreateMenuRequest, type CreateMenuResponse, type CreateSectionIdentifiers, type CreateSectionRequest, type CreateSectionResponse, type CreateVariationRequest, type CreateVariationResponse, type CustomTag, DayOfWeek, type DayOfWeekWithLiterals, type Deselection, type DiscardDraftCatalogRequest, type DiscardDraftCatalogResponse, type Discount, type DiscountApplyToFilterOneOf, type DiscountCondition, DiscountPlatform, type DiscountPlatformWithLiterals, DiscountType, type DiscountTypeWithLiterals, type DiscountValueOneOf, type DishOption, type DishOptionItem, type DishOptionMethodOneOf, type DishOptions, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type Extras, type File, FulfillmentType, type FulfillmentTypeWithLiterals, type GetItemIdentifiers, type GetItemOptions, type GetItemRequest, type GetItemResponse, type GetMenuIdentifiers, type GetMenuRequest, type GetMenuResponse, type GetSectionIdentifiers, type GetSectionRequest, type GetSectionResponse, type IdentificationData, type IdentificationDataIdOneOf, type IndexCacheCmd, type InvalidateCache, type InvalidateCacheGetByOneOf, type Item, type ItemIds, type ItemMetadata, ItemType, type ItemTypeWithLiterals, type Labels, type ListCatalogsOptions, type ListCatalogsRequest, type ListCatalogsResponse, type ListItemsOptions, type ListItemsRequest, type ListItemsResponse, type ListMenusOptions, type ListMenusRequest, type ListMenusResponse, type ListSectionsOptions, type ListSectionsRequest, type ListSectionsResponse, type Menu, type MenuSectionIds, type MenuUpdated, type MessageEnvelope, type Money, type NewVariation, type Page, type Paging, Platform, type PlatformWithLiterals, type PublishCatalogUpdated, type PublishDraftCatalogRequest, type PublishDraftCatalogResponse, type RemoveDishFromSectionRequest, type RemoveDishFromSectionResponse, type RestoreInfo, type Section, type SectionIds, type SectionItemIds, type Selection, SortOrder, type SortOrderWithLiterals, type Sorting, type SpecialHourPeriod, type TimePeriod, Type, type TypeWithLiterals, type URI, type UnarchiveMenuIdentifiers, type UnarchiveMenuRequest, type UnarchiveMenuResponse, type UpdateItemIdentifiers, type UpdateItemOptions, type UpdateItemRequest, type UpdateItemResponse, type UpdateMenuIdentifiers, type UpdateMenuOptions, type UpdateMenuRequest, type UpdateMenuResponse, type UpdateSectionIdentifiers, type UpdateSectionOptions, type UpdateSectionRequest, type UpdateSectionResponse, type V3CreateDishRequest, type V3CreateSectionRequest, type V3UpdateSectionRequest, type VisibilityCriteria, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, archiveMenu, bulkArchiveMenus, bulkCreateDishes, bulkCreateMenus, bulkCreateSections, bulkCreateVariations, bulkUnarchiveMenus, bulkUpdateItems, bulkUpdateMenus, bulkUpdateSections, createDish, createDraftCatalog, createMenu, createSection, createVariation, discardDraftCatalog, getItem, getMenu, getSection, listCatalogs, listItems, listMenus, listSections, onCatalogChanged, onCatalogCreated, publishDraftCatalog, unarchiveMenu, updateItem, updateMenu, updateSection };
