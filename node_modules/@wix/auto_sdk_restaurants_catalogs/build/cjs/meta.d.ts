import { CreateDraftCatalogRequest as CreateDraftCatalogRequest$1, CreateDraftCatalogResponse as CreateDraftCatalogResponse$1, PublishDraftCatalogRequest as PublishDraftCatalogRequest$1, PublishDraftCatalogResponse as PublishDraftCatalogResponse$1, DiscardDraftCatalogRequest as DiscardDraftCatalogRequest$1, DiscardDraftCatalogResponse as DiscardDraftCatalogResponse$1, BulkCreateVariationsRequest as BulkCreateVariationsRequest$1, BulkCreateVariationsResponse as BulkCreateVariationsResponse$1, BulkUpdateItemsRequest as BulkUpdateItemsRequest$1, BulkUpdateItemsResponse as BulkUpdateItemsResponse$1, BulkCreateDishesRequest as BulkCreateDishesRequest$1, BulkCreateDishesResponse as BulkCreateDishesResponse$1, BulkCreateMenusRequest as BulkCreateMenusRequest$1, BulkCreateMenusResponse as BulkCreateMenusResponse$1, BulkUpdateMenusRequest as BulkUpdateMenusRequest$1, BulkUpdateMenusResponse as BulkUpdateMenusResponse$1, BulkCreateSectionsRequest as BulkCreateSectionsRequest$1, BulkCreateSectionsResponse as BulkCreateSectionsResponse$1, BulkUpdateSectionsRequest as BulkUpdateSectionsRequest$1, BulkUpdateSectionsResponse as BulkUpdateSectionsResponse$1, BulkArchiveMenusRequest as BulkArchiveMenusRequest$1, BulkArchiveMenusResponse as BulkArchiveMenusResponse$1, BulkUnarchiveMenusRequest as BulkUnarchiveMenusRequest$1, BulkUnarchiveMenusResponse as BulkUnarchiveMenusResponse$1, ListCatalogsRequest as ListCatalogsRequest$1, ListCatalogsResponse as ListCatalogsResponse$1, GetMenuRequest as GetMenuRequest$1, GetMenuResponse as GetMenuResponse$1, GetSectionRequest as GetSectionRequest$1, GetSectionResponse as GetSectionResponse$1, UpdateMenuRequest as UpdateMenuRequest$1, UpdateMenuResponse as UpdateMenuResponse$1, V3UpdateSectionRequest as V3UpdateSectionRequest$1, UpdateSectionResponse as UpdateSectionResponse$1, ListMenusRequest as ListMenusRequest$1, ListMenusResponse as ListMenusResponse$1, ListSectionsRequest as ListSectionsRequest$1, ListSectionsResponse as ListSectionsResponse$1, CreateMenuRequest as CreateMenuRequest$1, CreateMenuResponse as CreateMenuResponse$1, ArchiveMenuRequest as ArchiveMenuRequest$1, ArchiveMenuResponse as ArchiveMenuResponse$1, UnarchiveMenuRequest as UnarchiveMenuRequest$1, UnarchiveMenuResponse as UnarchiveMenuResponse$1, V3CreateSectionRequest as V3CreateSectionRequest$1, CreateSectionResponse as CreateSectionResponse$1, GetItemRequest as GetItemRequest$1, GetItemResponse as GetItemResponse$1, ListItemsRequest as ListItemsRequest$1, ListItemsResponse as ListItemsResponse$1, UpdateItemRequest as UpdateItemRequest$1, UpdateItemResponse as UpdateItemResponse$1, V3CreateDishRequest as V3CreateDishRequest$1, CreateDishResponse as CreateDishResponse$1, CreateVariationRequest as CreateVariationRequest$1, CreateVariationResponse as CreateVariationResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

/**
 * Collection of menus and discounts available in a specific location.
 * Use a [draft catalog](https://dev.wix.com/api/rest/wix-restaurants/catalogs/draft-catalogs) to publish multiple changes to a catalog at the same time.
 * You can read more about catalogs in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Catalog {
    /**
     * Catalog ID.
     * @readonly
     */
    id?: string | null;
    /**
     * ID of the location the catalog belongs to. See the [Locations API](https://dev.wix.com/api/rest/business-info/locations/introduction) for more details.
     * @readonly
     * @format GUID
     */
    locationId?: string | null;
    /**
     * Whether the catalog is archived.
     * __Note:__ Archived catalogs can't be updated.
     * @readonly
     */
    archived?: boolean;
    /**
     * Date and time the last time a draft catalog has been published in `yyyy-mm-ddThh:mm:sssZ` format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
     * @readonly
     */
    draftPublishedDate?: Date | null;
}
interface CreateDraftCatalogRequest {
    /**
     * ID of the catalog to create a draft version for.
     * @format GUID
     */
    catalogId: string;
}
interface CreateDraftCatalogResponse {
    /** Created draft catalog. */
    catalog?: Catalog;
}
interface PublishDraftCatalogRequest {
    /**
     * ID of the draft catalog to publish.
     * @format GUID
     */
    catalogId: string;
}
interface PublishDraftCatalogResponse {
    /** Published catalog. */
    catalog?: Catalog;
}
interface DiscardDraftCatalogRequest {
    /**
     * ID of the draft catalog to discard.
     * @format GUID
     */
    catalogId: string;
}
interface DiscardDraftCatalogResponse {
}
interface BulkCreateVariationsRequest {
    /** ID of the catalog the variations will belong to. */
    catalogId: string;
    /**
     * Variations to create. Limited to 20 variations.
     * @minSize 1
     * @maxSize 20
     */
    variations?: NewVariation[];
    /** Whether the full variation entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface NewVariation {
    /**
     * Variation name.
     * @minLength 1
     */
    name?: string;
}
interface BulkCreateVariationsResponse {
    /** Information about the created variations. */
    results?: BulkItemResult[];
    /** Bulk Create Variations metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkItemResult {
    /** Metadata of the item. */
    entityMetadata?: ItemMetadata;
    /** Item. */
    entity?: Item;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * Anything that customers can buy in the restaurant. Items can be of type `DISH` or `VARIATION`.
 * You can read more about items in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Item {
    /**
     * Item ID.
     * @readonly
     */
    id?: string | null;
    /** Item name. */
    name?: string | null;
    /** Item description. */
    description?: string | null;
    /** Item price. */
    price?: Money;
    /** URL of the item's image file. */
    imageUrl?: string | null;
    /** Item labels. For example spicy, hot, vegan, gluten-free, or organic. */
    labels?: Labels;
    /** Whether the item is in stock. */
    inStock?: boolean | null;
    /**
     * Tax rate of the item in percent.
     * @decimalValue options { maxScale:3 }
     */
    taxRate?: string | null;
    /**
     * Whether the item is archived. Defaults to `false`. **Note:** Archived items can't be updated.
     * @readonly
     */
    archived?: boolean | null;
    /**
     * Visibility criteria that must be met for the item to appear in the live site.
     * In case of multiple visibility criteria, every criterion must be fulfilled.
     */
    visibilityCriteria?: VisibilityCriteria;
    /** Items customers can choose to modify a dish. Can be an extra, selection, or deselection. */
    dishOptions?: DishOptions;
    /** Whether a customer can add a special request when ordering this item. Defaults to `true`. */
    acceptSpecialRequest?: boolean | null;
    /**
     * Item type.
     * @readonly
     */
    type?: ItemTypeWithLiterals;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
interface Money {
    /**
     * Monetary amount in decimal string format. For example, `3.99`, `6`, and `10.5` are all accepted values.
     * @format DECIMAL_VALUE
     */
    value?: string;
    /**
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     * @format CURRENCY
     * @readonly
     */
    currency?: string;
}
interface Labels {
    values?: string[];
}
interface VisibilityCriteria {
    /**
     * Whether the entity appears in the live site. Defaults to `true`.
     * If `false`, the entity isn't rendered in the live site, even if each visibility criterion is fulfilled.
     */
    visible?: boolean | null;
    /**
     * Fulfillment types.
     * @minSize 1
     * @maxSize 2
     */
    fulfillmentTypes?: FulfillmentTypeWithLiterals[];
    /**
     * Ordering platforms.
     * @minSize 1
     * @maxSize 5
     */
    platforms?: PlatformWithLiterals[];
    /** Time periods when the entity is available. */
    availability?: Availability;
}
declare enum FulfillmentType {
    UNSPECIFIED_FULFILLMENT_TYPE = "UNSPECIFIED_FULFILLMENT_TYPE",
    DELIVERY = "DELIVERY",
    PICKUP_OR_DINE_IN = "PICKUP_OR_DINE_IN"
}
/** @enumType */
type FulfillmentTypeWithLiterals = FulfillmentType | 'UNSPECIFIED_FULFILLMENT_TYPE' | 'DELIVERY' | 'PICKUP_OR_DINE_IN';
declare enum Platform {
    UNSPECIFIED_PLATFORM = "UNSPECIFIED_PLATFORM",
    SITE = "SITE",
    MOBILE_SITE = "MOBILE_SITE",
    WIX_APP = "WIX_APP",
    CALL_CENTER = "CALL_CENTER",
    CHAT_BOT = "CHAT_BOT"
}
/** @enumType */
type PlatformWithLiterals = Platform | 'UNSPECIFIED_PLATFORM' | 'SITE' | 'MOBILE_SITE' | 'WIX_APP' | 'CALL_CENTER' | 'CHAT_BOT';
interface Availability {
    /**
     * Weekly recurring time periods when the entity is available.
     * Limited to 100 time periods.
     */
    periods?: TimePeriod[];
    /** Exceptions to the entity's regular availability. The entity can be available or not available during the special hour period. */
    specialHourPeriods?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the entity is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are 00:00-24:00, where 24:00 represents
     * midnight at the end of the specified day.
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
declare enum DayOfWeek {
    UNDEFINED = "UNDEFINED",
    SUN = "SUN",
    MON = "MON",
    TUE = "TUE",
    WED = "WED",
    THU = "THU",
    FRI = "FRI",
    SAT = "SAT"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'UNDEFINED' | 'SUN' | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /** Whether the item is available during the exception. Defaults to `true`. */
    available?: boolean;
    /** Name of the special hour period. In the dashboard, the special hour period is called event. */
    eventName?: string | null;
}
interface DishOptions {
    values?: DishOption[];
}
interface DishOption extends DishOptionMethodOneOf {
    /** Item of type `DISH` or `VARIATION` that customers can select. For example a dish size. Customers can choose only a single selection per dish. */
    selection?: Selection;
    /** Item of type `DISH` or `VARIATION` that customers can add to a dish. For example a topping. Customers can add multiple extras per dish. */
    extras?: Extras;
    /** Item of type `DISH` or `VARIATION` that customers can remove from a dish. For example a specific ingredient. Customers can remove multiple deselections per dish. */
    deselection?: Deselection;
    /** Dish option name. */
    name?: string;
    /** @readonly */
    type?: TypeWithLiterals;
}
/** @oneof */
interface DishOptionMethodOneOf {
    /** Item of type `DISH` or `VARIATION` that customers can select. For example a dish size. Customers can choose only a single selection per dish. */
    selection?: Selection;
    /** Item of type `DISH` or `VARIATION` that customers can add to a dish. For example a topping. Customers can add multiple extras per dish. */
    extras?: Extras;
    /** Item of type `DISH` or `VARIATION` that customers can remove from a dish. For example a specific ingredient. Customers can remove multiple deselections per dish. */
    deselection?: Deselection;
}
interface DishOptionItem {
    /** Item ID of the dish option. */
    itemId?: string;
    /** Dish option price. `0` for free choices that are included in the dish's price. */
    price?: Money;
}
interface Selection {
    /** Item ID of the default choice. */
    defaultChoice?: string | null;
    /** Item IDs of the available choices. */
    availableChoices?: DishOptionItem[];
}
interface Extras {
    /** Item IDs of the default choices. */
    defaultChoices?: string[];
    /**
     * Minimum number of extras a customer must choose. Defaults to `0`. Must be lower than or equal to the value of `availableChoices`.
     * @max 2147483647
     */
    minChoices?: number | null;
    /**
     * Maximum number of extras a customer can choose. Defaults to the value of `availableChoices`. Must be greater than or equal to the value of `minChoices`.
     * @max 2147483647
     */
    maxChoices?: number | null;
    /** Item IDs of the available choices. */
    availableChoices?: DishOptionItem[];
}
interface Deselection {
    /** Item IDs of the available choices. */
    availableChoices?: DishOptionItem[];
}
declare enum Type {
    UNSPECIFIED_DISH_OPTION_TYPE = "UNSPECIFIED_DISH_OPTION_TYPE",
    SELECTION = "SELECTION",
    EXTRAS = "EXTRAS",
    DESELECTION = "DESELECTION"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNSPECIFIED_DISH_OPTION_TYPE' | 'SELECTION' | 'EXTRAS' | 'DESELECTION';
declare enum ItemType {
    UNSPECIFIED_ITEM_TYPE = "UNSPECIFIED_ITEM_TYPE",
    DISH = "DISH",
    VARIATION = "VARIATION"
}
/** @enumType */
type ItemTypeWithLiterals = ItemType | 'UNSPECIFIED_ITEM_TYPE' | 'DISH' | 'VARIATION';
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateItemsRequest {
    /** ID of the catalog the items belong to. */
    catalogId: string;
    /**
     * Items to update. Limited to 20 items.
     * @minSize 1
     * @maxSize 20
     */
    items?: Item[];
    /** Whether the full item entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkUpdateItemsResponse {
    /** Information about the updated items. */
    results?: BulkItemResult[];
    /** Bulk Update Items metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCreateDishesRequest {
    /** ID of the catalog the dishes will belong to. */
    catalogId: string;
    /**
     * Information about the dishes to create. Limited to 20 dishes.
     * @minSize 1
     * @maxSize 20
     */
    createDishRequests?: CreateDishRequest[];
    /** Whether the full item entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface CreateDishRequest {
    /** ID of the menu the dish will belong to. */
    menuId?: string;
    /** ID of the section the dish will belong to. */
    sectionId?: string;
    /** Dish to create. */
    dish?: Item;
}
interface BulkCreateDishesResponse {
    /** Information about the created dishes. */
    results?: BulkItemResult[];
    /** Bulk Create Dishes metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCreateMenusRequest {
    /** ID of the catalog the menus will belong to. */
    catalogId: string;
    /**
     * Information about the menus to create. Limited to 20 menus.
     * @minSize 1
     * @maxSize 20
     */
    menus?: Menu[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Collection of sections that show what customers can buy in the restaurant.
 * You can read more about menus in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Menu {
    /**
     * Menu ID.
     * @readonly
     */
    id?: string | null;
    /** Menu name. */
    name?: string | null;
    /** Menu description. */
    description?: string | null;
    /** URL of the menu's image file. */
    imageUrl?: string | null;
    /**
     * Visibility criteria that must be met for the menu to appear in the live site.
     * In case of multiple visibility criteria, every criterion must be fulfilled.
     */
    visibilityCriteria?: VisibilityCriteria;
    /** IDs of the sections that are included in the menu. */
    sectionIds?: MenuSectionIds;
    /**
     * Whether the menu is archived. Defaults to `false`. **Note:** Archived menus can't be updated.
     * @readonly
     */
    archived?: boolean | null;
}
interface MenuSectionIds {
    values?: string[];
}
interface BulkCreateMenusResponse {
    /** Information about the created menus. */
    results?: BulkMenuResult[];
    /** Bulk Create Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkMenuResult {
    /** Menu metadata. */
    entityMetadata?: ItemMetadata;
    /** Menu. */
    entity?: Menu;
}
interface BulkUpdateMenusRequest {
    /** ID of the catalog the menus belong to. */
    catalogId: string;
    /**
     * Menus to update.
     * @minSize 1
     * @maxSize 20
     */
    menus?: Menu[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkUpdateMenusResponse {
    /** Information about the updated menus. */
    results?: BulkMenuResult[];
    /** Bulk Update Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCreateSectionsRequest {
    /** ID of the catalog the sections will belong to. */
    catalogId: string;
    /**
     * Information about the sections to create. Limited to 20 sections.
     * @minSize 1
     * @maxSize 20
     */
    createSectionRequests?: CreateSectionRequest[];
    /** Whether the full section entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
/**
 * Collection of dishes that customers can buy in the restaurant.
 * You can read more about sections in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Section {
    /**
     * Section ID.
     * @readonly
     */
    id?: string | null;
    /**
     * ID of the menu the section belongs to.
     * @readonly
     */
    menuId?: string | null;
    /** Section name. */
    name?: string | null;
    /** Section description. */
    description?: string | null;
    /** URL of the section's image file. */
    imageUrl?: string | null;
    /** IDs of the items that belong to the section. */
    itemIds?: SectionItemIds;
    /**
     * Visibility criteria that must be met for the section to appear in the live site.
     * In case of multiple visibility criteria, every criterion must be fulfilled.
     */
    visibilityCriteria?: VisibilityCriteria;
    /**
     * Whether the section is archived. Defaults to `false`. **Note:** Archived sections can't be updated.
     * @readonly
     */
    archived?: boolean | null;
}
/** Item IDs of the dishes that belong to this section. */
interface SectionItemIds {
    values?: string[];
}
interface CreateSectionRequest {
    /** ID of the menu the section will belong to. */
    menuId?: string;
    /** Section to create. */
    section?: Section;
}
interface BulkCreateSectionsResponse {
    /** Information about the created sections. */
    results?: BulkSectionResult[];
    /** Bulk Create Sections metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkSectionResult {
    /** Section metadata. */
    entityMetadata?: ItemMetadata;
    /** Section. */
    entity?: Section;
}
interface BulkUpdateSectionsRequest {
    /** ID of the catalog the sections belong to. */
    catalogId: string;
    /**
     * Information about the sections to update. Limited to 20 sections.
     * @minSize 1
     * @maxSize 20
     */
    updateSectionsRequests?: UpdateSectionRequest[];
    /** Whether the full section entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface UpdateSectionRequest {
    /** ID of the menu the section will belong to. */
    menuId?: string;
    /** Section to update. */
    section?: Section;
}
interface BulkUpdateSectionsResponse {
    /** Information about the updated sections. */
    results?: BulkSectionResult[];
    /** Bulk Update Sections metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkArchiveMenusRequest {
    /** ID of the catalog the menus belong to. */
    catalogId: string;
    /**
     * IDs of the menus to archive.
     * @minSize 1
     * @maxSize 20
     */
    ids?: string[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkArchiveMenusResponse {
    /** Information about the archived menus. */
    results?: BulkMenuResult[];
    /** Bulk Archive Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkUnarchiveMenusRequest {
    /** ID of the catalog the menus belong to. */
    catalogId: string;
    /**
     * IDs of the menus to unarchive.
     * @minSize 1
     * @maxSize 20
     */
    ids?: string[];
    /** Whether the full menu entity is returned. Defaults to `true`. */
    returnFullEntity?: boolean;
}
interface BulkUnarchiveMenusResponse {
    /** Information about the unarchived menus. */
    results?: BulkMenuResult[];
    /** Bulk Unarchive Menus metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
    /**
     * tell us why you're invalidating the cache. You don't need to add your app name
     * @maxLength 256
     */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
}
interface App {
    /**
     * The AppDefId
     * @minLength 1
     */
    appDefId?: string;
    /**
     * The instance Id
     * @format GUID
     */
    instanceId?: string;
}
interface Page {
    /**
     * the msid the page is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Page ID
     * @minLength 1
     */
    pageId?: string;
}
interface URI {
    /**
     * the msid the URI is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes
     * @minLength 1
     */
    uriPath?: string;
}
interface File {
    /**
     * the msid the file is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by filename (for media files such as PDFs)
     * @minLength 1
     * @maxLength 256
     */
    fileName?: string;
}
interface CustomTag {
    /**
     * the msid the tag is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Tag to invalidate by
     * @minLength 1
     * @maxLength 256
     */
    tag?: string;
}
interface CatalogUpdated {
    /** @format GUID */
    metaSiteId?: string;
    /** @format GUID */
    locationId?: string | null;
    /** @format GUID */
    catalogId?: string | null;
    archived?: boolean;
    catalogItems?: Item[];
    catalogSections?: Section[];
    catalogMenus?: Menu[];
    catalogDiscounts?: Discount[];
}
/**
 * Customers can use a discount to pay less. Can be an amount or a percentage.
 * You can read more about discounts in the [introduction](https://dev.wix.com/api/rest/wix-restaurants/catalogs/introduction).
 */
interface Discount extends DiscountValueOneOf, DiscountApplyToFilterOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
    /**
     * Discount ID.
     * @readonly
     */
    id?: string | null;
    /** Discount name. */
    name?: string | null;
    /** Discount description. */
    description?: string | null;
    /** Whether the discount is active. Defaults to `true`. */
    active?: boolean | null;
    /** Discount type. */
    type?: DiscountTypeWithLiterals;
    /**
     * Discount condition.
     * All conditions must be met so that a customer can apply the discount.
     */
    condition?: DiscountCondition;
}
/** @oneof */
interface DiscountValueOneOf {
    /** Discount amount. */
    amount?: Money;
    /**
     * Discount percentage.
     * @decimalValue options { maxScale:3 }
     */
    percentage?: string | null;
}
/** @oneof */
interface DiscountApplyToFilterOneOf {
    /** IDs of the sections the discount applies to. */
    sectionIds?: SectionIds;
    /** IDs of the items the discount applies to. **Note:** The items must be of type `dish`. */
    itemIds?: ItemIds;
}
declare enum DiscountType {
    UNSPECIFIED_TYPE = "UNSPECIFIED_TYPE",
    OFF_ITEM = "OFF_ITEM",
    OFF_ORDER = "OFF_ORDER"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNSPECIFIED_TYPE' | 'OFF_ITEM' | 'OFF_ORDER';
interface SectionIds {
    values?: string[];
}
interface ItemIds {
    values?: string[];
}
interface DiscountCondition {
    /**
     * Which fulfillment types the discount applies to.
     * @minSize 1
     * @maxSize 2
     */
    fulfillmentTypes?: FulfillmentTypeWithLiterals[];
    /**
     * Which ordering platforms the discount applies to.
     * @minSize 1
     * @maxSize 3
     */
    platforms?: DiscountPlatformWithLiterals[];
    /** List of times when the discount is available. */
    availability?: Availability;
    /** Minimum order price for the discount. */
    minOrderPrice?: Money;
    /**
     * Coupon associated with the discount.
     * @readonly
     */
    coupon?: Coupon;
}
declare enum DiscountPlatform {
    UNSPECIFIED_PLATFORM = "UNSPECIFIED_PLATFORM",
    SITE = "SITE",
    MOBILE_SITE = "MOBILE_SITE",
    CALL_CENTER = "CALL_CENTER"
}
/** @enumType */
type DiscountPlatformWithLiterals = DiscountPlatform | 'UNSPECIFIED_PLATFORM' | 'SITE' | 'MOBILE_SITE' | 'CALL_CENTER';
interface Coupon {
    /**
     * Whether the customer needs to enter the coupon code to receive the discount. Defaults to `true`.
     * @readonly
     */
    applied?: boolean | null;
    /**
     * Coupon code.
     * @readonly
     */
    code?: string | null;
}
interface PublishCatalogUpdated {
    /** @format GUID */
    metaSiteId?: string;
    /** @format GUID */
    locationId?: string | null;
    /** @format GUID */
    catalogId?: string | null;
    archived?: boolean;
}
interface IndexCacheCmd {
    /** @format GUID */
    catalogId?: string;
    orgId?: string;
    orgLocale?: string;
    /** @format GUID */
    metaSiteId?: string | null;
}
interface CatalogChanged {
    /** Changed Catalog. */
    catalog?: Catalog;
}
interface ListCatalogsRequest {
    /** Sort order. Defaults to `ASC`. */
    sort?: Sorting;
    /** Paging information. `offset` defaults to `0` and `limit` defaults to `50`. The maximum for limit is `1,000`. */
    paging?: Paging;
    /** Whether archived catalogs are returned. Defaults to `false`. */
    archived?: boolean;
    /**
     * IDs of the locations for which the catalog will be returned. See the [Locations API](https://dev.wix.com/api/rest/business-info/locations/introduction) for more details.
     * @format GUID
     */
    locationIds?: string[];
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface ListCatalogsResponse {
    /** Retrieved catalogs. */
    catalogs?: Catalog[];
}
interface GetMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
interface GetMenuResponse {
    /** Retrieved menu. */
    menu?: Menu;
}
interface GetSectionRequest {
    /**
     * ID of the catalog the section belongs to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the catalog belongs to. */
    menuId: string;
    /** Section ID. */
    sectionId: string;
}
interface GetSectionResponse {
    /** Retrieved section. */
    section?: Section;
}
interface UpdateMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu to update. */
    menu?: Menu;
}
interface UpdateMenuResponse {
    /** Updated Menu. */
    menu?: Menu;
}
interface V3UpdateSectionRequest {
    /**
     * ID of the catalog the section belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
    /** Section to update. */
    section?: Section;
}
interface UpdateSectionResponse {
    /** Updated section. */
    section?: Section;
}
interface ListMenusRequest {
    /**
     * ID of the catalog the menus belong to.
     * @format GUID
     */
    catalogId: string;
    /** Field mask path. */
    fieldMask?: string[];
    /** Whether archived menus are returned. Defaults to `false`. */
    archived?: boolean;
}
interface ListMenusResponse {
    /** Retrieved menus. */
    menus?: Menu[];
}
interface ListSectionsRequest {
    /**
     * ID of the catalog the sections belong to.
     * @format GUID
     */
    catalogId: string;
    /** Field mask path. */
    fieldMask?: string[];
    /** Whether archived sections are returned. Defaults to `false`. */
    archived?: boolean;
}
interface ListSectionsResponse {
    /** Sections list. */
    sections?: Section[];
}
interface CreateMenuRequest {
    /**
     * ID of the catalog the menu will belong to.
     * @format GUID
     */
    catalogId: string;
    /** Menu to create. */
    menu: Menu;
}
interface CreateMenuResponse {
    /** Created Menu. */
    menu?: Menu;
}
interface ArchiveMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
interface ArchiveMenuResponse {
    /** Archived menu. */
    menu?: Menu;
}
interface UnarchiveMenuRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Menu ID. */
    menuId: string;
}
interface UnarchiveMenuResponse {
    /** Unarchived menu. */
    menu?: Menu;
}
interface ArchiveSectionRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId?: string;
    /** Menu ID. */
    menuId?: string;
    /** Section ID. */
    sectionId?: string;
}
interface ArchiveSectionResponse {
    /** Archived section. */
    section?: Section;
}
interface RemoveDishFromSectionRequest {
    /**
     * ID of the catalog the menu belongs to.
     * @format GUID
     */
    catalogId?: string;
    /** Menu ID. */
    menuId?: string;
    /** Section ID. */
    sectionId?: string;
    /** Item ID. */
    itemId?: string;
}
interface RemoveDishFromSectionResponse {
}
interface V3CreateSectionRequest {
    /**
     * ID of the catalog the section will belong to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the section will belong to. */
    menuId: string;
    /** Section to create. */
    section: Section;
}
interface CreateSectionResponse {
    /** Created section. */
    section?: Section;
}
interface GetItemRequest {
    /**
     * ID of the catalog the item belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Item ID. */
    itemId: string;
    /** Whether `visibilityCriteria` is returned. Defaults to `false`. */
    includeVisibilityCriteria?: boolean;
}
interface GetItemResponse {
    /** Retrieved item. */
    item?: Item;
}
interface ListItemsRequest {
    /** Field mask path. */
    fieldMask?: string[];
    /**
     * ID of the catalog the items belong to.
     * @format GUID
     */
    catalogId: string;
    /** Whether archived items are returned. Defaults to `false`. */
    archived?: boolean;
}
interface ListItemsResponse {
    /** Retrieved items. */
    items?: Item[];
}
interface UpdateItemRequest {
    /**
     * ID of the catalog the item belongs to.
     * @format GUID
     */
    catalogId: string;
    /** Item to update. */
    item?: Item;
}
interface UpdateItemResponse {
    /** Updated Item. */
    item?: Item;
}
interface V3CreateDishRequest {
    /**
     * ID of the catalog the dish will belong to.
     * @format GUID
     */
    catalogId: string;
    /** ID of the menu the dish will belong to. */
    menuId: string;
    /** ID of the section the dish will belong to. */
    sectionId: string;
    /** Item of type `dish` to create. */
    dish: Item;
}
interface CreateDishResponse {
    /** Created Dish. */
    dish?: Item;
}
interface CreateVariationRequest {
    /**
     * ID of the catalog the variation will belong to.
     * @format GUID
     */
    catalogId: string;
    /** Variation name. */
    name: string;
}
interface CreateVariationResponse {
    /** Created Variation. */
    variation?: Item;
}
interface MenuUpdated {
    /** @format GUID */
    metaSiteId?: string;
    organizationId?: string;
    /** @format GUID */
    locationId?: string | null;
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createDraftCatalog(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, CreateDraftCatalogRequest$1, CreateDraftCatalogRequest, CreateDraftCatalogResponse$1, CreateDraftCatalogResponse>;
declare function publishDraftCatalog(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, PublishDraftCatalogRequest$1, PublishDraftCatalogRequest, PublishDraftCatalogResponse$1, PublishDraftCatalogResponse>;
declare function discardDraftCatalog(): __PublicMethodMetaInfo<'DELETE', {
    catalogId: string;
}, DiscardDraftCatalogRequest$1, DiscardDraftCatalogRequest, DiscardDraftCatalogResponse$1, DiscardDraftCatalogResponse>;
declare function bulkCreateVariations(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkCreateVariationsRequest$1, BulkCreateVariationsRequest, BulkCreateVariationsResponse$1, BulkCreateVariationsResponse>;
declare function bulkUpdateItems(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkUpdateItemsRequest$1, BulkUpdateItemsRequest, BulkUpdateItemsResponse$1, BulkUpdateItemsResponse>;
declare function bulkCreateDishes(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkCreateDishesRequest$1, BulkCreateDishesRequest, BulkCreateDishesResponse$1, BulkCreateDishesResponse>;
declare function bulkCreateMenus(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkCreateMenusRequest$1, BulkCreateMenusRequest, BulkCreateMenusResponse$1, BulkCreateMenusResponse>;
declare function bulkUpdateMenus(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkUpdateMenusRequest$1, BulkUpdateMenusRequest, BulkUpdateMenusResponse$1, BulkUpdateMenusResponse>;
declare function bulkCreateSections(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkCreateSectionsRequest$1, BulkCreateSectionsRequest, BulkCreateSectionsResponse$1, BulkCreateSectionsResponse>;
declare function bulkUpdateSections(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkUpdateSectionsRequest$1, BulkUpdateSectionsRequest, BulkUpdateSectionsResponse$1, BulkUpdateSectionsResponse>;
declare function bulkArchiveMenus(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkArchiveMenusRequest$1, BulkArchiveMenusRequest, BulkArchiveMenusResponse$1, BulkArchiveMenusResponse>;
declare function bulkUnarchiveMenus(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, BulkUnarchiveMenusRequest$1, BulkUnarchiveMenusRequest, BulkUnarchiveMenusResponse$1, BulkUnarchiveMenusResponse>;
declare function listCatalogs(): __PublicMethodMetaInfo<'GET', {}, ListCatalogsRequest$1, ListCatalogsRequest, ListCatalogsResponse$1, ListCatalogsResponse>;
declare function getMenu(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
    menuId: string;
}, GetMenuRequest$1, GetMenuRequest, GetMenuResponse$1, GetMenuResponse>;
declare function getSection(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
    menuId: string;
    sectionId: string;
}, GetSectionRequest$1, GetSectionRequest, GetSectionResponse$1, GetSectionResponse>;
declare function updateMenu(): __PublicMethodMetaInfo<'PATCH', {
    catalogId: string;
    menuId: string;
}, UpdateMenuRequest$1, UpdateMenuRequest, UpdateMenuResponse$1, UpdateMenuResponse>;
declare function updateSection(): __PublicMethodMetaInfo<'PATCH', {
    catalogId: string;
    menuId: string;
    sectionId: string;
}, V3UpdateSectionRequest$1, V3UpdateSectionRequest, UpdateSectionResponse$1, UpdateSectionResponse>;
declare function listMenus(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
}, ListMenusRequest$1, ListMenusRequest, ListMenusResponse$1, ListMenusResponse>;
declare function listSections(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
}, ListSectionsRequest$1, ListSectionsRequest, ListSectionsResponse$1, ListSectionsResponse>;
declare function createMenu(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, CreateMenuRequest$1, CreateMenuRequest, CreateMenuResponse$1, CreateMenuResponse>;
declare function archiveMenu(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
    menuId: string;
}, ArchiveMenuRequest$1, ArchiveMenuRequest, ArchiveMenuResponse$1, ArchiveMenuResponse>;
declare function unarchiveMenu(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
    menuId: string;
}, UnarchiveMenuRequest$1, UnarchiveMenuRequest, UnarchiveMenuResponse$1, UnarchiveMenuResponse>;
declare function createSection(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
    menuId: string;
}, V3CreateSectionRequest$1, V3CreateSectionRequest, CreateSectionResponse$1, CreateSectionResponse>;
declare function getItem(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
    itemId: string;
}, GetItemRequest$1, GetItemRequest, GetItemResponse$1, GetItemResponse>;
declare function listItems(): __PublicMethodMetaInfo<'GET', {
    catalogId: string;
}, ListItemsRequest$1, ListItemsRequest, ListItemsResponse$1, ListItemsResponse>;
declare function updateItem(): __PublicMethodMetaInfo<'PATCH', {
    catalogId: string;
    itemId: string;
}, UpdateItemRequest$1, UpdateItemRequest, UpdateItemResponse$1, UpdateItemResponse>;
declare function createDish(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
    menuId: string;
    sectionId: string;
}, V3CreateDishRequest$1, V3CreateDishRequest, CreateDishResponse$1, CreateDishResponse>;
declare function createVariation(): __PublicMethodMetaInfo<'POST', {
    catalogId: string;
}, CreateVariationRequest$1, CreateVariationRequest, CreateVariationResponse$1, CreateVariationResponse>;

export { type ActionEvent as ActionEventOriginal, type App as AppOriginal, type ApplicationError as ApplicationErrorOriginal, type ArchiveMenuRequest as ArchiveMenuRequestOriginal, type ArchiveMenuResponse as ArchiveMenuResponseOriginal, type ArchiveSectionRequest as ArchiveSectionRequestOriginal, type ArchiveSectionResponse as ArchiveSectionResponseOriginal, type Availability as AvailabilityOriginal, type BulkActionMetadata as BulkActionMetadataOriginal, type BulkArchiveMenusRequest as BulkArchiveMenusRequestOriginal, type BulkArchiveMenusResponse as BulkArchiveMenusResponseOriginal, type BulkCreateDishesRequest as BulkCreateDishesRequestOriginal, type BulkCreateDishesResponse as BulkCreateDishesResponseOriginal, type BulkCreateMenusRequest as BulkCreateMenusRequestOriginal, type BulkCreateMenusResponse as BulkCreateMenusResponseOriginal, type BulkCreateSectionsRequest as BulkCreateSectionsRequestOriginal, type BulkCreateSectionsResponse as BulkCreateSectionsResponseOriginal, type BulkCreateVariationsRequest as BulkCreateVariationsRequestOriginal, type BulkCreateVariationsResponse as BulkCreateVariationsResponseOriginal, type BulkItemResult as BulkItemResultOriginal, type BulkMenuResult as BulkMenuResultOriginal, type BulkSectionResult as BulkSectionResultOriginal, type BulkUnarchiveMenusRequest as BulkUnarchiveMenusRequestOriginal, type BulkUnarchiveMenusResponse as BulkUnarchiveMenusResponseOriginal, type BulkUpdateItemsRequest as BulkUpdateItemsRequestOriginal, type BulkUpdateItemsResponse as BulkUpdateItemsResponseOriginal, type BulkUpdateMenusRequest as BulkUpdateMenusRequestOriginal, type BulkUpdateMenusResponse as BulkUpdateMenusResponseOriginal, type BulkUpdateSectionsRequest as BulkUpdateSectionsRequestOriginal, type BulkUpdateSectionsResponse as BulkUpdateSectionsResponseOriginal, type CatalogChanged as CatalogChangedOriginal, type Catalog as CatalogOriginal, type CatalogUpdated as CatalogUpdatedOriginal, type Coupon as CouponOriginal, type CreateDishRequest as CreateDishRequestOriginal, type CreateDishResponse as CreateDishResponseOriginal, type CreateDraftCatalogRequest as CreateDraftCatalogRequestOriginal, type CreateDraftCatalogResponse as CreateDraftCatalogResponseOriginal, type CreateMenuRequest as CreateMenuRequestOriginal, type CreateMenuResponse as CreateMenuResponseOriginal, type CreateSectionRequest as CreateSectionRequestOriginal, type CreateSectionResponse as CreateSectionResponseOriginal, type CreateVariationRequest as CreateVariationRequestOriginal, type CreateVariationResponse as CreateVariationResponseOriginal, type CustomTag as CustomTagOriginal, DayOfWeek as DayOfWeekOriginal, type DayOfWeekWithLiterals as DayOfWeekWithLiteralsOriginal, type Deselection as DeselectionOriginal, type DiscardDraftCatalogRequest as DiscardDraftCatalogRequestOriginal, type DiscardDraftCatalogResponse as DiscardDraftCatalogResponseOriginal, type DiscountApplyToFilterOneOf as DiscountApplyToFilterOneOfOriginal, type DiscountCondition as DiscountConditionOriginal, type Discount as DiscountOriginal, DiscountPlatform as DiscountPlatformOriginal, type DiscountPlatformWithLiterals as DiscountPlatformWithLiteralsOriginal, DiscountType as DiscountTypeOriginal, type DiscountTypeWithLiterals as DiscountTypeWithLiteralsOriginal, type DiscountValueOneOf as DiscountValueOneOfOriginal, type DishOptionItem as DishOptionItemOriginal, type DishOptionMethodOneOf as DishOptionMethodOneOfOriginal, type DishOption as DishOptionOriginal, type DishOptions as DishOptionsOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type Empty as EmptyOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type Extras as ExtrasOriginal, type File as FileOriginal, FulfillmentType as FulfillmentTypeOriginal, type FulfillmentTypeWithLiterals as FulfillmentTypeWithLiteralsOriginal, type GetItemRequest as GetItemRequestOriginal, type GetItemResponse as GetItemResponseOriginal, type GetMenuRequest as GetMenuRequestOriginal, type GetMenuResponse as GetMenuResponseOriginal, type GetSectionRequest as GetSectionRequestOriginal, type GetSectionResponse as GetSectionResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type IndexCacheCmd as IndexCacheCmdOriginal, type InvalidateCacheGetByOneOf as InvalidateCacheGetByOneOfOriginal, type InvalidateCache as InvalidateCacheOriginal, type ItemIds as ItemIdsOriginal, type ItemMetadata as ItemMetadataOriginal, type Item as ItemOriginal, ItemType as ItemTypeOriginal, type ItemTypeWithLiterals as ItemTypeWithLiteralsOriginal, type Labels as LabelsOriginal, type ListCatalogsRequest as ListCatalogsRequestOriginal, type ListCatalogsResponse as ListCatalogsResponseOriginal, type ListItemsRequest as ListItemsRequestOriginal, type ListItemsResponse as ListItemsResponseOriginal, type ListMenusRequest as ListMenusRequestOriginal, type ListMenusResponse as ListMenusResponseOriginal, type ListSectionsRequest as ListSectionsRequestOriginal, type ListSectionsResponse as ListSectionsResponseOriginal, type Menu as MenuOriginal, type MenuSectionIds as MenuSectionIdsOriginal, type MenuUpdated as MenuUpdatedOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type Money as MoneyOriginal, type NewVariation as NewVariationOriginal, type Page as PageOriginal, type Paging as PagingOriginal, Platform as PlatformOriginal, type PlatformWithLiterals as PlatformWithLiteralsOriginal, type PublishCatalogUpdated as PublishCatalogUpdatedOriginal, type PublishDraftCatalogRequest as PublishDraftCatalogRequestOriginal, type PublishDraftCatalogResponse as PublishDraftCatalogResponseOriginal, type RemoveDishFromSectionRequest as RemoveDishFromSectionRequestOriginal, type RemoveDishFromSectionResponse as RemoveDishFromSectionResponseOriginal, type RestoreInfo as RestoreInfoOriginal, type SectionIds as SectionIdsOriginal, type SectionItemIds as SectionItemIdsOriginal, type Section as SectionOriginal, type Selection as SelectionOriginal, SortOrder as SortOrderOriginal, type SortOrderWithLiterals as SortOrderWithLiteralsOriginal, type Sorting as SortingOriginal, type SpecialHourPeriod as SpecialHourPeriodOriginal, type TimePeriod as TimePeriodOriginal, Type as TypeOriginal, type TypeWithLiterals as TypeWithLiteralsOriginal, type URI as URIOriginal, type UnarchiveMenuRequest as UnarchiveMenuRequestOriginal, type UnarchiveMenuResponse as UnarchiveMenuResponseOriginal, type UpdateItemRequest as UpdateItemRequestOriginal, type UpdateItemResponse as UpdateItemResponseOriginal, type UpdateMenuRequest as UpdateMenuRequestOriginal, type UpdateMenuResponse as UpdateMenuResponseOriginal, type UpdateSectionRequest as UpdateSectionRequestOriginal, type UpdateSectionResponse as UpdateSectionResponseOriginal, type V3CreateDishRequest as V3CreateDishRequestOriginal, type V3CreateSectionRequest as V3CreateSectionRequestOriginal, type V3UpdateSectionRequest as V3UpdateSectionRequestOriginal, type VisibilityCriteria as VisibilityCriteriaOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, archiveMenu, bulkArchiveMenus, bulkCreateDishes, bulkCreateMenus, bulkCreateSections, bulkCreateVariations, bulkUnarchiveMenus, bulkUpdateItems, bulkUpdateMenus, bulkUpdateSections, createDish, createDraftCatalog, createMenu, createSection, createVariation, discardDraftCatalog, getItem, getMenu, getSection, listCatalogs, listItems, listMenus, listSections, publishDraftCatalog, unarchiveMenu, updateItem, updateMenu, updateSection };
