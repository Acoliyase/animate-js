export class RateLimiter {
  private readonly map = new Map<string, {
    count: number;
    timestamp: number;
    rateLimitCallbackCalled: boolean;
  }>();

  constructor(private options: {
    maxCalls: number;
    debounceMs: number;
    onRateLimit: (key: string) => void,
  }) { }

  run(key: string, cb: () => void) {
    this.cleanup();

    if (!key) {
      cb();
      return;
    }

    if (!this.map.has(key)) {
      this.map.set(key, {
        count: 0,
        timestamp: Date.now(),
        rateLimitCallbackCalled: false,
      });
    }

    const item = this.map.get(key)!;

    item.count++;
    item.timestamp = Date.now();

    if (item.count <= this.options.maxCalls) {
      cb();
    } else {
      if (!item.rateLimitCallbackCalled) {
        this.options.onRateLimit(key);
        item.rateLimitCallbackCalled = true;
      }
    }
  }

  cleanup() {
    [...this.map.entries()].forEach(([key, value]) => {
      if (Date.now() - value.timestamp >= this.options.debounceMs) {
        this.map.delete(key);
      }
    });
  }
}