import Chance from 'chance';
import { describe, test, expect, vi, afterEach, beforeEach } from 'vitest';
import { RateLimiter } from './rate-limiter.js';

const chance = new Chance();

describe('Rate Limiter', () => {
  let maxCalls: number;
  let callsOffset: number;
  let debounceMs: number;
  let rateLimiter: RateLimiter;
  let onRateLimit: (key: string) => void;

  beforeEach(() => {
    maxCalls = chance.integer({ min: 10, max: 100 });
    callsOffset = chance.integer({ min: 2, max: maxCalls - 2 });
    debounceMs = chance.integer({ min: 100, max: 1000 });

    onRateLimit = vi.fn();

    rateLimiter = new RateLimiter({
      maxCalls,
      debounceMs,
      onRateLimit,
    });

    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });
  
  test('should run callbacks always if key is empty', () => {
    const cb = vi.fn();

    for (let i = 0; i < maxCalls + callsOffset; i++) {
      rateLimiter.run('', cb);
    }

    expect(cb).toHaveBeenCalledTimes(maxCalls + callsOffset);
    expect(onRateLimit).not.toHaveBeenCalled();
  });

  test('should run callbacks if call count is less than maxCalls', () => {
    const key = chance.string();
    const cb = vi.fn();

    for (let i = 0; i < maxCalls - callsOffset; i++) {
      rateLimiter.run(key, cb);
    }

    expect(cb).toHaveBeenCalledTimes(maxCalls - callsOffset);
    expect(onRateLimit).not.toHaveBeenCalled();
  });

  test('should run callbacks if call count is equal to maxCalls', () => {
    const key = chance.string();
    const cb = vi.fn();

    for (let i = 0; i < maxCalls; i++) {
      rateLimiter.run(key, cb);
    }

    expect(cb).toHaveBeenCalledTimes(maxCalls);
    expect(onRateLimit).not.toHaveBeenCalled();
  });

  test('should not run callbacks if call count is greater than maxCalls', () => {
    const key = chance.string();
    const cb = vi.fn();

    for (let i = 0; i < maxCalls + callsOffset; i++) {
      rateLimiter.run(key, cb);
    }

    expect(cb).toHaveBeenCalledTimes(maxCalls);
    expect(onRateLimit).toHaveBeenCalledExactlyOnceWith(key);
  });

  test('should clear the call count after debounceMs', () => {
    const key = chance.string();
    const cb = vi.fn();

    for (let i = 0; i < maxCalls + callsOffset; i++) {
      rateLimiter.run(key, cb);
    }

    expect(cb).toHaveBeenCalledTimes(maxCalls);
    expect(onRateLimit).toHaveBeenCalledExactlyOnceWith(key);

    vi.advanceTimersByTime(debounceMs);

    for (let i = 0; i < maxCalls + callsOffset; i++) {
      rateLimiter.run(key, cb);
    }

    expect(cb).toHaveBeenCalledTimes(maxCalls * 2);
    expect(onRateLimit).toBeCalledTimes(2);
  });

  test('should limit calls for each key separately', () => {
    const key1 = chance.string();
    const key2 = chance.string();
    const cb = vi.fn();
    const cb2 = vi.fn();

    for (let i = 0; i < maxCalls + callsOffset; i++) {
      rateLimiter.run(key1, cb);
    }

    for (let i = 0; i < maxCalls + callsOffset; i++) {
      rateLimiter.run(key2, cb2);
    }

    expect(cb).toHaveBeenCalledTimes(maxCalls);
    expect(onRateLimit).toHaveBeenNthCalledWith(1, key1);

    expect(cb2).toHaveBeenCalledTimes(maxCalls);
    expect(onRateLimit).toHaveBeenNthCalledWith(2, key2);

    vi.advanceTimersByTime(debounceMs);
  });
});
