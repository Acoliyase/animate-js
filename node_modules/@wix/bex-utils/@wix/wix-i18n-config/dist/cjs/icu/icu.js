"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _intlMessageformat = _interopRequireDefault(require("intl-messageformat"));
var utils = _interopRequireWildcard(require("./utils"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function getDefaults() {
  return {
    memoize: true,
    memoizeFallback: false,
    bindI18n: '',
    bindI18nStore: undefined,
    parseErrorHandler: (_err, _key, res) => {
      return res;
    }
  };
}

/**
 * Copied from original ICU source code.
 * @source https://github.com/i18next/i18next-icu/blob/7809547c821a7ef3b2bb9ab2610cdbbcfedcb2f9/src/index.js
 *
 * It's done in order to support `IntlMessageFormat` out of the box.
 * `IntlMessageFormat` is adding formatters that are not provided by i18n.
 * For example, `select` formatter - https://formatjs.io/docs/core-concepts/icu-syntax#select-format
 * It allows to use following translation value: 'Welcome back{inputData, select, 0 {} 1 {, John}}'
 * See example in tests: __tests__/i18n.spec.tsx
 */
class ICU {
  constructor(options) {
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "formats", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "mem", void 0);
    this.type = 'i18nFormat';
    this.mem = {};
    this.init(null, options);
  }
  init(i18next, options) {
    var _this$options, _this$options2;
    const i18nextOptions = i18next && i18next.options && i18next.options.i18nFormat || {};
    this.options = utils.defaults(i18nextOptions, options, this.options || {}, getDefaults());
    this.formats = (_this$options = this.options) == null ? void 0 : _this$options.formats;
    if (i18next) {
      const {
        bindI18n,
        bindI18nStore,
        memoize
      } = this.options;

      // @ts-expect-error
      i18next.IntlMessageFormat = _intlMessageformat.default;
      // @ts-expect-error
      i18next.ICU = this;
      if (memoize) {
        if (bindI18n) {
          i18next.on(bindI18n, () => this.clearCache());
        }
        if (bindI18nStore) {
          i18next.store.on(bindI18nStore, () => this.clearCache());
        }
      }
    }
    if ((_this$options2 = this.options) != null && _this$options2.localeData) {
      if (Object.prototype.toString.apply(this.options.localeData) === '[object Array]') {
        this.options.localeData.forEach(ld => this.addLocaleData(ld));
      } else {
        this.addLocaleData(this.options.localeData);
      }
    }
  }
  addLocaleData(data) {
    const locales = Array.isArray(data) ? data : [data];
    locales.forEach(localeData => {
      if (localeData && localeData.locale) {
        // @ts-expect-error
        _intlMessageformat.default.__addLocaleData(localeData);
      }
    });
  }
  addUserDefinedFormats(formats) {
    this.formats = this.formats ? {
      ...this.formats,
      ...formats
    } : formats;
  }
  parse(res, options, lng, ns, key, info) {
    var _this$options3, _this$options4;
    const hadSuccessfulLookup = info && info.resolved && info.resolved.res;
    const memKey = ((_this$options3 = this.options) == null ? void 0 : _this$options3.memoize) && `${lng}.${ns}.${key.replace(/\./g, '###')}`;
    let fc;
    if ((_this$options4 = this.options) != null && _this$options4.memoize) {
      fc = utils.getPath(this.mem, memKey);
    }
    try {
      if (!fc) {
        var _this$options5;
        fc = new _intlMessageformat.default(res, lng, this.formats);
        if ((_this$options5 = this.options) != null && _this$options5.memoize && (this.options.memoizeFallback || !info || hadSuccessfulLookup)) {
          utils.setPath(this.mem, memKey, fc);
        }
      }
      return fc.format(options);
    } catch (err) {
      var _this$options6;
      return (_this$options6 = this.options) == null || _this$options6.parseErrorHandler == null ? void 0 : _this$options6.parseErrorHandler(err, key, res, options);
    }
  }
  addLookupKeys(finalKeys) {
    // no additional keys needed for select or plural
    // so there is no need to add keys to that finalKeys array
    return finalKeys;
  }
  clearCache() {
    this.mem = {};
  }
}

// @ts-expect-error
ICU.type = 'i18nFormat';
var _default = exports.default = ICU;
//# sourceMappingURL=icu.js.map