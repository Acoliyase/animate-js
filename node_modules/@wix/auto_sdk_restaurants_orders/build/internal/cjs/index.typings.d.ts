import { NonNullablePaths } from '@wix/sdk-types';

interface Order {
    /**
     * Order ID.
     * @readonly
     */
    _id?: string;
    /**
     * ID of the restaurant’s location.
     * @format GUID
     * @readonly
     */
    locationId?: string | null;
    /**
     * Order creation date and time in `yyyy-mm-ddThh:mm:sssZ` format.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time of order's latest update in `yyyy-mm-ddThh:mm:sssZ` format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Additional note to the order added by the customer.
     * @maxLength 1000
     */
    comment?: string | null;
    /**
     * Currency of the order.
     * @format CURRENCY
     */
    currency?: string | null;
    /** Current order status. */
    status?: StatusWithLiterals;
    /**
     * TEST This is a line item for the order of the property
     *
     * @minSize 1
     * @maxSize 300
     */
    lineItems?: LineItem[];
    /**
     * Discounts associated with the order.
     * @maxSize 100
     */
    discounts?: Discount[];
    /** Coupon applied to the order. */
    coupon?: Coupon;
    /**
     * Order payment information.
     * @minSize 1
     * @maxSize 100
     */
    payments?: Payment[];
    /** Order fulfillment information. */
    fulfillment?: Fulfillment;
    /** Customer information. */
    customer?: Customer;
    /** Order totals. */
    totals?: Totals;
    /**
     * Log of order updates.
     * @readonly
     */
    activities?: Activity[];
    /** Information about the sales channel that submitted the order. */
    channelInfo?: ChannelInfo;
    /**
     * Information about the order’s loyalty points.
     * Learn more about the [Wix Loyalty Program](https://dev.wix.com/api/rest/wix-loyalty-program/introduction).
     */
    loyaltyInfo?: LoyaltyInfo;
}
/** This might be extended in the future with pending orders statuses */
declare enum Status {
    /** Unspecified order status. */
    UNSPECIFIED_ORDER_STATUS = "UNSPECIFIED_ORDER_STATUS",
    /** Order is pending response from the payment provider. */
    PENDING = "PENDING",
    /** Order is new. */
    NEW = "NEW",
    /** Order was accepted. */
    ACCEPTED = "ACCEPTED",
    /** Order was canceled. */
    CANCELED = "CANCELED",
    /** Order was fulfilled. */
    FULFILLED = "FULFILLED"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNSPECIFIED_ORDER_STATUS' | 'PENDING' | 'NEW' | 'ACCEPTED' | 'CANCELED' | 'FULFILLED';
/** TEST  This is a line item for the order. */
interface LineItem {
    /**
     * Line item quantity.
     * @min 1
     * @max 100000
     */
    quantity?: number;
    /**
     * Line item price.
     * @decimalValue options { maxScale:2 }
     */
    price?: string;
    /**
     * Comment about the line item added by the customer.
     * @maxLength 1000
     */
    comment?: string | null;
    /**
     * List of all dish options available for the line item.
     * @maxSize 300
     */
    dishOptions?: LineItemOption[];
    /** References to the line item’s origin catalog. */
    catalogReference?: CatalogReference;
}
interface LineItemOption {
    /**
     * Line item option name.
     * @maxLength 1000
     */
    name?: string | null;
    /**
     * List of all dish options selected by the customer.
     * @maxSize 300
     */
    selectedChoices?: LineItem[];
    /**
     * Minimum number of dish options the customer is required to choose.
     * @max 2147483647
     */
    minChoices?: number | null;
    /**
     * Maximum number of dish options the customer is allowed to choose.
     * @min 1
     * @max 2147483647
     */
    maxChoices?: number | null;
    /** Dish option type. */
    type?: DisplayTypeWithLiterals;
    /**
     * List of all available choices for the dish option.
     * @minSize 1
     * @maxSize 300
     */
    availableChoices?: LineItemOptionItem[];
    /**
     * List of dish option IDs selected by default.
     * @maxSize 300
     */
    defaultChoices?: string[] | null;
}
declare enum DisplayType {
    /** Unspecified display type. */
    UNSPECIFIED_DISPLAY_TYPE = "UNSPECIFIED_DISPLAY_TYPE",
    /** Single choice selection. */
    SELECTION = "SELECTION",
    /** Multiple choice selection. */
    EXTRAS = "EXTRAS",
    /** Allow choice removal. */
    DESELECTION = "DESELECTION"
}
/** @enumType */
type DisplayTypeWithLiterals = DisplayType | 'UNSPECIFIED_DISPLAY_TYPE' | 'SELECTION' | 'EXTRAS' | 'DESELECTION';
interface LineItemOptionItem {
    /** Line item ID as defined in the catalog. */
    itemId?: string | null;
    /**
     * Line item price.
     * @decimalValue options { maxScale:2 }
     */
    price?: string | null;
    /**
     * Line item name.
     * @maxLength 1000
     */
    name?: string | null;
}
interface CatalogReference {
    /** Line item ID as defined in the catalog. */
    catalogItemId?: string;
    /**
     * Line item name as defined in the catalog.
     * @maxLength 1000
     * @readonly
     */
    catalogItemName?: string | null;
    /**
     * Item description as defined in the catalog.
     * @maxLength 1000
     * @readonly
     */
    catalogItemDescription?: string | null;
    /**
     * Item media url as defined in the catalog.
     * @format WEB_URL
     * @readonly
     */
    catalogItemMedia?: string | null;
}
interface Discount {
    /** Discount ID as defined in the catalog. */
    catalogDiscountId?: string;
    /**
     * Amount saved.
     * @decimalValue options { maxScale:2 }
     */
    appliedAmount?: string;
    /** Discount type. */
    catalogDiscountType?: DiscountTypeWithLiterals;
    /**
     * Discount name as defined in the catalog.
     * @minLength 1
     * @maxLength 256
     */
    catalogDiscountName?: string;
    /**
     * Discount description as defined in the catalog.
     *
     * Max: 1,000 characters
     * @minLength 1
     * @maxLength 1000
     * @readonly
     */
    catalogDiscountDescription?: string;
}
declare enum DiscountType {
    UNSPECIFIED_TYPE = "UNSPECIFIED_TYPE",
    OFF_ITEM = "OFF_ITEM",
    OFF_ORDER = "OFF_ORDER",
    OFF_ORDER_MANAGER_DISCOUNT = "OFF_ORDER_MANAGER_DISCOUNT"
}
/** @enumType */
type DiscountTypeWithLiterals = DiscountType | 'UNSPECIFIED_TYPE' | 'OFF_ITEM' | 'OFF_ORDER' | 'OFF_ORDER_MANAGER_DISCOUNT';
interface Coupon {
    /** Coupon code. */
    code?: string;
    /**
     * Coupon ID.
     * @format GUID
     */
    _id?: string;
}
interface Payment {
    /** Payment type. */
    type?: PaymentTypeWithLiterals;
    /**
     * Amount paid using this payment type. Only differs from total amount paid in case of split payments.
     * @decimalValue options { maxScale:2 }
     */
    amount?: string | null;
    /** Payment method. */
    method?: string | null;
    /**
     * Transaction ID.
     * See [Cashier API](https://dev.wix.com/api/rest/wix-cashier/payments/transaction) for more details.
     */
    providerTransactionId?: string | null;
}
declare enum PaymentType {
    /** Unspecified payment type. */
    UNSPECIFIED_PAYMENT_TYPE = "UNSPECIFIED_PAYMENT_TYPE",
    /** Cash */
    CASH = "CASH",
    /** credit */
    CREDIT = "CREDIT",
    /** Delivery club */
    DELIVERY_CLUB = "DELIVERY_CLUB",
    /** Delivery com */
    DELIVERY_COM = "DELIVERY_COM",
    /** Bitpay */
    BITPAY = "BITPAY",
    /** Cellarix */
    CELLARIX = "CELLARIX",
    /** Bits of gold */
    BITSOFGOLD = "BITSOFGOLD",
    /** Multi pass */
    MULTIPASS = "MULTIPASS",
    /** Tenbis */
    TENBIS = "TENBIS",
    /** Paypal */
    PAYPAL = "PAYPAL",
    /** MySodexo */
    MYSODEXO = "MYSODEXO",
    /** Wix Payments */
    WIX_PAYMENTS = "WIX_PAYMENTS"
}
/** @enumType */
type PaymentTypeWithLiterals = PaymentType | 'UNSPECIFIED_PAYMENT_TYPE' | 'CASH' | 'CREDIT' | 'DELIVERY_CLUB' | 'DELIVERY_COM' | 'BITPAY' | 'CELLARIX' | 'BITSOFGOLD' | 'MULTIPASS' | 'TENBIS' | 'PAYPAL' | 'MYSODEXO' | 'WIX_PAYMENTS';
interface Fulfillment extends FulfillmentDetailsOneOf {
    /** Delivery details. */
    deliveryDetails?: DeliveryDetails;
    /** Pickup details. */
    pickupDetails?: PickupDetails;
    /** Dine-in details */
    dineInDetails?: DineInDetails;
    /** Fulfillment type. */
    type?: FulfillmentTypeWithLiterals;
    /** Latest delivery time promised by the restaurant. */
    promisedTime?: Date | null;
    /** Whether the order should be fulfilled as soon as possible. Defaults to `true`. */
    asap?: boolean | null;
}
/** @oneof */
interface FulfillmentDetailsOneOf {
    /** Delivery details. */
    deliveryDetails?: DeliveryDetails;
    /** Pickup details. */
    pickupDetails?: PickupDetails;
    /** Dine-in details */
    dineInDetails?: DineInDetails;
}
declare enum FulfillmentType {
    /** Unspecified fulfillment type. */
    UNSPECIFIED_FULFILLMENT_TYPE = "UNSPECIFIED_FULFILLMENT_TYPE",
    /** Pickup */
    PICKUP = "PICKUP",
    /** Delivery */
    DELIVERY = "DELIVERY",
    /** Dine-in */
    DINE_IN = "DINE_IN"
}
/** @enumType */
type FulfillmentTypeWithLiterals = FulfillmentType | 'UNSPECIFIED_FULFILLMENT_TYPE' | 'PICKUP' | 'DELIVERY' | 'DINE_IN';
interface DeliveryDetails extends DeliveryDetailsProviderOneOf {
    /** Delivery through the restaurant. */
    restaurant?: Restaurant;
    /** Delivery through an external provider. */
    externalProvider?: ExternalProvider;
    /** Delivery address. */
    address?: DeliveryAddress;
    /** Information about the delivery pickup. */
    pickupInfo?: PickupInfo;
}
/** @oneof */
interface DeliveryDetailsProviderOneOf {
    /** Delivery through the restaurant. */
    restaurant?: Restaurant;
    /** Delivery through an external provider. */
    externalProvider?: ExternalProvider;
}
interface DeliveryAddress {
    /**
     * Formatted delivery address.
     * @maxLength 250
     */
    formatted?: string | null;
    /**
     * Country.
     * @maxLength 100
     */
    country?: string | null;
    /**
     * City name.
     * @maxLength 100
     */
    city?: string | null;
    /**
     * Street name.
     * @maxLength 100
     */
    street?: string | null;
    /**
     * Street number.
     * @maxLength 100
     */
    streetNumber?: string | null;
    /**
     * Apartment number.
     * @maxLength 100
     */
    apt?: string | null;
    /**
     * Floor.
     * @maxLength 100
     */
    floor?: string | null;
    /**
     * Entrance.
     * @maxLength 100
     */
    entrance?: string | null;
    /**
     * ZIP/postal code.
     * @maxLength 100
     */
    zipCode?: string | null;
    /**
     * Country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
     * @format COUNTRY
     */
    countryCode?: string | null;
    /** Special delivery instructions upon arrival to the address. */
    onArrival?: OnArrivalWithLiterals;
    /** Whether an approximate address is used. Defaults to `false`. In case of `false` a house number is required. */
    approximate?: boolean | null;
    /**
     * Delivery Instructions added by the customer.
     * @maxLength 500
     */
    comment?: string | null;
    /** Geo coordinates of the address. */
    location?: DeliveryAddressLocation;
    /** Address Line 2. */
    addressLine2?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
}
declare enum OnArrival {
    /** Unspecified arrival type. */
    UNSPECIFIED_ON_ARRIVAL_TYPE = "UNSPECIFIED_ON_ARRIVAL_TYPE",
    /** Ring the doorbell. */
    BUZZ_DOOR = "BUZZ_DOOR",
    /** Call the customer. */
    CALL_ME = "CALL_ME"
}
/** @enumType */
type OnArrivalWithLiterals = OnArrival | 'UNSPECIFIED_ON_ARRIVAL_TYPE' | 'BUZZ_DOOR' | 'CALL_ME';
interface DeliveryAddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
interface Restaurant {
    /**
     * Delivery fee.
     * @decimalValue options { maxScale:2 }
     */
    fee?: string | null;
}
interface ExternalProvider {
    /**
     * ID of the external delivery provider.
     * @format GUID
     */
    _id?: string;
    /**
     * Name of the external delivery provider.
     * @readonly
     */
    name?: string;
    /**
     * Delivery fee charged to the customer.
     * @decimalValue options { maxScale:2 }
     */
    customerFee?: string | null;
    /**
     * Fee paid by the restaurant to the external delivery provider.
     * @readonly
     * @decimalValue options { maxScale:2 }
     */
    commission?: string | null;
    /** Order pickup time. */
    pickupTime?: Date | null;
    /** Order drop off time. */
    dropOffTime?: Date | null;
}
interface PickupInfo {
    /** When a delivery is ready to be picked up. This is the start time of the pickup window. */
    windowStartTime?: Date | null;
    /** When a delivery must be picked up by. This is the end time of the pickup window. */
    windowEndTime?: Date | null;
}
interface DropOffInfo {
    /** Whether the order is delivered contactless. */
    contactless?: boolean;
}
interface PickupDetails {
    /**
     * Pickup fee charged to the customer.
     * @decimalValue options { maxScale:2 }
     */
    fee?: string | null;
    /** Curbside pickup method */
    curbside?: Curbside;
}
interface Curbside {
    /**
     * Additional information for curbside pickup.
     * @maxLength 50
     */
    info?: string;
}
interface DineInDetails {
    /** Label of dine-in information added by the restaurant, e.g. `table` or `booth`. */
    label?: string;
    /** Value of dine-in information added by the restaurant, e.g. `#6`. */
    value?: string;
}
/** Customer information. */
interface Customer extends CustomerIdOneOf {
    /**
     * Member ID.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Visitor ID.
     * @format GUID
     */
    visitorId?: string | null;
    /** First name. */
    firstName?: string;
    /** Last name. */
    lastName?: string;
    /** Phone number. */
    phone?: string | null;
    /** Email address. */
    email?: string;
    /**
     * Customer's contact ID.
     * See [Contacts API](https://dev.wix.com/api/rest/contacts/contacts/contacts-v4) for more details.
     * @format GUID
     */
    contactId?: string | null;
}
/** @oneof */
interface CustomerIdOneOf {
    /**
     * Member ID.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Visitor ID.
     * @format GUID
     */
    visitorId?: string | null;
}
interface Totals {
    /**
     * Order subtotal. Calculated by substracting delivery fee, tax and discount from order total.
     * @decimalValue options { maxScale:2 }
     */
    subtotal?: string;
    /**
     * Total order price.
     * @decimalValue options { maxScale:2 }
     */
    total?: string;
    /**
     * Total delivery fees charged to the customer.
     * @decimalValue options { maxScale:2 }
     */
    delivery?: string | null;
    /**
     * Total tax.
     * @decimalValue options { maxScale:2 }
     */
    tax?: string | null;
    /**
     * Total discount amount.
     * @decimalValue options { maxScale:2 }
     */
    discount?: string | null;
    /**
     * Total amount saved through the Wix Loyalty program.
     * @decimalValue options { maxScale:2 }
     */
    loyaltySavings?: string | null;
    /**
     * Total number of line items.
     * @readonly
     */
    quantity?: number;
    /**
     * Total tip.
     * @decimalValue options { maxScale:2 }
     */
    tip?: string | null;
}
interface ServiceFee {
    /**
     * The service fee's unique id.
     * @format GUID
     */
    ruleId?: string;
    /**
     * The service fee's name.
     * @readonly
     */
    name?: string;
    /** The service fee's fee as Money. */
    fee?: Money;
    /** The service fee's tax as Money. */
    tax?: Money;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
interface Money {
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     */
    value?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /** Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative. */
    formattedValue?: string | null;
}
interface Activity {
    /**
     * Activity timestamp.
     * @readonly
     */
    timestamp?: Date | null;
    /**
     * Optional message added during order activity.
     * @maxLength 1000
     * @readonly
     */
    message?: string | null;
}
interface ChannelInfo {
    type?: TypeWithLiterals;
}
declare enum Type {
    /** Unspecified channel type. */
    UNSPECIFIED_CHANNEL_TYPE = "UNSPECIFIED_CHANNEL_TYPE",
    /** Web */
    WEB = "WEB",
    /** Mobile web */
    MOBILE_WEB = "MOBILE_WEB",
    /** Mobile */
    MOBILE = "MOBILE",
    /** Call Center */
    CALL_CENTER = "CALL_CENTER",
    /** Facebook */
    FACEBOOK = "FACEBOOK",
    /** Third-party */
    TPA = "TPA"
}
/** @enumType */
type TypeWithLiterals = Type | 'UNSPECIFIED_CHANNEL_TYPE' | 'WEB' | 'MOBILE_WEB' | 'MOBILE' | 'CALL_CENTER' | 'FACEBOOK' | 'TPA';
interface LoyaltyInfo {
    /**
     * Associated Wix Loyalty reward ID.
     * @format GUID
     */
    rewardId?: string | null;
    /**
     * Amount saved redeeming Wix Loyalty reward.
     * @decimalValue options { maxScale:2 }
     */
    appliedAmount?: string | null;
    /**
     * Wix Loyalty points redeemed.
     * @readonly
     */
    redeemedPoints?: number | null;
    /**
     * Associated Wix Loyalty transaction ID.
     * @format GUID
     * @readonly
     */
    transactionId?: string | null;
    /**
     * Wix Loyalty estimated account point balance.
     * Equal to the sum of earned and adjusted points minus redeemed points.
     * The estimated point balance is the value before the order is completed. Following the purchase, the point balance is updated.
     * @readonly
     */
    estimatedAccountBalance?: number | null;
    /**
     * Wix Loyalty estimated total earned points.
     * The estimated total earned points is the value before the order is completed. Following the purchase, the total is updated.
     * @readonly
     */
    estimatedPointsEarned?: number | null;
    /**
     * Associated Wix Loyalty reward revision number, which increments by 1 each time the loyalty account is updated.
     *
     * To prevent conflicting changes, the current revision must be passed when updating the loyalty account.
     * Ignored when creating an account.
     * @readonly
     */
    rewardRevision?: string | null;
}
interface PosInfo {
    externalProvider?: PosInfoExternalProvider;
}
interface Error {
    /** Error code */
    code?: string;
    /** Error message */
    message?: string;
    /** Error params */
    params?: Record<string, string>;
}
interface PosInfoExternalProvider {
    /**
     * ID of the external provider.
     * @format GUID
     */
    _id?: string;
    /** ID of the order in the external provider. */
    orderId?: string;
    /** Order creation success */
    success?: boolean;
    /** Order creation errors */
    errors?: Error[];
}
interface GetTotalActiveOrdersRequest {
    /**
     * filter response to a specific location, otherwise return totals for all locations.
     * @format GUID
     */
    locationId?: string | null;
    organizationId?: string | null;
    /** Order delivery date and time for filtering new orders count, Must include a `gte:` or `lte:` prefix, for example: `gte:2021-10-26T12:48:15Z`. */
    promisedTimeNew?: string | null;
    /** Order delivery date and time for filtering new orders count, Must include a `gte:` or `lte:` prefix, for example: `gte:2021-10-26T12:48:15Z`. */
    promisedTimeInProgress?: string | null;
}
interface GetTotalActiveOrdersResponse {
    /** list of locationId's mapped to the total number of orders. */
    totals?: LocationToAmount[];
}
interface LocationToAmount {
    /** @format GUID */
    locationId?: string;
    /** @maxLength 150 */
    locationName?: string | null;
    totalNew?: number;
    totalInProgress?: number;
}
interface NewOrder {
    /** New order. */
    order?: Order;
}
interface GetOrderRequest {
    /** ID of the order to retrieve. */
    _id: string;
    /**
     * Set of fields to retrieve.
     * Fields that aren't included in `fieldmaks.paths` are ignored.
     * See [the article about field masks](https://dev.wix.com/api/rest/restaurants/orders/supported-field-masks)
     * for more details.
     */
    fieldMask?: string[];
}
interface GetOrderResponse {
    /** Retrieved order. */
    order?: Order;
}
interface ListOrdersRequest {
    /**
     * Set of fields to retrieve.
     * Fields that aren't included in `fieldmaks.paths` are ignored.
     * See [the article about field masks](https://dev.wix.com/api/rest/restaurants/orders/supported-field-masks)
     * for more details.
     */
    fieldMask?: string[];
    /** Order status. Currently, it is not possible to filter by status `FULFILLED`. */
    status?: StatusWithLiterals;
    /** Order creation date and time. Must include a `gte:` or `lte:` prefix, for example: `gte:2021-10-26T12:48:15Z`. */
    _createdDate?: string | null;
    /** Whether the order has been delivered. */
    delivered?: boolean | null;
    /**
     * Location filter. Pass an array of location IDs to return orders with any of the provided locations.
     * @format GUID
     */
    locationIds?: string[];
    /** Sorting options. */
    sort?: Sort;
    /**
     * Number of orders to return. The minimum limit is 1, the maximum 1000.
     * @min 1
     * @max 1000
     */
    limit?: number | null;
}
interface Sort {
    /** Field to sort by. */
    fieldName?: FieldNameWithLiterals;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum FieldName {
    CREATED_DATE = "CREATED_DATE",
    UPDATED_DATE = "UPDATED_DATE",
    PROMISED_TIME = "PROMISED_TIME"
}
/** @enumType */
type FieldNameWithLiterals = FieldName | 'CREATED_DATE' | 'UPDATED_DATE' | 'PROMISED_TIME';
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface ListOrdersResponse {
    /** List of retrieved orders. */
    orders?: Order[];
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface AcceptOrderRequest extends AcceptOrderRequestDeliveryTimeOneOf {
    /** ID of the order to mark as `ACCEPTED`. */
    _id: string;
    /**
     * Message when accepting the order.
     * @maxLength 1000
     */
    message?: string | null;
}
/** @oneof */
interface AcceptOrderRequestDeliveryTimeOneOf {
}
interface AcceptOrderResponse {
    /** Accepted order. */
    order?: Order;
}
interface OrderAccepted {
    /** Accepted order. */
    order?: Order;
}
interface CancelOrderRequest {
    /** ID of the order to mark as `CANCELED`. */
    _id: string;
    /**
     * Message when canceling the order.
     * @maxLength 1000
     */
    message?: string | null;
}
interface CancelOrderResponse {
    /** Canceled order. */
    order?: Order;
}
interface OrderCanceled {
    /** Canceled order. */
    order?: Order;
}
interface FulfillOrderRequest {
    /** ID of the order to mark as `FULFILLED`. */
    _id: string;
}
interface FulfillOrderResponse {
    /** Fulfilled order. */
    order?: Order;
}
interface OrderFulfilled {
    /** Fulfilled order. */
    order?: Order;
}
interface CountOrdersRequest {
    /**
     * Count orders only for a specific restaurant location
     * @format GUID
     */
    restaurantLocationId?: string | null;
    /** Limit the count only for orders that match the query */
    query?: CountOrdersQuery;
    /**
     * Count orders only for a specific OS location ID
     * @format GUID
     */
    locationId?: string | null;
}
interface CountOrdersQuery {
    /** Required - filter orders count by status. Supported values: NEW, ACCEPTED */
    status?: StatusWithLiterals;
    /**
     * Required - filter orders count by fulfillment promised time. (Latest delivery time promised by the restaurant)
     * Maximum supported range is up to 30 days.
     * NOTE: Count is a slow operation, for better performance request smaller time ranges.
     */
    promisedTime?: DateRangeFilter;
}
interface DateRangeFilter {
    /** Filter by date range, starting from given timestamp */
    startTime?: Date | null;
    /** Filter by date range, ending by a given timestamp */
    endTime?: Date | null;
}
interface CountOrdersResponse {
    /** Number of orders count that match the query */
    count?: number;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface NotifyOrderEventRequest {
    /** Order ID. */
    _id?: string;
    /** Metasite id */
    msid?: string;
    /** Notification event type */
    eventType?: EventTypeWithLiterals;
}
declare enum EventType {
    /** Order event can't be classified, due to an error/unhandled event */
    UNKNOWN = "UNKNOWN",
    /** Order Created. */
    CREATED = "CREATED",
    /** Order accepted */
    ACCEPTED = "ACCEPTED",
    /** Order Canceled */
    CANCELED = "CANCELED",
    /** Order Fulfilled */
    FULFILLED = "FULFILLED"
}
/** @enumType */
type EventTypeWithLiterals = EventType | 'UNKNOWN' | 'CREATED' | 'ACCEPTED' | 'CANCELED' | 'FULFILLED';
interface Empty {
}
interface GetOrderByMsidRequest {
    /** Order ID. */
    _id?: string;
    /**
     * Metasite id
     * @format GUID
     */
    msid?: string;
    /** Controls what data is returned in the response */
    fieldMask?: string[];
}
interface GetOrderByMsidResponse {
    /** Order data. */
    order?: Order;
}
interface ListOrdersByMsidRequest {
    /** Controls what data is returned in the response. */
    fieldMask?: string[];
    /** Order status to filter by. Currently Status Fulfilled is not supported */
    status?: StatusWithLiterals;
    /** Created date of the order epoch time. */
    _createdDate?: string | null;
    delivered?: boolean | null;
    /** Sorting of Orders in response. Default "CREATED_DATE:ASC" */
    sort?: Sort;
    /**
     * limit of records - min: 1 max: 2000
     * @min 1
     * @max 2000
     */
    limit?: number | null;
    /**
     * Metasite id
     * @format GUID
     */
    msid?: string;
}
interface ListOrdersByMsidResponse {
    /** Order data. */
    orders?: Order[];
}
interface NotifyOrderEventResponse {
}
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface OrderAcceptedEnvelope {
    data: OrderAccepted;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is accepted.
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.READ-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope View SEO Settings
 * @permissionScopeId SCOPE.PROMOTE.VIEW-SEO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @permissionId WIX_RESTAURANTS.READ_ORDERS
 * @webhook
 * @eventType wix.restaurants.v3.order_accepted
 * @serviceIdentifier com.wixpress.restaurants.orders.v3.OrdersApi
 * @slug accepted
 * @documentationMaturity preview
 * @deprecated
 */
declare function onOrderAccepted(handler: (event: OrderAcceptedEnvelope) => void | Promise<void>): void;
interface OrderCanceledEnvelope {
    data: OrderCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is canceled.
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.READ-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope View SEO Settings
 * @permissionScopeId SCOPE.PROMOTE.VIEW-SEO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @permissionId WIX_RESTAURANTS.READ_ORDERS
 * @webhook
 * @eventType wix.restaurants.v3.order_canceled
 * @serviceIdentifier com.wixpress.restaurants.orders.v3.OrdersApi
 * @slug canceled
 * @documentationMaturity preview
 * @deprecated
 */
declare function onOrderCanceled(handler: (event: OrderCanceledEnvelope) => void | Promise<void>): void;
interface OrderCreatedEnvelope {
    entity: Order;
    metadata: EventMetadata;
}
/**
 * > **Deprecation Notice**
 * >
 * > **The Order Created webhook has been replaced with**
 * > **the [New Order webhook](https://dev.wix.com/api/rest/wix-restaurants/orders/new-order-webhook)**
 * > **and will be removed on September 30, 2022. If your**
 * > **app uses this webhook, we recommend updating your**
 * > **code as soon as possible.
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.READ-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope View SEO Settings
 * @permissionScopeId SCOPE.PROMOTE.VIEW-SEO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @permissionId WIX_RESTAURANTS.READ_ORDERS
 * @webhook
 * @eventType wix.restaurants.v3.order_created
 * @serviceIdentifier com.wixpress.restaurants.orders.v3.OrdersApi
 * @slug created
 * @documentationMaturity preview
 * @deprecated
 * @replacedBy wix.ecom.v1.order_created
 * @targetRemovalDate 2025-09-30
 */
declare function onOrderCreated(handler: (event: OrderCreatedEnvelope) => void | Promise<void>): void;
interface OrderFulfilledEnvelope {
    data: OrderFulfilled;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is fulfilled.
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.READ-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope View SEO Settings
 * @permissionScopeId SCOPE.PROMOTE.VIEW-SEO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @permissionId WIX_RESTAURANTS.READ_ORDERS
 * @webhook
 * @eventType wix.restaurants.v3.order_fulfilled
 * @serviceIdentifier com.wixpress.restaurants.orders.v3.OrdersApi
 * @slug fulfilled
 * @documentationMaturity preview
 * @deprecated
 */
declare function onOrderFulfilled(handler: (event: OrderFulfilledEnvelope) => void | Promise<void>): void;
interface OrderNewOrderEnvelope {
    data: NewOrder;
    metadata: EventMetadata;
}
/**
 * Triggered on successful creation of a new order. This means
 * the order has been validated and the payment has cleared,
 * and now the site owner can accept or cancel the order.
 * @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.MANAGE-ORDERS
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-RESTAURANTS.READ-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Challenges
 * @permissionScopeId SCOPE.CHALLENGES.MANAGE
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope View SEO Settings
 * @permissionScopeId SCOPE.PROMOTE.VIEW-SEO
 * @permissionScope Access Verticals by Automations
 * @permissionScopeId SCOPE.CRM.ACCESS-VERTICALS-BY-AUTOMATIONS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Set Up Automations
 * @permissionScopeId SCOPE.CRM.SETUP-AUTOMATIONS
 * @permissionId WIX_RESTAURANTS.READ_ORDERS
 * @webhook
 * @eventType wix.restaurants.v3.order_new_order
 * @serviceIdentifier com.wixpress.restaurants.orders.v3.OrdersApi
 * @slug new_order
 * @documentationMaturity preview
 * @deprecated
 * @replacedBy wix.ecom.v1.order_created
 * @targetRemovalDate 2025-09-30
 */
declare function onOrderNewOrder(handler: (event: OrderNewOrderEnvelope) => void | Promise<void>): void;
/**
 * TEST The `getOrder()` function returns a Promise that is returned when an order is retrieved.
 *
 * 1. First do this.
 * 1. The do that
 *     + This is a bullet
 *     + So is this.
 *
 * > **Note**: This indentation is not how our notes generally look but I will waiit to see the branch preview. I am just trying out some markdown here.
 *
 * @param _id - ID of the order to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId WIX_RESTAURANTS.READ_ORDERS
 * @applicableIdentity APP
 * @returns TEST Curious where this shows up.
 * @fqn com.wixpress.restaurants.orders.v3.OrdersApi.GetOrder
 * @deprecated
 * @replacedBy com.wix.ecom.orders.v1.Orders.GetOrder
 * @targetRemovalDate 2025-09-30
 */
declare function getOrder(_id: string, options?: GetOrderOptions): Promise<NonNullablePaths<Order, `_id` | `status` | `lineItems` | `lineItems.${number}.quantity` | `lineItems.${number}.price` | `lineItems.${number}.catalogReference.catalogItemId` | `discounts` | `discounts.${number}.catalogDiscountId` | `discounts.${number}.appliedAmount` | `discounts.${number}.catalogDiscountType` | `discounts.${number}.catalogDiscountName` | `discounts.${number}.catalogDiscountDescription` | `coupon.code` | `coupon._id` | `payments` | `payments.${number}.type` | `fulfillment.deliveryDetails.externalProvider._id` | `fulfillment.deliveryDetails.externalProvider.name` | `fulfillment.deliveryDetails.address.onArrival` | `fulfillment.pickupDetails.curbside.info` | `fulfillment.dineInDetails.label` | `fulfillment.dineInDetails.value` | `fulfillment.type` | `customer.firstName` | `customer.lastName` | `customer.email` | `totals.subtotal` | `totals.total` | `totals.quantity` | `activities` | `channelInfo.type`, 5>>;
/** TEST The options for the order. */
interface GetOrderOptions {
    /**
     * Set of fields to retrieve.
     * Fields that aren't included in `fieldmaks.paths` are ignored.
     * See [the article about field masks](https://dev.wix.com/api/rest/restaurants/orders/supported-field-masks)
     * for more details.
     */
    fieldMask?: string[];
}
/**
 * Retrieves a list of up to 1000 orders, given the provided filters.
 * @public
 * @documentationMaturity preview
 * @permissionId WIX_RESTAURANTS.READ_ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.orders.v3.OrdersApi.ListOrders
 * @deprecated
 * @replacedBy com.wix.ecom.orders.v1.Orders.SearchOrders
 * @targetRemovalDate 2025-09-30
 */
declare function listOrders(options?: ListOrdersOptions): Promise<NonNullablePaths<ListOrdersResponse, `orders` | `orders.${number}._id` | `orders.${number}.status` | `orders.${number}.coupon.code` | `orders.${number}.coupon._id` | `orders.${number}.fulfillment.dineInDetails.label` | `orders.${number}.fulfillment.dineInDetails.value` | `orders.${number}.fulfillment.type` | `orders.${number}.customer.firstName` | `orders.${number}.customer.lastName` | `orders.${number}.customer.email` | `orders.${number}.totals.subtotal` | `orders.${number}.totals.total` | `orders.${number}.totals.quantity` | `orders.${number}.channelInfo.type`, 6>>;
interface ListOrdersOptions {
    /**
     * Set of fields to retrieve.
     * Fields that aren't included in `fieldmaks.paths` are ignored.
     * See [the article about field masks](https://dev.wix.com/api/rest/restaurants/orders/supported-field-masks)
     * for more details.
     */
    fieldMask?: string[];
    /** Order status. Currently, it is not possible to filter by status `FULFILLED`. */
    status?: StatusWithLiterals;
    /** Order creation date and time. Must include a `gte:` or `lte:` prefix, for example: `gte:2021-10-26T12:48:15Z`. */
    _createdDate?: string | null;
    /** Whether the order has been delivered. */
    delivered?: boolean | null;
    /**
     * Location filter. Pass an array of location IDs to return orders with any of the provided locations.
     * @format GUID
     */
    locationIds?: string[];
    /** Sorting options. */
    sort?: Sort;
    /**
     * Number of orders to return. The minimum limit is 1, the maximum 1000.
     * @min 1
     * @max 1000
     */
    limit?: number | null;
}
/**
 * Changes the order status to `ACCEPTED`.
 *
 * > **Note:** It is not possible to change the order status from `FULFILLED` to `ACCEPTED`.
 * @param _id - ID of the order to mark as `ACCEPTED`.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId WIX_RESTAURANTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.orders.v3.OrdersApi.AcceptOrder
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function acceptOrder(_id: string, options?: AcceptOrderOptions): Promise<NonNullablePaths<AcceptOrderResponse, `order._id` | `order.status` | `order.lineItems` | `order.lineItems.${number}.quantity` | `order.lineItems.${number}.price` | `order.lineItems.${number}.catalogReference.catalogItemId` | `order.discounts` | `order.discounts.${number}.catalogDiscountId` | `order.discounts.${number}.appliedAmount` | `order.discounts.${number}.catalogDiscountType` | `order.discounts.${number}.catalogDiscountName` | `order.discounts.${number}.catalogDiscountDescription` | `order.coupon.code` | `order.coupon._id` | `order.payments` | `order.payments.${number}.type` | `order.fulfillment.deliveryDetails.externalProvider._id` | `order.fulfillment.deliveryDetails.externalProvider.name` | `order.fulfillment.deliveryDetails.address.onArrival` | `order.fulfillment.pickupDetails.curbside.info` | `order.fulfillment.dineInDetails.label` | `order.fulfillment.dineInDetails.value` | `order.fulfillment.type` | `order.customer.firstName` | `order.customer.lastName` | `order.customer.email` | `order.totals.subtotal` | `order.totals.total` | `order.totals.quantity` | `order.activities` | `order.channelInfo.type`, 6>>;
interface AcceptOrderOptions extends AcceptOrderOptionsDeliveryTimeOneOf {
    /**
     * Message when accepting the order.
     * @maxLength 1000
     */
    message?: string | null;
}
/** @oneof */
interface AcceptOrderOptionsDeliveryTimeOneOf {
}
/**
 * Changes the order status to `CANCELED`.
 * @param _id - ID of the order to mark as `CANCELED`.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId WIX_RESTAURANTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.orders.v3.OrdersApi.CancelOrder
 * @deprecated
 * @replacedBy com.wix.ecom.orders.v1.Orders.CancelOrder
 * @targetRemovalDate 2025-09-30
 */
declare function cancelOrder(_id: string, options?: CancelOrderOptions): Promise<NonNullablePaths<CancelOrderResponse, `order._id` | `order.status` | `order.lineItems` | `order.lineItems.${number}.quantity` | `order.lineItems.${number}.price` | `order.lineItems.${number}.catalogReference.catalogItemId` | `order.discounts` | `order.discounts.${number}.catalogDiscountId` | `order.discounts.${number}.appliedAmount` | `order.discounts.${number}.catalogDiscountType` | `order.discounts.${number}.catalogDiscountName` | `order.discounts.${number}.catalogDiscountDescription` | `order.coupon.code` | `order.coupon._id` | `order.payments` | `order.payments.${number}.type` | `order.fulfillment.deliveryDetails.externalProvider._id` | `order.fulfillment.deliveryDetails.externalProvider.name` | `order.fulfillment.deliveryDetails.address.onArrival` | `order.fulfillment.pickupDetails.curbside.info` | `order.fulfillment.dineInDetails.label` | `order.fulfillment.dineInDetails.value` | `order.fulfillment.type` | `order.customer.firstName` | `order.customer.lastName` | `order.customer.email` | `order.totals.subtotal` | `order.totals.total` | `order.totals.quantity` | `order.activities` | `order.channelInfo.type`, 6>>;
interface CancelOrderOptions {
    /**
     * Message when canceling the order.
     * @maxLength 1000
     */
    message?: string | null;
}
/**
 * Changes the order status to `FULFILLED`.
 * @param _id - ID of the order to mark as `FULFILLED`.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId WIX_RESTAURANTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn com.wixpress.restaurants.orders.v3.OrdersApi.FulfillOrder
 * @deprecated
 * @targetRemovalDate 2025-09-30
 */
declare function fulfillOrder(_id: string): Promise<NonNullablePaths<FulfillOrderResponse, `order._id` | `order.status` | `order.lineItems` | `order.lineItems.${number}.quantity` | `order.lineItems.${number}.price` | `order.lineItems.${number}.catalogReference.catalogItemId` | `order.discounts` | `order.discounts.${number}.catalogDiscountId` | `order.discounts.${number}.appliedAmount` | `order.discounts.${number}.catalogDiscountType` | `order.discounts.${number}.catalogDiscountName` | `order.discounts.${number}.catalogDiscountDescription` | `order.coupon.code` | `order.coupon._id` | `order.payments` | `order.payments.${number}.type` | `order.fulfillment.deliveryDetails.externalProvider._id` | `order.fulfillment.deliveryDetails.externalProvider.name` | `order.fulfillment.deliveryDetails.address.onArrival` | `order.fulfillment.pickupDetails.curbside.info` | `order.fulfillment.dineInDetails.label` | `order.fulfillment.dineInDetails.value` | `order.fulfillment.type` | `order.customer.firstName` | `order.customer.lastName` | `order.customer.email` | `order.totals.subtotal` | `order.totals.total` | `order.totals.quantity` | `order.activities` | `order.channelInfo.type`, 6>>;

export { type AcceptOrderOptions, type AcceptOrderOptionsDeliveryTimeOneOf, type AcceptOrderRequest, type AcceptOrderRequestDeliveryTimeOneOf, type AcceptOrderResponse, type ActionEvent, type Activity, type BaseEventMetadata, type CancelOrderOptions, type CancelOrderRequest, type CancelOrderResponse, type CatalogReference, type ChannelInfo, type CountOrdersQuery, type CountOrdersRequest, type CountOrdersResponse, type Coupon, type Curbside, type CursorPaging, type Cursors, type Customer, type CustomerIdOneOf, type DateRangeFilter, type DeliveryAddress, type DeliveryAddressLocation, type DeliveryDetails, type DeliveryDetailsProviderOneOf, type DineInDetails, type Discount, DiscountType, type DiscountTypeWithLiterals, DisplayType, type DisplayTypeWithLiterals, type DomainEvent, type DomainEventBodyOneOf, type DropOffInfo, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type Error, type EventMetadata, EventType, type EventTypeWithLiterals, type ExternalProvider, FieldName, type FieldNameWithLiterals, type FulfillOrderRequest, type FulfillOrderResponse, type Fulfillment, type FulfillmentDetailsOneOf, FulfillmentType, type FulfillmentTypeWithLiterals, type GetOrderByMsidRequest, type GetOrderByMsidResponse, type GetOrderOptions, type GetOrderRequest, type GetOrderResponse, type GetTotalActiveOrdersRequest, type GetTotalActiveOrdersResponse, type IdentificationData, type IdentificationDataIdOneOf, type LineItem, type LineItemOption, type LineItemOptionItem, type ListOrdersByMsidRequest, type ListOrdersByMsidResponse, type ListOrdersOptions, type ListOrdersRequest, type ListOrdersResponse, type LocationToAmount, type LoyaltyInfo, type MessageEnvelope, type Money, type NewOrder, type NotifyOrderEventRequest, type NotifyOrderEventResponse, OnArrival, type OnArrivalWithLiterals, type Order, type OrderAccepted, type OrderAcceptedEnvelope, type OrderCanceled, type OrderCanceledEnvelope, type OrderCreatedEnvelope, type OrderFulfilled, type OrderFulfilledEnvelope, type OrderNewOrderEnvelope, type PagingMetadataV2, type Payment, PaymentType, type PaymentTypeWithLiterals, type PickupDetails, type PickupInfo, type PosInfo, type PosInfoExternalProvider, type Restaurant, type RestoreInfo, type ServiceFee, type Sort, SortOrder, type SortOrderWithLiterals, Status, type StatusWithLiterals, type Totals, Type, type TypeWithLiterals, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, acceptOrder, cancelOrder, fulfillOrder, getOrder, listOrders, onOrderAccepted, onOrderCanceled, onOrderCreated, onOrderFulfilled, onOrderNewOrder };
