// src/jsx-utils.ts
var JSXUtils = class {
  static init(types) {
    this.types = types;
  }
  static isCustomComponent(elementName) {
    return /^[A-Z]/.test(elementName);
  }
  static isAllowedCustomComponent(elementName) {
    return this.ALLOWED_CUSTOM_COMPONENTS.has(elementName);
  }
  static extractElementName(name) {
    if (this.types.isJSXIdentifier(name)) {
      return name.name;
    }
    if (this.types.isJSXNamespacedName(name)) {
      return name.name.name;
    }
    if (this.types.isJSXMemberExpression(name)) {
      const parts = [];
      let current = name;
      while (this.types.isJSXMemberExpression(current)) {
        parts.unshift(current.property.name);
        current = current.object;
      }
      parts.unshift(current.name);
      return parts.join(".");
    }
    return "";
  }
  static isEventHandler(attributeName) {
    return /^on[A-Z]/.test(attributeName);
  }
  static getAttributeName(attr) {
    return this.types.isJSXNamespacedName(attr.name) ? `${attr.name.namespace.name}:${attr.name.name.name}` : attr.name.name;
  }
  static isInsideCustomComponent(path) {
    let current = path.parentPath;
    while (current?.isJSXElement()) {
      const parentElement = current.node;
      const parentName = this.extractElementName(parentElement.openingElement.name);
      if (this.isCustomComponent(parentName)) return true;
      current = current.parentPath;
    }
    return false;
  }
};
JSXUtils.ALLOWED_CUSTOM_COMPONENTS = /* @__PURE__ */ new Set([
  "Image",
  "Link"
]);

// src/component-analyzer.ts
var ComponentAnalyzer = class {
  constructor(types) {
    this.types = types;
  }
  returnsJSX(componentPath) {
    const bodyPath = componentPath.get("body");
    if (bodyPath.isJSXElement() || bodyPath.isJSXFragment()) return true;
    if (bodyPath.isBlockStatement()) {
      return this.hasJSXReturn(bodyPath);
    }
    return false;
  }
  hasJSXReturn(bodyPath) {
    let hasJSXReturn = false;
    bodyPath.traverse({
      ReturnStatement(returnPath) {
        const argPath = returnPath.get("argument");
        if (argPath.isJSXElement() || argPath.isJSXFragment()) {
          hasJSXReturn = true;
          returnPath.stop();
        }
      },
      Function(innerFuncPath) {
        innerFuncPath.skip();
      }
    });
    return hasJSXReturn;
  }
  isComponentExported(declarationPath, componentName) {
    if (declarationPath.parentPath?.isExportDefaultDeclaration() || declarationPath.parentPath?.isExportNamedDeclaration()) {
      return true;
    }
    return this.hasIndirectExport(declarationPath, componentName);
  }
  hasIndirectExport(declarationPath, componentName) {
    const programPath = declarationPath.scope.getProgramParent().path;
    let isExported = false;
    programPath.traverse({
      noScope: true,
      ExportSpecifier: (specifierPath) => {
        if (this.types.isIdentifier(specifierPath.node.local) && specifierPath.node.local.name === componentName) {
          isExported = true;
          specifierPath.stop();
        }
      },
      ExportDefaultDeclaration: (exportPath) => {
        if (this.types.isIdentifier(exportPath.node.declaration) && exportPath.node.declaration.name === componentName) {
          isExported = true;
          exportPath.stop();
        }
      }
    });
    return isExported;
  }
};

// src/tailwind-mapper.ts
var TailwindMapper = class {
  static mapTailwindClassesToCssProperties(classNames) {
    const cssProperties = /* @__PURE__ */ new Set();
    if (!classNames.trim()) {
      return cssProperties;
    }
    const classes = classNames.split(/\s+/).filter((cls) => cls.length > 0);
    for (const className of classes) {
      for (const [pattern, properties] of this.tailwindToCssMap) {
        if (pattern.test(className)) {
          properties.forEach((prop) => cssProperties.add(prop));
          break;
        }
      }
    }
    return cssProperties;
  }
};
TailwindMapper.tailwindToCssMap = /* @__PURE__ */ new Map([
  // Background
  [/^bg-/, ["background-color"]],
  // Padding
  [/^p-(\d+|px|auto|\[.*\])$/, ["padding"]],
  [/^px-(\d+|px|auto|\[.*\])$/, ["padding-left", "padding-right"]],
  [/^py-(\d+|px|auto|\[.*\])$/, ["padding-top", "padding-bottom"]],
  [/^pt-(\d+|px|auto|\[.*\])$/, ["padding-top"]],
  [/^pr-(\d+|px|auto|\[.*\])$/, ["padding-right"]],
  [/^pb-(\d+|px|auto|\[.*\])$/, ["padding-bottom"]],
  [/^pl-(\d+|px|auto|\[.*\])$/, ["padding-left"]],
  // Margin
  [/^m-(\d+|px|auto|\[.*\])$/, ["margin"]],
  [/^mx-(\d+|px|auto|\[.*\])$/, ["margin-left", "margin-right"]],
  [/^my-(\d+|px|auto|\[.*\])$/, ["margin-top", "margin-bottom"]],
  [/^mt-(\d+|px|auto|\[.*\])$/, ["margin-top"]],
  [/^mr-(\d+|px|auto|\[.*\])$/, ["margin-right"]],
  [/^mb-(\d+|px|auto|\[.*\])$/, ["margin-bottom"]],
  [/^ml-(\d+|px|auto|\[.*\])$/, ["margin-left"]],
  // Text and Font
  [/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/, ["font-size", "line-height"]],
  [/^text-/, ["color"]],
  // This should come after text-size patterns
  [/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/, ["font-weight"]],
  [/^font-/, ["font-family"]],
  [/^leading-/, ["line-height"]],
  [/^tracking-/, ["letter-spacing"]],
  // Width and Height
  [/^w-/, ["width"]],
  [/^h-/, ["height"]],
  [/^min-w-/, ["min-width"]],
  [/^min-h-/, ["min-height"]],
  [/^max-w-/, ["max-width"]],
  [/^max-h-/, ["max-height"]],
  // Display
  [/^(block|inline-block|inline|flex|inline-flex|table|inline-table|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row-group|table-row|flow-root|grid|inline-grid|contents|list-item|hidden)$/, ["display"]],
  // Flexbox
  [/^flex-/, ["flex"]],
  [/^flex$/, ["display"]],
  [/^justify-/, ["justify-content"]],
  [/^items-/, ["align-items"]],
  [/^self-/, ["align-self"]],
  [/^content-/, ["align-content"]],
  // Grid
  [/^grid-cols-/, ["grid-template-columns"]],
  [/^grid-rows-/, ["grid-template-rows"]],
  [/^grid/, ["display"]],
  [/^col-/, ["grid-column"]],
  [/^row-/, ["grid-row"]],
  [/^gap-/, ["gap"]],
  // Position
  [/^(static|fixed|absolute|relative|sticky)$/, ["position"]],
  [/^(top|right|bottom|left)-/, ["top", "right", "bottom", "left"]],
  [/^inset-/, ["top", "right", "bottom", "left"]],
  [/^z-/, ["z-index"]],
  // Border
  [/^border$/, ["border-width"]],
  [/^border-/, ["border-color", "border-width", "border-style"]],
  [/^rounded/, ["border-radius"]],
  // Shadow
  [/^shadow/, ["box-shadow"]],
  [/^drop-shadow/, ["filter"]],
  // Opacity
  [/^opacity-/, ["opacity"]],
  // Transform
  [/^(scale|rotate|translate|skew)-/, ["transform"]],
  [/^transform/, ["transform"]],
  // Transition
  [/^transition/, ["transition"]],
  [/^duration-/, ["transition-duration"]],
  [/^ease-/, ["transition-timing-function"]],
  [/^delay-/, ["transition-delay"]],
  // Animation
  [/^animate-/, ["animation"]],
  // Overflow
  [/^overflow/, ["overflow"]],
  // Cursor
  [/^cursor-/, ["cursor"]],
  // Select
  [/^select-/, ["user-select"]],
  // Pointer Events
  [/^pointer-events-/, ["pointer-events"]],
  // Visibility
  [/^(visible|invisible)$/, ["visibility"]]
]);

// src/consts.ts
var IGNORED_ATTRIBUTES = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "transition"
]);

// src/jsx-processor.ts
var DATA_DYNAMIC_ATTRIBUTE = "data-dynamic";
var JSXProcessor = class {
  constructor(types) {
    this.types = types;
  }
  processJSXElement(path) {
    const dynamicAttributes = this.collectDynamicAttributes(path);
    this.checkForDynamicChildren(path, dynamicAttributes);
    dynamicAttributes.delete("key");
    if (dynamicAttributes.size > 0) {
      this.addDataDynamicAttribute(path, dynamicAttributes);
    }
  }
  collectDynamicAttributes(path) {
    const dynamicAttributes = /* @__PURE__ */ new Set();
    const attributes = path.get("attributes");
    for (const attrPath of attributes) {
      if (attrPath.isJSXAttribute()) {
        this.processJSXAttribute(attrPath, dynamicAttributes);
      } else if (attrPath.isJSXSpreadAttribute()) {
        this.processJSXSpreadAttribute(attrPath, dynamicAttributes);
      }
    }
    return dynamicAttributes;
  }
  processJSXAttribute(attrPath, dynamicAttributes) {
    const attributeName = JSXUtils.getAttributeName(attrPath.node);
    if (attributeName === "key" || JSXUtils.isEventHandler(attributeName) || !attrPath.node.value || !this.types.isJSXExpressionContainer(attrPath.node.value)) {
      return;
    }
    const expressionPath = attrPath.get("value.expression");
    if (!this.isDynamicExpression(expressionPath)) return;
    if (attributeName === "dangerouslySetInnerHTML") {
      dynamicAttributes.add("text");
    } else if (attributeName === "className" || attributeName === "tw") {
      this.handleClassNameAttribute(expressionPath, dynamicAttributes);
    } else {
      dynamicAttributes.add(attributeName);
    }
  }
  handleClassNameAttribute(expressionPath, dynamicAttributes) {
    if (expressionPath.isConditionalExpression() && this.handleStaticTernaryClasses(expressionPath, dynamicAttributes)) {
      return;
    }
    const handlers = [
      () => this.handleTernaryExpression(expressionPath, dynamicAttributes),
      () => this.handleLogicalExpression(expressionPath, dynamicAttributes),
      () => this.handleBinaryExpression(expressionPath, dynamicAttributes)
    ];
    for (const handler of handlers) {
      if (handler()) return;
    }
    dynamicAttributes.add("className");
  }
  handleStaticTernaryClasses(expressionPath, dynamicAttributes) {
    const staticValues = /* @__PURE__ */ new Set();
    if (!this.collectAllStaticStringLiterals(expressionPath, staticValues) || staticValues.size === 0) {
      return false;
    }
    const allProps = /* @__PURE__ */ new Set();
    for (const val of staticValues) {
      const props = TailwindMapper.mapTailwindClassesToCssProperties(val);
      if (props.size === 0) {
        dynamicAttributes.add("className");
        return true;
      }
      props.forEach((p) => allProps.add(p));
    }
    allProps.forEach((p) => dynamicAttributes.add(p));
    return true;
  }
  collectAllStaticStringLiterals(expr, out) {
    if (expr.isStringLiteral()) {
      out.add(expr.node.value);
      return true;
    }
    if (expr.isConditionalExpression()) {
      const consequent = expr.get("consequent");
      const alternate = expr.get("alternate");
      return this.collectAllStaticStringLiterals(consequent, out) && this.collectAllStaticStringLiterals(alternate, out);
    }
    return false;
  }
  handleTernaryExpression(expressionPath, dynamicAttributes) {
    if (!expressionPath.isConditionalExpression()) return false;
    const { consequent, alternate } = expressionPath.node;
    if (this.types.isStringLiteral(consequent) && this.types.isStringLiteral(alternate)) {
      const consequentProps = TailwindMapper.mapTailwindClassesToCssProperties(consequent.value);
      const alternateProps = TailwindMapper.mapTailwindClassesToCssProperties(alternate.value);
      if (consequentProps.size > 0 && alternateProps.size > 0) {
        consequentProps.forEach((prop) => dynamicAttributes.add(prop));
        alternateProps.forEach((prop) => dynamicAttributes.add(prop));
      } else {
        dynamicAttributes.add("className");
      }
      return true;
    }
    return false;
  }
  handleLogicalExpression(expressionPath, dynamicAttributes) {
    if (!expressionPath.isLogicalExpression() || expressionPath.node.operator !== "&&") {
      return false;
    }
    const right = expressionPath.node.right;
    if (this.types.isStringLiteral(right)) {
      this.addTailwindOrClassName(right.value, dynamicAttributes);
      return true;
    }
    return false;
  }
  handleBinaryExpression(expressionPath, dynamicAttributes) {
    if (!expressionPath.isBinaryExpression() || expressionPath.node.operator !== "+") {
      return false;
    }
    const right = expressionPath.node.right;
    if (this.types.isStringLiteral(right)) {
      this.addTailwindOrClassName(right.value, dynamicAttributes);
      return true;
    }
    return false;
  }
  addTailwindOrClassName(value, dynamicAttributes) {
    const props = TailwindMapper.mapTailwindClassesToCssProperties(value);
    if (props.size > 0) {
      props.forEach((prop) => dynamicAttributes.add(prop));
    } else {
      dynamicAttributes.add("className");
    }
  }
  checkForDynamicChildren(path, dynamicAttributes) {
    const parentElement = path.parentPath;
    if (!parentElement?.isJSXElement()) return;
    const children = parentElement.get("children");
    let hasStaticText = false;
    let hasDynamicExpression = false;
    for (const childPath of children) {
      if (childPath.isJSXText()) {
        const text = childPath.node.value.trim();
        if (text.length > 0) {
          hasStaticText = true;
        }
      } else if (childPath.isJSXExpressionContainer()) {
        const expression = childPath.get("expression");
        if (expression.node && !this.types.isJSXEmptyExpression(expression.node) && expression.isExpression()) {
          if (this.isDynamicExpression(expression) && !this.producesJSX(expression)) {
            hasDynamicExpression = true;
          }
          this.processAllJSXElementsInExpression(expression);
        }
      } else if (childPath.isJSXElement() || childPath.isJSXFragment()) {
        this.processAllJSXElementsInExpression(childPath);
      }
    }
    if (hasStaticText && hasDynamicExpression) {
      dynamicAttributes.add("text-composition");
    } else if (hasDynamicExpression) {
      dynamicAttributes.add("text");
    }
  }
  isDynamicExpression(expressionPath) {
    const dynamicTypes = [
      "Identifier",
      "MemberExpression",
      "CallExpression",
      "BinaryExpression",
      "ConditionalExpression",
      "LogicalExpression",
      "ArrayExpression",
      "ObjectExpression"
    ];
    if (dynamicTypes.includes(expressionPath.node.type)) return true;
    return expressionPath.isTemplateLiteral() && expressionPath.node.expressions.length > 0;
  }
  producesJSX(expressionPath) {
    if (expressionPath.isJSXElement() || expressionPath.isJSXFragment()) return true;
    if (expressionPath.isConditionalExpression()) {
      const consequent = expressionPath.get("consequent");
      const alternate = expressionPath.get("alternate");
      return consequent.isJSXElement() || consequent.isJSXFragment() || (alternate.isJSXElement() || alternate.isJSXFragment());
    }
    if (expressionPath.isLogicalExpression()) {
      const right = expressionPath.get("right");
      return right.isJSXElement() || right.isJSXFragment();
    }
    return expressionPath.isCallExpression() && this.isJSXProducingCall(expressionPath);
  }
  isJSXProducingCall(callExpr) {
    const callee = callExpr.get("callee");
    if (!callee.isMemberExpression()) return false;
    const property = callee.get("property");
    if (!property.isIdentifier() || !["map", "flatMap"].includes(property.node.name)) {
      return false;
    }
    const args = callExpr.get("arguments");
    const callback = args[0];
    if (!callback?.isFunction()) return false;
    const body = callback.get("body");
    if (body.isJSXElement() || body.isJSXFragment()) return true;
    if (body.isBlockStatement()) {
      let returnsJSX = false;
      body.traverse({
        noScope: true,
        ReturnStatement(returnPath) {
          const arg = returnPath.get("argument");
          if (arg.isJSXElement() || arg.isJSXFragment()) {
            returnsJSX = true;
            returnPath.stop();
          }
        },
        Function(funcPath) {
          funcPath.skip();
        }
      });
      return returnsJSX;
    }
    return false;
  }
  addDataDynamicAttribute(path, dynamicAttributes) {
    const elementName = JSXUtils.extractElementName(path.node.name);
    if (JSXUtils.isCustomComponent(elementName) && !JSXUtils.isAllowedCustomComponent(elementName)) {
      return;
    }
    if (this.hasIgnoredAttributes(path)) {
      return;
    }
    const hasExisting = path.node.attributes.some(
      (attr) => this.types.isJSXAttribute(attr) && JSXUtils.getAttributeName(attr) === DATA_DYNAMIC_ATTRIBUTE
    );
    if (!hasExisting) {
      const sortedAttrs = Array.from(dynamicAttributes).sort();
      path.node.attributes.push(
        this.types.jsxAttribute(
          this.types.jsxIdentifier(DATA_DYNAMIC_ATTRIBUTE),
          this.types.stringLiteral(sortedAttrs.join(" "))
        )
      );
    }
  }
  hasIgnoredAttributes(path) {
    const ignoredAttributes = new Set(IGNORED_ATTRIBUTES);
    return path.node.attributes.some((attr) => {
      if (this.types.isJSXAttribute(attr)) {
        const attrName = JSXUtils.getAttributeName(attr);
        return ignoredAttributes.has(attrName);
      }
      return false;
    });
  }
  processJSXSpreadAttribute(attrPath, dynamicAttributes) {
    const spreadArg = attrPath.get("argument");
    const objectExpr = this.resolveObjectExpression(spreadArg);
    if (!objectExpr) {
      dynamicAttributes.add("className");
      return;
    }
    const properties = objectExpr.get("properties");
    for (const propPath of properties) {
      if (propPath.isObjectProperty()) {
        const attrName = this.getObjectPropertyKey(propPath.node);
        if (attrName && attrName !== "key" && !JSXUtils.isEventHandler(attrName)) {
          const valuePath = propPath.get("value");
          if (this.isDynamicExpression(valuePath)) {
            dynamicAttributes.add(attrName);
          }
        }
      }
    }
  }
  resolveObjectExpression(path) {
    if (path.isObjectExpression()) return path;
    if (path.isIdentifier()) {
      const binding = path.scope.getBinding(path.node.name);
      if (binding?.path.isVariableDeclarator()) {
        const init = binding.path.get("init");
        if (init.isObjectExpression()) return init;
      }
    }
    return null;
  }
  getObjectPropertyKey(property) {
    if (this.types.isIdentifier(property.key) && !property.computed) {
      return property.key.name;
    }
    if (this.types.isStringLiteral(property.key)) {
      return property.key.value;
    }
    return null;
  }
  // Recursively process all JSX elements inside an expression (e.g., in .map, ternary, etc.)
  processAllJSXElementsInExpression(expressionPath) {
    if (this.types.isJSXElement(expressionPath.node)) {
      const openingElement = expressionPath.get("openingElement");
      this.processJSXElement(openingElement);
      const children = expressionPath.get("children");
      for (const child of children) {
        if (child.isJSXElement() || child.isJSXFragment()) {
          this.processAllJSXElementsInExpression(child);
        } else if (child.isJSXExpressionContainer()) {
          const expr = child.get("expression");
          if (expr && expr.node && expr.isExpression()) {
            this.processAllJSXElementsInExpression(expr);
          }
        }
      }
    } else if (expressionPath.isConditionalExpression()) {
      const consequent = expressionPath.get("consequent");
      const alternate = expressionPath.get("alternate");
      this.processAllJSXElementsInExpression(consequent);
      this.processAllJSXElementsInExpression(alternate);
    } else if (expressionPath.isLogicalExpression()) {
      const right = expressionPath.get("right");
      this.processAllJSXElementsInExpression(right);
    } else if (expressionPath.isCallExpression()) {
      if (this.isJSXProducingCall(expressionPath)) {
        const args = expressionPath.get("arguments");
        const callback = args[0];
        if (callback?.isFunction()) {
          const body = callback.get("body");
          if (body.isJSXElement() || body.isJSXFragment()) {
            this.processAllJSXElementsInExpression(body);
          }
          if (body.isBlockStatement()) {
            body.traverse({
              ReturnStatement: (returnPath) => {
                const arg = returnPath.get("argument");
                if (arg.isJSXElement() || arg.isJSXFragment()) {
                  this.processAllJSXElementsInExpression(arg);
                }
              },
              Function(funcPath) {
                funcPath.skip();
              }
            });
          }
        }
      }
    }
  }
};

// src/index.ts
var BabelPluginJsxDynamicData = class {
  constructor(types) {
    this.types = types;
    this.componentUsageMap = /* @__PURE__ */ new Map();
    this.componentInfoMap = /* @__PURE__ */ new Map();
    JSXUtils.init(types);
    this.componentAnalyzer = new ComponentAnalyzer(types);
    this.jsxProcessor = new JSXProcessor(types);
  }
  createPlugin() {
    return {
      name: "babel-plugin-jsx-dynamic-data",
      visitor: {
        Program: (path) => {
          this.processProgram(path);
        }
      }
    };
  }
  processProgram(path) {
    this.collectComponentInformation(path);
    this.processQualifiedComponents();
    this.resetState();
  }
  collectComponentInformation(path) {
    path.traverse({
      noScope: true,
      JSXOpeningElement: (jsxPath) => {
        const elementName = JSXUtils.extractElementName(jsxPath.node.name);
        if (JSXUtils.isCustomComponent(elementName)) {
          this.componentUsageMap.set(elementName, true);
        }
      }
    });
    path.traverse({
      noScope: true,
      FunctionDeclaration: (funcPath) => {
        const componentName = funcPath.node.id?.name;
        if (componentName && JSXUtils.isCustomComponent(componentName)) {
          this.addComponentInfo(componentName, funcPath, funcPath);
        }
      },
      VariableDeclarator: (varPath) => {
        const componentInfo = this.extractVariableComponentInfo(varPath);
        if (componentInfo) {
          this.addComponentInfo(
            componentInfo.name,
            componentInfo.funcPath,
            componentInfo.declarationPath
          );
        }
      }
    });
  }
  extractVariableComponentInfo(varPath) {
    const id = varPath.get("id");
    const init = varPath.get("init");
    if (!id.isIdentifier() || !JSXUtils.isCustomComponent(id.node.name)) {
      return null;
    }
    if (!init.isArrowFunctionExpression() && !init.isFunctionExpression()) {
      return null;
    }
    const declarationPath = varPath.parentPath;
    if (!declarationPath?.isVariableDeclaration()) {
      return null;
    }
    return {
      name: id.node.name,
      funcPath: init,
      declarationPath
    };
  }
  addComponentInfo(name, funcPath, declarationPath) {
    this.componentInfoMap.set(name, {
      name,
      path: funcPath,
      declarationPath,
      isUsedAsJSX: this.componentUsageMap.get(name) || false
    });
  }
  processQualifiedComponents() {
    for (const componentInfo of this.componentInfoMap.values()) {
      if (this.shouldProcessComponent(componentInfo)) {
        this.processComponent(componentInfo);
      }
    }
  }
  shouldProcessComponent(componentInfo) {
    const returnsJSX = this.componentAnalyzer.returnsJSX(componentInfo.path);
    return returnsJSX;
  }
  processComponent(componentInfo) {
    componentInfo.path.traverse({
      JSXOpeningElement: (jsxPath) => {
        this.processJSXElement(jsxPath);
      }
    });
  }
  processJSXElement(path) {
    this.jsxProcessor.processJSXElement(path);
  }
  resetState() {
    this.componentUsageMap.clear();
    this.componentInfoMap.clear();
  }
};
function babelPluginJsxDynamicData({ types }) {
  const plugin = new BabelPluginJsxDynamicData(types);
  return plugin.createPlugin();
}
export {
  babelPluginJsxDynamicData as default
};
//# sourceMappingURL=index.mjs.map