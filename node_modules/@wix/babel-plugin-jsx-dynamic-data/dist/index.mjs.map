{"version":3,"sources":["../src/jsx-utils.ts","../src/component-analyzer.ts","../src/tailwind-mapper.ts","../src/consts.ts","../src/jsx-processor.ts","../src/index.ts"],"sourcesContent":["import type { NodePath } from '@babel/core';\nimport type * as t from '@babel/types';\nimport type { JSXElementName } from './types';\n\nexport class JSXUtils {\n  private static types: typeof t;\n\n  private static readonly ALLOWED_CUSTOM_COMPONENTS = new Set([\n    'Image',\n    'Link'\n  ]);\n\n  static init(types: typeof t) {\n    this.types = types;\n  }\n\n  static isCustomComponent(elementName: string): boolean {\n    return /^[A-Z]/.test(elementName);\n  }\n\n  static isAllowedCustomComponent(elementName: string): boolean {\n    return this.ALLOWED_CUSTOM_COMPONENTS.has(elementName);\n  }\n\n  static extractElementName(name: JSXElementName): string {\n    if (this.types.isJSXIdentifier(name)) {\n      return name.name;\n    }\n    \n    if (this.types.isJSXNamespacedName(name)) {\n      return name.name.name;\n    }\n    \n    if (this.types.isJSXMemberExpression(name)) {\n      const parts: string[] = [];\n      let current: t.JSXMemberExpression | t.JSXIdentifier = name;\n      \n      while (this.types.isJSXMemberExpression(current)) {\n        parts.unshift(current.property.name);\n        current = current.object;\n      }\n      parts.unshift(current.name);\n      \n      return parts.join('.');\n    }\n    \n    return '';\n  }\n\n  static isEventHandler(attributeName: string): boolean {\n    return /^on[A-Z]/.test(attributeName);\n  }\n\n  static getAttributeName(attr: t.JSXAttribute): string {\n    return this.types.isJSXNamespacedName(attr.name)\n      ? `${attr.name.namespace.name}:${attr.name.name.name}`\n      : attr.name.name;\n  }\n\n  static isInsideCustomComponent(path: NodePath<t.JSXOpeningElement>): boolean {\n    let current = path.parentPath;\n    \n    while (current?.isJSXElement()) {\n      const parentElement = current.node as t.JSXElement;\n      const parentName = this.extractElementName(parentElement.openingElement.name);\n      \n      if (this.isCustomComponent(parentName)) return true;\n      current = current.parentPath;\n    }\n    \n    return false;\n  }\n} ","import type { NodePath } from '@babel/core';\nimport type * as t from '@babel/types';\n\nexport class ComponentAnalyzer {\n  constructor(private types: typeof t) {}\n\n  returnsJSX(componentPath: NodePath<t.FunctionDeclaration | t.ArrowFunctionExpression | t.FunctionExpression>): boolean {\n    const bodyPath = componentPath.get(\"body\");\n    \n    if (bodyPath.isJSXElement() || bodyPath.isJSXFragment()) return true;\n    \n    if (bodyPath.isBlockStatement()) {\n      return this.hasJSXReturn(bodyPath);\n    }\n    \n    return false;\n  }\n\n  private hasJSXReturn(bodyPath: NodePath<t.BlockStatement>): boolean {\n    let hasJSXReturn = false;\n    \n    bodyPath.traverse({\n      ReturnStatement(returnPath: NodePath<t.ReturnStatement>) {\n        const argPath = returnPath.get(\"argument\");\n        if (argPath.isJSXElement() || argPath.isJSXFragment()) {\n          hasJSXReturn = true;\n          returnPath.stop();\n        }\n      },\n      Function(innerFuncPath: NodePath<t.Function>) {\n        innerFuncPath.skip();\n      }\n    });\n    \n    return hasJSXReturn;\n  }\n\n  isComponentExported(\n    declarationPath: NodePath<t.FunctionDeclaration | t.VariableDeclaration>,\n    componentName: string\n  ): boolean {\n    // Check direct export first (most common case)\n    if (declarationPath.parentPath?.isExportDefaultDeclaration() ||\n        declarationPath.parentPath?.isExportNamedDeclaration()) {\n      return true;\n    }\n\n    // Check for indirect exports\n    return this.hasIndirectExport(declarationPath, componentName);\n  }\n\n  private hasIndirectExport(\n    declarationPath: NodePath<t.FunctionDeclaration | t.VariableDeclaration>,\n    componentName: string\n  ): boolean {\n    const programPath = declarationPath.scope.getProgramParent().path as NodePath<t.Program>;\n    let isExported = false;\n    \n    programPath.traverse({\n      noScope: true,\n      ExportSpecifier: (specifierPath: NodePath<t.ExportSpecifier>) => {\n        if (this.types.isIdentifier(specifierPath.node.local) && \n            specifierPath.node.local.name === componentName) {\n          isExported = true;\n          specifierPath.stop();\n        }\n      },\n      ExportDefaultDeclaration: (exportPath: NodePath<t.ExportDefaultDeclaration>) => {\n        if (this.types.isIdentifier(exportPath.node.declaration) && \n            exportPath.node.declaration.name === componentName) {\n          isExported = true;\n          exportPath.stop();\n        }\n      }\n    });\n    \n    return isExported;\n  }\n} ","export class TailwindMapper {\n  private static readonly tailwindToCssMap = new Map<RegExp, string[]>([\n    // Background\n    [/^bg-/, ['background-color']],\n    \n    // Padding\n    [/^p-(\\d+|px|auto|\\[.*\\])$/, ['padding']],\n    [/^px-(\\d+|px|auto|\\[.*\\])$/, ['padding-left', 'padding-right']],\n    [/^py-(\\d+|px|auto|\\[.*\\])$/, ['padding-top', 'padding-bottom']],\n    [/^pt-(\\d+|px|auto|\\[.*\\])$/, ['padding-top']],\n    [/^pr-(\\d+|px|auto|\\[.*\\])$/, ['padding-right']],\n    [/^pb-(\\d+|px|auto|\\[.*\\])$/, ['padding-bottom']],\n    [/^pl-(\\d+|px|auto|\\[.*\\])$/, ['padding-left']],\n    \n    // Margin\n    [/^m-(\\d+|px|auto|\\[.*\\])$/, ['margin']],\n    [/^mx-(\\d+|px|auto|\\[.*\\])$/, ['margin-left', 'margin-right']],\n    [/^my-(\\d+|px|auto|\\[.*\\])$/, ['margin-top', 'margin-bottom']],\n    [/^mt-(\\d+|px|auto|\\[.*\\])$/, ['margin-top']],\n    [/^mr-(\\d+|px|auto|\\[.*\\])$/, ['margin-right']],\n    [/^mb-(\\d+|px|auto|\\[.*\\])$/, ['margin-bottom']],\n    [/^ml-(\\d+|px|auto|\\[.*\\])$/, ['margin-left']],\n    \n    // Text and Font\n    [/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/, ['font-size', 'line-height']],\n    [/^text-/, ['color']], // This should come after text-size patterns\n    [/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/, ['font-weight']],\n    [/^font-/, ['font-family']],\n    [/^leading-/, ['line-height']],\n    [/^tracking-/, ['letter-spacing']],\n    \n    // Width and Height\n    [/^w-/, ['width']],\n    [/^h-/, ['height']],\n    [/^min-w-/, ['min-width']],\n    [/^min-h-/, ['min-height']],\n    [/^max-w-/, ['max-width']],\n    [/^max-h-/, ['max-height']],\n    \n    // Display\n    [/^(block|inline-block|inline|flex|inline-flex|table|inline-table|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row-group|table-row|flow-root|grid|inline-grid|contents|list-item|hidden)$/, ['display']],\n    \n    // Flexbox\n    [/^flex-/, ['flex']],\n    [/^flex$/, ['display']],\n    [/^justify-/, ['justify-content']],\n    [/^items-/, ['align-items']],\n    [/^self-/, ['align-self']],\n    [/^content-/, ['align-content']],\n    \n    // Grid\n    [/^grid-cols-/, ['grid-template-columns']],\n    [/^grid-rows-/, ['grid-template-rows']],\n    [/^grid/, ['display']],\n    [/^col-/, ['grid-column']],\n    [/^row-/, ['grid-row']],\n    [/^gap-/, ['gap']],\n    \n    // Position\n    [/^(static|fixed|absolute|relative|sticky)$/, ['position']],\n    [/^(top|right|bottom|left)-/, ['top', 'right', 'bottom', 'left']],\n    [/^inset-/, ['top', 'right', 'bottom', 'left']],\n    [/^z-/, ['z-index']],\n    \n    // Border\n    [/^border$/, ['border-width']],\n    [/^border-/, ['border-color', 'border-width', 'border-style']],\n    [/^rounded/, ['border-radius']],\n    \n    // Shadow\n    [/^shadow/, ['box-shadow']],\n    [/^drop-shadow/, ['filter']],\n    \n    // Opacity\n    [/^opacity-/, ['opacity']],\n    \n    // Transform\n    [/^(scale|rotate|translate|skew)-/, ['transform']],\n    [/^transform/, ['transform']],\n    \n    // Transition\n    [/^transition/, ['transition']],\n    [/^duration-/, ['transition-duration']],\n    [/^ease-/, ['transition-timing-function']],\n    [/^delay-/, ['transition-delay']],\n    \n    // Animation\n    [/^animate-/, ['animation']],\n    \n    // Overflow\n    [/^overflow/, ['overflow']],\n    \n    // Cursor\n    [/^cursor-/, ['cursor']],\n    \n    // Select\n    [/^select-/, ['user-select']],\n    \n    // Pointer Events\n    [/^pointer-events-/, ['pointer-events']],\n    \n    // Visibility\n    [/^(visible|invisible)$/, ['visibility']],\n  ]);\n\n  static mapTailwindClassesToCssProperties(classNames: string): Set<string> {\n    const cssProperties = new Set<string>();\n    \n    if (!classNames.trim()) {\n      return cssProperties;\n    }\n    \n    const classes = classNames.split(/\\s+/).filter(cls => cls.length > 0);\n    \n    for (const className of classes) {\n      for (const [pattern, properties] of this.tailwindToCssMap) {\n        if (pattern.test(className)) {\n          properties.forEach(prop => cssProperties.add(prop));\n          break; // Use first match to avoid overlapping patterns\n        }\n      }\n    }\n    \n    return cssProperties;\n  }\n} ","export const IGNORED_ATTRIBUTES = new Set([\n  'initial',\n  'animate',\n  'transition',\n]);","import type { NodePath } from '@babel/core';\nimport type * as t from '@babel/types';\nimport { JSXUtils } from './jsx-utils';\nimport { TailwindMapper } from './tailwind-mapper';\nimport { IGNORED_ATTRIBUTES } from './consts';\n\nconst DATA_DYNAMIC_ATTRIBUTE = 'data-dynamic';\n\nexport class JSXProcessor {\n  constructor(private types: typeof t) {}\n\n  processJSXElement(path: NodePath<t.JSXOpeningElement>): void {\n    const dynamicAttributes = this.collectDynamicAttributes(path);\n    this.checkForDynamicChildren(path, dynamicAttributes);\n    \n    // Remove 'key' attribute from dynamic attributes\n    dynamicAttributes.delete('key');\n    \n    if (dynamicAttributes.size > 0) {\n      this.addDataDynamicAttribute(path, dynamicAttributes);\n    }\n  }\n\n  private collectDynamicAttributes(path: NodePath<t.JSXOpeningElement>): Set<string> {\n    const dynamicAttributes = new Set<string>();\n    const attributes = path.get('attributes') as NodePath<t.JSXAttribute | t.JSXSpreadAttribute>[];\n\n    for (const attrPath of attributes) {\n      if (attrPath.isJSXAttribute()) {\n        this.processJSXAttribute(attrPath, dynamicAttributes);\n      } else if (attrPath.isJSXSpreadAttribute()) {\n        this.processJSXSpreadAttribute(attrPath, dynamicAttributes);\n      }\n    }\n\n    return dynamicAttributes;\n  }\n\n  private processJSXAttribute(\n    attrPath: NodePath<t.JSXAttribute>,\n    dynamicAttributes: Set<string>\n  ): void {\n    const attributeName = JSXUtils.getAttributeName(attrPath.node);\n    \n    // Skip non-dynamic attributes\n    if (attributeName === 'key' || JSXUtils.isEventHandler(attributeName) || \n        !attrPath.node.value || !this.types.isJSXExpressionContainer(attrPath.node.value)) {\n      return;\n    }\n\n    const expressionPath = attrPath.get('value.expression') as NodePath<t.Expression>;\n    if (!this.isDynamicExpression(expressionPath)) return;\n\n    // Handle special attributes\n    if (attributeName === 'dangerouslySetInnerHTML') {\n      dynamicAttributes.add('text');\n    } else if (attributeName === 'className' || attributeName === 'tw') {\n      this.handleClassNameAttribute(expressionPath, dynamicAttributes);\n    } else {\n      dynamicAttributes.add(attributeName);\n    }\n  }\n\n  private handleClassNameAttribute(\n    expressionPath: NodePath<t.Expression>,\n    dynamicAttributes: Set<string>\n  ): void {\n    // Handle nested ternary static values with Tailwind mapping\n    if (expressionPath.isConditionalExpression() && \n        this.handleStaticTernaryClasses(expressionPath, dynamicAttributes)) {\n      return;\n    }\n\n    // Handle different expression types\n    const handlers = [\n      () => this.handleTernaryExpression(expressionPath, dynamicAttributes),\n      () => this.handleLogicalExpression(expressionPath, dynamicAttributes),\n      () => this.handleBinaryExpression(expressionPath, dynamicAttributes)\n    ];\n\n    for (const handler of handlers) {\n      if (handler()) return;\n    }\n\n    // Default fallback\n    dynamicAttributes.add('className');\n  }\n\n  private handleStaticTernaryClasses(\n    expressionPath: NodePath<t.ConditionalExpression>,\n    dynamicAttributes: Set<string>\n  ): boolean {\n    const staticValues = new Set<string>();\n    if (!this.collectAllStaticStringLiterals(expressionPath, staticValues) || staticValues.size === 0) {\n      return false;\n    }\n\n    // Check if all are Tailwind classes\n    const allProps = new Set<string>();\n    for (const val of staticValues) {\n      const props = TailwindMapper.mapTailwindClassesToCssProperties(val);\n      if (props.size === 0) {\n        dynamicAttributes.add('className');\n        return true;\n      }\n      props.forEach(p => allProps.add(p));\n    }\n\n    allProps.forEach(p => dynamicAttributes.add(p));\n    return true;\n  }\n\n  private collectAllStaticStringLiterals(\n    expr: NodePath<t.Expression>,\n    out: Set<string>\n  ): boolean {\n    if (expr.isStringLiteral()) {\n      out.add(expr.node.value);\n      return true;\n    }\n    \n    if (expr.isConditionalExpression()) {\n      const consequent = expr.get('consequent') as NodePath<t.Expression>;\n      const alternate = expr.get('alternate') as NodePath<t.Expression>;\n      return this.collectAllStaticStringLiterals(consequent, out) && \n             this.collectAllStaticStringLiterals(alternate, out);\n    }\n    \n    return false;\n  }\n\n  private handleTernaryExpression(\n    expressionPath: NodePath<t.Expression>,\n    dynamicAttributes: Set<string>\n  ): boolean {\n    if (!expressionPath.isConditionalExpression()) return false;\n\n    const { consequent, alternate } = expressionPath.node;\n    if (this.types.isStringLiteral(consequent) && this.types.isStringLiteral(alternate)) {\n      const consequentProps = TailwindMapper.mapTailwindClassesToCssProperties(consequent.value);\n      const alternateProps = TailwindMapper.mapTailwindClassesToCssProperties(alternate.value);\n      \n      if (consequentProps.size > 0 && alternateProps.size > 0) {\n        consequentProps.forEach(prop => dynamicAttributes.add(prop));\n        alternateProps.forEach(prop => dynamicAttributes.add(prop));\n      } else {\n        dynamicAttributes.add('className');\n      }\n      return true;\n    }\n    return false;\n  }\n\n  private handleLogicalExpression(\n    expressionPath: NodePath<t.Expression>,\n    dynamicAttributes: Set<string>\n  ): boolean {\n    if (!expressionPath.isLogicalExpression() || expressionPath.node.operator !== '&&') {\n      return false;\n    }\n\n    const right = expressionPath.node.right;\n    if (this.types.isStringLiteral(right)) {\n      this.addTailwindOrClassName(right.value, dynamicAttributes);\n      return true;\n    }\n    return false;\n  }\n\n  private handleBinaryExpression(\n    expressionPath: NodePath<t.Expression>,\n    dynamicAttributes: Set<string>\n  ): boolean {\n    if (!expressionPath.isBinaryExpression() || expressionPath.node.operator !== '+') {\n      return false;\n    }\n\n    const right = expressionPath.node.right;\n    if (this.types.isStringLiteral(right)) {\n      this.addTailwindOrClassName(right.value, dynamicAttributes);\n      return true;\n    }\n    return false;\n  }\n\n  private addTailwindOrClassName(value: string, dynamicAttributes: Set<string>): void {\n    const props = TailwindMapper.mapTailwindClassesToCssProperties(value);\n    if (props.size > 0) {\n      props.forEach(prop => dynamicAttributes.add(prop));\n    } else {\n      dynamicAttributes.add('className');\n    }\n  }\n\n  private checkForDynamicChildren(\n    path: NodePath<t.JSXOpeningElement>,\n    dynamicAttributes: Set<string>\n  ): void {\n    const parentElement = path.parentPath;\n    if (!parentElement?.isJSXElement()) return;\n\n    const children = parentElement.get('children') as NodePath<t.JSXText | t.JSXExpressionContainer | t.JSXSpreadChild | t.JSXElement | t.JSXFragment>[];\n    \n    let hasStaticText = false;\n    let hasDynamicExpression = false;\n    \n    for (const childPath of children) {\n      if (childPath.isJSXText()) {\n        const text = childPath.node.value.trim();\n        if (text.length > 0) {\n          hasStaticText = true;\n        }\n      } else if (childPath.isJSXExpressionContainer()) {\n        const expression = childPath.get('expression') as NodePath<t.Expression | t.JSXEmptyExpression>;\n        if (expression.node && !this.types.isJSXEmptyExpression(expression.node) && expression.isExpression()) {\n          if (this.isDynamicExpression(expression as NodePath<t.Expression>) && !this.producesJSX(expression as NodePath<t.Expression>)) {\n            hasDynamicExpression = true;\n          }\n          this.processAllJSXElementsInExpression(expression as NodePath<t.Expression>);\n        }\n      } else if (childPath.isJSXElement() || childPath.isJSXFragment()) {\n        this.processAllJSXElementsInExpression(childPath as NodePath<t.Expression>);\n      }\n    }\n    \n    if (hasStaticText && hasDynamicExpression) {\n      dynamicAttributes.add('text-composition');\n    } else if (hasDynamicExpression) {\n      dynamicAttributes.add('text');\n    }\n  }\n\n  private isDynamicExpression(expressionPath: NodePath<t.Expression>): boolean {\n    const dynamicTypes = [\n      'Identifier', 'MemberExpression', 'CallExpression', 'BinaryExpression',\n      'ConditionalExpression', 'LogicalExpression', 'ArrayExpression', 'ObjectExpression'\n    ];\n    \n    if (dynamicTypes.includes(expressionPath.node.type)) return true;\n    \n    // Template literal with expressions\n    return expressionPath.isTemplateLiteral() && expressionPath.node.expressions.length > 0;\n  }\n\n  private producesJSX(expressionPath: NodePath<t.Expression>): boolean {\n    if (expressionPath.isJSXElement() || expressionPath.isJSXFragment()) return true;\n\n    if (expressionPath.isConditionalExpression()) {\n      const consequent = expressionPath.get('consequent');\n      const alternate = expressionPath.get('alternate');\n      return (consequent.isJSXElement() || consequent.isJSXFragment()) ||\n             (alternate.isJSXElement() || alternate.isJSXFragment());\n    }\n\n    if (expressionPath.isLogicalExpression()) {\n      const right = expressionPath.get('right');\n      return right.isJSXElement() || right.isJSXFragment();\n    }\n\n    return expressionPath.isCallExpression() && this.isJSXProducingCall(expressionPath);\n  }\n\n  private isJSXProducingCall(callExpr: NodePath<t.CallExpression>): boolean {\n    const callee = callExpr.get('callee');\n    if (!callee.isMemberExpression()) return false;\n\n    const property = callee.get('property');\n    if (!property.isIdentifier() || !['map', 'flatMap'].includes(property.node.name)) {\n      return false;\n    }\n\n    const args = callExpr.get('arguments');\n    const callback = args[0];\n    if (!callback?.isFunction()) return false;\n\n    const body = callback.get('body');\n    if (body.isJSXElement() || body.isJSXFragment()) return true;\n\n    if (body.isBlockStatement()) {\n      let returnsJSX = false;\n      body.traverse({\n        noScope: true,\n        ReturnStatement(returnPath) {\n          const arg = returnPath.get('argument');\n          if (arg.isJSXElement() || arg.isJSXFragment()) {\n            returnsJSX = true;\n            returnPath.stop();\n          }\n        },\n        Function(funcPath) { funcPath.skip(); }\n      });\n      return returnsJSX;\n    }\n\n    return false;\n  }\n\n  private addDataDynamicAttribute(\n    path: NodePath<t.JSXOpeningElement>,\n    dynamicAttributes: Set<string>\n  ): void {\n    // Only add data-dynamic to primitive HTML elements\n    const elementName = JSXUtils.extractElementName(path.node.name);\n    if (JSXUtils.isCustomComponent(elementName) && !JSXUtils.isAllowedCustomComponent(elementName)) {\n      return;\n    }\n\n    if (this.hasIgnoredAttributes(path)) {\n      return;\n    }\n\n    const hasExisting = path.node.attributes.some(\n      attr => this.types.isJSXAttribute(attr) && \n              JSXUtils.getAttributeName(attr) === DATA_DYNAMIC_ATTRIBUTE\n    );\n    \n    if (!hasExisting) {\n      const sortedAttrs = Array.from(dynamicAttributes).sort();\n      path.node.attributes.push(\n        this.types.jsxAttribute(\n          this.types.jsxIdentifier(DATA_DYNAMIC_ATTRIBUTE),\n          this.types.stringLiteral(sortedAttrs.join(' '))\n        )\n      );\n    }\n  }\n\n  private hasIgnoredAttributes(path: NodePath<t.JSXOpeningElement>): boolean {\n    const ignoredAttributes = new Set(IGNORED_ATTRIBUTES);\n\n    return path.node.attributes.some(attr => {\n      if (this.types.isJSXAttribute(attr)) {\n        const attrName = JSXUtils.getAttributeName(attr);\n        return ignoredAttributes.has(attrName);\n      }\n      return false;\n    });\n  }\n\n  private processJSXSpreadAttribute(\n    attrPath: NodePath<t.JSXSpreadAttribute>,\n    dynamicAttributes: Set<string>\n  ): void {\n    const spreadArg = attrPath.get('argument') as NodePath<t.Expression>;\n    const objectExpr = this.resolveObjectExpression(spreadArg);\n    \n    if (!objectExpr) {\n      // If we can't resolve the object, assume it might have common dynamic attributes\n      dynamicAttributes.add('className');\n      return;\n    }\n\n    const properties = objectExpr.get('properties') as NodePath<t.ObjectMethod | t.ObjectProperty | t.SpreadElement>[];\n    \n    for (const propPath of properties) {\n      if (propPath.isObjectProperty()) {\n        const attrName = this.getObjectPropertyKey(propPath.node);\n        if (attrName && attrName !== 'key' && !JSXUtils.isEventHandler(attrName)) {\n          const valuePath = propPath.get('value') as NodePath<t.Expression>;\n          if (this.isDynamicExpression(valuePath)) {\n            dynamicAttributes.add(attrName);\n          }\n        }\n      }\n    }\n  }\n\n  private resolveObjectExpression(path: NodePath<t.Expression>): NodePath<t.ObjectExpression> | null {\n    if (path.isObjectExpression()) return path;\n    \n    if (path.isIdentifier()) {\n      const binding = path.scope.getBinding(path.node.name);\n      if (binding?.path.isVariableDeclarator()) {\n        const init = binding.path.get('init');\n        if (init.isObjectExpression()) return init;\n      }\n    }\n    \n    return null;\n  }\n\n  private getObjectPropertyKey(property: t.ObjectProperty): string | null {\n    if (this.types.isIdentifier(property.key) && !property.computed) {\n      return property.key.name;\n    }\n    if (this.types.isStringLiteral(property.key)) {\n      return property.key.value;\n    }\n    return null;\n  }\n\n  // Recursively process all JSX elements inside an expression (e.g., in .map, ternary, etc.)\n  private processAllJSXElementsInExpression(expressionPath: NodePath<t.Expression>): void {\n    if (this.types.isJSXElement(expressionPath.node)) {\n      const openingElement = (expressionPath as NodePath<t.JSXElement>).get('openingElement') as NodePath<t.JSXOpeningElement>;\n      this.processJSXElement(openingElement);\n      // Also process children recursively\n      const children = (expressionPath as NodePath<t.JSXElement>).get('children') as NodePath<any>[];\n      for (const child of children) {\n        if (child.isJSXElement() || child.isJSXFragment()) {\n          this.processAllJSXElementsInExpression(child as NodePath<t.Expression>);\n        } else if (child.isJSXExpressionContainer()) {\n          const expr = child.get('expression') as NodePath<t.Expression>;\n          if (expr && expr.node && expr.isExpression()) {\n            this.processAllJSXElementsInExpression(expr);\n          }\n        }\n      }\n    } else if (expressionPath.isConditionalExpression()) {\n      const consequent = expressionPath.get('consequent') as NodePath<t.Expression>;\n      const alternate = expressionPath.get('alternate') as NodePath<t.Expression>;\n      this.processAllJSXElementsInExpression(consequent);\n      this.processAllJSXElementsInExpression(alternate);\n    } else if (expressionPath.isLogicalExpression()) {\n      const right = expressionPath.get('right') as NodePath<t.Expression>;\n      this.processAllJSXElementsInExpression(right);\n    } else if (expressionPath.isCallExpression()) {\n      // Check for .map or .flatMap producing JSX\n      if (this.isJSXProducingCall(expressionPath)) {\n        const args = expressionPath.get('arguments');\n        const callback = args[0];\n        if (callback?.isFunction()) {\n          const body = callback.get('body');\n          if (body.isJSXElement() || body.isJSXFragment()) {\n            this.processAllJSXElementsInExpression(body as NodePath<t.Expression>);\n          }\n          if (body.isBlockStatement()) {\n            body.traverse({\n              ReturnStatement: (returnPath) => {\n                const arg = returnPath.get('argument');\n                if (arg.isJSXElement() || arg.isJSXFragment()) {\n                  this.processAllJSXElementsInExpression(arg as NodePath<t.Expression>);\n                }\n              },\n              Function(funcPath) { funcPath.skip(); }\n            });\n          }\n        }\n      }\n    }\n  }\n} ","import type * as t from '@babel/types';\nimport { JSXUtils } from './jsx-utils';\nimport { ComponentAnalyzer } from './component-analyzer';\nimport { JSXProcessor } from './jsx-processor';\nimport { NodePath, PluginObj } from '@babel/core';\n\ninterface ComponentInfo {\n  name: string;\n  path: NodePath<t.FunctionDeclaration | t.ArrowFunctionExpression | t.FunctionExpression>;\n  declarationPath: NodePath<t.FunctionDeclaration | t.VariableDeclaration>;\n  isUsedAsJSX: boolean;\n}\n\nclass BabelPluginJsxDynamicData {\n  private componentAnalyzer: ComponentAnalyzer;\n  private jsxProcessor: JSXProcessor;\n  private componentUsageMap = new Map<string, boolean>();\n  private componentInfoMap = new Map<string, ComponentInfo>();\n\n  constructor(private types: typeof t) {\n    JSXUtils.init(types);\n    this.componentAnalyzer = new ComponentAnalyzer(types);\n    this.jsxProcessor = new JSXProcessor(types);\n  }\n\n  createPlugin(): PluginObj {\n    return {\n      name: \"babel-plugin-jsx-dynamic-data\",\n      visitor: {\n        Program: (path: NodePath<t.Program>) => {\n          this.processProgram(path);\n        }\n      },\n    };\n  }\n\n  private processProgram(path: NodePath<t.Program>): void {\n    // Collect component information\n    this.collectComponentInformation(path);\n    \n    // Process qualified components\n    this.processQualifiedComponents();\n    \n    // Reset state for next file\n    this.resetState();\n  }\n\n  private collectComponentInformation(path: NodePath<t.Program>): void {\n    // Phase 1: Collect JSX usage information\n    path.traverse({\n      noScope: true,\n      JSXOpeningElement: (jsxPath: NodePath<t.JSXOpeningElement>) => {\n        const elementName = JSXUtils.extractElementName(jsxPath.node.name);\n        if (JSXUtils.isCustomComponent(elementName)) {\n          this.componentUsageMap.set(elementName, true);\n        }\n      }\n    });\n    \n    // Phase 2: Collect component declarations\n    path.traverse({\n      noScope: true,\n      FunctionDeclaration: (funcPath: NodePath<t.FunctionDeclaration>) => {\n        const componentName = funcPath.node.id?.name;\n        if (componentName && JSXUtils.isCustomComponent(componentName)) {\n          this.addComponentInfo(componentName, funcPath, funcPath);\n        }\n      },\n      \n      VariableDeclarator: (varPath: NodePath<t.VariableDeclarator>) => {\n        const componentInfo = this.extractVariableComponentInfo(varPath);\n        if (componentInfo) {\n          this.addComponentInfo(\n            componentInfo.name,\n            componentInfo.funcPath,\n            componentInfo.declarationPath\n          );\n        }\n      }\n    });\n  }\n\n  private extractVariableComponentInfo(varPath: NodePath<t.VariableDeclarator>) {\n    const id = varPath.get(\"id\");\n    const init = varPath.get(\"init\");\n    \n    if (!id.isIdentifier() || !JSXUtils.isCustomComponent(id.node.name)) {\n      return null;\n    }\n    \n    if (!init.isArrowFunctionExpression() && !init.isFunctionExpression()) {\n      return null;\n    }\n    \n    const declarationPath = varPath.parentPath;\n    if (!declarationPath?.isVariableDeclaration()) {\n      return null;\n    }\n    \n    return {\n      name: id.node.name,\n      funcPath: init as NodePath<t.ArrowFunctionExpression | t.FunctionExpression>,\n      declarationPath\n    };\n  }\n\n  private addComponentInfo(\n    name: string,\n    funcPath: NodePath<t.FunctionDeclaration | t.ArrowFunctionExpression | t.FunctionExpression>,\n    declarationPath: NodePath<t.FunctionDeclaration | t.VariableDeclaration>\n  ): void {\n    this.componentInfoMap.set(name, {\n      name,\n      path: funcPath,\n      declarationPath,\n      isUsedAsJSX: this.componentUsageMap.get(name) || false\n    });\n  }\n\n  private processQualifiedComponents(): void {\n    for (const componentInfo of this.componentInfoMap.values()) {\n      if (this.shouldProcessComponent(componentInfo)) {\n        this.processComponent(componentInfo);\n      }\n    }\n  }\n\n  private shouldProcessComponent(componentInfo: ComponentInfo): boolean {\n    // Check if component returns JSX - process all components that return JSX\n    const returnsJSX = this.componentAnalyzer.returnsJSX(componentInfo.path);\n    \n    return returnsJSX;\n  }\n\n  private processComponent(componentInfo: ComponentInfo): void {\n    // Process JSX elements within this component\n    componentInfo.path.traverse({\n      JSXOpeningElement: (jsxPath: NodePath<t.JSXOpeningElement>) => {\n        this.processJSXElement(jsxPath);\n      }\n    });\n  }\n\n  private processJSXElement(path: NodePath<t.JSXOpeningElement>): void {\n    // Process all JSX elements - JSXProcessor will handle whether to add data-dynamic\n    this.jsxProcessor.processJSXElement(path);\n  }\n\n  private resetState(): void {\n    this.componentUsageMap.clear();\n    this.componentInfoMap.clear();\n  }\n}\n\nexport default function babelPluginJsxDynamicData({ types }: { types: typeof t }): PluginObj {\n  const plugin = new BabelPluginJsxDynamicData(types);\n  return plugin.createPlugin();\n}"],"mappings":"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","names":[]}