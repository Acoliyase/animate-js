import { NonNullablePaths } from '@wix/sdk-types';

interface OnboardingAvailability {
    /**
     * ID of this entity
     * @format GUID
     * @readonly
     */
    _id?: string;
    /** Information about CBD specific flow. Will have DECLINED status if user is not in United States */
    cbdFlow?: CbdFlow;
    /** Information about all restricted goods user might sell. */
    restrictedGoodsFlow?: RestrictedGoodsFlow;
    /** Information about services Wix Partner sells. */
    partnerFlow?: PartnerFlow;
    /**
     * True, only if Wix Payments available to user due to the way account was created. False otherwise.
     * @readonly
     */
    wixPaymentsAvailable?: boolean;
}
interface CbdFlow {
    /**
     * Current status of CBD flow.
     * DECLINED - User does not sell CBD (or at least we do not know about it). Any payment service provider can be connected.
     * POSSIBLE - User possibly sells CBD and we should ask for confirmation. User still can connect Wix Payments.
     * CONFIRMED - User confirmed to sell CBD and now we should ask to complete attestation form. Only CBD providers can be connected. User can't connect Wix Payments.
     */
    status?: StatusWithLiterals;
    /** Information about completion of attestation form. Include date of signing. */
    attestationInfo?: AttestationInfo;
}
declare enum Status {
    UNDEFINED = "UNDEFINED",
    DECLINED = "DECLINED",
    POSSIBLE = "POSSIBLE",
    CONFIRMED = "CONFIRMED"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNDEFINED' | 'DECLINED' | 'POSSIBLE' | 'CONFIRMED';
interface AttestationInfo {
    /**
     * Date of signing attestation form (only if status is CONFIRMED)
     * @readonly
     */
    attestationFormSignedDate?: Date | null;
    /** True, if attestation form was signed. False otherwise. */
    formSigned?: boolean | null;
}
interface RestrictedGoodsFlow {
    /**
     * Current status of Restricted Goods flow.
     * DECLINED - User confirmed that they don't sell any restricted goods. User may connect Wix Payments.
     * CONFIRMED - User confirmed that they do sell restricted goods. User can't connect Wix Payments.
     */
    status?: RestrictedGoodsFlowStatusWithLiterals;
    /**
     * Contains detailed list of which restricted categories user sell.
     * @maxSize 30
     */
    categories?: RestrictedGoodsCategoryWithLiterals[];
}
declare enum RestrictedGoodsFlowStatus {
    UNDEFINED = "UNDEFINED",
    DECLINED = "DECLINED",
    CONFIRMED = "CONFIRMED"
}
/** @enumType */
type RestrictedGoodsFlowStatusWithLiterals = RestrictedGoodsFlowStatus | 'UNDEFINED' | 'DECLINED' | 'CONFIRMED';
declare enum RestrictedGoodsCategory {
    UNDEFINED = "UNDEFINED",
    TOBACCO_ALCOHOL = "TOBACCO_ALCOHOL",
    FIREARMS_WEAPONS = "FIREARMS_WEAPONS",
    ADULT = "ADULT",
    MEDICAL = "MEDICAL",
    FINANCIAL = "FINANCIAL",
    TRAVEL_AGENCIES = "TRAVEL_AGENCIES",
    GAMBLING_LOTTERIES_SKILL_GAMES = "GAMBLING_LOTTERIES_SKILL_GAMES",
    BINARY_OPTIONS_CRYPTOCURRENCIES = "BINARY_OPTIONS_CRYPTOCURRENCIES",
    MARKETPLACES = "MARKETPLACES",
    OTHER = "OTHER",
    CBD = "CBD",
    TOBACCO_E_CIGARETTES = "TOBACCO_E_CIGARETTES",
    ALCOHOL = "ALCOHOL",
    NUTRACEUTICALS = "NUTRACEUTICALS",
    MISLEADING_MARKETING = "MISLEADING_MARKETING",
    INTELLECTUAL_PROPERTY = "INTELLECTUAL_PROPERTY"
}
/** @enumType */
type RestrictedGoodsCategoryWithLiterals = RestrictedGoodsCategory | 'UNDEFINED' | 'TOBACCO_ALCOHOL' | 'FIREARMS_WEAPONS' | 'ADULT' | 'MEDICAL' | 'FINANCIAL' | 'TRAVEL_AGENCIES' | 'GAMBLING_LOTTERIES_SKILL_GAMES' | 'BINARY_OPTIONS_CRYPTOCURRENCIES' | 'MARKETPLACES' | 'OTHER' | 'CBD' | 'TOBACCO_E_CIGARETTES' | 'ALCOHOL' | 'NUTRACEUTICALS' | 'MISLEADING_MARKETING' | 'INTELLECTUAL_PROPERTY';
interface PartnerFlow {
    /**
     * Current status of Partner flow.
     * DECLINED - User sells only approved services and may connect Wix Payments.
     * CONFIRMED - User sells not approved services and can't connect Wix Payments.
     */
    status?: PartnerFlowStatusWithLiterals;
}
declare enum PartnerFlowStatus {
    UNDEFINED = "UNDEFINED",
    DECLINED = "DECLINED",
    CONFIRMED = "CONFIRMED"
}
/** @enumType */
type PartnerFlowStatusWithLiterals = PartnerFlowStatus | 'UNDEFINED' | 'DECLINED' | 'CONFIRMED';
interface GetOnboardingAvailabilityRequest {
}
interface GetOnboardingAvailabilityResponse {
    /** Current state of onboarding availability for the merchant. */
    onboardingAvailability?: OnboardingAvailability;
}
interface UpdateCbdFlowRequest {
    /** New state of CBD flow for merchant. */
    cbdFlow?: CbdFlow;
}
interface UpdateCbdFlowResponse {
    /** Current state of onboarding availability for the merchant. */
    onboardingAvailability?: OnboardingAvailability;
}
interface UpdateRestrictedGoodsFlowRequest {
    /** New state of restricted goods flow for merchant. */
    restrictedGoods?: RestrictedGoodsFlow;
}
interface UpdateRestrictedGoodsFlowResponse {
    /** Current state of onboarding availability for the merchant. */
    onboardingAvailability?: OnboardingAvailability;
}
interface UpdatePartnerFlowRequest {
    /** New state of partner flow for merchant. */
    partnerFlow?: PartnerFlow;
}
interface UpdatePartnerFlowResponse {
    /** Current state of onboarding availability for the merchant. */
    onboardingAvailability?: OnboardingAvailability;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface OnboardingAvailabilityCreatedEnvelope {
    entity: OnboardingAvailability;
    metadata: EventMetadata;
}
/** @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId CASHIER.ONBOARDING_AVAILABILITY_READ
 * @webhook
 * @eventType wix.cashier.onboarding_availability.v1.onboarding_availability_created
 * @serviceIdentifier wix.cashier.onboarding_availability.v1.OnboardingAvailabilityService
 * @slug created
 * @documentationMaturity preview
 */
declare function onOnboardingAvailabilityCreated(handler: (event: OnboardingAvailabilityCreatedEnvelope) => void | Promise<void>): void;
interface OnboardingAvailabilityUpdatedEnvelope {
    entity: OnboardingAvailability;
    metadata: EventMetadata;
}
/** @permissionScope Manage Stores
 * @permissionScopeId SCOPE.STORES.MANAGE-STORES
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId CASHIER.ONBOARDING_AVAILABILITY_READ
 * @webhook
 * @eventType wix.cashier.onboarding_availability.v1.onboarding_availability_updated
 * @serviceIdentifier wix.cashier.onboarding_availability.v1.OnboardingAvailabilityService
 * @slug updated
 * @documentationMaturity preview
 */
declare function onOnboardingAvailabilityUpdated(handler: (event: OnboardingAvailabilityUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Fetch current state of onboarding availability for meta site.
 * @public
 * @documentationMaturity preview
 * @permissionId CASHIER.ONBOARDING_AVAILABILITY_READ
 * @applicableIdentity APP
 * @fqn wix.cashier.onboarding_availability.v1.OnboardingAvailabilityService.GetOnboardingAvailability
 */
declare function getOnboardingAvailability(): Promise<NonNullablePaths<GetOnboardingAvailabilityResponse, `onboardingAvailability._id` | `onboardingAvailability.cbdFlow.status` | `onboardingAvailability.restrictedGoodsFlow.status` | `onboardingAvailability.restrictedGoodsFlow.categories` | `onboardingAvailability.partnerFlow.status` | `onboardingAvailability.wixPaymentsAvailable`, 4>>;
/**
 * Update current state of CBD flow for meta site.
 * @public
 * @documentationMaturity preview
 * @permissionId CASHIER.ONBOARDING_AVAILABILITY_UPDATE_CBD_FLOW
 * @applicableIdentity APP
 * @fqn wix.cashier.onboarding_availability.v1.OnboardingAvailabilityService.UpdateCbdFlow
 */
declare function updateCbdFlow(options?: UpdateCbdFlowOptions): Promise<NonNullablePaths<UpdateCbdFlowResponse, `onboardingAvailability._id` | `onboardingAvailability.cbdFlow.status` | `onboardingAvailability.restrictedGoodsFlow.status` | `onboardingAvailability.restrictedGoodsFlow.categories` | `onboardingAvailability.partnerFlow.status` | `onboardingAvailability.wixPaymentsAvailable`, 4>>;
interface UpdateCbdFlowOptions {
    /** New state of CBD flow for merchant. */
    cbdFlow?: CbdFlow;
}
/**
 * Update current state of Restricted Goods flow for meta site.
 * @public
 * @documentationMaturity preview
 * @permissionId CASHIER.ONBOARDING_AVAILABILITY_UPDATE_RG_FLOW
 * @applicableIdentity APP
 * @fqn wix.cashier.onboarding_availability.v1.OnboardingAvailabilityService.UpdateRestrictedGoodsFlow
 */
declare function updateRestrictedGoodsFlow(options?: UpdateRestrictedGoodsFlowOptions): Promise<NonNullablePaths<UpdateRestrictedGoodsFlowResponse, `onboardingAvailability._id` | `onboardingAvailability.cbdFlow.status` | `onboardingAvailability.restrictedGoodsFlow.status` | `onboardingAvailability.restrictedGoodsFlow.categories` | `onboardingAvailability.partnerFlow.status` | `onboardingAvailability.wixPaymentsAvailable`, 4>>;
interface UpdateRestrictedGoodsFlowOptions {
    /** New state of restricted goods flow for merchant. */
    restrictedGoods?: RestrictedGoodsFlow;
}
/**
 * Update current state of partner flow for meta site.
 * @public
 * @documentationMaturity preview
 * @permissionId CASHIER.ONBOARDING_AVAILABILITY_UPDATE_PARTNER_FLOW
 * @applicableIdentity APP
 * @fqn wix.cashier.onboarding_availability.v1.OnboardingAvailabilityService.UpdatePartnerFlow
 */
declare function updatePartnerFlow(options?: UpdatePartnerFlowOptions): Promise<NonNullablePaths<UpdatePartnerFlowResponse, `onboardingAvailability._id` | `onboardingAvailability.cbdFlow.status` | `onboardingAvailability.restrictedGoodsFlow.status` | `onboardingAvailability.restrictedGoodsFlow.categories` | `onboardingAvailability.partnerFlow.status` | `onboardingAvailability.wixPaymentsAvailable`, 4>>;
interface UpdatePartnerFlowOptions {
    /** New state of partner flow for merchant. */
    partnerFlow?: PartnerFlow;
}

export { type ActionEvent, type AttestationInfo, type BaseEventMetadata, type CbdFlow, type DomainEvent, type DomainEventBodyOneOf, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type GetOnboardingAvailabilityRequest, type GetOnboardingAvailabilityResponse, type IdentificationData, type IdentificationDataIdOneOf, type MessageEnvelope, type OnboardingAvailability, type OnboardingAvailabilityCreatedEnvelope, type OnboardingAvailabilityUpdatedEnvelope, type PartnerFlow, PartnerFlowStatus, type PartnerFlowStatusWithLiterals, type RestoreInfo, RestrictedGoodsCategory, type RestrictedGoodsCategoryWithLiterals, type RestrictedGoodsFlow, RestrictedGoodsFlowStatus, type RestrictedGoodsFlowStatusWithLiterals, Status, type StatusWithLiterals, type UpdateCbdFlowOptions, type UpdateCbdFlowRequest, type UpdateCbdFlowResponse, type UpdatePartnerFlowOptions, type UpdatePartnerFlowRequest, type UpdatePartnerFlowResponse, type UpdateRestrictedGoodsFlowOptions, type UpdateRestrictedGoodsFlowRequest, type UpdateRestrictedGoodsFlowResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, getOnboardingAvailability, onOnboardingAvailabilityCreated, onOnboardingAvailabilityUpdated, updateCbdFlow, updatePartnerFlow, updateRestrictedGoodsFlow };
