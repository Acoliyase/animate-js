import Long from 'long';
import { ValidationType } from '../domain';
import { CONSTANT_VALUES, FORMAT_VALUES } from './constant-values';
import { ValidationExtractor } from './validation-extractor';
import { applyScale, decrement, generatorTypeToFunctionName, increment, padArray, typeToGeneratorType, wrapperToBusinessSchemaType, } from './value-generator-utils';
export function getGeneratorTypeForField(field) {
    return typeToGeneratorType(getTypeForGenerator(field));
}
export function getGeneratorTypeForFieldType(filedType) {
    return typeToGeneratorType(filedType);
}
export function someString(_a) {
    var _b;
    var _c = _a === void 0 ? {
        validations: [],
        isUnsigned: false,
    } : _a, validations = _c.validations, isUnsigned = _c.isUnsigned;
    if (!(validations === null || validations === void 0 ? void 0 : validations.length)) {
        return CONSTANT_VALUES.STRING;
    }
    var validationExtractor = new ValidationExtractor(validations);
    var _d = validationExtractor.getStringValidations(), minLength = _d.minLength, maxLength = _d.maxLength, format = _d.format;
    var decimalValidations = validationExtractor.getValidationOfType(ValidationType.DECIMAL_VALUE);
    if (decimalValidations) {
        var scale = ((_b = decimalValidations.value) === null || _b === void 0 ? void 0 : _b.maxScale) || 0;
        return someNumber({ validations: validations, isUnsigned: isUnsigned }).toFixed(scale);
    }
    if (format) {
        return FORMAT_VALUES[format];
    }
    var shouldPadStringEndWithValues = minLength && CONSTANT_VALUES.STRING.length < minLength;
    if (shouldPadStringEndWithValues) {
        return CONSTANT_VALUES.STRING.padEnd(minLength, CONSTANT_VALUES.STRING);
    }
    var shouldShortenString = maxLength && CONSTANT_VALUES.STRING.length > maxLength;
    if (shouldShortenString) {
        return CONSTANT_VALUES.STRING.substring(0, maxLength);
    }
    return CONSTANT_VALUES.STRING;
}
export function someNumber(_a) {
    var _b = _a === void 0 ? {
        validations: [],
        isUnsigned: false,
    } : _a, validations = _b.validations, isUnsigned = _b.isUnsigned, defaultValue = _b.defaultValue;
    var actualDefaultValue = defaultValue || (isUnsigned ? CONSTANT_VALUES.UINT : CONSTANT_VALUES.INT);
    if (!(validations === null || validations === void 0 ? void 0 : validations.length)) {
        return actualDefaultValue;
    }
    var validationExtractor = new ValidationExtractor(validations);
    var _c = validationExtractor.getNumberValidations(), min = _c.min, max = _c.max, lowerThanEqual = _c.lowerThanEqual, lowerThan = _c.lowerThan, greaterThanEqual = _c.greaterThanEqual, greaterThan = _c.greaterThan, maxScale = _c.maxScale;
    var minOrMax = min || greaterThanEqual || max || lowerThanEqual;
    var numberValue = applyNumberValidations({
        greaterThan: greaterThan,
        minOrMax: minOrMax,
        lowerThan: lowerThan,
        maxScale: maxScale,
    }, actualDefaultValue);
    return applyScale(maxScale, numberValue);
}
export function someLong(_a) {
    var _b = _a === void 0 ? {
        validations: [],
        isUnsigned: false,
    } : _a, validations = _b.validations, isUnsigned = _b.isUnsigned;
    var number = someNumber({ validations: validations, isUnsigned: isUnsigned });
    // new Long(min || max, 0, true) in case of unsigned
    // new Long(min || max, 0) otherwise
    return new Long(number, 0, isUnsigned);
}
export function someFloat(_a) {
    var _b = _a === void 0 ? { validations: [] } : _a, validations = _b.validations;
    return someNumber({ validations: validations, defaultValue: CONSTANT_VALUES.FLOAT });
}
export function someRepeated(_a, onlyStringValues) {
    var _b = _a === void 0 ? { validations: [] } : _a, validations = _b.validations;
    var repeatedValue = onlyStringValues
        ? CONSTANT_VALUES.FIELD_MASK
        : CONSTANT_VALUES.LIST_VALUE;
    if (!(validations === null || validations === void 0 ? void 0 : validations.length)) {
        return repeatedValue;
    }
    var validationExtractor = new ValidationExtractor(validations);
    var _c = validationExtractor.getRepeatedValidations(), minSize = _c.minSize, maxSize = _c.maxSize;
    var shouldPadArrayWithValue = minSize && repeatedValue.length < minSize;
    if (shouldPadArrayWithValue) {
        return padArray(repeatedValue, minSize, CONSTANT_VALUES.STRING);
    }
    var shouldReduceArraySize = maxSize && repeatedValue.length > maxSize;
    if (shouldReduceArraySize) {
        return repeatedValue.slice(0, maxSize);
    }
    return repeatedValue;
}
export function someDuration(_a) {
    var _b = _a === void 0 ? { validations: [] } : _a, validations = _b.validations;
    return CONSTANT_VALUES.DURATION;
}
export function someDate(_a) {
    var _b = _a === void 0 ? { validations: [] } : _a, validations = _b.validations;
    return CONSTANT_VALUES.DATE;
}
export function someBytes(_a) {
    var _b = _a === void 0 ? { validations: [] } : _a, validations = _b.validations;
    return CONSTANT_VALUES.BYTES;
}
export function someAny(_a) {
    var _b = _a === void 0 ? { validations: [] } : _a, validations = _b.validations;
    return CONSTANT_VALUES.EMPTY_OBJECT;
}
export function getGeneratorFunctionNameForGeneratorType(generatorType) {
    return generatorTypeToFunctionName(generatorType);
}
function applyNumberValidations(_a, defaultValue) {
    var greaterThan = _a.greaterThan, minOrMax = _a.minOrMax, lowerThan = _a.lowerThan, maxScale = _a.maxScale;
    if (greaterThan) {
        return increment(maxScale, greaterThan);
    }
    else if (minOrMax) {
        return minOrMax;
    }
    else if (lowerThan) {
        return decrement(maxScale, lowerThan);
    }
    else {
        return defaultValue;
    }
}
function getTypeForGenerator(field) {
    if (field.mapValueType && field.mapValueType !== 'UNKNOWN_TYPE') {
        return wrapperToBusinessSchemaType(field.schemaName) || field.mapValueType;
    }
    return getFieldType(field);
}
function getFieldType(field) {
    return wrapperToBusinessSchemaType(field.schemaName) || field.type;
}
//# sourceMappingURL=value-generator.js.map