import { __awaiter, __generator } from "tslib";
import Long from 'long';
import { getGeneratorFunctionNameForGeneratorType, getGeneratorTypeForField, someAny, someDate, someDuration, someFloat, someLong, someNumber, someRepeated, someString, } from '../src';
import { Type, ValidationType } from '../src/domain';
import { CONSTANT_VALUES, FORMAT_VALUES, } from '../src/value-generator/constant-values';
import { FunctionNames, GeneratorType } from '../src/value-generator/constants';
describe('Value generator', function () {
    describe('Get generator type', function () {
        it('should return string', function () {
            expect(getGeneratorTypeForField(getSimpleField(Type.STRING))).toEqual(GeneratorType.STRING);
        });
        it('should return number', function () {
            var types = [Type.INT32, Type.SINT32, Type.DOUBLE];
            types.forEach(function (type) {
                return expect(getGeneratorTypeForField(getSimpleField(type))).toEqual(GeneratorType.NUMBER);
            });
        });
        it('should return string (int 64 numbers represented as string number)', function () {
            var types = [Type.INT64, Type.SINT64, Type.FIXED64, Type.SFIXED64];
            types.forEach(function (type) {
                return expect(getGeneratorTypeForField(getSimpleField(type))).toEqual(GeneratorType.STRING);
            });
        });
        it('should return float', function () {
            var types = [Type.FLOAT, Type.FIXED32, Type.SFIXED32];
            types.forEach(function (type) {
                return expect(getGeneratorTypeForField(getSimpleField(type))).toEqual(GeneratorType.FLOAT);
            });
        });
        it('should return repeated', function () {
            var types = ['google.protobuf.ListValue', 'google.protobuf.FieldMask'];
            types.forEach(function (type) {
                return expect(getGeneratorTypeForField(getComplexField(type))).toEqual(GeneratorType.REPEATED);
            });
        });
        it('should return duration', function () {
            expect(getGeneratorTypeForField(getComplexField('google.protobuf.Duration'))).toEqual(GeneratorType.DURATION);
        });
        it('should return date', function () {
            expect(getGeneratorTypeForField(getComplexField('google.protobuf.Timestamp'))).toEqual(GeneratorType.DATE);
        });
        it('should return bytes', function () {
            var bytesProtoType = 'google.protobuf.BytesValue';
            var bytesBusinessSchemaType = Type.BYTES;
            expect(getGeneratorTypeForField(getSimpleField(bytesBusinessSchemaType))).toEqual(GeneratorType.BYTES);
            expect(getGeneratorTypeForField(getComplexField(bytesProtoType))).toEqual(GeneratorType.BYTES);
        });
        it('should return other', function () {
            var types = ['google.protobuf.BoolValue', 'google.protobuf.NullValue'];
            types.forEach(function (type) {
                return expect(getGeneratorTypeForField(getComplexField(type))).toEqual(GeneratorType.OTHER);
            });
        });
        it('should return any', function () {
            var types = [
                'google.protobuf.Struct',
                'google.protobuf.Value',
                'wix.rich_content.v1.Struct',
                'wix.rich_content.v1.Value', // TODO - remove when rich content create V2 without copy/paste google types
            ];
            types.forEach(function (type) {
                return expect(getGeneratorTypeForField(getComplexField(type))).toEqual(GeneratorType.ANY);
            });
        });
        function getSimpleField(type, validations) {
            if (validations === void 0) { validations = []; }
            return {
                name: 'field_name',
                type: type,
                validations: validations,
            };
        }
        function getComplexField(type, validations) {
            if (validations === void 0) { validations = []; }
            return {
                name: 'field_name',
                type: Type.OBJECT,
                schemaName: type,
                validations: validations,
            };
        }
    });
    describe('Get function name by generator type', function () {
        it('should return someString', function () {
            expect(getGeneratorFunctionNameForGeneratorType(GeneratorType.STRING)).toEqual(FunctionNames.SOME_STRING);
        });
        it('should return someBytes', function () {
            expect(getGeneratorFunctionNameForGeneratorType(GeneratorType.BYTES)).toEqual(FunctionNames.SOME_BYTES);
        });
        it('should return someAny', function () {
            expect(getGeneratorFunctionNameForGeneratorType(GeneratorType.ANY)).toEqual(FunctionNames.SOME_ANY);
        });
    });
    describe('Generation functions', function () {
        var min = 2;
        var max = 20;
        var minNumberValidation = {
            type: ValidationType.MIN,
            value: min,
        };
        var maxNumberValidation = {
            type: ValidationType.MAX,
            value: max,
        };
        describe('Strings', function () {
            it('should generate strings', function () {
                expect(someString()).toEqual(CONSTANT_VALUES.STRING);
            });
            it('should return a constant string if it satisfies the validations', function () {
                var minLengthValidation = [
                    { value: 10, type: ValidationType.MIN_LENGTH },
                    { value: 30, type: ValidationType.MAX_LENGTH },
                ];
                var value = someString({ validations: minLengthValidation });
                expect(value).toEqual(CONSTANT_VALUES.STRING);
                expect(value.length).toEqual(CONSTANT_VALUES.STRING.length);
            });
            it('should repeat the string until desired min length', function () {
                var minLength = 30;
                var minLengthValidation = [
                    { value: minLength, type: ValidationType.MIN_LENGTH },
                ];
                var expectedValue = CONSTANT_VALUES.STRING.padEnd(minLength, CONSTANT_VALUES.STRING);
                var value = someString({ validations: minLengthValidation });
                expect(value).toEqual(expectedValue);
                expect(value.length).toEqual(minLength);
            });
            it('should trim the string if default is larger than max length', function () {
                var maxLength = 10;
                var maxLengthValidation = [
                    { value: maxLength, type: ValidationType.MAX_LENGTH },
                ];
                var expectedValue = CONSTANT_VALUES.STRING.substring(0, maxLength);
                var value = someString({ validations: maxLengthValidation });
                expect(value).toEqual(expectedValue);
                expect(value.length).toEqual(maxLength);
            });
            describe('Format', function () {
                it('generates all formats', function () {
                    var allFormats = Object.keys(FORMAT_VALUES);
                    allFormats.forEach(function (format) {
                        var value = someString({
                            validations: [{ type: ValidationType.FORMAT, value: format }],
                        });
                        expect(value).toEqual(FORMAT_VALUES[format]);
                    });
                });
            });
            describe('with Decimal Value', function () {
                var getDecimalValueValidation = function (value) { return ({
                    type: ValidationType.DECIMAL_VALUE,
                    value: value,
                }); };
                it('should use gte (greater then equal) as value for number', function () {
                    var decimalValueGreaterThanEqual = { gte: 1 };
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.gte.toString());
                });
                it('should use incremented gt (greater than) as value for number', function () {
                    var decimalValueGreaterThan = { gt: 1 };
                    var expected = (decimalValueGreaterThan.gt + 1).toString();
                    var value = someString({
                        validations: [getDecimalValueValidation(decimalValueGreaterThan)],
                    });
                    expect(value).toEqual(expected);
                });
                it('should use incremented gt (greater than) as value even when lt and lte exist', function () {
                    var decimalValueGreaterThanLowerThan = { gt: 1, lte: 3, lt: 3 };
                    var expected = (decimalValueGreaterThanLowerThan.gt + 1).toString();
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanLowerThan),
                        ],
                    });
                    expect(value).toEqual(expected);
                });
                it('should use lte (lower than equal) as value', function () {
                    var decimalValueGreaterThanEqual = { lte: 2 };
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.lte.toString());
                });
                it('should use lt (lower than) decremented as value', function () {
                    var decimalValueGreaterThanEqual = { lt: 2 };
                    var expected = (decimalValueGreaterThanEqual.lt - 1).toString();
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expected);
                });
                it('should return float when maxScale is present with gte', function () {
                    var decimalValueGreaterThanEqual = { gte: 2, maxScale: 2 };
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual("".concat(decimalValueGreaterThanEqual.gte, ".00"));
                });
                it('should return float when maxScale is present with lte', function () {
                    var decimalValueGreaterThanEqual = { lte: 2, maxScale: 2 };
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual("".concat(decimalValueGreaterThanEqual.lte, ".00"));
                });
                it('should increment according to maxScale', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: 0.11,
                        lte: 9.99,
                        maxScale: 2,
                    };
                    var expectedValue = (decimalValueGreaterThanEqual.gt + 0.01).toString();
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                it('should decrement according to maxScale', function () {
                    var decimalValueLowerThan = { lt: 2, maxScale: 2 };
                    var expected = (decimalValueLowerThan.lt - 0.01).toString();
                    var value = someString({
                        validations: [getDecimalValueValidation(decimalValueLowerThan)],
                    });
                    expect(value).toEqual(expected);
                });
                it('should support having only max scale', function () {
                    var decimalValueMaxScale = { maxScale: 2 };
                    var value = someString({
                        validations: [getDecimalValueValidation(decimalValueMaxScale)],
                    });
                    expect(value).toEqual('-1337.00');
                });
                it('should handle string values', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: '0.11',
                        lte: '9.99',
                        maxScale: 2,
                    };
                    var expectedValue = (parseFloat(decimalValueGreaterThanEqual.gt) + 0.01).toString();
                    var value = someString({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                it('should return a string number when decimal value validation is present', function () {
                    var stringNumber = someString({
                        validations: [{ type: ValidationType.DECIMAL_VALUE }],
                    });
                    expect(stringNumber).toEqual('-1337');
                });
                it('should return an unsigned string number when decimal value validation is present', function () {
                    var stringNumber = someString({
                        validations: [{ type: ValidationType.DECIMAL_VALUE }],
                        isUnsigned: true,
                    });
                    expect(stringNumber).toEqual('1337');
                });
                // todo: handle {gte: "0.11" lte: "9.99" maxScale: 2}
            });
        });
        describe('Numbers', function () {
            it('should return constant number as a string', function () {
                var value = someNumber();
                expect(value).toEqual(CONSTANT_VALUES.INT);
            });
            it('should use the maximum validation as number value', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someNumber({ validations: [maxNumberValidation] });
                    expect(value).toEqual(max);
                    return [2 /*return*/];
                });
            }); });
            it('should use the minimum validation as number value', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someNumber({ validations: [minNumberValidation] });
                    expect(value).toEqual(min);
                    return [2 /*return*/];
                });
            }); });
            it('should use the minimum validation as number value when having both min and max', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someNumber({
                        validations: [minNumberValidation, maxNumberValidation],
                    });
                    expect(value).toEqual(min);
                    return [2 /*return*/];
                });
            }); });
            // todo: move to params object with validations, defaultValue and isUnsigned
            it('should use unsigned int when needed', function () {
                var value = someNumber({ isUnsigned: true });
                expect(value).toEqual(CONSTANT_VALUES.UINT);
            });
            describe('with Decimal Value', function () {
                var getDecimalValueValidation = function (value) { return ({
                    type: ValidationType.DECIMAL_VALUE,
                    value: value,
                }); };
                it('should use gte (greater then equal) as value for number', function () {
                    var decimalValueGreaterThanEqual = { gte: 1 };
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.gte);
                });
                it('should use incremented gt (greater than) as value for number', function () {
                    var decimalValueGreaterThan = { gt: 1 };
                    var value = someNumber({
                        validations: [getDecimalValueValidation(decimalValueGreaterThan)],
                    });
                    expect(value).toEqual(decimalValueGreaterThan.gt + 1);
                });
                it('should use incremented gt (greater than) as value even when lt and lte exist', function () {
                    var decimalValueGreaterThanLowerThan = { gt: 1, lte: 3, lt: 3 };
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanLowerThan),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanLowerThan.gt + 1);
                });
                it('should use lte (lower than equal) as value', function () {
                    var decimalValueGreaterThanEqual = { lte: 2 };
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.lte);
                });
                it('should use lt (lower than) decremented as value', function () {
                    var decimalValueGreaterThanEqual = { lt: 2 };
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.lt - 1);
                });
                it('should return float when maxScale is present with gte', function () {
                    var decimalValueGreaterThanEqual = { gte: 2, maxScale: 2 };
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(parseFloat("".concat(decimalValueGreaterThanEqual.gte, ".00")));
                });
                it('should return float when maxScale is present with lte', function () {
                    var decimalValueGreaterThanEqual = { lte: 2, maxScale: 2 };
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(parseFloat("".concat(decimalValueGreaterThanEqual.lte, ".00")));
                });
                it('should increment according to maxScale', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: 0.11,
                        lte: 9.99,
                        maxScale: 2,
                    };
                    var expectedValue = decimalValueGreaterThanEqual.gt + 0.01;
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                it('should decrement according to maxScale', function () {
                    var decimalValueLowerThan = { lt: 2, maxScale: 2 };
                    var value = someNumber({
                        validations: [getDecimalValueValidation(decimalValueLowerThan)],
                    });
                    expect(value).toEqual(decimalValueLowerThan.lt - 0.01);
                });
                it('should support having only max scale', function () {
                    var decimalValueMaxScale = { maxScale: 2 };
                    var value = someNumber({
                        validations: [getDecimalValueValidation(decimalValueMaxScale)],
                    });
                    expect(value).toEqual(-1337.0);
                });
                it('should handle string values', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: '0.11',
                        lte: '9.99',
                        maxScale: 2,
                    };
                    var expectedValue = parseFloat(decimalValueGreaterThanEqual.gt) + 0.01;
                    var value = someNumber({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                // todo: handle {gte: "0.11" lte: "9.99" maxScale: 2}
            });
        });
        describe('Long', function () {
            var isUnsigned = true;
            it('should use minimum validation number as long value', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someLong({ validations: [minNumberValidation] });
                    expect(value).toEqual(new Long(min, 0));
                    return [2 /*return*/];
                });
            }); });
            it('should use maximum validation number as long value', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someLong({ validations: [maxNumberValidation] });
                    expect(value).toEqual(new Long(max, 0));
                    return [2 /*return*/];
                });
            }); });
            it('should use default long as an unsigned long value', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someLong({ isUnsigned: isUnsigned });
                    expect(value).toEqual(new Long(CONSTANT_VALUES.UINT, 0, true));
                    return [2 /*return*/];
                });
            }); });
            it('should use minimum validation number as an unsigned long value', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someLong({
                        validations: [minNumberValidation],
                        isUnsigned: isUnsigned,
                    });
                    expect(value).toEqual(new Long(min, 0, true));
                    return [2 /*return*/];
                });
            }); });
            it('should use maximum validation number as an unsigned long value', function () { return __awaiter(void 0, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    value = someLong({
                        validations: [maxNumberValidation],
                        isUnsigned: isUnsigned,
                    });
                    expect(value).toEqual(new Long(max, 0, true));
                    return [2 /*return*/];
                });
            }); });
        });
        describe('Float', function () {
            var floatMin = 2.1;
            var floatMax = 4.6;
            var minFloatValidation = {
                type: ValidationType.MIN,
                value: floatMin,
            };
            var maxFloatValidation = {
                type: ValidationType.MAX,
                value: floatMax,
            };
            it('should return the default float', function () {
                expect(someFloat()).toEqual(CONSTANT_VALUES.FLOAT);
            });
            it('should return a float according to min value', function () {
                expect(someFloat({ validations: [minFloatValidation] })).toEqual(floatMin);
            });
            it('should return a float according to max value', function () {
                expect(someFloat({ validations: [maxFloatValidation] })).toEqual(floatMax);
            });
        });
        describe('Repeated', function () {
            it('should handle list value', function () {
                var expectedArrayValue = [
                    CONSTANT_VALUES.EMPTY_OBJECT,
                    CONSTANT_VALUES.STRING,
                    CONSTANT_VALUES.INT,
                ];
                expect(someRepeated()).toEqual(expectedArrayValue);
            });
            it('should generate list value with min length filled with empty objects', function () {
                var value = someRepeated({
                    validations: [{ type: ValidationType.MIN_SIZE, value: 6 }],
                });
                var expectedArrayValue = [
                    CONSTANT_VALUES.EMPTY_OBJECT,
                    CONSTANT_VALUES.STRING,
                    CONSTANT_VALUES.INT,
                    CONSTANT_VALUES.STRING,
                    CONSTANT_VALUES.STRING,
                    CONSTANT_VALUES.STRING,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
            it('should generate list value with max size', function () {
                var value = someRepeated({
                    validations: [{ type: ValidationType.MAX_SIZE, value: 2 }],
                });
                var expectedArrayValue = [
                    CONSTANT_VALUES.EMPTY_OBJECT,
                    CONSTANT_VALUES.STRING,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
            it('should generate list value when constant value satisfies array size validations', function () {
                var value = someRepeated({
                    validations: [
                        { type: ValidationType.MIN_SIZE, value: 1 },
                        { type: ValidationType.MAX_SIZE, value: 4 },
                    ],
                });
                var expectedArrayValue = [
                    CONSTANT_VALUES.EMPTY_OBJECT,
                    CONSTANT_VALUES.STRING,
                    CONSTANT_VALUES.INT,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
            it('should work for field mask', function () {
                var fillWithOnlyStrings = true;
                var value = someRepeated({ validations: [{ type: ValidationType.MIN_SIZE, value: 2 }] }, fillWithOnlyStrings);
                var expectedArrayValue = [
                    CONSTANT_VALUES.STRING,
                    CONSTANT_VALUES.STRING,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
        });
        describe('Date and Duration', function () {
            it('should return constant date', function () {
                expect(someDate()).toEqual(CONSTANT_VALUES.DATE);
            });
            it('should return constant duration', function () {
                var duration = someDuration();
                expect(duration).toEqual(CONSTANT_VALUES.DURATION);
                expect(typeof duration.seconds).toEqual('string');
                expect(typeof duration.nanos).toEqual('number');
            });
        });
        describe('Any', function () {
            it('should return empty object', function () {
                expect(someAny()).toEqual(CONSTANT_VALUES.EMPTY_OBJECT);
            });
        });
    });
});
//# sourceMappingURL=value-generator.spec.js.map