"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var long_1 = tslib_1.__importDefault(require("long"));
var src_1 = require("../src");
var domain_1 = require("../src/domain");
var constant_values_1 = require("../src/value-generator/constant-values");
var constants_1 = require("../src/value-generator/constants");
describe('Value generator', function () {
    describe('Get generator type', function () {
        it('should return string', function () {
            expect((0, src_1.getGeneratorTypeForField)(getSimpleField(domain_1.Type.STRING))).toEqual(constants_1.GeneratorType.STRING);
        });
        it('should return number', function () {
            var types = [domain_1.Type.INT32, domain_1.Type.SINT32, domain_1.Type.DOUBLE];
            types.forEach(function (type) {
                return expect((0, src_1.getGeneratorTypeForField)(getSimpleField(type))).toEqual(constants_1.GeneratorType.NUMBER);
            });
        });
        it('should return string (int 64 numbers represented as string number)', function () {
            var types = [domain_1.Type.INT64, domain_1.Type.SINT64, domain_1.Type.FIXED64, domain_1.Type.SFIXED64];
            types.forEach(function (type) {
                return expect((0, src_1.getGeneratorTypeForField)(getSimpleField(type))).toEqual(constants_1.GeneratorType.STRING);
            });
        });
        it('should return float', function () {
            var types = [domain_1.Type.FLOAT, domain_1.Type.FIXED32, domain_1.Type.SFIXED32];
            types.forEach(function (type) {
                return expect((0, src_1.getGeneratorTypeForField)(getSimpleField(type))).toEqual(constants_1.GeneratorType.FLOAT);
            });
        });
        it('should return repeated', function () {
            var types = ['google.protobuf.ListValue', 'google.protobuf.FieldMask'];
            types.forEach(function (type) {
                return expect((0, src_1.getGeneratorTypeForField)(getComplexField(type))).toEqual(constants_1.GeneratorType.REPEATED);
            });
        });
        it('should return duration', function () {
            expect((0, src_1.getGeneratorTypeForField)(getComplexField('google.protobuf.Duration'))).toEqual(constants_1.GeneratorType.DURATION);
        });
        it('should return date', function () {
            expect((0, src_1.getGeneratorTypeForField)(getComplexField('google.protobuf.Timestamp'))).toEqual(constants_1.GeneratorType.DATE);
        });
        it('should return bytes', function () {
            var bytesProtoType = 'google.protobuf.BytesValue';
            var bytesBusinessSchemaType = domain_1.Type.BYTES;
            expect((0, src_1.getGeneratorTypeForField)(getSimpleField(bytesBusinessSchemaType))).toEqual(constants_1.GeneratorType.BYTES);
            expect((0, src_1.getGeneratorTypeForField)(getComplexField(bytesProtoType))).toEqual(constants_1.GeneratorType.BYTES);
        });
        it('should return other', function () {
            var types = ['google.protobuf.BoolValue', 'google.protobuf.NullValue'];
            types.forEach(function (type) {
                return expect((0, src_1.getGeneratorTypeForField)(getComplexField(type))).toEqual(constants_1.GeneratorType.OTHER);
            });
        });
        it('should return any', function () {
            var types = [
                'google.protobuf.Struct',
                'google.protobuf.Value',
                'wix.rich_content.v1.Struct',
                'wix.rich_content.v1.Value', // TODO - remove when rich content create V2 without copy/paste google types
            ];
            types.forEach(function (type) {
                return expect((0, src_1.getGeneratorTypeForField)(getComplexField(type))).toEqual(constants_1.GeneratorType.ANY);
            });
        });
        function getSimpleField(type, validations) {
            if (validations === void 0) { validations = []; }
            return {
                name: 'field_name',
                type: type,
                validations: validations,
            };
        }
        function getComplexField(type, validations) {
            if (validations === void 0) { validations = []; }
            return {
                name: 'field_name',
                type: domain_1.Type.OBJECT,
                schemaName: type,
                validations: validations,
            };
        }
    });
    describe('Get function name by generator type', function () {
        it('should return someString', function () {
            expect((0, src_1.getGeneratorFunctionNameForGeneratorType)(constants_1.GeneratorType.STRING)).toEqual(constants_1.FunctionNames.SOME_STRING);
        });
        it('should return someBytes', function () {
            expect((0, src_1.getGeneratorFunctionNameForGeneratorType)(constants_1.GeneratorType.BYTES)).toEqual(constants_1.FunctionNames.SOME_BYTES);
        });
        it('should return someAny', function () {
            expect((0, src_1.getGeneratorFunctionNameForGeneratorType)(constants_1.GeneratorType.ANY)).toEqual(constants_1.FunctionNames.SOME_ANY);
        });
    });
    describe('Generation functions', function () {
        var min = 2;
        var max = 20;
        var minNumberValidation = {
            type: domain_1.ValidationType.MIN,
            value: min,
        };
        var maxNumberValidation = {
            type: domain_1.ValidationType.MAX,
            value: max,
        };
        describe('Strings', function () {
            it('should generate strings', function () {
                expect((0, src_1.someString)()).toEqual(constant_values_1.CONSTANT_VALUES.STRING);
            });
            it('should return a constant string if it satisfies the validations', function () {
                var minLengthValidation = [
                    { value: 10, type: domain_1.ValidationType.MIN_LENGTH },
                    { value: 30, type: domain_1.ValidationType.MAX_LENGTH },
                ];
                var value = (0, src_1.someString)({ validations: minLengthValidation });
                expect(value).toEqual(constant_values_1.CONSTANT_VALUES.STRING);
                expect(value.length).toEqual(constant_values_1.CONSTANT_VALUES.STRING.length);
            });
            it('should repeat the string until desired min length', function () {
                var minLength = 30;
                var minLengthValidation = [
                    { value: minLength, type: domain_1.ValidationType.MIN_LENGTH },
                ];
                var expectedValue = constant_values_1.CONSTANT_VALUES.STRING.padEnd(minLength, constant_values_1.CONSTANT_VALUES.STRING);
                var value = (0, src_1.someString)({ validations: minLengthValidation });
                expect(value).toEqual(expectedValue);
                expect(value.length).toEqual(minLength);
            });
            it('should trim the string if default is larger than max length', function () {
                var maxLength = 10;
                var maxLengthValidation = [
                    { value: maxLength, type: domain_1.ValidationType.MAX_LENGTH },
                ];
                var expectedValue = constant_values_1.CONSTANT_VALUES.STRING.substring(0, maxLength);
                var value = (0, src_1.someString)({ validations: maxLengthValidation });
                expect(value).toEqual(expectedValue);
                expect(value.length).toEqual(maxLength);
            });
            describe('Format', function () {
                it('generates all formats', function () {
                    var allFormats = Object.keys(constant_values_1.FORMAT_VALUES);
                    allFormats.forEach(function (format) {
                        var value = (0, src_1.someString)({
                            validations: [{ type: domain_1.ValidationType.FORMAT, value: format }],
                        });
                        expect(value).toEqual(constant_values_1.FORMAT_VALUES[format]);
                    });
                });
            });
            describe('with Decimal Value', function () {
                var getDecimalValueValidation = function (value) { return ({
                    type: domain_1.ValidationType.DECIMAL_VALUE,
                    value: value,
                }); };
                it('should use gte (greater then equal) as value for number', function () {
                    var decimalValueGreaterThanEqual = { gte: 1 };
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.gte.toString());
                });
                it('should use incremented gt (greater than) as value for number', function () {
                    var decimalValueGreaterThan = { gt: 1 };
                    var expected = (decimalValueGreaterThan.gt + 1).toString();
                    var value = (0, src_1.someString)({
                        validations: [getDecimalValueValidation(decimalValueGreaterThan)],
                    });
                    expect(value).toEqual(expected);
                });
                it('should use incremented gt (greater than) as value even when lt and lte exist', function () {
                    var decimalValueGreaterThanLowerThan = { gt: 1, lte: 3, lt: 3 };
                    var expected = (decimalValueGreaterThanLowerThan.gt + 1).toString();
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanLowerThan),
                        ],
                    });
                    expect(value).toEqual(expected);
                });
                it('should use lte (lower than equal) as value', function () {
                    var decimalValueGreaterThanEqual = { lte: 2 };
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.lte.toString());
                });
                it('should use lt (lower than) decremented as value', function () {
                    var decimalValueGreaterThanEqual = { lt: 2 };
                    var expected = (decimalValueGreaterThanEqual.lt - 1).toString();
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expected);
                });
                it('should return float when maxScale is present with gte', function () {
                    var decimalValueGreaterThanEqual = { gte: 2, maxScale: 2 };
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual("".concat(decimalValueGreaterThanEqual.gte, ".00"));
                });
                it('should return float when maxScale is present with lte', function () {
                    var decimalValueGreaterThanEqual = { lte: 2, maxScale: 2 };
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual("".concat(decimalValueGreaterThanEqual.lte, ".00"));
                });
                it('should increment according to maxScale', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: 0.11,
                        lte: 9.99,
                        maxScale: 2,
                    };
                    var expectedValue = (decimalValueGreaterThanEqual.gt + 0.01).toString();
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                it('should decrement according to maxScale', function () {
                    var decimalValueLowerThan = { lt: 2, maxScale: 2 };
                    var expected = (decimalValueLowerThan.lt - 0.01).toString();
                    var value = (0, src_1.someString)({
                        validations: [getDecimalValueValidation(decimalValueLowerThan)],
                    });
                    expect(value).toEqual(expected);
                });
                it('should support having only max scale', function () {
                    var decimalValueMaxScale = { maxScale: 2 };
                    var value = (0, src_1.someString)({
                        validations: [getDecimalValueValidation(decimalValueMaxScale)],
                    });
                    expect(value).toEqual('-1337.00');
                });
                it('should handle string values', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: '0.11',
                        lte: '9.99',
                        maxScale: 2,
                    };
                    var expectedValue = (parseFloat(decimalValueGreaterThanEqual.gt) + 0.01).toString();
                    var value = (0, src_1.someString)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                it('should return a string number when decimal value validation is present', function () {
                    var stringNumber = (0, src_1.someString)({
                        validations: [{ type: domain_1.ValidationType.DECIMAL_VALUE }],
                    });
                    expect(stringNumber).toEqual('-1337');
                });
                it('should return an unsigned string number when decimal value validation is present', function () {
                    var stringNumber = (0, src_1.someString)({
                        validations: [{ type: domain_1.ValidationType.DECIMAL_VALUE }],
                        isUnsigned: true,
                    });
                    expect(stringNumber).toEqual('1337');
                });
                // todo: handle {gte: "0.11" lte: "9.99" maxScale: 2}
            });
        });
        describe('Numbers', function () {
            it('should return constant number as a string', function () {
                var value = (0, src_1.someNumber)();
                expect(value).toEqual(constant_values_1.CONSTANT_VALUES.INT);
            });
            it('should use the maximum validation as number value', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someNumber)({ validations: [maxNumberValidation] });
                    expect(value).toEqual(max);
                    return [2 /*return*/];
                });
            }); });
            it('should use the minimum validation as number value', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someNumber)({ validations: [minNumberValidation] });
                    expect(value).toEqual(min);
                    return [2 /*return*/];
                });
            }); });
            it('should use the minimum validation as number value when having both min and max', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someNumber)({
                        validations: [minNumberValidation, maxNumberValidation],
                    });
                    expect(value).toEqual(min);
                    return [2 /*return*/];
                });
            }); });
            // todo: move to params object with validations, defaultValue and isUnsigned
            it('should use unsigned int when needed', function () {
                var value = (0, src_1.someNumber)({ isUnsigned: true });
                expect(value).toEqual(constant_values_1.CONSTANT_VALUES.UINT);
            });
            describe('with Decimal Value', function () {
                var getDecimalValueValidation = function (value) { return ({
                    type: domain_1.ValidationType.DECIMAL_VALUE,
                    value: value,
                }); };
                it('should use gte (greater then equal) as value for number', function () {
                    var decimalValueGreaterThanEqual = { gte: 1 };
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.gte);
                });
                it('should use incremented gt (greater than) as value for number', function () {
                    var decimalValueGreaterThan = { gt: 1 };
                    var value = (0, src_1.someNumber)({
                        validations: [getDecimalValueValidation(decimalValueGreaterThan)],
                    });
                    expect(value).toEqual(decimalValueGreaterThan.gt + 1);
                });
                it('should use incremented gt (greater than) as value even when lt and lte exist', function () {
                    var decimalValueGreaterThanLowerThan = { gt: 1, lte: 3, lt: 3 };
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanLowerThan),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanLowerThan.gt + 1);
                });
                it('should use lte (lower than equal) as value', function () {
                    var decimalValueGreaterThanEqual = { lte: 2 };
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.lte);
                });
                it('should use lt (lower than) decremented as value', function () {
                    var decimalValueGreaterThanEqual = { lt: 2 };
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(decimalValueGreaterThanEqual.lt - 1);
                });
                it('should return float when maxScale is present with gte', function () {
                    var decimalValueGreaterThanEqual = { gte: 2, maxScale: 2 };
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(parseFloat("".concat(decimalValueGreaterThanEqual.gte, ".00")));
                });
                it('should return float when maxScale is present with lte', function () {
                    var decimalValueGreaterThanEqual = { lte: 2, maxScale: 2 };
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(parseFloat("".concat(decimalValueGreaterThanEqual.lte, ".00")));
                });
                it('should increment according to maxScale', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: 0.11,
                        lte: 9.99,
                        maxScale: 2,
                    };
                    var expectedValue = decimalValueGreaterThanEqual.gt + 0.01;
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                it('should decrement according to maxScale', function () {
                    var decimalValueLowerThan = { lt: 2, maxScale: 2 };
                    var value = (0, src_1.someNumber)({
                        validations: [getDecimalValueValidation(decimalValueLowerThan)],
                    });
                    expect(value).toEqual(decimalValueLowerThan.lt - 0.01);
                });
                it('should support having only max scale', function () {
                    var decimalValueMaxScale = { maxScale: 2 };
                    var value = (0, src_1.someNumber)({
                        validations: [getDecimalValueValidation(decimalValueMaxScale)],
                    });
                    expect(value).toEqual(-1337.0);
                });
                it('should handle string values', function () {
                    var decimalValueGreaterThanEqual = {
                        gt: '0.11',
                        lte: '9.99',
                        maxScale: 2,
                    };
                    var expectedValue = parseFloat(decimalValueGreaterThanEqual.gt) + 0.01;
                    var value = (0, src_1.someNumber)({
                        validations: [
                            getDecimalValueValidation(decimalValueGreaterThanEqual),
                        ],
                    });
                    expect(value).toEqual(expectedValue);
                });
                // todo: handle {gte: "0.11" lte: "9.99" maxScale: 2}
            });
        });
        describe('Long', function () {
            var isUnsigned = true;
            it('should use minimum validation number as long value', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someLong)({ validations: [minNumberValidation] });
                    expect(value).toEqual(new long_1.default(min, 0));
                    return [2 /*return*/];
                });
            }); });
            it('should use maximum validation number as long value', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someLong)({ validations: [maxNumberValidation] });
                    expect(value).toEqual(new long_1.default(max, 0));
                    return [2 /*return*/];
                });
            }); });
            it('should use default long as an unsigned long value', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someLong)({ isUnsigned: isUnsigned });
                    expect(value).toEqual(new long_1.default(constant_values_1.CONSTANT_VALUES.UINT, 0, true));
                    return [2 /*return*/];
                });
            }); });
            it('should use minimum validation number as an unsigned long value', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someLong)({
                        validations: [minNumberValidation],
                        isUnsigned: isUnsigned,
                    });
                    expect(value).toEqual(new long_1.default(min, 0, true));
                    return [2 /*return*/];
                });
            }); });
            it('should use maximum validation number as an unsigned long value', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var value;
                return tslib_1.__generator(this, function (_a) {
                    value = (0, src_1.someLong)({
                        validations: [maxNumberValidation],
                        isUnsigned: isUnsigned,
                    });
                    expect(value).toEqual(new long_1.default(max, 0, true));
                    return [2 /*return*/];
                });
            }); });
        });
        describe('Float', function () {
            var floatMin = 2.1;
            var floatMax = 4.6;
            var minFloatValidation = {
                type: domain_1.ValidationType.MIN,
                value: floatMin,
            };
            var maxFloatValidation = {
                type: domain_1.ValidationType.MAX,
                value: floatMax,
            };
            it('should return the default float', function () {
                expect((0, src_1.someFloat)()).toEqual(constant_values_1.CONSTANT_VALUES.FLOAT);
            });
            it('should return a float according to min value', function () {
                expect((0, src_1.someFloat)({ validations: [minFloatValidation] })).toEqual(floatMin);
            });
            it('should return a float according to max value', function () {
                expect((0, src_1.someFloat)({ validations: [maxFloatValidation] })).toEqual(floatMax);
            });
        });
        describe('Repeated', function () {
            it('should handle list value', function () {
                var expectedArrayValue = [
                    constant_values_1.CONSTANT_VALUES.EMPTY_OBJECT,
                    constant_values_1.CONSTANT_VALUES.STRING,
                    constant_values_1.CONSTANT_VALUES.INT,
                ];
                expect((0, src_1.someRepeated)()).toEqual(expectedArrayValue);
            });
            it('should generate list value with min length filled with empty objects', function () {
                var value = (0, src_1.someRepeated)({
                    validations: [{ type: domain_1.ValidationType.MIN_SIZE, value: 6 }],
                });
                var expectedArrayValue = [
                    constant_values_1.CONSTANT_VALUES.EMPTY_OBJECT,
                    constant_values_1.CONSTANT_VALUES.STRING,
                    constant_values_1.CONSTANT_VALUES.INT,
                    constant_values_1.CONSTANT_VALUES.STRING,
                    constant_values_1.CONSTANT_VALUES.STRING,
                    constant_values_1.CONSTANT_VALUES.STRING,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
            it('should generate list value with max size', function () {
                var value = (0, src_1.someRepeated)({
                    validations: [{ type: domain_1.ValidationType.MAX_SIZE, value: 2 }],
                });
                var expectedArrayValue = [
                    constant_values_1.CONSTANT_VALUES.EMPTY_OBJECT,
                    constant_values_1.CONSTANT_VALUES.STRING,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
            it('should generate list value when constant value satisfies array size validations', function () {
                var value = (0, src_1.someRepeated)({
                    validations: [
                        { type: domain_1.ValidationType.MIN_SIZE, value: 1 },
                        { type: domain_1.ValidationType.MAX_SIZE, value: 4 },
                    ],
                });
                var expectedArrayValue = [
                    constant_values_1.CONSTANT_VALUES.EMPTY_OBJECT,
                    constant_values_1.CONSTANT_VALUES.STRING,
                    constant_values_1.CONSTANT_VALUES.INT,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
            it('should work for field mask', function () {
                var fillWithOnlyStrings = true;
                var value = (0, src_1.someRepeated)({ validations: [{ type: domain_1.ValidationType.MIN_SIZE, value: 2 }] }, fillWithOnlyStrings);
                var expectedArrayValue = [
                    constant_values_1.CONSTANT_VALUES.STRING,
                    constant_values_1.CONSTANT_VALUES.STRING,
                ];
                expect(value).toEqual(expectedArrayValue);
            });
        });
        describe('Date and Duration', function () {
            it('should return constant date', function () {
                expect((0, src_1.someDate)()).toEqual(constant_values_1.CONSTANT_VALUES.DATE);
            });
            it('should return constant duration', function () {
                var duration = (0, src_1.someDuration)();
                expect(duration).toEqual(constant_values_1.CONSTANT_VALUES.DURATION);
                expect(typeof duration.seconds).toEqual('string');
                expect(typeof duration.nanos).toEqual('number');
            });
        });
        describe('Any', function () {
            it('should return empty object', function () {
                expect((0, src_1.someAny)()).toEqual(constant_values_1.CONSTANT_VALUES.EMPTY_OBJECT);
            });
        });
    });
});
//# sourceMappingURL=value-generator.spec.js.map