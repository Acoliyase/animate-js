import { NonNullablePaths } from '@wix/sdk-types';

interface Order {
    /** Unique order number. */
    orderNumber?: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    reservationId?: string;
    /**
     * Payment snapshot ID. Empty for the `FREE` order.
     * @format GUID
     * @readonly
     */
    snapshotId?: string;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /**
     * Contact ID of buyer, resolved using the email address specified. See the Contacts API for additional information.
     * @format GUID
     */
    contactId?: string;
    /**
     * Buyer member ID, if applicable.
     * @format GUID
     */
    memberId?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /** Guest first name. */
    firstName?: string;
    /** Guest last name. */
    lastName?: string;
    /**
     * Guest email address.
     * @format EMAIL
     */
    email?: string;
    /** Checkout form response. When each purchased ticket is assigned to a guest, guest forms are returned for each ticket, and buyer info is returned. */
    checkoutForm?: FormResponse;
    /** Whether the order is confirmed. Triggered once the payment gateway processes the payment and funds reach the merchant's account. */
    confirmed?: boolean;
    /**
     * Order status. Possible values:
     * - `FREE`: The order is confirmed, no payment is required.
     * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
     * - `PAID`: The order is paid.
     * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
     * - `INITIATED`: The order is awaiting for payment.
     * - `CANCELED`: The order is canceled.
     * - `DECLINED`: The order is payment is declined.
     */
    status?: OrderStatusWithLiterals;
    /** Payment method used for purchase, for example, "payPal", "creditCard", etc. */
    method?: string;
    /** Quantity of ordered tickets. */
    ticketsQuantity?: number;
    /** Total order price. */
    totalPrice?: Money;
    /** Ticket PDF URL. */
    ticketsPdf?: string;
    /** Tickets (generated after payment). */
    tickets?: TicketingTicket[];
    /** Whether the order is archived. */
    archived?: boolean;
    /** Whether the order is anonymized by GDPR delete. */
    anonymized?: boolean;
    /** Guest full name. */
    fullName?: string;
    /** Order invoice. */
    invoice?: Invoice;
    /** Whether all tickets in an order are checked in. */
    fullyCheckedIn?: boolean;
    /** Internal order payment details. */
    paymentDetails?: PaymentDetails;
    /** Checkout channel type. */
    channel?: ChannelTypeWithLiterals;
    /**
     * Date and time the order was last updated.
     * @readonly
     */
    updated?: Date | null;
    /** Whether marketing consent was given. */
    marketingConsent?: boolean | null;
}
interface FormResponse {
    /**
     * Input fields for a checkout form.
     * @maxSize 200
     */
    inputValues?: InputValue[];
}
interface InputValue {
    /**
     * Input field name.
     * @maxLength 100
     */
    inputName?: string;
    /**
     * Input field value.
     * @maxLength 5000
     */
    value?: string;
    /**
     * Multiple input field values.
     * @maxSize 100
     * @maxLength 5000
     */
    values?: string[];
}
interface FormattedAddress {
    /**
     * 1-line address representation.
     * @maxLength 200
     */
    formatted?: string;
    /** Address components. */
    address?: Address;
}
/** Physical address */
interface Address extends AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
/** @oneof */
interface AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
}
interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
}
interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
interface Subdivision {
    /** Short subdivision code. */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
/** Subdivision Concordance values */
interface StandardDetails {
    /**
     * subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30
     * @maxLength 20
     */
    iso31662?: string | null;
}
declare enum OrderStatus {
    /** Order status isn't available for this request fieldset. */
    NA_ORDER_STATUS = "NA_ORDER_STATUS",
    /** Order is confirmed, no payment is required. */
    FREE = "FREE",
    /** Order was paid, but the payment gateway suspended the payment. */
    PENDING = "PENDING",
    /** Order is paid. */
    PAID = "PAID",
    /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `"PAID"`. */
    OFFLINE_PENDING = "OFFLINE_PENDING",
    /** Order is waiting for payment at the cashier. */
    INITIATED = "INITIATED",
    /** Order is canceled. */
    CANCELED = "CANCELED",
    /** Order payment is declined. */
    DECLINED = "DECLINED",
    /** Order payment is authorized. */
    AUTHORIZED = "AUTHORIZED",
    /** Order payment is voided. */
    VOIDED = "VOIDED",
    /** Order is partially paid with less than the total amount. */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
/** @enumType */
type OrderStatusWithLiterals = OrderStatus | 'NA_ORDER_STATUS' | 'FREE' | 'PENDING' | 'PAID' | 'OFFLINE_PENDING' | 'INITIATED' | 'CANCELED' | 'DECLINED' | 'AUTHORIZED' | 'VOIDED' | 'PARTIALLY_PAID';
interface Money {
    /**
     * *Deprecated:** Use `value` instead.
     * @format DECIMAL_VALUE
     * @deprecated
     */
    amount?: string;
    /**
     * Currency code. Must be a valid [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     */
    value?: string | null;
}
interface TicketingTicket {
    /** Unique ticket number which is assigned automatically when creating a ticket. */
    ticketNumber?: string;
    /** Associated order number. */
    orderNumber?: string;
    /**
     * Ticket definition ID. See the Ticket Definition API for additional information.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket type. */
    name?: string;
    /** Ticket price. */
    price?: Money;
    /**
     * Whether the ticket requires payment.
     * @readonly
     */
    free?: boolean;
    /** Event and ticket policies. */
    policy?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Associated order status. */
    orderStatus?: OrderStatusWithLiterals;
    /**
     * Whether the order and ticket are archived.
     * If set to `true`, they aren't visible in the order list.
     */
    orderArchived?: boolean;
    /** Buyer full name. */
    orderFullName?: string;
    /** Guest full name. */
    guestFullName?: string | null;
    /** Guest personal details. */
    guestDetails?: GuestDetails;
    /** Whether the ticket is visible in an order. */
    archived?: boolean;
    /**
     * Ticket owner member ID.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Whether ticket was anonymized by GDPR delete.
     * Anonymized tickets no longer contain personally identifiable information (PII).
     */
    anonymized?: boolean;
    /**
     * Ticket check-in URL.
     * Shown as a QR code image in PDF.
     * Format: `https://www.wixevents.com/check-in/{ticket number},{event id}`.
     * Example: `https://www.wixevents.com/check-in/AAAA-AAAA-BB021,00000000-0000-0000-0000-000000000000`
     */
    checkInUrl?: string;
    /** URL for ticket PDF download. */
    ticketPdfUrl?: string;
    /** Associated order checkout channel type. */
    channel?: ChannelTypeWithLiterals;
    /**
     * URL to download ticket in the `.pkpass` format for Apple Wallet
     * @format WEB_URL
     * @readonly
     */
    walletPassUrl?: string;
    /**
     * Whether ticket is canceled.
     * @readonly
     */
    canceled?: boolean | null;
}
interface CheckIn {
    /** Time of a ticket's check-in. */
    created?: Date | null;
}
interface GuestDetails {
    /** Whether ticket belongs to assigned guest. */
    guestAssigned?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /**
     * Guest email.
     * @format EMAIL
     */
    email?: string | null;
    /** Full form response. */
    form?: FormResponse;
    /**
     * Contact ID associated with this guest.
     * @format GUID
     */
    contactId?: string | null;
    /**
     * Guest phone number.
     * @format PHONE
     */
    phone?: string | null;
}
declare enum ChannelType {
    /** Buyer created the order via an online channel, such as a website or mobile app. */
    ONLINE = "ONLINE",
    /** Sales person created the order and collected the money. */
    OFFLINE_POS = "OFFLINE_POS"
}
/** @enumType */
type ChannelTypeWithLiterals = ChannelType | 'ONLINE' | 'OFFLINE_POS';
interface TicketDetails {
    /**
     * Unique seat ID in the event venue.
     * @minLength 1
     * @maxLength 36
     */
    seatId?: string | null;
    /**
     * Section label.
     * @readonly
     */
    sectionLabel?: string | null;
    /**
     * Area label.
     * @readonly
     */
    areaLabel?: string | null;
    /**
     * Table label.
     * @readonly
     */
    tableLabel?: string | null;
    /**
     * Row label.
     * @readonly
     */
    rowLabel?: string | null;
    /**
     * Seat label in a row or table.
     * @readonly
     */
    seatLabel?: string | null;
    /**
     * Seating plan ID.
     * @format GUID
     * @readonly
     */
    planId?: string | null;
    /**
     * Number of places in the spot.
     *
     * Default: `1`.
     * @min 1
     * @max 50
     */
    capacity?: number | null;
    /**
     * Custom price of a ticket.
     * @format DECIMAL_VALUE
     */
    priceOverride?: string | null;
    /**
     * Pricing option ID.
     * @format GUID
     */
    pricingOptionId?: string | null;
    /**
     * Pricing option name.
     * @readonly
     */
    pricingOptionName?: string | null;
}
interface Invoice {
    /** Items listed in the invoice. */
    items?: Item[];
    /**
     * Total cart amount.
     * @deprecated
     */
    total?: Money;
    /** Discount applied to a cart. */
    discount?: Discount;
    /** Tax applied to a cart. */
    tax?: Tax;
    /** Total cart amount before discount, tax, and fees. */
    subTotal?: Money;
    /**
     * Total amount of a cart after discount, tax, and fees.
     * Grand total is calculated in the following order:
     * 1. Total prices of all items in the cart are calculated.
     * 2. Discount is subtracted from the cart, if applicable.
     * 3. Tax is added, if applicable.
     * 4. Wix ticket service fee is added.
     */
    grandTotal?: Money;
    /**
     * Fees applied to the cart.
     * @readonly
     */
    fees?: Fee[];
    /** Total revenue, excluding fees. Taxes and payment provider fees aren't deducted. */
    revenue?: Money;
    /** Invoice preview URL. This value is only returned when the order is paid. */
    previewUrl?: string | null;
}
interface Item {
    /**
     * Unique line item ID.
     * @format GUID
     */
    _id?: string;
    /**
     * Line item quantity.
     * @min 1
     * @max 50
     */
    quantity?: number;
    /** Line item name. */
    name?: string;
    /** Line item price. */
    price?: Money;
    /** Total price for line items. It's calculated by multiplying price and item quantity. */
    total?: Money;
    /** Discount applied to the line item. */
    discount?: Discount;
    /** Tax applied to the item. */
    tax?: Tax;
    /**
     * Fees applied to the item.
     * @readonly
     */
    fees?: Fee[];
}
interface Discount {
    /** Total discount amount. */
    amount?: Money;
    /** Total sum after the discount. */
    afterDiscount?: Money;
    /**
     * Discount coupon code.
     * @deprecated
     */
    code?: string;
    /**
     * Discount coupon name.
     * @deprecated
     */
    name?: string;
    /**
     * Discount coupon ID.
     * @deprecated
     */
    couponId?: string;
    /** Discount items. */
    discounts?: DiscountItem[];
}
interface DiscountItem extends DiscountItemDiscountOneOf {
    /** Coupon discount. */
    coupon?: CouponDiscount;
    /** Pricing plan discount. */
    paidPlan?: PaidPlanDiscount;
    /** Total discount amount. */
    amount?: Money;
}
/** @oneof */
interface DiscountItemDiscountOneOf {
    /** Coupon discount. */
    coupon?: CouponDiscount;
    /** Pricing plan discount. */
    paidPlan?: PaidPlanDiscount;
}
interface CouponDiscount {
    /** Discount coupon name. **Deprecated:** Use `invoice.discounts.coupon.name` instead. */
    name?: string;
    /** Discount coupon code. **Deprecated:** Use `invoice.discounts.coupon.code` instead. */
    code?: string;
    /** Discount coupon ID. **Deprecated:** Use `invoice.discounts.coupon.couponId` instead. */
    couponId?: string;
}
interface PaidPlanDiscount extends PaidPlanDiscountDiscountOneOf {
    /** Discount by percentage applied to tickets. */
    percentDiscount?: PercentDiscount;
    /** Name of pricing plan. */
    name?: string;
}
/** @oneof */
interface PaidPlanDiscountDiscountOneOf {
    /** Discount by percentage applied to tickets. */
    percentDiscount?: PercentDiscount;
}
interface PercentDiscount {
    /**
     * Percent rate.
     * @decimalValue options { gte:0.01, lte:100, maxScale:2 }
     */
    rate?: string;
    /** Number of discounted tickets. */
    quantityDiscounted?: number;
}
interface Tax {
    /** Tax type. */
    type?: TaxTypeWithLiterals;
    /**
     * Tax name.
     * @readonly
     */
    name?: string;
    /**
     * Tax rate.
     * @format DECIMAL_VALUE
     */
    rate?: string;
    /** Taxable amount. */
    taxable?: Money;
    /** Total tax amount. */
    amount?: Money;
}
declare enum TaxType {
    /** Tax is included in the ticket price. */
    INCLUDED = "INCLUDED",
    /** Tax is added to the order at the checkout. */
    ADDED = "ADDED",
    /** Tax is added to the final total at the checkout. */
    ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
}
/** @enumType */
type TaxTypeWithLiterals = TaxType | 'INCLUDED' | 'ADDED' | 'ADDED_AT_CHECKOUT';
interface Fee {
    /** Fee identifier. */
    name?: FeeNameWithLiterals;
    /** How fee is calculated. */
    type?: FeeTypeWithLiterals;
    /**
     * Fee rate.
     * @format DECIMAL_VALUE
     * @readonly
     */
    rate?: string;
    /** Total amount of fee charges. */
    amount?: Money;
}
declare enum FeeName {
    /** Wix ticket service fee charges applied to the line item. */
    WIX_FEE = "WIX_FEE"
}
/** @enumType */
type FeeNameWithLiterals = FeeName | 'WIX_FEE';
declare enum FeeType {
    /** Fee is added to the ticket price at checkout. */
    FEE_ADDED = "FEE_ADDED",
    /** Seller absorbs the fee. It's deducted from the ticket price. */
    FEE_INCLUDED = "FEE_INCLUDED",
    /** Fee is added to the ticket price at checkout. */
    FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT"
}
/** @enumType */
type FeeTypeWithLiterals = FeeType | 'FEE_ADDED' | 'FEE_INCLUDED' | 'FEE_ADDED_AT_CHECKOUT';
interface PaymentDetails {
    /** Wix Payments transaction. */
    transaction?: PaymentTransaction;
}
interface PaymentTransaction {
    /**
     * Wix Payments transaction ID.
     * @format GUID
     * @readonly
     */
    transactionId?: string;
    /**
     * Transaction payment method, for example, "payPal", "creditCard", etc.
     * @readonly
     */
    method?: string;
}
declare enum ScheduledActionEnumAction {
    /** Action not scheduled. */
    UNKNOWN_ACTION = "UNKNOWN_ACTION",
    /** Captured after the delay. */
    CAPTURE = "CAPTURE",
    /** Void after the delay. */
    VOID = "VOID"
}
/** @enumType */
type ScheduledActionEnumActionWithLiterals = ScheduledActionEnumAction | 'UNKNOWN_ACTION' | 'CAPTURE' | 'VOID';
declare enum Action {
    /** Order can be archived. */
    ARCHIVE = "ARCHIVE",
    /** Order can be unarchived. */
    UNARCHIVE = "UNARCHIVE",
    /** Order can be confirmed. */
    CONFIRM = "CONFIRM",
    /** Order can be captured. */
    CAPTURE = "CAPTURE",
    /** Order can be voided. */
    VOID = "VOID"
}
/** @enumType */
type ActionWithLiterals = Action | 'ARCHIVE' | 'UNARCHIVE' | 'CONFIRM' | 'CAPTURE' | 'VOID';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @format GUID
     */
    giftCardPaymentId?: string | null;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string | null;
    /** Whether the gift card payment is voided. */
    voided?: boolean | null;
    /** Amount */
    amount?: Money;
    /**
     * Obfuscated gift card code.
     * @maxLength 30
     */
    obfuscatedCode?: string | null;
    /**
     * Gift card code.
     * @maxLength 30
     */
    code?: string | null;
}
interface BalanceSummary {
    /** Amount left to pay. */
    balance?: Money;
}
/** Triggered when an order is deleted. */
interface OrderDeleted {
    /** Date and time the order was deleted. */
    timestamp?: Date | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Whether the order was anonymized by GDPR delete. */
    anonymized?: boolean;
    /** Order type. */
    orderType?: OrderTypeWithLiterals;
    /** Whether the event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
}
declare enum OrderType {
    /** Buyer form is used for all tickets. */
    UNASSIGNED_TICKETS = "UNASSIGNED_TICKETS",
    /** Each order ticket has its own form. */
    ASSIGNED_TICKETS = "ASSIGNED_TICKETS"
}
/** @enumType */
type OrderTypeWithLiterals = OrderType | 'UNASSIGNED_TICKETS' | 'ASSIGNED_TICKETS';
interface Ticket {
    /** Unique issued ticket number. */
    ticketNumber?: string;
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Ticket price. */
    price?: Money;
    /** Whether ticket is archived. */
    archived?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /** Guest email. */
    email?: string | null;
    /**
     * Contact ID associated with this ticket.
     * @format GUID
     */
    contactId?: string | null;
    /** Whether ticket is confirmed */
    confirmed?: boolean;
    /**
     * Member ID associated with this ticket.
     * @format GUID
     */
    memberId?: string | null;
    /** Ticket form response (only assigned tickets contain separate forms). */
    form?: FormResponse;
    /** Ticket name. */
    ticketName?: string;
    /** Anonymized tickets no longer contain personally identifiable information (PII). */
    anonymized?: boolean;
    /** URL and password to online conference */
    onlineConferencingLogin?: OnlineConferencingLogin;
    /**
     * Seat ID associated with this ticket.
     * @maxLength 36
     */
    seatId?: string | null;
    /** Whether ticket is canceled. */
    canceled?: boolean | null;
}
interface OnlineConferencingLogin {
    /**
     * Link URL to the online conference.
     * @format WEB_URL
     * @readonly
     */
    link?: string;
    /**
     * Password for the online conference.
     * @readonly
     */
    password?: string | null;
}
interface ListOrdersRequest {
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     * @max 400
     */
    limit?: number;
    /**
     * Predefined sets of fields to return.
     * - `TICKETS`: Returns `tickets`.
     * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
     * - `FORM` : Returns `checkoutForm`.
     * - `INVOICE`: Returns `invoice`.
     *
     * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
     *
     * @maxSize 20
     */
    fieldset?: OrderFieldsetWithLiterals[];
    /**
     * Order status. Possible values:
     * - `FREE`: The order is confirmed, no payment is required.
     * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
     * - `PAID`: The order is paid.
     * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
     * - `INITIATED`: The order is awaiting for payment.
     * - `CANCELED`: The order is canceled.
     * - `DECLINED`: The order is payment is declined.
     */
    status?: OrderStatusWithLiterals[];
    /**
     * Event ID to which the order belongs.
     * @format GUID
     * @maxSize 100
     */
    eventId?: string[];
    /**
     * Order number.
     * @maxLength 36
     * @maxSize 500
     */
    orderNumber?: string[];
    /**
     * Site member ID.
     * @format GUID
     * @maxSize 500
     */
    memberId?: string[];
    /**
     * Field facets,
     * @maxLength 100
     * @maxSize 20
     */
    facet?: string[];
    /**
     * Search filter. You can search `fullName`, `email` and `orderNumber`.
     * @maxLength 200
     */
    searchPhrase?: string;
    /**
     * Event creator ID.
     * @format GUID
     * @maxSize 50
     */
    eventCreatorId?: string[];
    /**
     * Sort order.
     * Default: `created:asc`.
     * @maxLength 100
     */
    sort?: string;
    /** Order tag. */
    tag?: OrderTagWithLiterals[];
    /**
     * Guest contact IDs.
     * @format GUID
     * @maxSize 100
     */
    contactId?: string[];
}
declare enum OrderFieldset {
    /** Returns `tickets`. */
    TICKETS = "TICKETS",
    /**
     * Returns `archived`, `confirmed`, `created`, `firstName`, `fullName`,
     * `lastName`, `method`, `reservationId`, `snapshotId`,
     * `status`, `ticketsPdf`, `ticketsQuantity`, `totalPrice`.
     */
    DETAILS = "DETAILS",
    /** Returns `checkoutForm`. */
    FORM = "FORM",
    /** Returns `invoice`. */
    INVOICE = "INVOICE"
}
/** @enumType */
type OrderFieldsetWithLiterals = OrderFieldset | 'TICKETS' | 'DETAILS' | 'FORM' | 'INVOICE';
declare enum OrderTag {
    /** Return only confirmed orders. */
    CONFIRMED = "CONFIRMED",
    /** Return only unconfirmed orders. */
    UNCONFIRMED = "UNCONFIRMED",
    /** Return only member orders. */
    MEMBER = "MEMBER",
    /** Return only archived orders. */
    ARCHIVED = "ARCHIVED",
    /** Return only non archived orders. */
    NON_ARCHIVED = "NON_ARCHIVED",
    /** Return only orders with all guests checked-in. */
    FULLY_CHECKED_IN = "FULLY_CHECKED_IN",
    /** Return only orders with no guests checked-in. */
    NOT_FULLY_CHECKED_IN = "NOT_FULLY_CHECKED_IN"
}
/** @enumType */
type OrderTagWithLiterals = OrderTag | 'CONFIRMED' | 'UNCONFIRMED' | 'MEMBER' | 'ARCHIVED' | 'NON_ARCHIVED' | 'FULLY_CHECKED_IN' | 'NOT_FULLY_CHECKED_IN';
interface ListOrdersResponse {
    /** Total orders matching the given filters. */
    total?: number;
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     * @max 100
     */
    limit?: number;
    /** Orders. */
    orders?: Order[];
    /** Filter facets. */
    facets?: Record<string, FacetCounts>;
    /** Order data enriched facets. */
    orderFacets?: OrderFacets;
}
interface FacetCounts {
    /** Facet counts aggregated per value. */
    counts?: Record<string, number>;
}
interface OrderFacets {
    /** Filter facets. */
    facets?: Record<string, OrderFacetCounts>;
}
interface OrderFacetCounts {
    /** Facet counts aggregated per value */
    counts?: Record<string, Counts>;
}
interface Counts {
    /** Number or orders */
    count?: number;
    /** Number of tickets within orders */
    tickets?: number;
    /** Number of tickets with check-in */
    ticketsCheckIn?: number;
}
interface GetOrderRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
    /**
     * Predefined sets of fields to return.
     * - `TICKETS`: Returns `tickets`.
     * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
     * - `FORM` : Returns `checkoutForm`.
     * - `INVOICE`: Returns `invoice`.
     *
     * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
     *
     * @maxSize 20
     */
    fieldset?: OrderFieldsetWithLiterals[];
}
interface GetOrderResponse {
    /** Requested order. */
    order?: Order;
    /** "Add to calendar" links. */
    calendarLinks?: CalendarLinks;
}
interface CalendarLinks {
    /** "Add to Google calendar" URL. */
    google?: string;
    /** "Download ICS calendar file" URL. */
    ics?: string;
}
interface UpdateOrderRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
    /** Set of field paths to update. */
    fields?: string[];
    /** Checkout form. */
    checkoutForm?: FormResponse;
    /** Whether to archive the order. */
    archived?: boolean;
}
interface UpdateOrderResponse {
    /** Updated order. */
    order?: Order;
}
/** Triggered when an order is updated. */
interface OrderUpdated {
    /** Date and time the order was updated. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
    confirmed?: boolean;
    /**
     * Order status. Possible values:
     * - `FREE`: The order is confirmed, no payment is required.
     * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
     * - `PAID`: The order is paid.
     * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
     * - `INITIATED`: The order is awaiting for payment.
     * - `CANCELED`: The order is canceled.
     * - `DECLINED`: The order is payment is declined.
     */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
    /** Whether order was archived and excluded from results. */
    archived?: boolean;
    /** Whether event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
}
interface BulkUpdateOrdersRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    orderNumber?: string[];
    /** Set of fields to update. */
    fields?: string[];
    /** Whether to archive the order. */
    archived?: boolean;
}
interface BulkUpdateOrdersResponse {
    /** Updated orders. */
    orders?: Order[];
}
interface ConfirmOrderRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Order numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 100
     */
    orderNumber?: string[];
}
interface ConfirmOrderResponse {
    /** Confirmed orders. */
    orders?: Order[];
}
interface GetSummaryRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string | null;
}
interface GetSummaryResponse {
    /** Ticket sales grouped by currency. */
    sales?: TicketSales[];
}
interface TicketSales {
    /** Total balance of confirmed transactions. */
    total?: Money;
    /** Total number of confirmed orders. */
    totalOrders?: number;
    /** Total number of tickets purchased. */
    totalTickets?: number;
    /** Total revenue, excluding fees (taxes and payment provider fees are not deducted). */
    revenue?: Money;
}
interface GetInvoicePreviewRequest {
    /**
     * Event ID to which the invoice belongs.
     * @format GUID
     */
    eventId?: string;
    /** Order number. */
    orderNumber?: string;
}
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface GetPaymentInfoRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /** Order number. */
    orderNumber?: string;
}
interface GetPaymentInfoResponse {
    transactions?: PaymentTransactionSummary[];
    status?: string | null;
    /**
     * @format GUID
     * @readonly
     */
    transactionId?: string | null;
    /** Whether at least one transaction that is not in the final status exists. */
    active?: boolean;
}
interface PaymentTransactionSummary {
    /**
     * Wix Payments transaction ID.
     * @format GUID
     * @readonly
     */
    transactionId?: string;
    /**
     * Final transaction status.
     * @readonly
     */
    finalTransactionStatus?: string;
    /** Transaction events. */
    events?: PaymentTransactionEvent[];
}
interface PaymentTransactionEvent {
    /**
     * Order snapshot ID.
     * @format GUID
     * @readonly
     */
    snapshotId?: string;
    /**
     * Transaction status
     * @readonly
     */
    transactionStatus?: string;
    /**
     * Transaction Payment method e.g., "payPal", "creditCard", etc.
     * @readonly
     */
    paymentMethod?: string;
    /**
     * Transaction payment amount
     * @readonly
     */
    paymentAmount?: Money;
    /**
     * Crated date
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Reason code
     * @readonly
     */
    reasonCode?: string | null;
    /**
     * Refunded amount
     * @readonly
     */
    refundedAmount?: Money;
}
interface CaptureAuthorizedPaymentRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /**
     * Order number.
     * @minLength 1
     * @maxLength 36
     */
    orderNumber: string;
}
interface CaptureAuthorizedPaymentResponse {
}
interface VoidAuthorizedPaymentRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /**
     * Order number.
     * @minLength 1
     * @maxLength 36
     */
    orderNumber: string;
}
interface VoidAuthorizedPaymentResponse {
}
interface FindOrderByReservationIdRequest {
    /**
     * Event ID
     * @format GUID
     */
    eventId?: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    reservationId?: string;
}
interface FindOrderByReservationIdResponse {
    /** Order. */
    order?: Order;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** Triggered when an order is confirmed. */
interface OrderConfirmed {
    /** Date and time the order was confirmed. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Notifications silenced for this domain event. */
    silent?: boolean | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email address. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /**
     * Order status. Possible values:
     * - `FREE`: The order is confirmed, no payment is required.
     * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
     * - `PAID`: The order is paid.
     * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
     * - `INITIATED`: The order is awaiting for payment.
     * - `CANCELED`: The order is canceled.
     * - `DECLINED`: The order is payment is declined.
     */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets (generated after payment). */
    tickets?: Ticket[];
    /** Invoice. */
    invoice?: Invoice;
    /** Reservation ID associated with the order. */
    reservationId?: string;
}
/** Triggered when an order is paid. */
interface OrderPaid {
    /** Date and time the order was paid. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Notifications silenced for this domain event. */
    silent?: boolean | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Reservation ID associated with this order. */
    reservationId?: string;
    /**
     * Contact ID associated with this order.
     * @maxLength 36
     */
    contactId?: string;
    /**
     * Member ID associated with this order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Buyer first name.
     * @maxLength 255
     */
    firstName?: string;
    /**
     * Buyer last name.
     * @maxLength 255
     */
    lastName?: string;
    /**
     * Buyer email address.
     * @maxLength 255
     */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /**
     * Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc.
     * @maxLength 255
     */
    method?: string | null;
    /**
     * Tickets (generated after payment).
     * @maxSize 50
     */
    tickets?: Ticket[];
    /** Invoice. */
    invoice?: Invoice;
}
/** Triggered when a reservation is created. */
interface ReservationCreated {
    /** Date and time the reservation was created. */
    timestamp?: Date | null;
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId?: string;
    /**
     * Reservation ID.
     * Can be used to retrieve a reservation invoice.
     * @format GUID
     */
    reservationId?: string;
    /** Date and time the reservation expires. */
    expires?: Date | null;
    /** Reservation status. */
    status?: ReservationStatusWithLiterals;
    /**
     * Amount of tickets in the reservation.
     * @maxSize 50
     */
    quantities?: TicketQuantity[];
    /** Date and time the reservation was updated. */
    _updatedDate?: Date | null;
    /**
     * Number of reservations.
     * @maxSize 50
     */
    counts?: ReservationCount[];
}
declare enum ReservationStatus {
    /** The reservation is pending confirmation. It will expire after a certain amount of time. */
    RESERVATION_PENDING = "RESERVATION_PENDING",
    /** The reservation is confirmed and won't expire. */
    RESERVATION_CONFIRMED = "RESERVATION_CONFIRMED",
    /** The reservation is canceled because it's not paid. */
    RESERVATION_CANCELED = "RESERVATION_CANCELED",
    /** The reservation is canceled manually by the buyer. */
    RESERVATION_CANCELED_MANUALLY = "RESERVATION_CANCELED_MANUALLY",
    /** The reservation has expired. */
    RESERVATION_EXPIRED = "RESERVATION_EXPIRED"
}
/** @enumType */
type ReservationStatusWithLiterals = ReservationStatus | 'RESERVATION_PENDING' | 'RESERVATION_CONFIRMED' | 'RESERVATION_CANCELED' | 'RESERVATION_CANCELED_MANUALLY' | 'RESERVATION_EXPIRED';
interface TicketQuantity {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string | null;
    /** Quantity. */
    quantity?: number | null;
    /** Quantity update timestamp. */
    _updatedDate?: Date | null;
}
interface ReservationCount {
    /** Reservation Count snapshot timestamp. */
    timestamp?: Date | null;
    /**
     * Ticket Definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Confirmed reservation count. */
    confirmedCount?: number;
    /** Pending reservation count. */
    pendingCount?: number;
    /** True if paid ticket reservation exist. */
    paidExists?: boolean;
}
/** Triggered when a reservation is updated. */
interface ReservationUpdated {
    /** Date and time the reservation was updated. */
    timestamp?: Date | null;
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId?: string;
    /**
     * Reservation ID.
     * Can be used to retrieve a reservation invoice.
     * @format GUID
     */
    reservationId?: string;
    /** Reservation status. */
    status?: ReservationStatusWithLiterals;
    /** Date and time the reservation expires. */
    expires?: Date | null;
    /**
     * Amount of tickets in the reservation.
     * @maxSize 50
     */
    quantities?: TicketQuantity[];
    /** Date and time the reservation was updated. */
    _updatedDate?: Date | null;
    /**
     * Number of reservations.
     * @maxSize 50
     */
    counts?: ReservationCount[];
}
interface GetCheckoutOptionsRequest {
}
interface GetCheckoutOptionsResponse {
    /** Whether any payment method is configured and available for payment. */
    paymentMethodConfigured?: boolean;
    /** Whether coupons are accepted at checkout. */
    acceptCoupons?: boolean;
    /** Whether premium services are enabled. Enabled for free if site doesn't sell any paid tickets. Selling tickets for a fee requires a premium feature `"events_sell_tickets"`. */
    premiumServices?: boolean;
    /** Whether there are any paid tickets available for sale. */
    paidTickets?: boolean;
    /** Whether gift cards are accepted at checkout. */
    acceptGiftCards?: boolean;
}
interface ListAvailableTicketsRequest {
    /**
     * Event ID to list tickets for. If not specified, available tickets for all events on a site will be returned.
     * @format GUID
     */
    eventId?: string;
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     *
     * **Default:** `0`. If you don't pass this field in the request, only `metadata` is returned.
     * @max 100
     */
    limit?: number;
    /**
     * Sort order.
     * Default: `created:asc`.
     * @maxLength 100
     */
    sort?: string;
    state?: StateWithLiterals[];
}
declare enum State {
    INCLUDE_HIDDEN_NOT_ON_SALE = "INCLUDE_HIDDEN_NOT_ON_SALE"
}
/** @enumType */
type StateWithLiterals = State | 'INCLUDE_HIDDEN_NOT_ON_SALE';
interface ListAvailableTicketsResponse {
    /** Ticket definitions meta data. */
    metaData?: ResponseMetaData;
    /** Ticket definitions. */
    definitions?: TicketDefinition[];
}
interface ResponseMetaData {
    /** Number of items in the response. */
    count?: number;
    /** Offset of items. */
    offset?: number;
    /** Total number of matching items. */
    total?: number;
}
interface TicketDefinition {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    _id?: string;
    /** Ticket price. */
    price?: Money;
    /** Whether the ticket is free (read only). */
    free?: boolean;
    /** Ticket name. */
    name?: string;
    /** Ticket description. */
    description?: string;
    /**
     * Limit of tickets that can be purchased per checkout. If tickets are unlimited in the definition, the limit per checkout is 20 tickets.
     * @max 20
     */
    limitPerCheckout?: number;
    /** Custom sort index. */
    orderIndex?: number;
    /** Event and ticket policies. */
    policy?: string;
    /** Sensitive dashboard data. */
    dashboard?: Dashboard;
    /**
     * Event ID associated with the ticket.
     * @format GUID
     */
    eventId?: string;
    /**
     * Configuration of the fixed-rate Wix service fee that is applied at checkout to each ticket sold.
     * @readonly
     */
    wixFeeConfig?: WixFeeConfig;
    /** Ticket sale period. */
    salePeriod?: TicketSalePeriod;
    /**
     * Ticket sale status.
     * @readonly
     */
    saleStatus?: TicketSaleStatusWithLiterals;
    /** Ticket state. */
    state?: StateWithLiterals[];
    /** Ticket pricing. */
    pricing?: TicketPricing;
}
interface Dashboard {
    /** Whether ticket is hidden and cannot be sold. */
    hidden?: boolean;
    /**
     * Number of tickets sold and reserved.
     * @deprecated
     */
    sold?: number;
    /** Whether the ticket has limited quantity. */
    limited?: boolean;
    /** Ticket limit. `NULL` if the tickets are unlimited. */
    quantity?: number | null;
    /** Number of unsold tickets. `NULL` if the tickets are unlimited. */
    unsold?: number | null;
    /** Number of tickets sold. */
    ticketsSold?: number;
    /** Number of tickets reserved. */
    ticketsReserved?: number;
}
interface WixFeeConfig {
    /** Fee calculation method. */
    type?: FeeTypeWithLiterals;
}
interface TicketSalePeriod {
    /** Ticket sale start timestamp. */
    startDate?: Date | null;
    /** Ticket sale end timestamp. */
    endDate?: Date | null;
    /** Whether to hide this ticket if it isn't on sale. */
    hideNotOnSale?: boolean;
}
declare enum TicketSaleStatus {
    /** Ticket sale is scheduled to start. */
    SALE_SCHEDULED = "SALE_SCHEDULED",
    /** Ticket sale has started. */
    SALE_STARTED = "SALE_STARTED",
    /** Ticket sale has ended. */
    SALE_ENDED = "SALE_ENDED"
}
/** @enumType */
type TicketSaleStatusWithLiterals = TicketSaleStatus | 'SALE_SCHEDULED' | 'SALE_STARTED' | 'SALE_ENDED';
interface TicketPricing extends TicketPricingPriceOneOf {
    /** Ticket price which is read only. */
    fixedPrice?: Money;
    /** Min price per ticket, customizable. */
    minPrice?: Money;
    /** Ticket pricing options. */
    pricingOptions?: PricingOptions;
    /**
     * Ticket pricing type.
     * @readonly
     */
    pricingType?: TypeWithLiterals;
}
/** @oneof */
interface TicketPricingPriceOneOf {
    /** Ticket price which is read only. */
    fixedPrice?: Money;
    /** Min price per ticket, customizable. */
    minPrice?: Money;
    /** Ticket pricing options. */
    pricingOptions?: PricingOptions;
}
interface PricingOptions {
    /** Multiple ticket pricing options. */
    options?: PricingOption[];
}
interface PricingOption {
    /**
     * Ticket pricing option ID.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Ticket pricing option name.
     * @minLength 1
     * @maxLength 200
     */
    name?: string | null;
    /** Ticket pricing option price. */
    price?: Money;
}
declare enum Type {
    STANDARD = "STANDARD",
    DONATION = "DONATION"
}
/** @enumType */
type TypeWithLiterals = Type | 'STANDARD' | 'DONATION';
interface QueryAvailableTicketsRequest {
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     *
     * **Default:** `0`. If you don't pass this field in the request, only `metadata` is returned.
     * @max 1000
     */
    limit?: number;
    /** Ticket definition. */
    filter?: Record<string, any> | null;
    /**
     * Which fields to return.
     * @maxSize 20
     */
    fieldset?: TicketDefinitionFieldsetWithLiterals[];
    /**
     * Sort order.
     * Default: `created:asc`.
     * @maxLength 100
     */
    sort?: string;
}
declare enum TicketDefinitionFieldset {
    /** Include `policy` in the response. */
    POLICY = "POLICY",
    /** Include `dashboard` in the response. */
    DASHBOARD = "DASHBOARD"
}
/** @enumType */
type TicketDefinitionFieldsetWithLiterals = TicketDefinitionFieldset | 'POLICY' | 'DASHBOARD';
interface QueryAvailableTicketsResponse {
    /** Ticket definitions meta data. */
    metaData?: ResponseMetaData;
    /** Ticket definitions. */
    definitions?: TicketDefinition[];
}
interface CreateReservationRequest {
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Tickets to reserve.
     * @minSize 1
     * @maxSize 50
     */
    ticketQuantities?: TicketReservationQuantity[];
    /** Whether to ignore the available ticket limits upon a reservation. */
    ignoreLimits?: boolean;
    /** Whether to allow reservations for hidden tickets. */
    allowHiddenTickets?: boolean;
}
interface TicketReservationQuantity {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /**
     * Quantity of tickets to reserve.
     * @min 1
     * @max 50
     */
    quantity?: number;
    /**
     * Override the predefined ticket price.
     * @maxLength 13
     * @format DECIMAL_VALUE
     */
    priceOverride?: string | null;
    /** Optional ticket details. */
    ticketDetails?: TicketDetails[];
}
interface CreateReservationResponse {
    /**
     * Reservation ID.
     * @format GUID
     */
    _id?: string;
    /** Date and time the reservation expires. */
    expires?: Date | null;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
    /** Reservation invoice. */
    invoice?: Invoice;
    /** Reservation status. */
    reservationStatus?: ReservationStatusWithLiterals;
}
interface TicketReservation {
    /**
     * Amount of reserved tickets.
     * @min 1
     * @max 20
     */
    quantity?: number;
    /** An object containing ticket information. */
    ticket?: TicketDefinition;
    /** Optional ticket details. */
    ticketDetails?: TicketDetails[];
}
interface CancelReservationRequest {
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    _id: string;
}
interface CancelReservationResponse {
}
interface GetInvoiceRequest {
    /**
     * Event ID to which the invoice belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    reservationId: string;
    /** Optional discount to be applied on the returned invoice. */
    withDiscount?: DiscountRequest;
    /** Optional benefit granted by the pricing plan to be applied on the returned invoice. */
    paidPlanBenefit?: PaidPlanBenefit;
}
interface DiscountRequest {
    /**
     * Discount coupon code.
     * @maxLength 20
     */
    couponCode?: string;
}
interface PaidPlanBenefit {
    /**
     * Pricing plan ID.
     * @format GUID
     */
    planOrderId?: string;
    /**
     * Pricing plan benefit ID.
     * @format GUID
     */
    benefitId?: string;
}
interface GetInvoiceResponse {
    /** Invoice with applied discount. */
    invoice?: Invoice;
    /** Discount errors, if relevant. */
    discountErrors?: DiscountErrors;
    /** Reservation expiration time. */
    expires?: Date | null;
    /**
     * Reservation status. Possible values:
     * - `RESERVATION_PENDING`: The reservation is pending confirmation. It will expire after a certain amount of time.
     * - `RESERVATION_CONFIRMED`: The reservation is confirmed and will not expire.
     * - `RESERVATION_CANCELED`: The reservation is canceled because it's not paid.
     * - `RESERVATION_CANCELED_MANUALLY`: The reservation is canceled manually by the buyer.
     * - `RESERVATION_EXPIRED`: The reservation has expired.
     */
    reservationStatus?: ReservationStatusWithLiterals;
    /** Whether this reservation is already used in a checkout. */
    reservationOccupied?: boolean;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
}
interface DiscountErrors {
    /** Object containing error information. */
    error?: Error[];
}
interface Error {
    /** A code identifying the error type. */
    code?: string;
}
interface GiftCardErrors {
    /**
     * Error.
     * @maxSize 10
     */
    error?: GiftCardErrorsError[];
}
interface GiftCardErrorsError {
    /** @maxLength 100 */
    code?: string;
}
interface CheckoutRequest {
    /**
     * Event ID to which the checkout belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string;
    /** Member ID. If empty, no site member is associated with this order. */
    memberId?: string;
    /** Discount to apply on the invoice. */
    discount?: DiscountRequest;
    /** Buyer details. */
    buyer?: Buyer;
    /**
     * Guest details.
     * @minSize 1
     * @maxSize 50
     */
    guests?: Guest[];
    /** Benefit granted by the pricing plan. */
    paidPlanBenefit?: PaidPlanBenefit;
    /** Options controlling the checkout process. */
    options?: CheckoutOptions;
    /** Whether marketing consent was given. */
    marketingConsent?: boolean | null;
}
interface Buyer {
    /**
     * Buyer first name.
     * @minLength 1
     * @maxLength 50
     */
    firstName?: string;
    /**
     * Buyer last name.
     * @minLength 1
     * @maxLength 50
     */
    lastName?: string;
    /**
     * Buyer email.
     * @format EMAIL
     * @minLength 5
     * @maxLength 255
     */
    email?: string;
}
interface Guest {
    /** Specific guest info. */
    form?: FormResponse;
}
interface CheckoutOptions {
    /** Whether to ignore settings to notify contacts. */
    silent?: boolean;
    /** Whether the payment is to be done in person between the buyer and the merchant. When true, the completed order is created with status `OFFLINE_PENDING` and `inPerson` payment method. */
    payInPerson?: boolean;
    /** Whether to ignore form validation. */
    ignoreFormValidation?: boolean;
    /** Marks payment as already paid */
    markAsPaid?: boolean | null;
}
interface CheckoutResponse {
    /** Created order. */
    order?: Order;
    /**
     * Order expiration time.
     * **Note:** Only applicable to orders with the `INITIATED` status.
     */
    expires?: Date | null;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
    /** Order page URL. */
    orderPageUrl?: string | null;
}
/** Triggered when an order is initiated. */
interface OrderInitiated {
    /** Date and time the order was initiated. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Guest first name. */
    firstName?: string;
    /** Guest last name. */
    lastName?: string;
    /** Guest email address. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /**
     * Order status. Possible values:
     * - `FREE`: The order is confirmed, no payment is required.
     * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
     * - `PAID`: The order is paid.
     * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
     * - `INITIATED`: The order is awaiting for payment.
     * - `CANCELED`: The order is canceled.
     * - `DECLINED`: The order is payment is declined.
     */
    status?: OrderStatusWithLiterals;
    /** Invoice. */
    invoice?: Invoice;
    /** Reservation ID associated with the order. */
    reservationId?: string;
    /** Order was marked as paid. */
    markedAsPaid?: boolean | null;
    /** Whether marketing consent was given. */
    marketingConsent?: boolean | null;
}
interface UpdateCheckoutRequest {
    /**
     * Event ID to which the checkout belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
    /** Buyer details. */
    buyer?: Buyer;
    /**
     * Guest details.
     * @minSize 1
     * @maxSize 20
     */
    guests?: Guest[];
    /**
     * Member ID.
     *
     * If empty, no site member is associated with this order.
     */
    memberId?: string | null;
    /** Discount to apply on the invoice. */
    discount?: DiscountRequest;
    /** Benefit granted by the pricing plan. */
    paidPlanBenefit?: PaidPlanBenefit;
}
interface UpdateCheckoutResponse {
    /** Updated order. */
    order?: Order;
    /** Order page URL. */
    orderPageUrl?: string | null;
}
interface OrderPageUrls {
    /**
     * Success order page URL.
     * @format WEB_URL
     */
    success?: string | null;
    /**
     * Pending order page URL.
     * @format WEB_URL
     */
    pending?: string | null;
    /**
     * Canceled order page URL.
     * @format WEB_URL
     */
    canceled?: string | null;
    /**
     * Error order page URL.
     * @format WEB_URL
     */
    error?: string | null;
}
interface PosCheckoutRequest {
    /**
     * Event ID to which the checkout belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId: string;
    /**
     * Payment details ID.
     * Not required if reservation total is 0. In this case the order will be created with status `FREE` and no payment.
     * @format GUID
     */
    paymentDetailsId?: string | null;
}
interface PosCheckoutResponse {
    /** Created order. */
    order?: Order;
    /** Time when the order expires, applies to orders with status is `INITIATED`. */
    expires?: Date | null;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
}
interface GetReservationRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string | null;
}
interface GetReservationResponse {
    /** Reservation. */
    reservation?: Reservation;
}
interface Reservation {
    /** Date and time the ticket reservation was created. */
    _createdDate?: Date | null;
    /** Date and time the ticket reservation was last updated. */
    _updatedDate?: Date | null;
    /** Date and time the pending ticket reservation will expire. */
    expirationDate?: Date | null;
    /** Reservation status. */
    reservationStatus?: ReservationStatusWithLiterals;
    /**
     * Ticket reservations.
     * @maxSize 50
     */
    reservations?: TicketReservation[];
}
interface ConfirmReservationRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string | null;
}
interface ConfirmReservationResponse {
    /** Reservation. */
    reservation?: Reservation;
}
interface ExpireReservationRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string | null;
}
interface ExpireReservationResponse {
    /** Reservation. */
    reservation?: Reservation;
}
interface QueryEventsWithPaidReservationsRequest {
    /**
     * Event Keys.
     * @minSize 1
     * @maxSize 100
     */
    eventKeys?: EventKey[];
}
interface EventKey {
    /**
     * Instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
}
interface QueryEventsWithPaidReservationsResponse {
    /**
     * Event IDs.
     * @format GUID
     * @maxSize 100
     */
    eventIds?: string[] | null;
}
/** @docsIgnore */
type UpdateOrderApplicationErrors = {
    code?: 'ORDER_ACTION_NOT_AVAILABLE';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkUpdateOrdersApplicationErrors = {
    code?: 'ORDER_ACTION_NOT_AVAILABLE';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ConfirmOrderApplicationErrors = {
    code?: 'ORDER_ACTION_NOT_AVAILABLE';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CaptureAuthorizedPaymentApplicationErrors = {
    code?: 'ORDER_STATUS_NOT_AUTHORIZED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type VoidAuthorizedPaymentApplicationErrors = {
    code?: 'ORDER_STATUS_NOT_AUTHORIZED';
    description?: string;
    data?: Record<string, any>;
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface OrderDeletedEnvelope {
    data: OrderDeleted;
    metadata: BaseEventMetadata;
}
/**
 * This event is triggered when an order is deleted via a GDPR request.
 * @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Basic Events Order Info
 * @permissionScopeId SCOPE.DC-EVENTS.READ-BASIC-ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-ORDERS
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @webhook
 * @eventType wix.events.ticketing.events.OrderDeleted
 * @serviceIdentifier wix.events.ticketing.OrderManagement
 * @slug order_deleted
 */
declare function onOrderDeleted(handler: (event: OrderDeletedEnvelope) => void | Promise<void>): void;
interface OrderUpdatedEnvelope {
    data: OrderUpdated;
    metadata: BaseEventMetadata;
}
/** @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Basic Events Order Info
 * @permissionScopeId SCOPE.DC-EVENTS.READ-BASIC-ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-ORDERS
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @webhook
 * @eventType wix.events.ticketing.events.OrderUpdated
 * @serviceIdentifier wix.events.ticketing.OrderManagement
 * @slug order_updated
 */
declare function onOrderUpdated(handler: (event: OrderUpdatedEnvelope) => void | Promise<void>): void;
interface OrderConfirmedEnvelope {
    data: OrderConfirmed;
    metadata: BaseEventMetadata;
}
/** @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Basic Events Order Info
 * @permissionScopeId SCOPE.DC-EVENTS.READ-BASIC-ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-ORDERS
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @webhook
 * @eventType wix.events.ticketing.events.OrderConfirmed
 * @serviceIdentifier wix.events.ticketing.CheckoutService
 * @slug order_confirmed
 */
declare function onOrderConfirmed(handler: (event: OrderConfirmedEnvelope) => void | Promise<void>): void;
interface OrderInitiatedEnvelope {
    data: OrderInitiated;
    metadata: BaseEventMetadata;
}
/** @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Basic Events Order Info
 * @permissionScopeId SCOPE.DC-EVENTS.READ-BASIC-ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-ORDERS
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @webhook
 * @eventType wix.events.ticketing.events.OrderInitiated
 * @serviceIdentifier wix.events.ticketing.CheckoutService
 * @slug order_initiated
 */
declare function onOrderInitiated(handler: (event: OrderInitiatedEnvelope) => void | Promise<void>): void;
interface OrderReservationCreatedEnvelope {
    data: ReservationCreated;
    metadata: BaseEventMetadata;
}
/** @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Basic Events Order Info
 * @permissionScopeId SCOPE.DC-EVENTS.READ-BASIC-ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-ORDERS
 * @permissionId WIX_EVENTS.READ_INVOICE
 * @webhook
 * @eventType wix.events.ticketing.events.ReservationCreated
 * @serviceIdentifier wix.events.ticketing.CheckoutService
 * @slug reservation_created
 * @deprecated
 * @replacedBy wix.events.v1.ticket_reservation_created
 * @targetRemovalDate 2026-03-31
 */
declare function onOrderReservationCreated(handler: (event: OrderReservationCreatedEnvelope) => void | Promise<void>): void;
interface OrderReservationUpdatedEnvelope {
    data: ReservationUpdated;
    metadata: BaseEventMetadata;
}
/** @permissionScope Read Events - all read permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.READ-EVENTS
 * @permissionScope Manage Events - all permissions
 * @permissionScopeId SCOPE.DC-EVENTS-MEGA.MANAGE-EVENTS
 * @permissionScope Manage Events
 * @permissionScopeId SCOPE.EVENTS.MANAGE-EVENTS
 * @permissionScope Read Basic Events Order Info
 * @permissionScopeId SCOPE.DC-EVENTS.READ-BASIC-ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-EVENTS.MANAGE-ORDERS
 * @permissionId WIX_EVENTS.READ_INVOICE
 * @webhook
 * @eventType wix.events.ticketing.events.ReservationUpdated
 * @serviceIdentifier wix.events.ticketing.CheckoutService
 * @slug reservation_updated
 * @deprecated
 * @replacedBy wix.events.v1.ticket_reservation_updated
 * @targetRemovalDate 2026-03-31
 */
declare function onOrderReservationUpdated(handler: (event: OrderReservationUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves a list of orders, including ticket data.
 * @public
 * @param options - An object representing the available options for retrieving a list of orders.
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.OrderManagement.ListOrders
 */
declare function listOrders(options?: ListOrdersOptions): Promise<NonNullablePaths<ListOrdersResponse, `total` | `offset` | `limit` | `orders` | `orders.${number}.orderNumber` | `orders.${number}.reservationId` | `orders.${number}.snapshotId` | `orders.${number}.eventId` | `orders.${number}.contactId` | `orders.${number}.memberId` | `orders.${number}.firstName` | `orders.${number}.lastName` | `orders.${number}.email` | `orders.${number}.confirmed` | `orders.${number}.status` | `orders.${number}.method` | `orders.${number}.ticketsQuantity` | `orders.${number}.totalPrice.amount` | `orders.${number}.totalPrice.currency` | `orders.${number}.ticketsPdf` | `orders.${number}.archived` | `orders.${number}.anonymized` | `orders.${number}.fullName` | `orders.${number}.invoice.discount.code` | `orders.${number}.invoice.discount.name` | `orders.${number}.invoice.discount.couponId` | `orders.${number}.invoice.tax.type` | `orders.${number}.invoice.tax.name` | `orders.${number}.invoice.tax.rate` | `orders.${number}.fullyCheckedIn` | `orders.${number}.paymentDetails.transaction.transactionId` | `orders.${number}.paymentDetails.transaction.method` | `orders.${number}.channel`, 6>>;
interface ListOrdersOptions {
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     * @max 400
     */
    limit?: number;
    /**
     * Predefined sets of fields to return.
     * - `TICKETS`: Returns `tickets`.
     * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
     * - `FORM` : Returns `checkoutForm`.
     * - `INVOICE`: Returns `invoice`.
     *
     * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
     * @maxSize 20
     */
    fieldset?: OrderFieldsetWithLiterals[];
    /**
     * Order status. Possible values:
     * - `FREE`: The order is confirmed, no payment is required.
     * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
     * - `PAID`: The order is paid.
     * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
     * - `INITIATED`: The order is awaiting for payment.
     * - `CANCELED`: The order is canceled.
     * - `DECLINED`: The order is payment is declined.
     */
    status?: OrderStatusWithLiterals[];
    /**
     * Event ID to which the order belongs.
     * @format GUID
     * @maxSize 100
     */
    eventId?: string[];
    /**
     * Order number.
     * @maxLength 36
     * @maxSize 500
     */
    orderNumber?: string[];
    /**
     * Site member ID.
     * @format GUID
     * @maxSize 500
     */
    memberId?: string[];
    /**
     * Field facets.
     * @maxLength 100
     * @maxSize 20
     */
    facet?: string[];
    /**
     * Search filter. You can search `fullName`, `email` and `orderNumber`.
     * @maxLength 200
     */
    searchPhrase?: string;
    /**
     * Event creator ID.
     * @format GUID
     * @maxSize 50
     */
    eventCreatorId?: string[];
    /**
     * Sort order.
     * Default: `created:asc`.
     * @maxLength 100
     */
    sort?: string;
    /** Order tag. */
    tag?: OrderTagWithLiterals[];
    /**
     * Guest contact IDs.
     * @format GUID
     * @maxSize 100
     */
    contactId?: string[];
}
/**
 * Retrieves an order, including ticket data.
 * <!--
 * >The fieldsets in this function are restricted and only run if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 * @public
 * @requiredField identifiers
 * @requiredField identifiers.eventId
 * @requiredField identifiers.orderNumber
 * @param options - An object representing the available options for getting an order.
 * @param identifiers - An object containing identifiers for the order to be retrieved.
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @applicableIdentity APP
 * @returns Requested order.
 * @fqn wix.events.ticketing.OrderManagement.GetOrder
 */
declare function getOrder(identifiers: NonNullablePaths<GetOrderIdentifiers, `eventId` | `orderNumber`, 2>, options?: GetOrderOptions): Promise<NonNullablePaths<Order, `orderNumber` | `reservationId` | `snapshotId` | `eventId` | `contactId` | `memberId` | `firstName` | `lastName` | `email` | `checkoutForm.inputValues` | `checkoutForm.inputValues.${number}.inputName` | `checkoutForm.inputValues.${number}.value` | `confirmed` | `status` | `method` | `ticketsQuantity` | `totalPrice.amount` | `totalPrice.currency` | `ticketsPdf` | `tickets` | `tickets.${number}.ticketNumber` | `tickets.${number}.orderNumber` | `tickets.${number}.ticketDefinitionId` | `tickets.${number}.name` | `tickets.${number}.free` | `tickets.${number}.policy` | `tickets.${number}.orderStatus` | `tickets.${number}.orderArchived` | `tickets.${number}.orderFullName` | `tickets.${number}.guestDetails.guestAssigned` | `tickets.${number}.archived` | `tickets.${number}.anonymized` | `tickets.${number}.checkInUrl` | `tickets.${number}.ticketPdfUrl` | `tickets.${number}.channel` | `tickets.${number}.walletPassUrl` | `archived` | `anonymized` | `fullName` | `invoice.items` | `invoice.items.${number}._id` | `invoice.items.${number}.quantity` | `invoice.items.${number}.name` | `invoice.items.${number}.discount.code` | `invoice.items.${number}.discount.name` | `invoice.items.${number}.discount.couponId` | `invoice.items.${number}.tax.type` | `invoice.items.${number}.tax.name` | `invoice.items.${number}.tax.rate` | `invoice.fees` | `fullyCheckedIn` | `paymentDetails.transaction.transactionId` | `paymentDetails.transaction.method` | `channel`, 6>>;
interface GetOrderIdentifiers {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
}
interface GetOrderOptions {
    /**
     * Predefined sets of fields to return.
     * - `TICKETS`: Returns `tickets`.
     * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
     * - `FORM` : Returns `checkoutForm`.
     * - `INVOICE`: Returns `invoice`.
     *
     * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
     * @maxSize 20
     */
    fieldset?: OrderFieldsetWithLiterals[];
}
/**
 * Updates an order.
 * @public
 * @requiredField identifiers
 * @requiredField identifiers.eventId
 * @requiredField identifiers.orderNumber
 * @param options - An object representing the available options for updating an order.
 * @param identifiers - An object containing identifiers for the order to be updated.
 * @permissionId WIX_EVENTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.OrderManagement.UpdateOrder
 */
declare function updateOrder(identifiers: NonNullablePaths<UpdateOrderIdentifiers, `eventId` | `orderNumber`, 2>, options?: UpdateOrderOptions): Promise<NonNullablePaths<UpdateOrderResponse, `order.orderNumber` | `order.reservationId` | `order.snapshotId` | `order.eventId` | `order.contactId` | `order.memberId` | `order.firstName` | `order.lastName` | `order.email` | `order.checkoutForm.inputValues` | `order.checkoutForm.inputValues.${number}.inputName` | `order.checkoutForm.inputValues.${number}.value` | `order.confirmed` | `order.status` | `order.method` | `order.ticketsQuantity` | `order.totalPrice.amount` | `order.totalPrice.currency` | `order.ticketsPdf` | `order.tickets` | `order.tickets.${number}.ticketNumber` | `order.tickets.${number}.orderNumber` | `order.tickets.${number}.ticketDefinitionId` | `order.tickets.${number}.name` | `order.tickets.${number}.free` | `order.tickets.${number}.policy` | `order.tickets.${number}.orderStatus` | `order.tickets.${number}.orderArchived` | `order.tickets.${number}.orderFullName` | `order.tickets.${number}.guestDetails.guestAssigned` | `order.tickets.${number}.archived` | `order.tickets.${number}.anonymized` | `order.tickets.${number}.checkInUrl` | `order.tickets.${number}.ticketPdfUrl` | `order.tickets.${number}.channel` | `order.tickets.${number}.walletPassUrl` | `order.archived` | `order.anonymized` | `order.fullName` | `order.invoice.items` | `order.invoice.items.${number}._id` | `order.invoice.items.${number}.quantity` | `order.invoice.items.${number}.name` | `order.invoice.items.${number}.discount.code` | `order.invoice.items.${number}.discount.name` | `order.invoice.items.${number}.discount.couponId` | `order.invoice.items.${number}.tax.type` | `order.invoice.items.${number}.tax.name` | `order.invoice.items.${number}.tax.rate` | `order.invoice.fees` | `order.fullyCheckedIn` | `order.paymentDetails.transaction.transactionId` | `order.paymentDetails.transaction.method` | `order.channel`, 7> & {
    __applicationErrorsType?: UpdateOrderApplicationErrors;
}>;
interface UpdateOrderIdentifiers {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
}
interface UpdateOrderOptions {
    /** Set of field paths to update. */
    fields?: string[];
    /** Checkout form. */
    checkoutForm?: FormResponse;
    /** Whether to archive the order. */
    archived?: boolean;
}
/**
 * Archives multiple orders.
 * @public
 * @requiredField eventId
 * @param options - An object representing the available options for confirming an order.
 * @param eventId - Event ID to which the order belongs.
 * @permissionId WIX_EVENTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.OrderManagement.BulkUpdateOrders
 */
declare function bulkUpdateOrders(eventId: string, options?: BulkUpdateOrdersOptions): Promise<NonNullablePaths<BulkUpdateOrdersResponse, `orders` | `orders.${number}.orderNumber` | `orders.${number}.reservationId` | `orders.${number}.snapshotId` | `orders.${number}.eventId` | `orders.${number}.contactId` | `orders.${number}.memberId` | `orders.${number}.firstName` | `orders.${number}.lastName` | `orders.${number}.email` | `orders.${number}.confirmed` | `orders.${number}.status` | `orders.${number}.method` | `orders.${number}.ticketsQuantity` | `orders.${number}.totalPrice.amount` | `orders.${number}.totalPrice.currency` | `orders.${number}.ticketsPdf` | `orders.${number}.archived` | `orders.${number}.anonymized` | `orders.${number}.fullName` | `orders.${number}.invoice.discount.code` | `orders.${number}.invoice.discount.name` | `orders.${number}.invoice.discount.couponId` | `orders.${number}.invoice.tax.type` | `orders.${number}.invoice.tax.name` | `orders.${number}.invoice.tax.rate` | `orders.${number}.fullyCheckedIn` | `orders.${number}.paymentDetails.transaction.transactionId` | `orders.${number}.paymentDetails.transaction.method` | `orders.${number}.channel`, 6> & {
    __applicationErrorsType?: BulkUpdateOrdersApplicationErrors;
}>;
interface BulkUpdateOrdersOptions {
    /**
     * Unique order number.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    orderNumber?: string[];
    /** Set of fields to update. */
    fields?: string[];
    /** Whether to archive the order. */
    archived?: boolean;
}
/**
 * Confirms an order.
 *
 *
 * This function changes order status from `INITIATED`, `PENDING`, `OFFLINE_PENDING` to `PAID`.
 * Confirming orders with `INITIATED` or `PENDING` status triggers an email with the tickets to the buyer (and to additional guests, if provided).
 * @public
 * @requiredField eventId
 * @param options - An object representing the available options for confirming an order.
 * @param eventId - Event ID to which the order belongs.
 * @permissionId WIX_EVENTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.OrderManagement.ConfirmOrder
 */
declare function confirmOrder(eventId: string, options?: ConfirmOrderOptions): Promise<NonNullablePaths<ConfirmOrderResponse, `orders` | `orders.${number}.orderNumber` | `orders.${number}.reservationId` | `orders.${number}.snapshotId` | `orders.${number}.eventId` | `orders.${number}.contactId` | `orders.${number}.memberId` | `orders.${number}.firstName` | `orders.${number}.lastName` | `orders.${number}.email` | `orders.${number}.confirmed` | `orders.${number}.status` | `orders.${number}.method` | `orders.${number}.ticketsQuantity` | `orders.${number}.totalPrice.amount` | `orders.${number}.totalPrice.currency` | `orders.${number}.ticketsPdf` | `orders.${number}.archived` | `orders.${number}.anonymized` | `orders.${number}.fullName` | `orders.${number}.invoice.discount.code` | `orders.${number}.invoice.discount.name` | `orders.${number}.invoice.discount.couponId` | `orders.${number}.invoice.tax.type` | `orders.${number}.invoice.tax.name` | `orders.${number}.invoice.tax.rate` | `orders.${number}.fullyCheckedIn` | `orders.${number}.paymentDetails.transaction.transactionId` | `orders.${number}.paymentDetails.transaction.method` | `orders.${number}.channel`, 6> & {
    __applicationErrorsType?: ConfirmOrderApplicationErrors;
}>;
interface ConfirmOrderOptions {
    /**
     * Order numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 100
     */
    orderNumber?: string[];
}
/**
 * Retrieves a summary of total ticket sales.
 * <!--
 * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 * @public
 * @param options - An object representing the available options for retrieving a summary of total ticket sales.
 * @permissionId WIX_EVENTS.READ_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.OrderManagement.GetSummary
 */
declare function getSummary(options?: GetSummaryOptions): Promise<NonNullablePaths<GetSummaryResponse, `sales` | `sales.${number}.total.amount` | `sales.${number}.total.currency` | `sales.${number}.totalOrders` | `sales.${number}.totalTickets`, 5>>;
interface GetSummaryOptions {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string | null;
}
/**
 * Captures authorized payment asynchronously.
 * Eventually order will become paid.
 * For orders with non-authorized payments request will fail.
 * @param orderNumber - Order number.
 * @public
 * @requiredField orderNumber
 * @permissionId WIX_EVENTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.OrderManagement.CaptureAuthorizedPayment
 */
declare function captureAuthorizedPayment(orderNumber: string, options?: CaptureAuthorizedPaymentOptions): Promise<void & {
    __applicationErrorsType?: CaptureAuthorizedPaymentApplicationErrors;
}>;
interface CaptureAuthorizedPaymentOptions {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
}
/**
 * Voids authorized payment asynchronously.
 * Eventually order will become voided.
 * For orders with non-authorized payments request will fail.
 * @param orderNumber - Order number.
 * @public
 * @requiredField orderNumber
 * @permissionId WIX_EVENTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.OrderManagement.VoidAuthorizedPayment
 */
declare function voidAuthorizedPayment(orderNumber: string, options?: VoidAuthorizedPaymentOptions): Promise<void & {
    __applicationErrorsType?: VoidAuthorizedPaymentApplicationErrors;
}>;
interface VoidAuthorizedPaymentOptions {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
}
/**
 * Retrieves checkout details.
 * @public
 * @permissionId WIX_EVENTS.READ_CHECKOUT
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.GetCheckoutOptions
 */
declare function getCheckoutOptions(): Promise<NonNullablePaths<GetCheckoutOptionsResponse, `paymentMethodConfigured` | `acceptCoupons` | `premiumServices` | `paidTickets` | `acceptGiftCards`, 2>>;
/**
 * Returns tickets available to reserve.
 * <!--
 * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 * @public
 * @param options - An object representing the available options for retrieving a list of tickets available for reservation.
 * @permissionId WIX_EVENTS.READ_CHECKOUT
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.ListAvailableTickets
 */
declare function listAvailableTickets(options?: ListAvailableTicketsOptions): Promise<NonNullablePaths<ListAvailableTicketsResponse, `metaData.count` | `metaData.offset` | `metaData.total` | `definitions` | `definitions.${number}._id` | `definitions.${number}.price.amount` | `definitions.${number}.price.currency` | `definitions.${number}.free` | `definitions.${number}.name` | `definitions.${number}.description` | `definitions.${number}.limitPerCheckout` | `definitions.${number}.orderIndex` | `definitions.${number}.policy` | `definitions.${number}.dashboard.hidden` | `definitions.${number}.dashboard.sold` | `definitions.${number}.dashboard.limited` | `definitions.${number}.dashboard.ticketsSold` | `definitions.${number}.dashboard.ticketsReserved` | `definitions.${number}.eventId` | `definitions.${number}.wixFeeConfig.type` | `definitions.${number}.salePeriod.hideNotOnSale` | `definitions.${number}.saleStatus` | `definitions.${number}.pricing.pricingType`, 5>>;
interface ListAvailableTicketsOptions {
    /**
     * Event ID to list tickets for. If not specified, available tickets for all events on a site will be returned.
     * @format GUID
     */
    eventId?: string;
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     *
     * **Default:** `0`. If you don't pass this field in the request, only `metadata` is returned.
     * @max 100
     */
    limit?: number;
    /**
     * Sort order.
     * Default: `created:asc`.
     * @maxLength 100
     */
    sort?: string;
    state?: StateWithLiterals[];
}
/**
 * Returns tickets available to reserve.
 * <!--
 * > Note: The fieldsets in this function are restricted and only run if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 * @public
 * @param options - An object representing the available options for retrieving a list of tickets available for reservation.
 * @permissionId WIX_EVENTS.READ_CHECKOUT
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.QueryAvailableTickets
 */
declare function queryAvailableTickets(options?: QueryAvailableTicketsOptions): Promise<NonNullablePaths<QueryAvailableTicketsResponse, `metaData.count` | `metaData.offset` | `metaData.total` | `definitions` | `definitions.${number}._id` | `definitions.${number}.price.amount` | `definitions.${number}.price.currency` | `definitions.${number}.free` | `definitions.${number}.name` | `definitions.${number}.description` | `definitions.${number}.limitPerCheckout` | `definitions.${number}.orderIndex` | `definitions.${number}.policy` | `definitions.${number}.dashboard.hidden` | `definitions.${number}.dashboard.sold` | `definitions.${number}.dashboard.limited` | `definitions.${number}.dashboard.ticketsSold` | `definitions.${number}.dashboard.ticketsReserved` | `definitions.${number}.eventId` | `definitions.${number}.wixFeeConfig.type` | `definitions.${number}.salePeriod.hideNotOnSale` | `definitions.${number}.saleStatus` | `definitions.${number}.pricing.pricingType`, 5>>;
interface QueryAvailableTicketsOptions {
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     *
     * **Default:** `0`. If you don't pass this field in the request, only `metadata` is returned.
     * @max 1000
     */
    limit?: number;
    /** Ticket definition. */
    filter?: Record<string, any> | null;
    /**
     * Which fields to return.
     * @maxSize 20
     */
    fieldset?: TicketDefinitionFieldsetWithLiterals[];
    /**
     * Sort order.
     * Default: `created:asc`.
     * @maxLength 100
     */
    sort?: string;
}
/**
 * Reserves tickets for 20 minutes.
 *
 *
 * Reserved tickets are deducted from ticket stock and cannot be bought by another site visitor.
 * When the reservation expires, the tickets are added back to the stock.
 * @public
 * @requiredField eventId
 * @param options - An object representing the available options for creating a reservation.
 * @param eventId - Event ID to which the reservation belongs.
 * @permissionId WIX_EVENTS.CHECKOUT
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.CreateReservation
 * @deprecated
 * @replacedBy wix.events.ticketreservations.v1.TicketReservationManagement.CreateTicketReservation
 * @targetRemovalDate 2026-03-31
 */
declare function createReservation(eventId: string, options?: CreateReservationOptions): Promise<NonNullablePaths<CreateReservationResponse, `_id` | `reservations` | `reservations.${number}.quantity` | `reservations.${number}.ticket._id` | `reservations.${number}.ticket.price.amount` | `reservations.${number}.ticket.price.currency` | `reservations.${number}.ticket.free` | `reservations.${number}.ticket.name` | `reservations.${number}.ticket.description` | `reservations.${number}.ticket.limitPerCheckout` | `reservations.${number}.ticket.orderIndex` | `reservations.${number}.ticket.policy` | `reservations.${number}.ticket.dashboard.hidden` | `reservations.${number}.ticket.dashboard.sold` | `reservations.${number}.ticket.dashboard.limited` | `reservations.${number}.ticket.dashboard.ticketsSold` | `reservations.${number}.ticket.dashboard.ticketsReserved` | `reservations.${number}.ticket.eventId` | `reservations.${number}.ticket.wixFeeConfig.type` | `reservations.${number}.ticket.salePeriod.hideNotOnSale` | `reservations.${number}.ticket.saleStatus` | `reservations.${number}.ticket.pricing.pricingType` | `invoice.items` | `invoice.items.${number}._id` | `invoice.items.${number}.quantity` | `invoice.items.${number}.name` | `invoice.items.${number}.price.amount` | `invoice.items.${number}.price.currency` | `invoice.items.${number}.discount.code` | `invoice.items.${number}.discount.name` | `invoice.items.${number}.discount.couponId` | `invoice.items.${number}.tax.type` | `invoice.items.${number}.tax.name` | `invoice.items.${number}.tax.rate` | `invoice.fees` | `reservationStatus`, 6>>;
interface CreateReservationOptions {
    /**
     * Tickets to reserve.
     * @minSize 1
     * @maxSize 50
     */
    ticketQuantities?: TicketReservationQuantity[];
    /** Whether to ignore the available ticket limits upon a reservation. */
    ignoreLimits?: boolean;
    /** Whether to allow reservations for hidden tickets. */
    allowHiddenTickets?: boolean;
}
/**
 * Cancels ticket reservation and returns tickets to stock.
 * <!--
 * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
 * -->
 * @param _id - Reservation ID.
 * @public
 * @requiredField _id
 * @requiredField eventId
 * @param identifiers - An object containing identifiers for the reservation to be cancelled.
 * @param eventId - Event ID to which the reservation belongs.
 * @permissionId WIX_EVENTS.CHECKOUT
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.CancelReservation
 * @deprecated
 * @replacedBy wix.events.ticketreservations.v1.TicketReservationManagement.CancelTicketReservation
 * @targetRemovalDate 2026-03-31
 */
declare function cancelReservation(_id: string, eventId: string): Promise<void>;
/**
 * Generates a preview of an invoice, including the given coupon or pricing plan.
 * @param reservationId - Reservation ID.
 * @public
 * @requiredField eventId
 * @requiredField reservationId
 * @param options - An object representing the available options for generating a preview of a reservation invoice.
 * @param identifiers - An object containing identifiers for the reservation invoice preview to be generated.
 * @param eventId - Event ID to which the invoice belongs.
 * @permissionId WIX_EVENTS.READ_INVOICE
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.GetInvoice
 */
declare function getInvoice(reservationId: string, eventId: string, options?: GetInvoiceOptions): Promise<NonNullablePaths<GetInvoiceResponse, `invoice.items` | `invoice.items.${number}._id` | `invoice.items.${number}.quantity` | `invoice.items.${number}.name` | `invoice.items.${number}.price.amount` | `invoice.items.${number}.price.currency` | `invoice.items.${number}.discount.code` | `invoice.items.${number}.discount.name` | `invoice.items.${number}.discount.couponId` | `invoice.items.${number}.tax.type` | `invoice.items.${number}.tax.name` | `invoice.items.${number}.tax.rate` | `invoice.fees` | `discountErrors.error` | `discountErrors.error.${number}.code` | `reservationStatus` | `reservationOccupied` | `reservations` | `reservations.${number}.quantity` | `reservations.${number}.ticket._id` | `reservations.${number}.ticket.price.amount` | `reservations.${number}.ticket.price.currency` | `reservations.${number}.ticket.free` | `reservations.${number}.ticket.name` | `reservations.${number}.ticket.description` | `reservations.${number}.ticket.limitPerCheckout` | `reservations.${number}.ticket.orderIndex` | `reservations.${number}.ticket.policy` | `reservations.${number}.ticket.dashboard.hidden` | `reservations.${number}.ticket.dashboard.sold` | `reservations.${number}.ticket.dashboard.limited` | `reservations.${number}.ticket.dashboard.ticketsSold` | `reservations.${number}.ticket.dashboard.ticketsReserved` | `reservations.${number}.ticket.eventId` | `reservations.${number}.ticket.wixFeeConfig.type` | `reservations.${number}.ticket.salePeriod.hideNotOnSale` | `reservations.${number}.ticket.saleStatus` | `reservations.${number}.ticket.pricing.pricingType`, 6>>;
interface GetInvoiceOptions {
    /** Optional discount to be applied on the returned invoice. */
    withDiscount?: DiscountRequest;
    /** Optional benefit granted by the pricing plan to be applied on the returned invoice. */
    paidPlanBenefit?: PaidPlanBenefit;
}
/**
 * Checkouts the reserved tickets.
 *
 *
 * Creates an order and associates it with a site visitor contact.
 * Guest details are received from the [Registration Form](https://www.wix.com/velo/reference/wix-events-v2/forms/introduction) input fields.
 *
 * There is a possibility to use a separate ready-made Wix checkout form where the user will be redirected from your non-Wix site or a custom ticket picker created with Velo.
 * To build the checkout form path, get your event base URL by using the [`getEvent()`](https://www.wix.com/velo/reference/wix-events-backend/wixevents/getevent) function and add the following path:
 * `/{{EVENT_PAGE_SLUG}}/{{SLUG}}/ticket-form?reservationId={{YOUR_RESERVATION_ID}}`
 *
 * Example:  `https://johndoe.wixsite.com/weddings/event-details/doe-wedding/ticket-form?reservationId=2be6d34a-2a1e-459f-897b-b4a66e73f69a`
 * @public
 * @requiredField eventId
 * @requiredField options.guests.form
 * @param options - An object representing the available options for checking out a reserved ticket.
 * @param eventId - Event ID to which the checkout belongs.
 * @permissionId WIX_EVENTS.CHECKOUT
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.Checkout
 */
declare function checkout(eventId: string, options?: NonNullablePaths<CheckoutOptionsForRequest, `guests.${number}.form`, 4>): Promise<NonNullablePaths<CheckoutResponse, `order.orderNumber` | `order.reservationId` | `order.snapshotId` | `order.eventId` | `order.contactId` | `order.memberId` | `order.firstName` | `order.lastName` | `order.email` | `order.checkoutForm.inputValues` | `order.checkoutForm.inputValues.${number}.inputName` | `order.checkoutForm.inputValues.${number}.value` | `order.confirmed` | `order.status` | `order.method` | `order.ticketsQuantity` | `order.totalPrice.amount` | `order.totalPrice.currency` | `order.ticketsPdf` | `order.tickets` | `order.tickets.${number}.ticketNumber` | `order.tickets.${number}.orderNumber` | `order.tickets.${number}.ticketDefinitionId` | `order.tickets.${number}.name` | `order.tickets.${number}.free` | `order.tickets.${number}.policy` | `order.tickets.${number}.orderStatus` | `order.tickets.${number}.orderArchived` | `order.tickets.${number}.orderFullName` | `order.tickets.${number}.guestDetails.guestAssigned` | `order.tickets.${number}.archived` | `order.tickets.${number}.anonymized` | `order.tickets.${number}.checkInUrl` | `order.tickets.${number}.ticketPdfUrl` | `order.tickets.${number}.channel` | `order.tickets.${number}.walletPassUrl` | `order.archived` | `order.anonymized` | `order.fullName` | `order.invoice.items` | `order.invoice.items.${number}._id` | `order.invoice.items.${number}.quantity` | `order.invoice.items.${number}.name` | `order.invoice.items.${number}.discount.code` | `order.invoice.items.${number}.discount.name` | `order.invoice.items.${number}.discount.couponId` | `order.invoice.items.${number}.tax.type` | `order.invoice.items.${number}.tax.name` | `order.invoice.items.${number}.tax.rate` | `order.invoice.fees` | `order.fullyCheckedIn` | `order.paymentDetails.transaction.transactionId` | `order.paymentDetails.transaction.method` | `order.channel` | `reservations` | `reservations.${number}.quantity` | `reservations.${number}.ticket._id` | `reservations.${number}.ticket.price.amount` | `reservations.${number}.ticket.price.currency` | `reservations.${number}.ticket.free` | `reservations.${number}.ticket.name` | `reservations.${number}.ticket.description` | `reservations.${number}.ticket.limitPerCheckout` | `reservations.${number}.ticket.orderIndex` | `reservations.${number}.ticket.policy` | `reservations.${number}.ticket.dashboard.hidden` | `reservations.${number}.ticket.dashboard.sold` | `reservations.${number}.ticket.dashboard.limited` | `reservations.${number}.ticket.dashboard.ticketsSold` | `reservations.${number}.ticket.dashboard.ticketsReserved` | `reservations.${number}.ticket.eventId` | `reservations.${number}.ticket.wixFeeConfig.type` | `reservations.${number}.ticket.salePeriod.hideNotOnSale` | `reservations.${number}.ticket.saleStatus` | `reservations.${number}.ticket.pricing.pricingType`, 7>>;
interface CheckoutOptionsForRequest {
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string;
    /** Member ID. If empty, no site member is associated with this order. */
    memberId?: string;
    /** Discount to apply on the invoice. */
    discount?: DiscountRequest;
    /** Buyer details. */
    buyer?: Buyer;
    /**
     * Guest details.
     * @minSize 1
     * @maxSize 50
     */
    guests?: Guest[];
    /** Benefit granted by the pricing plan. */
    paidPlanBenefit?: PaidPlanBenefit;
    /** Options controlling the checkout process. */
    options?: CheckoutOptions;
    /** Whether marketing consent was given. */
    marketingConsent?: boolean | null;
}
/**
 * Updates order and tickets.
 *
 *
 * Only applicable for orders with `INITIATED`, `PENDING`, `OFFLINE_PENDING` statuses.
 * @param orderNumber - Unique order number.
 * @public
 * @requiredField eventId
 * @requiredField orderNumber
 * @param options - An object representing the available options for updating an order and tickets.
 * @param identifiers - An object containing identifiers for the order and tickets to be updated.
 * @param eventId - Event ID to which the checkout belongs.
 * @permissionId WIX_EVENTS.CHECKOUT
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.UpdateCheckout
 */
declare function updateCheckout(orderNumber: string, eventId: string, options?: UpdateCheckoutOptions): Promise<NonNullablePaths<UpdateCheckoutResponse, `order.orderNumber` | `order.reservationId` | `order.snapshotId` | `order.eventId` | `order.contactId` | `order.memberId` | `order.firstName` | `order.lastName` | `order.email` | `order.checkoutForm.inputValues` | `order.checkoutForm.inputValues.${number}.inputName` | `order.checkoutForm.inputValues.${number}.value` | `order.confirmed` | `order.status` | `order.method` | `order.ticketsQuantity` | `order.totalPrice.amount` | `order.totalPrice.currency` | `order.ticketsPdf` | `order.tickets` | `order.tickets.${number}.ticketNumber` | `order.tickets.${number}.orderNumber` | `order.tickets.${number}.ticketDefinitionId` | `order.tickets.${number}.name` | `order.tickets.${number}.free` | `order.tickets.${number}.policy` | `order.tickets.${number}.orderStatus` | `order.tickets.${number}.orderArchived` | `order.tickets.${number}.orderFullName` | `order.tickets.${number}.guestDetails.guestAssigned` | `order.tickets.${number}.archived` | `order.tickets.${number}.anonymized` | `order.tickets.${number}.checkInUrl` | `order.tickets.${number}.ticketPdfUrl` | `order.tickets.${number}.channel` | `order.tickets.${number}.walletPassUrl` | `order.archived` | `order.anonymized` | `order.fullName` | `order.invoice.items` | `order.invoice.items.${number}._id` | `order.invoice.items.${number}.quantity` | `order.invoice.items.${number}.name` | `order.invoice.items.${number}.discount.code` | `order.invoice.items.${number}.discount.name` | `order.invoice.items.${number}.discount.couponId` | `order.invoice.items.${number}.tax.type` | `order.invoice.items.${number}.tax.name` | `order.invoice.items.${number}.tax.rate` | `order.invoice.fees` | `order.fullyCheckedIn` | `order.paymentDetails.transaction.transactionId` | `order.paymentDetails.transaction.method` | `order.channel`, 7>>;
interface UpdateCheckoutOptions {
    /** Buyer details. */
    buyer?: Buyer;
    /**
     * Guest details.
     * @minSize 1
     * @maxSize 20
     */
    guests?: Guest[];
    /**
     * Member ID.
     *
     * If empty, no site member is associated with this order.
     */
    memberId?: string | null;
    /** Discount to apply on the invoice. */
    discount?: DiscountRequest;
    /** Benefit granted by the pricing plan. */
    paidPlanBenefit?: PaidPlanBenefit;
}
/**
 * Creates order with payment details already initiated via Cashier Pay API.
 * @public
 * @documentationMaturity preview
 * @requiredField eventId
 * @requiredField options.reservationId
 * @param eventId - Event ID to which the checkout belongs.
 * @permissionId WIX_EVENTS.MANAGE_ORDERS
 * @applicableIdentity APP
 * @fqn wix.events.ticketing.CheckoutService.PosCheckout
 */
declare function posCheckout(eventId: string, options?: NonNullablePaths<PosCheckoutOptions, `reservationId`, 2>): Promise<NonNullablePaths<PosCheckoutResponse, `order.orderNumber` | `order.reservationId` | `order.snapshotId` | `order.eventId` | `order.contactId` | `order.memberId` | `order.firstName` | `order.lastName` | `order.email` | `order.checkoutForm.inputValues` | `order.checkoutForm.inputValues.${number}.inputName` | `order.checkoutForm.inputValues.${number}.value` | `order.confirmed` | `order.status` | `order.method` | `order.ticketsQuantity` | `order.totalPrice.amount` | `order.totalPrice.currency` | `order.ticketsPdf` | `order.tickets` | `order.tickets.${number}.ticketNumber` | `order.tickets.${number}.orderNumber` | `order.tickets.${number}.ticketDefinitionId` | `order.tickets.${number}.name` | `order.tickets.${number}.free` | `order.tickets.${number}.policy` | `order.tickets.${number}.orderStatus` | `order.tickets.${number}.orderArchived` | `order.tickets.${number}.orderFullName` | `order.tickets.${number}.guestDetails.guestAssigned` | `order.tickets.${number}.archived` | `order.tickets.${number}.anonymized` | `order.tickets.${number}.checkInUrl` | `order.tickets.${number}.ticketPdfUrl` | `order.tickets.${number}.channel` | `order.tickets.${number}.walletPassUrl` | `order.archived` | `order.anonymized` | `order.fullName` | `order.invoice.items` | `order.invoice.items.${number}._id` | `order.invoice.items.${number}.quantity` | `order.invoice.items.${number}.name` | `order.invoice.items.${number}.discount.code` | `order.invoice.items.${number}.discount.name` | `order.invoice.items.${number}.discount.couponId` | `order.invoice.items.${number}.tax.type` | `order.invoice.items.${number}.tax.name` | `order.invoice.items.${number}.tax.rate` | `order.invoice.fees` | `order.fullyCheckedIn` | `order.paymentDetails.transaction.transactionId` | `order.paymentDetails.transaction.method` | `order.channel` | `reservations` | `reservations.${number}.quantity` | `reservations.${number}.ticket._id` | `reservations.${number}.ticket.price.amount` | `reservations.${number}.ticket.price.currency` | `reservations.${number}.ticket.free` | `reservations.${number}.ticket.name` | `reservations.${number}.ticket.description` | `reservations.${number}.ticket.limitPerCheckout` | `reservations.${number}.ticket.orderIndex` | `reservations.${number}.ticket.policy` | `reservations.${number}.ticket.dashboard.hidden` | `reservations.${number}.ticket.dashboard.sold` | `reservations.${number}.ticket.dashboard.limited` | `reservations.${number}.ticket.dashboard.ticketsSold` | `reservations.${number}.ticket.dashboard.ticketsReserved` | `reservations.${number}.ticket.eventId` | `reservations.${number}.ticket.wixFeeConfig.type` | `reservations.${number}.ticket.salePeriod.hideNotOnSale` | `reservations.${number}.ticket.saleStatus` | `reservations.${number}.ticket.pricing.pricingType`, 7>>;
interface PosCheckoutOptions {
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId: string;
    /**
     * Payment details ID.
     * Not required if reservation total is 0. In this case the order will be created with status `FREE` and no payment.
     * @format GUID
     */
    paymentDetailsId?: string | null;
}

export { Action, type ActionWithLiterals, type Address, type AddressLocation, type AddressStreetOneOf, type BalanceSummary, type BaseEventMetadata, type BulkUpdateOrdersApplicationErrors, type BulkUpdateOrdersOptions, type BulkUpdateOrdersRequest, type BulkUpdateOrdersResponse, type Buyer, type CalendarLinks, type CancelReservationRequest, type CancelReservationResponse, type CaptureAuthorizedPaymentApplicationErrors, type CaptureAuthorizedPaymentOptions, type CaptureAuthorizedPaymentRequest, type CaptureAuthorizedPaymentResponse, ChannelType, type ChannelTypeWithLiterals, type CheckIn, type CheckoutOptions, type CheckoutOptionsForRequest, type CheckoutRequest, type CheckoutResponse, type ConfirmOrderApplicationErrors, type ConfirmOrderOptions, type ConfirmOrderRequest, type ConfirmOrderResponse, type ConfirmReservationRequest, type ConfirmReservationResponse, type Counts, type CouponDiscount, type CreateReservationOptions, type CreateReservationRequest, type CreateReservationResponse, type Dashboard, type Discount, type DiscountErrors, type DiscountItem, type DiscountItemDiscountOneOf, type DiscountRequest, type Error, type EventKey, type ExpireReservationRequest, type ExpireReservationResponse, type FacetCounts, type Fee, FeeName, type FeeNameWithLiterals, FeeType, type FeeTypeWithLiterals, type FindOrderByReservationIdRequest, type FindOrderByReservationIdResponse, type FormResponse, type FormattedAddress, type GetCheckoutOptionsRequest, type GetCheckoutOptionsResponse, type GetInvoiceOptions, type GetInvoicePreviewRequest, type GetInvoiceRequest, type GetInvoiceResponse, type GetOrderIdentifiers, type GetOrderOptions, type GetOrderRequest, type GetOrderResponse, type GetPaymentInfoRequest, type GetPaymentInfoResponse, type GetReservationRequest, type GetReservationResponse, type GetSummaryOptions, type GetSummaryRequest, type GetSummaryResponse, type GiftCardErrors, type GiftCardErrorsError, type GiftCardPaymentDetails, type Guest, type GuestDetails, type HeadersEntry, type IdentificationData, type IdentificationDataIdOneOf, type InputValue, type Invoice, type Item, type ListAvailableTicketsOptions, type ListAvailableTicketsRequest, type ListAvailableTicketsResponse, type ListOrdersOptions, type ListOrdersRequest, type ListOrdersResponse, type MessageEnvelope, type Money, type OnlineConferencingLogin, type Order, type OrderConfirmed, type OrderConfirmedEnvelope, type OrderDeleted, type OrderDeletedEnvelope, type OrderFacetCounts, type OrderFacets, OrderFieldset, type OrderFieldsetWithLiterals, type OrderInitiated, type OrderInitiatedEnvelope, type OrderPageUrls, type OrderPaid, type OrderReservationCreatedEnvelope, type OrderReservationUpdatedEnvelope, OrderStatus, type OrderStatusWithLiterals, OrderTag, type OrderTagWithLiterals, OrderType, type OrderTypeWithLiterals, type OrderUpdated, type OrderUpdatedEnvelope, type PaidPlanBenefit, type PaidPlanDiscount, type PaidPlanDiscountDiscountOneOf, type PaymentDetails, type PaymentTransaction, type PaymentTransactionEvent, type PaymentTransactionSummary, type PercentDiscount, type PosCheckoutOptions, type PosCheckoutRequest, type PosCheckoutResponse, type PricingOption, type PricingOptions, type QueryAvailableTicketsOptions, type QueryAvailableTicketsRequest, type QueryAvailableTicketsResponse, type QueryEventsWithPaidReservationsRequest, type QueryEventsWithPaidReservationsResponse, type RawHttpResponse, type Reservation, type ReservationCount, type ReservationCreated, ReservationStatus, type ReservationStatusWithLiterals, type ReservationUpdated, type ResponseMetaData, ScheduledActionEnumAction, type ScheduledActionEnumActionWithLiterals, type StandardDetails, State, type StateWithLiterals, type StreetAddress, type Subdivision, SubdivisionType, type SubdivisionTypeWithLiterals, type Tax, TaxType, type TaxTypeWithLiterals, type Ticket, type TicketDefinition, TicketDefinitionFieldset, type TicketDefinitionFieldsetWithLiterals, type TicketDetails, type TicketPricing, type TicketPricingPriceOneOf, type TicketQuantity, type TicketReservation, type TicketReservationQuantity, type TicketSalePeriod, TicketSaleStatus, type TicketSaleStatusWithLiterals, type TicketSales, type TicketingTicket, Type, type TypeWithLiterals, type UpdateCheckoutOptions, type UpdateCheckoutRequest, type UpdateCheckoutResponse, type UpdateOrderApplicationErrors, type UpdateOrderIdentifiers, type UpdateOrderOptions, type UpdateOrderRequest, type UpdateOrderResponse, type VoidAuthorizedPaymentApplicationErrors, type VoidAuthorizedPaymentOptions, type VoidAuthorizedPaymentRequest, type VoidAuthorizedPaymentResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, type WixFeeConfig, bulkUpdateOrders, cancelReservation, captureAuthorizedPayment, checkout, confirmOrder, createReservation, getCheckoutOptions, getInvoice, getOrder, getSummary, listAvailableTickets, listOrders, onOrderConfirmed, onOrderDeleted, onOrderInitiated, onOrderReservationCreated, onOrderReservationUpdated, onOrderUpdated, posCheckout, queryAvailableTickets, updateCheckout, updateOrder, voidAuthorizedPayment };
