import { ListOrdersRequest as ListOrdersRequest$1, ListOrdersResponse as ListOrdersResponse$1, GetOrderRequest as GetOrderRequest$1, GetOrderResponse as GetOrderResponse$1, UpdateOrderRequest as UpdateOrderRequest$1, UpdateOrderResponse as UpdateOrderResponse$1, BulkUpdateOrdersRequest as BulkUpdateOrdersRequest$1, BulkUpdateOrdersResponse as BulkUpdateOrdersResponse$1, ConfirmOrderRequest as ConfirmOrderRequest$1, ConfirmOrderResponse as ConfirmOrderResponse$1, GetSummaryRequest as GetSummaryRequest$1, GetSummaryResponse as GetSummaryResponse$1, CaptureAuthorizedPaymentRequest as CaptureAuthorizedPaymentRequest$1, CaptureAuthorizedPaymentResponse as CaptureAuthorizedPaymentResponse$1, VoidAuthorizedPaymentRequest as VoidAuthorizedPaymentRequest$1, VoidAuthorizedPaymentResponse as VoidAuthorizedPaymentResponse$1, GetCheckoutOptionsRequest as GetCheckoutOptionsRequest$1, GetCheckoutOptionsResponse as GetCheckoutOptionsResponse$1, ListAvailableTicketsRequest as ListAvailableTicketsRequest$1, ListAvailableTicketsResponse as ListAvailableTicketsResponse$1, QueryAvailableTicketsRequest as QueryAvailableTicketsRequest$1, QueryAvailableTicketsResponse as QueryAvailableTicketsResponse$1, CreateReservationRequest as CreateReservationRequest$1, CreateReservationResponse as CreateReservationResponse$1, CancelReservationRequest as CancelReservationRequest$1, CancelReservationResponse as CancelReservationResponse$1, GetInvoiceRequest as GetInvoiceRequest$1, GetInvoiceResponse as GetInvoiceResponse$1, CheckoutRequest as CheckoutRequest$1, CheckoutResponse as CheckoutResponse$1, UpdateCheckoutRequest as UpdateCheckoutRequest$1, UpdateCheckoutResponse as UpdateCheckoutResponse$1, PosCheckoutRequest as PosCheckoutRequest$1, PosCheckoutResponse as PosCheckoutResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

interface Order {
    /** Unique order number. */
    orderNumber?: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    reservationId?: string;
    /**
     * Payment snapshot ID.
     * Empty if `status` of the order is `"FREE"`.
     * @format GUID
     * @readonly
     */
    snapshotId?: string;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /**
     * Contact ID of buyer, resolved using the email address specified. See the Contacts API for additional information.
     * @format GUID
     */
    contactId?: string;
    /**
     * Buyer member ID, if applicable. See the Members API for additional information.
     * @format GUID
     */
    memberId?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /** Guest first name. */
    firstName?: string;
    /** Guest last name. */
    lastName?: string;
    /**
     * Guest email address.
     * @format EMAIL
     */
    email?: string;
    /** Checkout form response. When each purchased ticket is assigned to a guest, guest forms are returned for each ticket, and buyer info is returned. */
    checkoutForm?: FormResponse;
    /** Whether the order is confirmed. Triggered once the payment gateway processes the payment and funds reach the merchant's account. */
    confirmed?: boolean;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Payment method used for purchase, for example, "payPal", "creditCard", etc. */
    method?: string;
    /** Amount of tickets ordered. */
    ticketsQuantity?: number;
    /** Total order price. */
    totalPrice?: Money;
    /** Ticket PDF URL. */
    ticketsPdf?: string;
    /** Tickets (generated after payment). */
    tickets?: TicketingTicket[];
    /** Whether the order is archived. */
    archived?: boolean;
    /** Whether the order is anonymized by GDPR delete. */
    anonymized?: boolean;
    /** Guest full name. */
    fullName?: string;
    /** Order invoice. */
    invoice?: Invoice;
    /** Whether all tickets in an order are checked in. */
    fullyCheckedIn?: boolean;
    /** Internal order payment details. */
    paymentDetails?: PaymentDetails;
    /** Checkout channel type. */
    channel?: ChannelTypeWithLiterals;
    /**
     * Date and time the order was last updated.
     * @readonly
     */
    updated?: Date | null;
    /** Whether marketing consent was given. */
    marketingConsent?: boolean | null;
}
interface FormResponse {
    /**
     * Form field inputs.
     * @maxSize 200
     */
    inputValues?: InputValue[];
}
interface InputValue {
    /**
     * Form field input name.
     * @maxLength 100
     */
    inputName?: string;
    /**
     * Form field value.
     * @maxLength 5000
     */
    value?: string;
    /**
     * Form field values.
     * @maxSize 100
     * @maxLength 5000
     */
    values?: string[];
}
interface FormattedAddress {
    /**
     * 1-line address representation.
     * @maxLength 200
     */
    formatted?: string;
    /** Address components. */
    address?: Address;
}
/** Physical address */
interface Address extends AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
/** @oneof */
interface AddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
}
interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
}
interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
interface Subdivision {
    /** Short subdivision code. */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
/** Subdivision Concordance values */
interface StandardDetails {
    /**
     * subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30
     * @maxLength 20
     */
    iso31662?: string | null;
}
declare enum OrderStatus {
    /** Order status isn't available for this request fieldset. */
    NA_ORDER_STATUS = "NA_ORDER_STATUS",
    /** Order is confirmed, no payment is required. */
    FREE = "FREE",
    /** Order was paid, but the payment gateway suspended the payment. */
    PENDING = "PENDING",
    /** Order is paid. */
    PAID = "PAID",
    /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `"PAID"`. */
    OFFLINE_PENDING = "OFFLINE_PENDING",
    /** Order is waiting for payment at the cashier. */
    INITIATED = "INITIATED",
    /** Order is canceled. */
    CANCELED = "CANCELED",
    /** Order payment is declined. */
    DECLINED = "DECLINED",
    /** Order payment is authorized. */
    AUTHORIZED = "AUTHORIZED",
    /** Order payment is voided. */
    VOIDED = "VOIDED",
    /** Order is partially paid with less than the total amount. */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
/** @enumType */
type OrderStatusWithLiterals = OrderStatus | 'NA_ORDER_STATUS' | 'FREE' | 'PENDING' | 'PAID' | 'OFFLINE_PENDING' | 'INITIATED' | 'CANCELED' | 'DECLINED' | 'AUTHORIZED' | 'VOIDED' | 'PARTIALLY_PAID';
interface Money {
    /**
     * *Deprecated:** Use `value` instead.
     * @format DECIMAL_VALUE
     * @deprecated
     */
    amount?: string;
    /**
     * 3-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. For example, `USD`.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     */
    value?: string | null;
}
interface TicketingTicket {
    /** Unique ticket number which is assigned automatically when creating a ticket. */
    ticketNumber?: string;
    /** Associated order number. */
    orderNumber?: string;
    /**
     * Ticket definition ID. See the Ticket Definition API for additional information.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket type. */
    name?: string;
    /** Ticket price. */
    price?: Money;
    /**
     * Whether the ticket requires payment.
     * @readonly
     */
    free?: boolean;
    /** Ticket and event policies. */
    policy?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Associated order status. */
    orderStatus?: OrderStatusWithLiterals;
    /**
     * Whether the order and ticket are archived.
     * If set to `true`, they aren't visible in the order list.
     */
    orderArchived?: boolean;
    /** Buyer full name. */
    orderFullName?: string;
    /** Guest full name. */
    guestFullName?: string | null;
    /** Guest personal details. */
    guestDetails?: GuestDetails;
    /** Whether the ticket is visible in an order. */
    archived?: boolean;
    /**
     * Ticket owner member ID.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Whether ticket was anonymized by GDPR delete.
     * Anonymized tickets no longer contain personally identifiable information (PII).
     */
    anonymized?: boolean;
    /**
     * Ticket check-in URL.
     *
     * Shown as QR code image in PDF.  <br/>
     * Format: `"https://www.wixevents.com/check-in/{ticket number},{event id}"`  <br/>
     * Example: `"https://www.wixevents.com/check-in/AAAA-AAAA-BB021,00000000-0000-0000-0000-000000000000"`
     */
    checkInUrl?: string;
    /** URL for ticket PDF download. */
    ticketPdfUrl?: string;
    /** Associated order checkout channel type. */
    channel?: ChannelTypeWithLiterals;
    /**
     * URL to download a ticket in `.pkpass` format for Apple Wallet.
     * @format WEB_URL
     * @readonly
     */
    walletPassUrl?: string;
    /**
     * Whether ticket is canceled.
     * @readonly
     */
    canceled?: boolean | null;
}
interface CheckIn {
    /** Time of a ticket's check-in. */
    created?: Date | null;
}
interface GuestDetails {
    /** Whether ticket belongs to assigned guest. */
    guestAssigned?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /**
     * Guest email.
     * @format EMAIL
     */
    email?: string | null;
    /** Full form response. */
    form?: FormResponse;
    /**
     * Contact ID associated with this guest.
     * @format GUID
     */
    contactId?: string | null;
    /**
     * Guest phone number.
     * @format PHONE
     */
    phone?: string | null;
}
declare enum ChannelType {
    /** Buyer created the order via an online channel, such as a website or mobile app. */
    ONLINE = "ONLINE",
    /** Sales person created the order and collected the money. */
    OFFLINE_POS = "OFFLINE_POS"
}
/** @enumType */
type ChannelTypeWithLiterals = ChannelType | 'ONLINE' | 'OFFLINE_POS';
interface TicketDetails {
    /**
     * Unique seat ID in the event venue.
     * @minLength 1
     * @maxLength 36
     */
    seatId?: string | null;
    /**
     * Section label.
     * @readonly
     */
    sectionLabel?: string | null;
    /**
     * Area label.
     * @readonly
     */
    areaLabel?: string | null;
    /**
     * Table label.
     * @readonly
     */
    tableLabel?: string | null;
    /**
     * Row label.
     * @readonly
     */
    rowLabel?: string | null;
    /**
     * Seat label in a row or table.
     * @readonly
     */
    seatLabel?: string | null;
    /**
     * Seating plan ID.
     * @format GUID
     * @readonly
     */
    planId?: string | null;
    /**
     * Number of places in the spot.
     *
     * Default: `1`.
     * @min 1
     * @max 50
     */
    capacity?: number | null;
    /**
     * Custom price of a ticket.
     * @format DECIMAL_VALUE
     */
    priceOverride?: string | null;
    /**
     * Pricing option ID.
     * @format GUID
     */
    pricingOptionId?: string | null;
    /**
     * Pricing option name.
     * @readonly
     */
    pricingOptionName?: string | null;
}
interface Invoice {
    items?: Item[];
    /**
     * Total cart amount.
     * @deprecated
     */
    total?: Money;
    /** Discount applied to a cart. */
    discount?: Discount;
    /** Tax applied to a cart. */
    tax?: Tax;
    /** Total cart amount before discount, tax, and fees. */
    subTotal?: Money;
    /**
     * Total amount of a cart after discount, tax, and fees.
     * Grand total is calculated in the following order:
     * 1. Total prices of all items in the cart are calculated.
     * 2. Discount is subtracted from the cart, if applicable.
     * 3. Tax is added, if applicable.
     * 4. Wix ticket service fee is added.
     */
    grandTotal?: Money;
    /**
     * Fees applied to the cart.
     * @readonly
     */
    fees?: Fee[];
    /** Total revenue, excluding fees. Taxes and payment provider fees aren't deducted. */
    revenue?: Money;
    /** Invoice preview URL. Only returned if the order is paid. */
    previewUrl?: string | null;
}
interface Item {
    /**
     * Unique line item ID.
     * @format GUID
     */
    id?: string;
    /**
     * Line item quantity.
     * @min 1
     * @max 50
     */
    quantity?: number;
    /** Line item name. */
    name?: string;
    /** Line item price. */
    price?: Money;
    /** Total price for line items. Always equal to price * quantity. */
    total?: Money;
    /** Discount applied to the line item. */
    discount?: Discount;
    /** Tax applied to the item. */
    tax?: Tax;
    /**
     * Fees applied to the item.
     * @readonly
     */
    fees?: Fee[];
}
interface Discount {
    /** Total discount amount. */
    amount?: Money;
    /** Total sum after the discount. */
    afterDiscount?: Money;
    /**
     * Discount coupon code.
     * @deprecated
     */
    code?: string;
    /**
     * Discount coupon name.
     * @deprecated
     */
    name?: string;
    /**
     * Discount coupon ID.
     * @deprecated
     */
    couponId?: string;
    /** Discount items. */
    discounts?: DiscountItem[];
}
interface DiscountItem extends DiscountItemDiscountOneOf {
    /** Coupon discount. */
    coupon?: CouponDiscount;
    /** Pricing plan discount. */
    paidPlan?: PaidPlanDiscount;
    /** Total discount amount. */
    amount?: Money;
}
/** @oneof */
interface DiscountItemDiscountOneOf {
    /** Coupon discount. */
    coupon?: CouponDiscount;
    /** Pricing plan discount. */
    paidPlan?: PaidPlanDiscount;
}
interface CouponDiscount {
    /** Discount coupon name. **Deprecated:** Use `invoice.discounts.coupon.name` instead. */
    name?: string;
    /** Discount coupon code. **Deprecated:** Use `invoice.discounts.coupon.code` instead. */
    code?: string;
    /** Discount coupon ID. **Deprecated:** Use `invoice.discounts.coupon.couponId` instead. */
    couponId?: string;
}
interface PaidPlanDiscount extends PaidPlanDiscountDiscountOneOf {
    /** Discount by percentage applied to tickets. */
    percentDiscount?: PercentDiscount;
    /** Name of pricing plan. */
    name?: string;
}
/** @oneof */
interface PaidPlanDiscountDiscountOneOf {
    /** Discount by percentage applied to tickets. */
    percentDiscount?: PercentDiscount;
}
interface PercentDiscount {
    /**
     * Percent rate.
     * @decimalValue options { gte:0.01, lte:100, maxScale:2 }
     */
    rate?: string;
    /** Number of discounted tickets. */
    quantityDiscounted?: number;
}
interface Tax {
    /** Tax type. */
    type?: TaxTypeWithLiterals;
    /**
     * Tax name.
     * @readonly
     */
    name?: string;
    /**
     * Tax rate.
     * @format DECIMAL_VALUE
     */
    rate?: string;
    /** Taxable amount. */
    taxable?: Money;
    /** Total tax amount. */
    amount?: Money;
}
declare enum TaxType {
    /** Tax is included in the ticket price. */
    INCLUDED = "INCLUDED",
    /** Tax is added to the order at the checkout. */
    ADDED = "ADDED",
    /** Tax is added to the final total at the checkout. */
    ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
}
/** @enumType */
type TaxTypeWithLiterals = TaxType | 'INCLUDED' | 'ADDED' | 'ADDED_AT_CHECKOUT';
interface Fee {
    /** Fee identifier. */
    name?: FeeNameWithLiterals;
    /** How fee is calculated. */
    type?: FeeTypeWithLiterals;
    /**
     * Fee rate.
     * @format DECIMAL_VALUE
     * @readonly
     */
    rate?: string;
    /** Total amount of fee charges. */
    amount?: Money;
}
declare enum FeeName {
    /** Wix ticket service fee charges applied to the line item. */
    WIX_FEE = "WIX_FEE"
}
/** @enumType */
type FeeNameWithLiterals = FeeName | 'WIX_FEE';
declare enum FeeType {
    /** Fee is added to the ticket price at checkout. */
    FEE_ADDED = "FEE_ADDED",
    /** Seller absorbs the fee. It's deducted from the ticket price. */
    FEE_INCLUDED = "FEE_INCLUDED",
    /** Fee is added to the ticket price at checkout. */
    FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT"
}
/** @enumType */
type FeeTypeWithLiterals = FeeType | 'FEE_ADDED' | 'FEE_INCLUDED' | 'FEE_ADDED_AT_CHECKOUT';
interface PaymentDetails {
    /** Wix Payments transaction. */
    transaction?: PaymentTransaction;
}
interface PaymentTransaction {
    /**
     * Wix Payments transaction ID.
     * @format GUID
     * @readonly
     */
    transactionId?: string;
    /**
     * Transaction payment method, for example, "payPal", "creditCard", etc.
     * @readonly
     */
    method?: string;
}
declare enum ScheduledActionEnumAction {
    /** Action not scheduled. */
    UNKNOWN_ACTION = "UNKNOWN_ACTION",
    /** Captured after the delay. */
    CAPTURE = "CAPTURE",
    /** Void after the delay. */
    VOID = "VOID"
}
/** @enumType */
type ScheduledActionEnumActionWithLiterals = ScheduledActionEnumAction | 'UNKNOWN_ACTION' | 'CAPTURE' | 'VOID';
declare enum Action {
    /** Order can be archived. */
    ARCHIVE = "ARCHIVE",
    /** Order can be unarchived. */
    UNARCHIVE = "UNARCHIVE",
    /** Order can be confirmed. */
    CONFIRM = "CONFIRM",
    /** Order can be captured. */
    CAPTURE = "CAPTURE",
    /** Order can be voided. */
    VOID = "VOID"
}
/** @enumType */
type ActionWithLiterals = Action | 'ARCHIVE' | 'UNARCHIVE' | 'CONFIRM' | 'CAPTURE' | 'VOID';
interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @format GUID
     */
    giftCardPaymentId?: string | null;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string | null;
    /** Whether the gift card payment is voided. */
    voided?: boolean | null;
    /** Amount */
    amount?: Money;
    /**
     * Obfuscated gift card code.
     * @maxLength 30
     */
    obfuscatedCode?: string | null;
    /**
     * Gift card code.
     * @maxLength 30
     */
    code?: string | null;
}
interface BalanceSummary {
    /** Amount left to pay. */
    balance?: Money;
}
/** Triggered when an order is deleted. */
interface OrderDeleted {
    /** Date and time the order was deleted. */
    timestamp?: Date | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Whether the order was anonymized by GDPR delete. */
    anonymized?: boolean;
    /** Order type. */
    orderType?: OrderTypeWithLiterals;
    /** Whether the event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
}
declare enum OrderType {
    /** Buyer form is used for all tickets. */
    UNASSIGNED_TICKETS = "UNASSIGNED_TICKETS",
    /** Each order ticket has its own form. */
    ASSIGNED_TICKETS = "ASSIGNED_TICKETS"
}
/** @enumType */
type OrderTypeWithLiterals = OrderType | 'UNASSIGNED_TICKETS' | 'ASSIGNED_TICKETS';
interface Ticket {
    /** Unique issued ticket number. */
    ticketNumber?: string;
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Ticket check-in. */
    checkIn?: CheckIn;
    /** Ticket price. */
    price?: Money;
    /** Whether ticket is archived. */
    archived?: boolean;
    /** Guest first name. */
    firstName?: string | null;
    /** Guest last name. */
    lastName?: string | null;
    /** Guest email. */
    email?: string | null;
    /**
     * Contact ID associated with this ticket.
     * @format GUID
     */
    contactId?: string | null;
    /** Whether ticket is confirmed */
    confirmed?: boolean;
    /**
     * Member ID associated with this ticket.
     * @format GUID
     */
    memberId?: string | null;
    /** Ticket form response (only assigned tickets contain separate forms). */
    form?: FormResponse;
    /** Ticket name. */
    ticketName?: string;
    /** Anonymized tickets no longer contain personally identifiable information (PII). */
    anonymized?: boolean;
    /** URL and password to online conference */
    onlineConferencingLogin?: OnlineConferencingLogin;
    /**
     * Seat ID associated with this ticket.
     * @maxLength 36
     */
    seatId?: string | null;
    /** Whether ticket is canceled. */
    canceled?: boolean | null;
}
interface OnlineConferencingLogin {
    /**
     * Link URL to the online conference.
     * @format WEB_URL
     * @readonly
     */
    link?: string;
    /**
     * Password for the online conference.
     * @readonly
     */
    password?: string | null;
}
interface ListOrdersRequest {
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     * @max 400
     */
    limit?: number;
    /**
     * Which fields to return.
     * @maxSize 20
     */
    fieldset?: OrderFieldsetWithLiterals[];
    /** Status. */
    status?: OrderStatusWithLiterals[];
    /**
     * Event ID.
     * @format GUID
     * @maxSize 100
     */
    eventId?: string[];
    /**
     * Order number.
     * @maxLength 36
     * @maxSize 500
     */
    orderNumber?: string[];
    /**
     * Site member ID.
     * @format GUID
     * @maxSize 500
     */
    memberId?: string[];
    /**
     * Field facets.
     * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-orders).
     * @maxLength 100
     * @maxSize 20
     */
    facet?: string[];
    /**
     * Textual search filter - search is performed on "full_name", "email" and "order_number".
     * @maxLength 200
     */
    searchPhrase?: string;
    /**
     * Event creator ID.
     * @format GUID
     * @maxSize 50
     */
    eventCreatorId?: string[];
    /**
     * Sort order. Defaults to "created:asc".
     * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-orders).
     * @maxLength 100
     */
    sort?: string;
    /** Order tag. */
    tag?: OrderTagWithLiterals[];
    /**
     * Guest contact IDs.
     * @format GUID
     * @maxSize 100
     */
    contactId?: string[];
}
declare enum OrderFieldset {
    /** Returns `tickets`. */
    TICKETS = "TICKETS",
    /**
     * Returns `archived`, `confirmed`, `created`, `firstName`, `fullName`,
     * `lastName`, `method`, `reservationId`, `snapshotId`,
     * `status`, `ticketsPdf`, `ticketsQuantity`, `totalPrice`.
     */
    DETAILS = "DETAILS",
    /** Returns `checkoutForm`. */
    FORM = "FORM",
    /** Returns `invoice`. */
    INVOICE = "INVOICE"
}
/** @enumType */
type OrderFieldsetWithLiterals = OrderFieldset | 'TICKETS' | 'DETAILS' | 'FORM' | 'INVOICE';
declare enum OrderTag {
    /** Return only confirmed orders. */
    CONFIRMED = "CONFIRMED",
    /** Return only unconfirmed orders. */
    UNCONFIRMED = "UNCONFIRMED",
    /** Return only member orders. */
    MEMBER = "MEMBER",
    /** Return only archived orders. */
    ARCHIVED = "ARCHIVED",
    /** Return only non archived orders. */
    NON_ARCHIVED = "NON_ARCHIVED",
    /** Return only orders with all guests checked-in. */
    FULLY_CHECKED_IN = "FULLY_CHECKED_IN",
    /** Return only orders with no guests checked-in. */
    NOT_FULLY_CHECKED_IN = "NOT_FULLY_CHECKED_IN"
}
/** @enumType */
type OrderTagWithLiterals = OrderTag | 'CONFIRMED' | 'UNCONFIRMED' | 'MEMBER' | 'ARCHIVED' | 'NON_ARCHIVED' | 'FULLY_CHECKED_IN' | 'NOT_FULLY_CHECKED_IN';
interface ListOrdersResponse {
    /** Total orders matching the given filters. */
    total?: number;
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     * @max 100
     */
    limit?: number;
    /** Orders. */
    orders?: Order[];
    /** Filter facets. */
    facets?: Record<string, FacetCounts>;
    /** Order data enriched facets. */
    orderFacets?: OrderFacets;
}
interface FacetCounts {
    /** Facet counts aggregated per value. */
    counts?: Record<string, number>;
}
interface OrderFacets {
    /** Filter facets. */
    facets?: Record<string, OrderFacetCounts>;
}
interface OrderFacetCounts {
    /** Facet counts aggregated per value */
    counts?: Record<string, Counts>;
}
interface Counts {
    /** Number or orders */
    count?: number;
    /** Number of tickets within orders */
    tickets?: number;
    /** Number of tickets with check-in */
    ticketsCheckIn?: number;
}
interface GetOrderRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
    /**
     * Which fields to return.
     * @maxSize 20
     */
    fieldset?: OrderFieldsetWithLiterals[];
}
interface GetOrderResponse {
    /** Requested order. */
    order?: Order;
    /** "Add to calendar" links. */
    calendarLinks?: CalendarLinks;
}
interface CalendarLinks {
    /** "Add to Google calendar" URL. */
    google?: string;
    /** "Download ICS calendar file" URL. */
    ics?: string;
}
interface UpdateOrderRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
    /** Set of field paths to update. */
    fields?: string[];
    /** Checkout form. */
    checkoutForm?: FormResponse;
    /** Whether to archive the order. */
    archived?: boolean;
}
interface UpdateOrderResponse {
    /** Updated order. */
    order?: Order;
}
/** Triggered when an order is updated. */
interface OrderUpdated {
    /** Date and time the order was updated. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
    confirmed?: boolean;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets generated after payment. */
    tickets?: Ticket[];
    /** Whether order was archived and excluded from results. */
    archived?: boolean;
    /** Whether event was triggered by GDPR delete request. */
    triggeredByAnonymizeRequest?: boolean;
}
interface BulkUpdateOrdersRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @minLength 1
     * @maxLength 36
     * @minSize 1
     * @maxSize 100
     */
    orderNumber?: string[];
    /** Set of fields to update. */
    fields?: string[];
    /** Whether to archive the order. */
    archived?: boolean;
}
interface BulkUpdateOrdersResponse {
    /** Updated orders. */
    orders?: Order[];
}
interface ConfirmOrderRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Order numbers.
     * @minLength 1
     * @maxLength 36
     * @maxSize 100
     */
    orderNumber?: string[];
}
interface ConfirmOrderResponse {
    /** Confirmed orders. */
    orders?: Order[];
}
interface GetSummaryRequest {
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string | null;
}
interface GetSummaryResponse {
    /** Ticket sales grouped by currency. */
    sales?: TicketSales[];
}
interface TicketSales {
    /** Total balance of confirmed transactions. */
    total?: Money;
    /** Total number of confirmed orders. */
    totalOrders?: number;
    /** Total number of tickets purchased. */
    totalTickets?: number;
    /** Total revenue, excluding fees (taxes and payment provider fees are not deducted). */
    revenue?: Money;
}
interface GetInvoicePreviewRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /** Order number. */
    orderNumber?: string;
}
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface GetPaymentInfoRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /** Order number. */
    orderNumber?: string;
}
interface GetPaymentInfoResponse {
    transactions?: PaymentTransactionSummary[];
    status?: string | null;
    /**
     * @format GUID
     * @readonly
     */
    transactionId?: string | null;
    /** Whether at least one transaction that is not in the final status exists. */
    active?: boolean;
}
interface PaymentTransactionSummary {
    /**
     * Wix Payments transaction ID.
     * @format GUID
     * @readonly
     */
    transactionId?: string;
    /**
     * Final transaction status.
     * @readonly
     */
    finalTransactionStatus?: string;
    /** Transaction events. */
    events?: PaymentTransactionEvent[];
}
interface PaymentTransactionEvent {
    /**
     * Order snapshot ID.
     * @format GUID
     * @readonly
     */
    snapshotId?: string;
    /**
     * Transaction status
     * @readonly
     */
    transactionStatus?: string;
    /**
     * Transaction Payment method e.g., "payPal", "creditCard", etc.
     * @readonly
     */
    paymentMethod?: string;
    /**
     * Transaction payment amount
     * @readonly
     */
    paymentAmount?: Money;
    /**
     * Crated date
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Reason code
     * @readonly
     */
    reasonCode?: string | null;
    /**
     * Refunded amount
     * @readonly
     */
    refundedAmount?: Money;
}
interface CaptureAuthorizedPaymentRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /**
     * Order number.
     * @minLength 1
     * @maxLength 36
     */
    orderNumber: string;
}
interface CaptureAuthorizedPaymentResponse {
}
interface VoidAuthorizedPaymentRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string;
    /**
     * Order number.
     * @minLength 1
     * @maxLength 36
     */
    orderNumber: string;
}
interface VoidAuthorizedPaymentResponse {
}
interface FindOrderByReservationIdRequest {
    /**
     * Event ID
     * @format GUID
     */
    eventId?: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    reservationId?: string;
}
interface FindOrderByReservationIdResponse {
    /** Order. */
    order?: Order;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** Triggered when an order is confirmed. */
interface OrderConfirmed {
    /** Date and time the order was confirmed. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Notifications silenced for this domain event. */
    silent?: boolean | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /** Buyer first name. */
    firstName?: string;
    /** Buyer last name. */
    lastName?: string;
    /** Buyer email address. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
    method?: string | null;
    /** Tickets (generated after payment). */
    tickets?: Ticket[];
    /** Invoice. */
    invoice?: Invoice;
    /** Reservation ID associated with the order. */
    reservationId?: string;
}
/** Triggered when an order is paid. */
interface OrderPaid {
    /** Date and time the order was paid. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Notifications silenced for this domain event. */
    silent?: boolean | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Reservation ID associated with this order. */
    reservationId?: string;
    /**
     * Contact ID associated with this order.
     * @maxLength 36
     */
    contactId?: string;
    /**
     * Member ID associated with this order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Buyer first name.
     * @maxLength 255
     */
    firstName?: string;
    /**
     * Buyer last name.
     * @maxLength 255
     */
    lastName?: string;
    /**
     * Buyer email address.
     * @maxLength 255
     */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /**
     * Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc.
     * @maxLength 255
     */
    method?: string | null;
    /**
     * Tickets (generated after payment).
     * @maxSize 50
     */
    tickets?: Ticket[];
    /** Invoice. */
    invoice?: Invoice;
}
/** Triggered when a reservation is created. */
interface ReservationCreated {
    /** Date and time the reservation was created. */
    timestamp?: Date | null;
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId?: string;
    /**
     * Reservation ID.
     * Can be used to retrieve a reservation invoice.
     * @format GUID
     */
    reservationId?: string;
    /** Date and time the reservation expires. */
    expires?: Date | null;
    /** Reservation status. */
    status?: ReservationStatusWithLiterals;
    /**
     * Amount of tickets in the reservation.
     * @maxSize 50
     */
    quantities?: TicketQuantity[];
    /** Date and time the reservation was updated. */
    updatedDate?: Date | null;
    /**
     * Number of reservations.
     * @maxSize 50
     */
    counts?: ReservationCount[];
}
declare enum ReservationStatus {
    /** The reservation is pending confirmation. It will expire after a certain amount of time. */
    RESERVATION_PENDING = "RESERVATION_PENDING",
    /** The reservation is confirmed and won't expire. */
    RESERVATION_CONFIRMED = "RESERVATION_CONFIRMED",
    /** The reservation is canceled because it's not paid. */
    RESERVATION_CANCELED = "RESERVATION_CANCELED",
    /** The reservation is canceled manually by the buyer. */
    RESERVATION_CANCELED_MANUALLY = "RESERVATION_CANCELED_MANUALLY",
    /** The reservation has expired. */
    RESERVATION_EXPIRED = "RESERVATION_EXPIRED"
}
/** @enumType */
type ReservationStatusWithLiterals = ReservationStatus | 'RESERVATION_PENDING' | 'RESERVATION_CONFIRMED' | 'RESERVATION_CANCELED' | 'RESERVATION_CANCELED_MANUALLY' | 'RESERVATION_EXPIRED';
interface TicketQuantity {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string | null;
    /** Quantity. */
    quantity?: number | null;
    /** Quantity update timestamp. */
    updatedDate?: Date | null;
}
interface ReservationCount {
    /** Reservation Count snapshot timestamp. */
    timestamp?: Date | null;
    /**
     * Ticket Definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /** Confirmed reservation count. */
    confirmedCount?: number;
    /** Pending reservation count. */
    pendingCount?: number;
    /** True if paid ticket reservation exist. */
    paidExists?: boolean;
}
/** Triggered when a reservation is updated. */
interface ReservationUpdated {
    /** Date and time the reservation was updated. */
    timestamp?: Date | null;
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId?: string;
    /**
     * Reservation ID.
     * Can be used to retrieve a reservation invoice.
     * @format GUID
     */
    reservationId?: string;
    /** Reservation status. */
    status?: ReservationStatusWithLiterals;
    /** Date and time the reservation expires. */
    expires?: Date | null;
    /**
     * Amount of tickets in the reservation.
     * @maxSize 50
     */
    quantities?: TicketQuantity[];
    /** Date and time the reservation was updated. */
    updatedDate?: Date | null;
    /**
     * Number of reservations.
     * @maxSize 50
     */
    counts?: ReservationCount[];
}
interface GetCheckoutOptionsRequest {
}
interface GetCheckoutOptionsResponse {
    /** Whether any payment method is configured and available for payment. */
    paymentMethodConfigured?: boolean;
    /** Whether coupons are accepted at checkout. */
    acceptCoupons?: boolean;
    /** Whether premium services are enabled. Enabled for free if site doesn't sell any paid tickets. Selling tickets for a fee requires a premium feature `"events_sell_tickets"`. */
    premiumServices?: boolean;
    /** Whether there are any paid tickets available for sale. */
    paidTickets?: boolean;
    /** Whether gift cards are accepted at checkout. */
    acceptGiftCards?: boolean;
}
interface ListAvailableTicketsRequest {
    /**
     * Event ID to list tickets for. If not specified, available tickets for all events on a site will be returned.
     * @format GUID
     */
    eventId?: string;
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     *
     * **Default:** `0`. If you don't pass this field in the request, only `metadata` is returned.
     * @max 100
     */
    limit?: number;
    /**
     * Sort order.
     *
     * Default: `created:asc`.
     * @maxLength 100
     */
    sort?: string;
    state?: StateWithLiterals[];
}
declare enum State {
    INCLUDE_HIDDEN_NOT_ON_SALE = "INCLUDE_HIDDEN_NOT_ON_SALE"
}
/** @enumType */
type StateWithLiterals = State | 'INCLUDE_HIDDEN_NOT_ON_SALE';
interface ListAvailableTicketsResponse {
    /** Ticket definitions meta data. */
    metaData?: ResponseMetaData;
    /** Ticket definitions. */
    definitions?: TicketDefinition[];
}
interface ResponseMetaData {
    /** Number of items in the response. */
    count?: number;
    /** Offset of items. */
    offset?: number;
    /** Total number of matching items. */
    total?: number;
}
interface TicketDefinition {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    id?: string;
    /** Ticket price. */
    price?: Money;
    /** Whether the ticket is free (read only). */
    free?: boolean;
    /** Ticket name. */
    name?: string;
    /** Ticket description. */
    description?: string;
    /**
     * Limit of tickets that can be purchased per checkout.
     * Set to 20 for unlimited ticket definition.
     * @max 20
     */
    limitPerCheckout?: number;
    /** Custom sort index. */
    orderIndex?: number;
    /** Policy information plain text block, as printed on the ticket. */
    policy?: string;
    /** Sensitive dashboard data. */
    dashboard?: Dashboard;
    /**
     * Event ID associated with the ticket.
     * @format GUID
     */
    eventId?: string;
    /**
     * Configuration of the fixed-rate Wix service fee that is applied at checkout to each ticket sold.
     * @readonly
     */
    wixFeeConfig?: WixFeeConfig;
    /** Ticket sale period. */
    salePeriod?: TicketSalePeriod;
    /**
     * Ticket sale status.
     * @readonly
     */
    saleStatus?: TicketSaleStatusWithLiterals;
    /** Ticket state. */
    state?: StateWithLiterals[];
    /** Ticket pricing. */
    pricing?: TicketPricing;
}
interface Dashboard {
    /** Whether ticket is hidden and cannot be sold. */
    hidden?: boolean;
    /**
     * Number of tickets sold and reserved.
     * @deprecated
     */
    sold?: number;
    /** Whether the ticket has limited quantity. */
    limited?: boolean;
    /** Ticket limit. `NULL` for unlimited ticket definitions. */
    quantity?: number | null;
    /** Number of unsold tickets. `NULL` for unlimited ticket definitions. */
    unsold?: number | null;
    /** Number of tickets sold. */
    ticketsSold?: number;
    /** Number of tickets reserved. */
    ticketsReserved?: number;
}
interface WixFeeConfig {
    /** Fee calculation method. */
    type?: FeeTypeWithLiterals;
}
interface TicketSalePeriod {
    /** Ticket sale start timestamp. */
    startDate?: Date | null;
    /** Ticket sale end timestamp. */
    endDate?: Date | null;
    /** Whether to hide this ticket if it isn't on sale. */
    hideNotOnSale?: boolean;
}
declare enum TicketSaleStatus {
    /** Ticket sale is scheduled to start. */
    SALE_SCHEDULED = "SALE_SCHEDULED",
    /** Ticket sale has started. */
    SALE_STARTED = "SALE_STARTED",
    /** Ticket sale has ended. */
    SALE_ENDED = "SALE_ENDED"
}
/** @enumType */
type TicketSaleStatusWithLiterals = TicketSaleStatus | 'SALE_SCHEDULED' | 'SALE_STARTED' | 'SALE_ENDED';
interface TicketPricing extends TicketPricingPriceOneOf {
    /** Ticket price which is read only. */
    fixedPrice?: Money;
    /** Min price per ticket, customizable. */
    minPrice?: Money;
    /** Ticket pricing options. */
    pricingOptions?: PricingOptions;
    /**
     * Ticket pricing type.
     * @readonly
     */
    pricingType?: TypeWithLiterals;
}
/** @oneof */
interface TicketPricingPriceOneOf {
    /** Ticket price which is read only. */
    fixedPrice?: Money;
    /** Min price per ticket, customizable. */
    minPrice?: Money;
    /** Ticket pricing options. */
    pricingOptions?: PricingOptions;
}
interface PricingOptions {
    /** Multiple ticket pricing options. */
    options?: PricingOption[];
}
interface PricingOption {
    /**
     * Ticket pricing option ID.
     * @format GUID
     */
    id?: string | null;
    /**
     * Ticket pricing option name.
     * @minLength 1
     * @maxLength 200
     */
    name?: string | null;
    /** Ticket pricing option price. */
    price?: Money;
}
declare enum Type {
    STANDARD = "STANDARD",
    DONATION = "DONATION"
}
/** @enumType */
type TypeWithLiterals = Type | 'STANDARD' | 'DONATION';
interface QueryAvailableTicketsRequest {
    /** Offset. */
    offset?: number;
    /**
     * Limit.
     *
     * **Default:** `0`. If you don't pass this field in the request, only `metadata` is returned.
     * @max 1000
     */
    limit?: number;
    /** Ticket definition. */
    filter?: Record<string, any> | null;
    /**
     * Which fields to return.
     * @maxSize 20
     */
    fieldset?: TicketDefinitionFieldsetWithLiterals[];
    /**
     * Sort order.
     *
     * Default: `"created:asc"`.
     * @maxLength 100
     */
    sort?: string;
}
declare enum TicketDefinitionFieldset {
    /** Include `policy` in the response. */
    POLICY = "POLICY",
    /** Include `dashboard` in the response. */
    DASHBOARD = "DASHBOARD"
}
/** @enumType */
type TicketDefinitionFieldsetWithLiterals = TicketDefinitionFieldset | 'POLICY' | 'DASHBOARD';
interface QueryAvailableTicketsResponse {
    /** Ticket definitions meta data. */
    metaData?: ResponseMetaData;
    /** Ticket definitions. */
    definitions?: TicketDefinition[];
}
interface CreateReservationRequest {
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Tickets to reserve.
     * @minSize 1
     * @maxSize 50
     */
    ticketQuantities?: TicketReservationQuantity[];
    /** Whether to ignore the available ticket limits upon a reservation. */
    ignoreLimits?: boolean;
    /** Whether to allow reservations for hidden tickets. */
    allowHiddenTickets?: boolean;
}
interface TicketReservationQuantity {
    /**
     * Ticket definition ID.
     * @format GUID
     */
    ticketDefinitionId?: string;
    /**
     * Quantity of tickets to reserve.
     * @min 1
     * @max 50
     */
    quantity?: number;
    /**
     * Ticket price to charge - overriding the ticket price.
     * @maxLength 13
     * @format DECIMAL_VALUE
     */
    priceOverride?: string | null;
    /** Optional ticket details. */
    ticketDetails?: TicketDetails[];
}
interface CreateReservationResponse {
    /**
     * Reservation ID.
     * @format GUID
     */
    id?: string;
    /** Date and time the reservation expires. */
    expires?: Date | null;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
    /** Reservation invoice. */
    invoice?: Invoice;
    /** Reservation status. */
    reservationStatus?: ReservationStatusWithLiterals;
}
interface TicketReservation {
    /**
     * Amount of reserved tickets.
     * @min 1
     * @max 20
     */
    quantity?: number;
    ticket?: TicketDefinition;
    /** Optional ticket details. */
    ticketDetails?: TicketDetails[];
}
interface CancelReservationRequest {
    /**
     * Event ID to which the reservation belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    id: string;
}
interface CancelReservationResponse {
}
interface GetInvoiceRequest {
    /**
     * Event ID to which the invoice belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Reservation ID.
     * @format GUID
     */
    reservationId: string;
    /** Optional discount to be applied on the returned invoice. */
    withDiscount?: DiscountRequest;
    /** Optional benefit granted by the pricing plan to be applied on the returned invoice. */
    paidPlanBenefit?: PaidPlanBenefit;
}
interface DiscountRequest {
    /**
     * Discount coupon code.
     * @maxLength 20
     */
    couponCode?: string;
}
interface PaidPlanBenefit {
    /**
     * Pricing plan ID.
     * @format GUID
     */
    planOrderId?: string;
    /**
     * Pricing plan benefit ID.
     * @format GUID
     */
    benefitId?: string;
}
interface GetInvoiceResponse {
    /** Invoice with applied discount. */
    invoice?: Invoice;
    /** Discount errors, if relevant. */
    discountErrors?: DiscountErrors;
    /** Time when the reservation expires. */
    expires?: Date | null;
    /** Reservation status. */
    reservationStatus?: ReservationStatusWithLiterals;
    /** Whether this reservation is already used in a checkout. */
    reservationOccupied?: boolean;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
}
interface DiscountErrors {
    /** Error. */
    error?: Error[];
}
interface Error {
    code?: string;
}
interface GiftCardErrors {
    /**
     * Error.
     * @maxSize 10
     */
    error?: GiftCardErrorsError[];
}
interface GiftCardErrorsError {
    /** @maxLength 100 */
    code?: string;
}
interface CheckoutRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId: string;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string;
    /** Member ID. If empty, no site member is associated with this order. */
    memberId?: string;
    /** Discount to apply on the invoice. */
    discount?: DiscountRequest;
    /** Buyer details. */
    buyer?: Buyer;
    /**
     * Guest details.
     * @minSize 1
     * @maxSize 50
     */
    guests?: Guest[];
    /** Benefit granted by the pricing plan. */
    paidPlanBenefit?: PaidPlanBenefit;
    /** Options controlling the checkout process. */
    options?: CheckoutOptions;
    /** Whether marketing consent was given. */
    marketingConsent?: boolean | null;
}
interface Buyer {
    /**
     * Buyer first name.
     * @minLength 1
     * @maxLength 50
     */
    firstName?: string;
    /**
     * Buyer last name.
     * @minLength 1
     * @maxLength 50
     */
    lastName?: string;
    /**
     * Buyer email.
     * @format EMAIL
     * @minLength 5
     * @maxLength 255
     */
    email?: string;
}
interface Guest {
    /** Specific guest info. */
    form?: FormResponse;
}
interface CheckoutOptions {
    /** Whether to ignore settings to notify contacts. */
    silent?: boolean;
    /** Whether the payment is to be done in person between the buyer and the merchant. When true, the completed order is created with status `OFFLINE_PENDING` and `inPerson` payment method. */
    payInPerson?: boolean;
    /** Whether to ignore form validation. */
    ignoreFormValidation?: boolean;
    /** Marks payment as already paid */
    markAsPaid?: boolean | null;
}
interface CheckoutResponse {
    /** Created order. */
    order?: Order;
    /** Time when the order expires, applies to orders with status = INITIATED. */
    expires?: Date | null;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
    /** Order page URL. */
    orderPageUrl?: string | null;
}
/** Triggered when an order is initiated. */
interface OrderInitiated {
    /** Date and time the order was initiated. */
    timestamp?: Date | null;
    /**
     * Site language when the order was initiated.
     * @format LANGUAGE
     */
    language?: string | null;
    /**
     * Locale in which the order was created.
     * @format LANGUAGE_TAG
     */
    locale?: string | null;
    /**
     * Event ID to which the order belongs.
     * @format GUID
     */
    eventId?: string;
    /** Unique order number. */
    orderNumber?: string;
    /** Contact ID associated with the order. */
    contactId?: string;
    /**
     * Member ID associated with the order.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * Date and time the order was created.
     * @readonly
     */
    created?: Date | null;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updated?: Date | null;
    /** Guest first name. */
    firstName?: string;
    /** Guest last name. */
    lastName?: string;
    /** Guest email address. */
    email?: string;
    /** Checkout form response. */
    checkoutForm?: FormResponse;
    /** Order status. */
    status?: OrderStatusWithLiterals;
    /** Invoice. */
    invoice?: Invoice;
    /** Reservation ID associated with the order. */
    reservationId?: string;
    /** Order was marked as paid. */
    markedAsPaid?: boolean | null;
    /** Whether marketing consent was given. */
    marketingConsent?: boolean | null;
}
interface UpdateCheckoutRequest {
    /**
     * Event ID to which the checkout belongs.
     * @format GUID
     */
    eventId: string;
    /**
     * Unique order number.
     * @maxLength 36
     */
    orderNumber: string;
    /** Buyer details. */
    buyer?: Buyer;
    /**
     * Guest details.
     * @minSize 1
     * @maxSize 20
     */
    guests?: Guest[];
    /**
     * Member ID.
     *
     * If empty, no site member is associated with this order.
     */
    memberId?: string | null;
    /** Discount to apply on the invoice. */
    discount?: DiscountRequest;
    /** Benefit granted by the pricing plan. */
    paidPlanBenefit?: PaidPlanBenefit;
}
interface UpdateCheckoutResponse {
    /** Updated order. */
    order?: Order;
    /** Order page URL. */
    orderPageUrl?: string | null;
}
interface OrderPageUrls {
    /**
     * Success order page URL.
     * @format WEB_URL
     */
    success?: string | null;
    /**
     * Pending order page URL.
     * @format WEB_URL
     */
    pending?: string | null;
    /**
     * Canceled order page URL.
     * @format WEB_URL
     */
    canceled?: string | null;
    /**
     * Error order page URL.
     * @format WEB_URL
     */
    error?: string | null;
}
interface PosCheckoutRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId: string;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId: string;
    /**
     * Payment details ID.
     * Not required if reservation total is 0. In this case the order will be created with status `FREE` and no payment.
     * @format GUID
     */
    paymentDetailsId?: string | null;
}
interface PosCheckoutResponse {
    /** Created order. */
    order?: Order;
    /** Time when the order expires, applies to orders with status is `INITIATED`. */
    expires?: Date | null;
    /** Ticket reservations. */
    reservations?: TicketReservation[];
}
interface GetReservationRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string | null;
}
interface GetReservationResponse {
    /** Reservation. */
    reservation?: Reservation;
}
interface Reservation {
    /** Date and time the ticket reservation was created. */
    createdDate?: Date | null;
    /** Date and time the ticket reservation was last updated. */
    updatedDate?: Date | null;
    /** Date and time the pending ticket reservation will expire. */
    expirationDate?: Date | null;
    /** Reservation status. */
    reservationStatus?: ReservationStatusWithLiterals;
    /**
     * Ticket reservations.
     * @maxSize 50
     */
    reservations?: TicketReservation[];
}
interface ConfirmReservationRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string | null;
}
interface ConfirmReservationResponse {
    /** Reservation. */
    reservation?: Reservation;
}
interface ExpireReservationRequest {
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
    /**
     * Ticket reservation ID.
     * @format GUID
     */
    reservationId?: string | null;
}
interface ExpireReservationResponse {
    /** Reservation. */
    reservation?: Reservation;
}
interface QueryEventsWithPaidReservationsRequest {
    /**
     * Event Keys.
     * @minSize 1
     * @maxSize 100
     */
    eventKeys?: EventKey[];
}
interface EventKey {
    /**
     * Instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event ID.
     * @format GUID
     */
    eventId?: string | null;
}
interface QueryEventsWithPaidReservationsResponse {
    /**
     * Event IDs.
     * @format GUID
     * @maxSize 100
     */
    eventIds?: string[] | null;
}
/** @docsIgnore */
type UpdateOrderApplicationErrors = {
    code?: 'ORDER_ACTION_NOT_AVAILABLE';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkUpdateOrdersApplicationErrors = {
    code?: 'ORDER_ACTION_NOT_AVAILABLE';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type ConfirmOrderApplicationErrors = {
    code?: 'ORDER_ACTION_NOT_AVAILABLE';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type CaptureAuthorizedPaymentApplicationErrors = {
    code?: 'ORDER_STATUS_NOT_AUTHORIZED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type VoidAuthorizedPaymentApplicationErrors = {
    code?: 'ORDER_STATUS_NOT_AUTHORIZED';
    description?: string;
    data?: Record<string, any>;
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function listOrders(): __PublicMethodMetaInfo<'GET', {}, ListOrdersRequest$1, ListOrdersRequest, ListOrdersResponse$1, ListOrdersResponse>;
declare function getOrder(): __PublicMethodMetaInfo<'GET', {
    eventId: string;
    orderNumber: string;
}, GetOrderRequest$1, GetOrderRequest, GetOrderResponse$1, GetOrderResponse>;
declare function updateOrder(): __PublicMethodMetaInfo<'PATCH', {
    eventId: string;
    orderNumber: string;
}, UpdateOrderRequest$1, UpdateOrderRequest, UpdateOrderResponse$1, UpdateOrderResponse>;
declare function bulkUpdateOrders(): __PublicMethodMetaInfo<'PATCH', {
    eventId: string;
}, BulkUpdateOrdersRequest$1, BulkUpdateOrdersRequest, BulkUpdateOrdersResponse$1, BulkUpdateOrdersResponse>;
declare function confirmOrder(): __PublicMethodMetaInfo<'POST', {
    eventId: string;
}, ConfirmOrderRequest$1, ConfirmOrderRequest, ConfirmOrderResponse$1, ConfirmOrderResponse>;
declare function getSummary(): __PublicMethodMetaInfo<'GET', {}, GetSummaryRequest$1, GetSummaryRequest, GetSummaryResponse$1, GetSummaryResponse>;
declare function captureAuthorizedPayment(): __PublicMethodMetaInfo<'POST', {
    orderNumber: string;
}, CaptureAuthorizedPaymentRequest$1, CaptureAuthorizedPaymentRequest, CaptureAuthorizedPaymentResponse$1, CaptureAuthorizedPaymentResponse>;
declare function voidAuthorizedPayment(): __PublicMethodMetaInfo<'POST', {
    orderNumber: string;
}, VoidAuthorizedPaymentRequest$1, VoidAuthorizedPaymentRequest, VoidAuthorizedPaymentResponse$1, VoidAuthorizedPaymentResponse>;
declare function getCheckoutOptions(): __PublicMethodMetaInfo<'GET', {}, GetCheckoutOptionsRequest$1, GetCheckoutOptionsRequest, GetCheckoutOptionsResponse$1, GetCheckoutOptionsResponse>;
declare function listAvailableTickets(): __PublicMethodMetaInfo<'GET', {}, ListAvailableTicketsRequest$1, ListAvailableTicketsRequest, ListAvailableTicketsResponse$1, ListAvailableTicketsResponse>;
declare function queryAvailableTickets(): __PublicMethodMetaInfo<'POST', {}, QueryAvailableTicketsRequest$1, QueryAvailableTicketsRequest, QueryAvailableTicketsResponse$1, QueryAvailableTicketsResponse>;
declare function createReservation(): __PublicMethodMetaInfo<'POST', {}, CreateReservationRequest$1, CreateReservationRequest, CreateReservationResponse$1, CreateReservationResponse>;
declare function cancelReservation(): __PublicMethodMetaInfo<'DELETE', {
    id: string;
}, CancelReservationRequest$1, CancelReservationRequest, CancelReservationResponse$1, CancelReservationResponse>;
declare function getInvoice(): __PublicMethodMetaInfo<'POST', {
    reservationId: string;
}, GetInvoiceRequest$1, GetInvoiceRequest, GetInvoiceResponse$1, GetInvoiceResponse>;
declare function checkout(): __PublicMethodMetaInfo<'POST', {}, CheckoutRequest$1, CheckoutRequest, CheckoutResponse$1, CheckoutResponse>;
declare function updateCheckout(): __PublicMethodMetaInfo<'PATCH', {
    orderNumber: string;
}, UpdateCheckoutRequest$1, UpdateCheckoutRequest, UpdateCheckoutResponse$1, UpdateCheckoutResponse>;
declare function posCheckout(): __PublicMethodMetaInfo<'POST', {}, PosCheckoutRequest$1, PosCheckoutRequest, PosCheckoutResponse$1, PosCheckoutResponse>;

export { Action as ActionOriginal, type ActionWithLiterals as ActionWithLiteralsOriginal, type AddressLocation as AddressLocationOriginal, type Address as AddressOriginal, type AddressStreetOneOf as AddressStreetOneOfOriginal, type BalanceSummary as BalanceSummaryOriginal, type BulkUpdateOrdersApplicationErrors as BulkUpdateOrdersApplicationErrorsOriginal, type BulkUpdateOrdersRequest as BulkUpdateOrdersRequestOriginal, type BulkUpdateOrdersResponse as BulkUpdateOrdersResponseOriginal, type Buyer as BuyerOriginal, type CalendarLinks as CalendarLinksOriginal, type CancelReservationRequest as CancelReservationRequestOriginal, type CancelReservationResponse as CancelReservationResponseOriginal, type CaptureAuthorizedPaymentApplicationErrors as CaptureAuthorizedPaymentApplicationErrorsOriginal, type CaptureAuthorizedPaymentRequest as CaptureAuthorizedPaymentRequestOriginal, type CaptureAuthorizedPaymentResponse as CaptureAuthorizedPaymentResponseOriginal, ChannelType as ChannelTypeOriginal, type ChannelTypeWithLiterals as ChannelTypeWithLiteralsOriginal, type CheckIn as CheckInOriginal, type CheckoutOptions as CheckoutOptionsOriginal, type CheckoutRequest as CheckoutRequestOriginal, type CheckoutResponse as CheckoutResponseOriginal, type ConfirmOrderApplicationErrors as ConfirmOrderApplicationErrorsOriginal, type ConfirmOrderRequest as ConfirmOrderRequestOriginal, type ConfirmOrderResponse as ConfirmOrderResponseOriginal, type ConfirmReservationRequest as ConfirmReservationRequestOriginal, type ConfirmReservationResponse as ConfirmReservationResponseOriginal, type Counts as CountsOriginal, type CouponDiscount as CouponDiscountOriginal, type CreateReservationRequest as CreateReservationRequestOriginal, type CreateReservationResponse as CreateReservationResponseOriginal, type Dashboard as DashboardOriginal, type DiscountErrors as DiscountErrorsOriginal, type DiscountItemDiscountOneOf as DiscountItemDiscountOneOfOriginal, type DiscountItem as DiscountItemOriginal, type Discount as DiscountOriginal, type DiscountRequest as DiscountRequestOriginal, type Error as ErrorOriginal, type EventKey as EventKeyOriginal, type ExpireReservationRequest as ExpireReservationRequestOriginal, type ExpireReservationResponse as ExpireReservationResponseOriginal, type FacetCounts as FacetCountsOriginal, FeeName as FeeNameOriginal, type FeeNameWithLiterals as FeeNameWithLiteralsOriginal, type Fee as FeeOriginal, FeeType as FeeTypeOriginal, type FeeTypeWithLiterals as FeeTypeWithLiteralsOriginal, type FindOrderByReservationIdRequest as FindOrderByReservationIdRequestOriginal, type FindOrderByReservationIdResponse as FindOrderByReservationIdResponseOriginal, type FormResponse as FormResponseOriginal, type FormattedAddress as FormattedAddressOriginal, type GetCheckoutOptionsRequest as GetCheckoutOptionsRequestOriginal, type GetCheckoutOptionsResponse as GetCheckoutOptionsResponseOriginal, type GetInvoicePreviewRequest as GetInvoicePreviewRequestOriginal, type GetInvoiceRequest as GetInvoiceRequestOriginal, type GetInvoiceResponse as GetInvoiceResponseOriginal, type GetOrderRequest as GetOrderRequestOriginal, type GetOrderResponse as GetOrderResponseOriginal, type GetPaymentInfoRequest as GetPaymentInfoRequestOriginal, type GetPaymentInfoResponse as GetPaymentInfoResponseOriginal, type GetReservationRequest as GetReservationRequestOriginal, type GetReservationResponse as GetReservationResponseOriginal, type GetSummaryRequest as GetSummaryRequestOriginal, type GetSummaryResponse as GetSummaryResponseOriginal, type GiftCardErrorsError as GiftCardErrorsErrorOriginal, type GiftCardErrors as GiftCardErrorsOriginal, type GiftCardPaymentDetails as GiftCardPaymentDetailsOriginal, type GuestDetails as GuestDetailsOriginal, type Guest as GuestOriginal, type HeadersEntry as HeadersEntryOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type InputValue as InputValueOriginal, type Invoice as InvoiceOriginal, type Item as ItemOriginal, type ListAvailableTicketsRequest as ListAvailableTicketsRequestOriginal, type ListAvailableTicketsResponse as ListAvailableTicketsResponseOriginal, type ListOrdersRequest as ListOrdersRequestOriginal, type ListOrdersResponse as ListOrdersResponseOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type Money as MoneyOriginal, type OnlineConferencingLogin as OnlineConferencingLoginOriginal, type OrderConfirmed as OrderConfirmedOriginal, type OrderDeleted as OrderDeletedOriginal, type OrderFacetCounts as OrderFacetCountsOriginal, type OrderFacets as OrderFacetsOriginal, OrderFieldset as OrderFieldsetOriginal, type OrderFieldsetWithLiterals as OrderFieldsetWithLiteralsOriginal, type OrderInitiated as OrderInitiatedOriginal, type Order as OrderOriginal, type OrderPageUrls as OrderPageUrlsOriginal, type OrderPaid as OrderPaidOriginal, OrderStatus as OrderStatusOriginal, type OrderStatusWithLiterals as OrderStatusWithLiteralsOriginal, OrderTag as OrderTagOriginal, type OrderTagWithLiterals as OrderTagWithLiteralsOriginal, OrderType as OrderTypeOriginal, type OrderTypeWithLiterals as OrderTypeWithLiteralsOriginal, type OrderUpdated as OrderUpdatedOriginal, type PaidPlanBenefit as PaidPlanBenefitOriginal, type PaidPlanDiscountDiscountOneOf as PaidPlanDiscountDiscountOneOfOriginal, type PaidPlanDiscount as PaidPlanDiscountOriginal, type PaymentDetails as PaymentDetailsOriginal, type PaymentTransactionEvent as PaymentTransactionEventOriginal, type PaymentTransaction as PaymentTransactionOriginal, type PaymentTransactionSummary as PaymentTransactionSummaryOriginal, type PercentDiscount as PercentDiscountOriginal, type PosCheckoutRequest as PosCheckoutRequestOriginal, type PosCheckoutResponse as PosCheckoutResponseOriginal, type PricingOption as PricingOptionOriginal, type PricingOptions as PricingOptionsOriginal, type QueryAvailableTicketsRequest as QueryAvailableTicketsRequestOriginal, type QueryAvailableTicketsResponse as QueryAvailableTicketsResponseOriginal, type QueryEventsWithPaidReservationsRequest as QueryEventsWithPaidReservationsRequestOriginal, type QueryEventsWithPaidReservationsResponse as QueryEventsWithPaidReservationsResponseOriginal, type RawHttpResponse as RawHttpResponseOriginal, type ReservationCount as ReservationCountOriginal, type ReservationCreated as ReservationCreatedOriginal, type Reservation as ReservationOriginal, ReservationStatus as ReservationStatusOriginal, type ReservationStatusWithLiterals as ReservationStatusWithLiteralsOriginal, type ReservationUpdated as ReservationUpdatedOriginal, type ResponseMetaData as ResponseMetaDataOriginal, ScheduledActionEnumAction as ScheduledActionEnumActionOriginal, type ScheduledActionEnumActionWithLiterals as ScheduledActionEnumActionWithLiteralsOriginal, type StandardDetails as StandardDetailsOriginal, State as StateOriginal, type StateWithLiterals as StateWithLiteralsOriginal, type StreetAddress as StreetAddressOriginal, type Subdivision as SubdivisionOriginal, SubdivisionType as SubdivisionTypeOriginal, type SubdivisionTypeWithLiterals as SubdivisionTypeWithLiteralsOriginal, type Tax as TaxOriginal, TaxType as TaxTypeOriginal, type TaxTypeWithLiterals as TaxTypeWithLiteralsOriginal, TicketDefinitionFieldset as TicketDefinitionFieldsetOriginal, type TicketDefinitionFieldsetWithLiterals as TicketDefinitionFieldsetWithLiteralsOriginal, type TicketDefinition as TicketDefinitionOriginal, type TicketDetails as TicketDetailsOriginal, type Ticket as TicketOriginal, type TicketPricing as TicketPricingOriginal, type TicketPricingPriceOneOf as TicketPricingPriceOneOfOriginal, type TicketQuantity as TicketQuantityOriginal, type TicketReservation as TicketReservationOriginal, type TicketReservationQuantity as TicketReservationQuantityOriginal, type TicketSalePeriod as TicketSalePeriodOriginal, TicketSaleStatus as TicketSaleStatusOriginal, type TicketSaleStatusWithLiterals as TicketSaleStatusWithLiteralsOriginal, type TicketSales as TicketSalesOriginal, type TicketingTicket as TicketingTicketOriginal, Type as TypeOriginal, type TypeWithLiterals as TypeWithLiteralsOriginal, type UpdateCheckoutRequest as UpdateCheckoutRequestOriginal, type UpdateCheckoutResponse as UpdateCheckoutResponseOriginal, type UpdateOrderApplicationErrors as UpdateOrderApplicationErrorsOriginal, type UpdateOrderRequest as UpdateOrderRequestOriginal, type UpdateOrderResponse as UpdateOrderResponseOriginal, type VoidAuthorizedPaymentApplicationErrors as VoidAuthorizedPaymentApplicationErrorsOriginal, type VoidAuthorizedPaymentRequest as VoidAuthorizedPaymentRequestOriginal, type VoidAuthorizedPaymentResponse as VoidAuthorizedPaymentResponseOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type WixFeeConfig as WixFeeConfigOriginal, type __PublicMethodMetaInfo, bulkUpdateOrders, cancelReservation, captureAuthorizedPayment, checkout, confirmOrder, createReservation, getCheckoutOptions, getInvoice, getOrder, getSummary, listAvailableTickets, listOrders, posCheckout, queryAvailableTickets, updateCheckout, updateOrder, voidAuthorizedPayment };
