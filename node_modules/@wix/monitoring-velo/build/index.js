// src/factory.ts
import { createFallbackMonitoringClient } from "@wix/monitoring";

// src/payload-builder.ts
import { getCallLocation } from "@wix/monitoring-common";

// src/utils/id-utils.ts
var generateId = () => {
  return typeof crypto !== "undefined" && typeof crypto.randomUUID === "function" ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
    const i = 16 * Math.random() | 0;
    return ("x" === e ? i : 3 & i | 8).toString(16);
  });
};

// src/utils/string-utils.ts
var stringifySafe = (value) => {
  try {
    return JSON.stringify(value);
  } catch (error) {
    return `Failed to stringify log value: ${error?.toString()}`;
  }
};

// src/payload-builder.ts
var buildTelemetryPayload = (options, params) => {
  const { namespace, producer, req, requestId } = options;
  const {
    message,
    level = "INFO",
    timestamp = Date.now(),
    tags,
    contexts
  } = params;
  const { __sourceLocation, ...restOfContext } = contexts ?? {};
  let siteUrl = "";
  if (req) {
    try {
      if (req.headers.get("referer")) {
        siteUrl = new URL(req.headers.get("referer") ?? "").origin;
      } else {
        siteUrl = new URL(req.url).origin;
      }
    } catch (e) {
    }
  }
  const messageParts = [message];
  if (tags) {
    messageParts.push(stringifySafe(tags));
  }
  if (Object.keys(restOfContext).length > 0) {
    messageParts.push(stringifySafe(restOfContext));
  }
  const sourceLocation = __sourceLocation ?? getCallLocation();
  return {
    insertId: generateId(),
    timestamp: new Date(timestamp).toISOString(),
    severity: level.toUpperCase(),
    labels: {
      tenantId: "",
      namespace,
      ...siteUrl ? { siteUrl } : {}
    },
    operation: {
      id: requestId ?? generateId(),
      producer
    },
    ...sourceLocation ? { sourceLocation } : {},
    jsonPayload: {
      message: messageParts.join(" ")
    }
  };
};

// src/constants.ts
var TELEMETRY_URL = "https://www.wixapis.com/wixcode/v1/telemetry/telemetry-messages";
var MAX_BATCH_SIZE = 100;
var THROTTLE_DURATION = 300;

// src/reporter.ts
var report = async (messages, authToken = "", fetch = globalThis.fetch) => {
  try {
    await fetch(TELEMETRY_URL, {
      method: "POST",
      body: JSON.stringify({ messages }),
      headers: {
        Authorization: authToken
      }
    });
  } catch (_e) {
  }
};

// src/batch-queue.ts
import throttle from "lodash/throttle";
var BatchQueue = class {
  constructor(options) {
    this.options = options;
    this.queue = [];
    this.batchQueuePromise = null;
    this.resolveBatchQueuePromise = null;
    this.flushThrottled = throttle(
      () => this.flush(),
      options.throttleDuration,
      {
        leading: false
      }
    );
  }
  flush() {
    const events = this.queue.splice(0);
    this.options.flushHandler(events).then(() => {
      this.resolveBatchQueuePromise?.();
      this.resolveBatchQueuePromise = null;
    });
    this.batchQueuePromise = null;
  }
  enqueue(payload) {
    this.queue.push(payload);
    if (!this.batchQueuePromise) {
      this.batchQueuePromise = new Promise((resolve) => {
        this.resolveBatchQueuePromise = resolve;
      });
      this.options.onBatchQueueCreated?.(this.batchQueuePromise);
    }
    if (this.queue.length === this.options.maxBatchSize) {
      this.flushThrottled.cancel();
      this.flush();
    } else {
      this.flushThrottled();
    }
  }
};

// src/utils/promise-utils.ts
var isPromise = (value) => typeof value?.then === "function";

// src/client.ts
import { getCallLocation as getCallLocation2 } from "@wix/monitoring-common";
var VeloClient = class {
  constructor(options) {
    this.options = options;
    this.reportError = (captureContext = {}, e) => {
      const { tags, contexts } = captureContext;
      const messagePayload = buildTelemetryPayload(this.options, {
        message: e?.toString() ?? "Unknown error",
        level: "error",
        tags,
        contexts: {
          __sourceLocation: getCallLocation2(e?.stack),
          ...contexts
        }
      });
      this.batchQueue.enqueue(messagePayload);
    };
    this.captureException = (error, captureContext) => {
      this.reportError(captureContext, error);
    };
    this.captureMessage = (message, captureContext = {}) => {
      const { level = "info", tags, contexts } = captureContext;
      const messagePayload = buildTelemetryPayload(this.options, {
        message,
        level,
        tags,
        contexts
      });
      this.batchQueue.enqueue(messagePayload);
    };
    this.startSpan = (spanOptions, callback) => {
      let res;
      try {
        res = callback();
        if (isPromise(res)) {
          res = res.then((_res) => {
            return _res;
          }).catch((e) => {
            this.reportError(spanOptions, e);
            throw e;
          });
        } else {
        }
      } catch (e) {
        this.reportError(spanOptions, e);
        throw e;
      }
      return res;
    };
    this.addBreadcrumb = (breadcrumb) => {
    };
    const { getAuthToken, fetch } = options;
    this.batchQueue = new BatchQueue({
      maxBatchSize: MAX_BATCH_SIZE,
      throttleDuration: THROTTLE_DURATION,
      flushHandler: (messages) => getAuthToken().then((token) => report(messages, token, fetch)),
      onBatchQueueCreated: options.onBatchQueueCreated
    });
  }
  startSpanManual(spanOptions) {
    return {
      end: () => {
      },
      fail: (error) => {
        this.reportError(spanOptions, error);
      }
    };
  }
  endSpanManual(spanOptions) {
  }
};

// src/factory.ts
var createVeloMonitoringClient = (options) => {
  const { getAuthToken } = options;
  if (!getAuthToken) {
    return createFallbackMonitoringClient("Missing getAuthToken");
  }
  return new VeloClient(options);
};
export {
  createVeloMonitoringClient
};
