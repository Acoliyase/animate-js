"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  createVeloMonitoringClient: () => createVeloMonitoringClient
});
module.exports = __toCommonJS(index_exports);

// src/factory.ts
var import_monitoring = require("@wix/monitoring");

// src/payload-builder.ts
var import_monitoring_common = require("@wix/monitoring-common");

// src/utils/id-utils.ts
var generateId = () => {
  return typeof crypto !== "undefined" && typeof crypto.randomUUID === "function" ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
    const i = 16 * Math.random() | 0;
    return ("x" === e ? i : 3 & i | 8).toString(16);
  });
};

// src/utils/string-utils.ts
var stringifySafe = (value) => {
  try {
    return JSON.stringify(value);
  } catch (error) {
    return `Failed to stringify log value: ${error?.toString()}`;
  }
};

// src/payload-builder.ts
var buildTelemetryPayload = (options, params) => {
  const { namespace, producer, req, requestId } = options;
  const {
    message,
    level = "INFO",
    timestamp = Date.now(),
    tags,
    contexts
  } = params;
  const { __sourceLocation, ...restOfContext } = contexts ?? {};
  let siteUrl = "";
  if (req) {
    try {
      if (req.headers.get("referer")) {
        siteUrl = new URL(req.headers.get("referer") ?? "").origin;
      } else {
        siteUrl = new URL(req.url).origin;
      }
    } catch (e) {
    }
  }
  const messageParts = [message];
  if (tags) {
    messageParts.push(stringifySafe(tags));
  }
  if (Object.keys(restOfContext).length > 0) {
    messageParts.push(stringifySafe(restOfContext));
  }
  const sourceLocation = __sourceLocation ?? (0, import_monitoring_common.getCallLocation)();
  return {
    insertId: generateId(),
    timestamp: new Date(timestamp).toISOString(),
    severity: level.toUpperCase(),
    labels: {
      tenantId: "",
      namespace,
      ...siteUrl ? { siteUrl } : {}
    },
    operation: {
      id: requestId ?? generateId(),
      producer
    },
    ...sourceLocation ? { sourceLocation } : {},
    jsonPayload: {
      message: messageParts.join(" ")
    }
  };
};

// src/constants.ts
var TELEMETRY_URL = "https://www.wixapis.com/wixcode/v1/telemetry/telemetry-messages";
var MAX_BATCH_SIZE = 100;
var THROTTLE_DURATION = 300;

// src/reporter.ts
var report = async (messages, authToken = "", fetch = globalThis.fetch) => {
  try {
    await fetch(TELEMETRY_URL, {
      method: "POST",
      body: JSON.stringify({ messages }),
      headers: {
        Authorization: authToken
      }
    });
  } catch (_e) {
  }
};

// src/batch-queue.ts
var import_throttle = __toESM(require("lodash/throttle"), 1);
var BatchQueue = class {
  constructor(options) {
    this.options = options;
    this.queue = [];
    this.batchQueuePromise = null;
    this.resolveBatchQueuePromise = null;
    this.flushThrottled = (0, import_throttle.default)(
      () => this.flush(),
      options.throttleDuration,
      {
        leading: false
      }
    );
  }
  flush() {
    const events = this.queue.splice(0);
    this.options.flushHandler(events).then(() => {
      this.resolveBatchQueuePromise?.();
      this.resolveBatchQueuePromise = null;
    });
    this.batchQueuePromise = null;
  }
  enqueue(payload) {
    this.queue.push(payload);
    if (!this.batchQueuePromise) {
      this.batchQueuePromise = new Promise((resolve) => {
        this.resolveBatchQueuePromise = resolve;
      });
      this.options.onBatchQueueCreated?.(this.batchQueuePromise);
    }
    if (this.queue.length === this.options.maxBatchSize) {
      this.flushThrottled.cancel();
      this.flush();
    } else {
      this.flushThrottled();
    }
  }
};

// src/utils/promise-utils.ts
var isPromise = (value) => typeof value?.then === "function";

// src/client.ts
var import_monitoring_common2 = require("@wix/monitoring-common");
var VeloClient = class {
  constructor(options) {
    this.options = options;
    this.reportError = (captureContext = {}, e) => {
      const { tags, contexts } = captureContext;
      const messagePayload = buildTelemetryPayload(this.options, {
        message: e?.toString() ?? "Unknown error",
        level: "error",
        tags,
        contexts: {
          __sourceLocation: (0, import_monitoring_common2.getCallLocation)(e?.stack),
          ...contexts
        }
      });
      this.batchQueue.enqueue(messagePayload);
    };
    this.captureException = (error, captureContext) => {
      this.reportError(captureContext, error);
    };
    this.captureMessage = (message, captureContext = {}) => {
      const { level = "info", tags, contexts } = captureContext;
      const messagePayload = buildTelemetryPayload(this.options, {
        message,
        level,
        tags,
        contexts
      });
      this.batchQueue.enqueue(messagePayload);
    };
    this.startSpan = (spanOptions, callback) => {
      let res;
      try {
        res = callback();
        if (isPromise(res)) {
          res = res.then((_res) => {
            return _res;
          }).catch((e) => {
            this.reportError(spanOptions, e);
            throw e;
          });
        } else {
        }
      } catch (e) {
        this.reportError(spanOptions, e);
        throw e;
      }
      return res;
    };
    this.addBreadcrumb = (breadcrumb) => {
    };
    const { getAuthToken, fetch } = options;
    this.batchQueue = new BatchQueue({
      maxBatchSize: MAX_BATCH_SIZE,
      throttleDuration: THROTTLE_DURATION,
      flushHandler: (messages) => getAuthToken().then((token) => report(messages, token, fetch)),
      onBatchQueueCreated: options.onBatchQueueCreated
    });
  }
  startSpanManual(spanOptions) {
    return {
      end: () => {
      },
      fail: (error) => {
        this.reportError(spanOptions, error);
      }
    };
  }
  endSpanManual(spanOptions) {
  }
};

// src/factory.ts
var createVeloMonitoringClient = (options) => {
  const { getAuthToken } = options;
  if (!getAuthToken) {
    return (0, import_monitoring.createFallbackMonitoringClient)("Missing getAuthToken");
  }
  return new VeloClient(options);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createVeloMonitoringClient
});
