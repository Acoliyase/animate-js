type Primitive$1 = number | string | boolean | bigint | symbol | null | undefined;
type Tags = Record<string, Primitive$1>;
type Context$1 = Record<string, unknown>;
type Contexts$1 = Record<string, Context$1 | undefined>;

interface SpanContextData$1 {
    traceId: string;
    spanId: string;
}
interface Span$1 {
    spanContext(): SpanContextData$1;
    end(): void;
}
interface ManualSpan {
    end(): void;
    fail(error: unknown): void;
}
interface SpanOptions {
    name: string;
    tags?: Tags;
}
interface EndSpanOptions {
    name: string;
}
interface Breadcrumb$1 {
    type?: string;
    category?: string;
    message: string;
    level?: 'info' | 'warning' | 'error';
    data?: Record<string, unknown>;
}
interface CaptureContext {
    level?: 'info' | 'warning' | 'error';
    tags?: Tags;
    contexts?: Contexts$1;
}
interface MonitoringClient {
    /**
     * Captures an exception event and sends it to Sentry.
     * @param error The error to capture
     * @param captureContext Optional additional data to attach to the Sentry e vent.
     */
    captureException(error: unknown, captureContext?: CaptureContext): void;
    /**
     * Captures a message event and sends it to Sentry.
     * @param message The message to capture
     * @param captureContext Define the level of the message or pass in additional data to attach to the message.
     */
    captureMessage(message: string, captureContext?: CaptureContext): void;
    /**
     * Wraps a function with a span and finishes the span after the function is done. The created span is the active span and will be used as parent by other spans created inside the function, as long as the function is executed while the scope is active.
     * @param spanOptions The options for the span
     * @param callback The function to wrap with a span
     * @returns The return value of the callback
     */
    startSpan<T>(spanOptions: SpanOptions, callback: (span: Span$1 | undefined) => T): T;
    /**
     * Starts a manual span. The span needs to be finished manually by either calling end() or fail() using the returned span object or by calling endSpanManual().
     * @param spanOptions The options for the span
     * @returns A span object that allows to end the span successfully or fail it.
     */
    startSpanManual(spanOptions: SpanOptions): ManualSpan;
    /**
     * Ends a manual span and sends it to Sentry. Spans can be ended using a MonitoringClient instance which wasn't necessarily used to start the span.
     * Calling this method will end the last span with the same name that was started using startSpanManual() and will ignore the others.
     * @param spanOptions The options for the span
     */
    endSpanManual(spanOptions: EndSpanOptions): void;
    /**
     * Records a new breadcrumb which will be attached to future events.
     * Breadcrumbs will be added to subsequent events to provide more context on user's actions prior to an error or crash.
     * @param breadcrumb The breadcrumb to record.
     */
    addBreadcrumb(breadcrumb: Breadcrumb$1): void;
}

type AttachmentType = 'event.attachment' | 'event.minidump' | 'event.applecrashreport' | 'unreal.context' | 'unreal.logs';

/**
 * @deprecated Please use a `SeverityLevel` string instead of the `Severity` enum. Acceptable values are 'fatal',
 * 'error', 'warning', 'log', 'info', and 'debug'.
 */
declare enum Severity {
    /** JSDoc */
    Fatal = "fatal",
    /** JSDoc */
    Error = "error",
    /** JSDoc */
    Warning = "warning",
    /** JSDoc */
    Log = "log",
    /** JSDoc */
    Info = "info",
    /** JSDoc */
    Debug = "debug"
}
type SeverityLevel = 'fatal' | 'error' | 'warning' | 'log' | 'info' | 'debug';

/** JSDoc */
interface Breadcrumb {
    type?: string;
    level?: Severity | SeverityLevel;
    event_id?: string;
    category?: string;
    message?: string;
    data?: {
        [key: string]: any;
    };
    timestamp?: number;
}

/** Request data included in an event as sent to Sentry */
interface Request {
    url?: string;
    method?: string;
    data?: any;
    query_string?: QueryParams;
    cookies?: {
        [key: string]: string;
    };
    env?: {
        [key: string]: string;
    };
    headers?: {
        [key: string]: string;
    };
}
type QueryParams = string | {
    [key: string]: string;
} | Array<[string, string]>;

type Primitive = number | string | boolean | bigint | symbol | null | undefined;

type Instrumenter = 'sentry' | 'otel';

/**
 * A time duration.
 */
type DurationUnit = 'nanosecond' | 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week';
/**
 * Size of information derived from bytes.
 */
type InformationUnit = 'bit' | 'byte' | 'kilobyte' | 'kibibyte' | 'megabyte' | 'mebibyte' | 'gigabyte' | 'terabyte' | 'tebibyte' | 'petabyte' | 'exabyte' | 'exbibyte';
/**
 * Fractions such as percentages.
 */
type FractionUnit = 'ratio' | 'percent';
/**
 * Untyped value without a unit.
 */
type NoneUnit = '' | 'none';
type LiteralUnion<T extends string> = T | Omit<T, T>;
type MeasurementUnit = LiteralUnion<DurationUnit | InformationUnit | FractionUnit | NoneUnit>;
type Measurements = Record<string, {
    value: number;
    unit: MeasurementUnit;
}>;

/**
 * Defines High-Resolution Time.
 *
 * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 */
type HrTime = [number, number];

type DataCategory = 'default' | 'error' | 'transaction' | 'replay' | 'security' | 'attachment' | 'session' | 'internal' | 'profile' | 'monitor' | 'feedback' | 'metric_bucket' | 'span' | 'unknown';

type EventDropReason = 'before_send' | 'event_processor' | 'network_error' | 'queue_overflow' | 'ratelimit_backoff' | 'sample_rate' | 'send_error' | 'internal_sdk_error';
type Outcome = {
    reason: EventDropReason;
    category: DataCategory;
    quantity: number;
};
type ClientReport = {
    timestamp: number;
    discarded_events: Outcome[];
};

/** Supported Sentry transport protocols in a Dsn. */
type DsnProtocol = 'http' | 'https';
/** Primitive components of a Dsn. */
interface DsnComponents {
    /** Protocol used to connect to Sentry. */
    protocol: DsnProtocol;
    /** Public authorization key. */
    publicKey?: string;
    /** Private authorization key (deprecated, optional). */
    pass?: string;
    /** Hostname of the Sentry instance. */
    host: string;
    /** Port of the Sentry instance. */
    port?: string;
    /** Sub path/ */
    path?: string;
    /** Project ID */
    projectId: string;
}

/**
 * Holds meta information to customize the behavior of Sentry's server-side event processing.
 **/
interface DebugMeta {
    images?: Array<DebugImage>;
}
type DebugImage = WasmDebugImage | SourceMapDebugImage | MachoDebugImage;
interface WasmDebugImage {
    type: 'wasm';
    debug_id: string;
    code_id?: string | null;
    code_file: string;
    debug_file?: string | null;
}
interface SourceMapDebugImage {
    type: 'sourcemap';
    code_file: string;
    debug_id: string;
}
interface MachoDebugImage {
    type: 'macho';
    debug_id: string;
    image_addr: string;
    image_size?: number;
    code_file?: string;
}

/**
 * Metadata about a captured exception, intended to provide a hint as to the means by which it was captured.
 */
interface Mechanism {
    /**
     * For now, restricted to `onerror`, `onunhandledrejection` (both obvious), `instrument` (the result of
     * auto-instrumentation), and `generic` (everything else). Converted to a tag on ingest.
     */
    type: string;
    /**
     * In theory, whether or not the exception has been handled by the user. In practice, whether or not we see it before
     * it hits the global error/rejection handlers, whether through explicit handling by the user or auto instrumentation.
     * Converted to a tag on ingest and used in various ways in the UI.
     */
    handled?: boolean;
    /**
     * Arbitrary data to be associated with the mechanism (for example, errors coming from event handlers include the
     * handler name and the event target. Will show up in the UI directly above the stacktrace.
     */
    data?: {
        [key: string]: string | boolean;
    };
    /**
     * True when `captureException` is called with anything other than an instance of `Error` (or, in the case of browser,
     * an instance of `ErrorEvent`, `DOMError`, or `DOMException`). causing us to create a synthetic error in an attempt
     * to recreate the stacktrace.
     */
    synthetic?: boolean;
    /**
     * Describes the source of the exception, in the case that this is a derived (linked or aggregate) error.
     *
     * This should be populated with the name of the property where the exception was found on the parent exception.
     * E.g. "cause", "errors[0]", "errors[1]"
     */
    source?: string;
    /**
     * Indicates whether the exception is an `AggregateException`.
     */
    is_exception_group?: boolean;
    /**
     * An identifier for the exception inside the `event.exception.values` array. This identifier is referenced to via the
     * `parent_id` attribute to link and aggregate errors.
     */
    exception_id?: number;
    /**
     * References another exception via the `exception_id` field to indicate that this excpetion is a child of that
     * exception in the case of aggregate or linked errors.
     */
    parent_id?: number;
}

/** JSDoc */
interface StackFrame {
    filename?: string;
    function?: string;
    module?: string;
    platform?: string;
    lineno?: number;
    colno?: number;
    abs_path?: string;
    context_line?: string;
    pre_context?: string[];
    post_context?: string[];
    in_app?: boolean;
    instruction_addr?: string;
    addr_mode?: string;
    vars?: {
        [key: string]: any;
    };
    debug_id?: string;
    module_metadata?: any;
}

/** JSDoc */
interface Stacktrace {
    frames?: StackFrame[];
    frames_omitted?: [number, number];
}

/** JSDoc */
interface Exception {
    type?: string;
    value?: string;
    mechanism?: Mechanism;
    module?: string;
    thread_id?: number;
    stacktrace?: Stacktrace;
}

type Extra = unknown;
type Extras = Record<string, Extra>;

/**
 * An interface describing a user of an application or a handled request.
 */
interface User {
    [key: string]: any;
    id?: string | number;
    ip_address?: string;
    email?: string;
    username?: string;
    /**
     * @deprecated Functonality for segment has been removed. Use a custom tag or context instead to capture this information.
     */
    segment?: string;
}
interface UserFeedback {
    event_id: string;
    email: User['email'];
    name: string;
    comments: string;
}

interface Session {
    sid: string;
    did?: string | number;
    init: boolean;
    timestamp: number;
    started: number;
    duration?: number;
    status: SessionStatus;
    release?: string;
    environment?: string;
    userAgent?: string;
    ipAddress?: string;
    errors: number;
    user?: User | null;
    ignoreDuration: boolean;
    abnormal_mechanism?: string;
    /**
     * Overrides default JSON serialization of the Session because
     * the Sentry servers expect a slightly different schema of a session
     * which is described in the interface @see SerializedSession in this file.
     *
     * @return a Sentry-backend conforming JSON object of the session
     */
    toJSON(): SerializedSession;
}
type SessionStatus = 'ok' | 'exited' | 'crashed' | 'abnormal';
/** JSDoc */
interface SessionAggregates {
    attrs?: {
        environment?: string;
        release?: string;
    };
    aggregates: Array<AggregationCounts>;
}
interface AggregationCounts {
    started: string;
    errored?: number;
    exited?: number;
    crashed?: number;
}
interface SerializedSession {
    init: boolean;
    sid: string;
    did?: string;
    timestamp: string;
    started: string;
    duration?: number;
    status: SessionStatus;
    errors: number;
    abnormal_mechanism?: string;
    attrs?: {
        release?: string;
        environment?: string;
        user_agent?: string;
        ip_address?: string;
    };
}

/** JSDoc */
interface Package {
    name: string;
    version: string;
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
}

interface SdkInfo {
    name?: string;
    version?: string;
    integrations?: string[];
    packages?: Package[];
}

/** JSDoc */
interface Thread {
    id?: number;
    name?: string;
    stacktrace?: Stacktrace;
    crashed?: boolean;
    current?: boolean;
}

/** JSDoc */
interface Event {
    event_id?: string;
    message?: string;
    logentry?: {
        message?: string;
        params?: string[];
    };
    timestamp?: number;
    start_timestamp?: number;
    level?: Severity | SeverityLevel;
    platform?: string;
    logger?: string;
    server_name?: string;
    release?: string;
    dist?: string;
    environment?: string;
    sdk?: SdkInfo;
    request?: Request;
    transaction?: string;
    modules?: {
        [key: string]: string;
    };
    fingerprint?: string[];
    exception?: {
        values?: Exception[];
    };
    breadcrumbs?: Breadcrumb[];
    contexts?: Contexts;
    tags?: {
        [key: string]: Primitive;
    };
    extra?: Extras;
    user?: User;
    type?: EventType;
    spans?: Span[];
    measurements?: Measurements;
    debug_meta?: DebugMeta;
    sdkProcessingMetadata?: {
        [key: string]: any;
    };
    transaction_info?: {
        source: TransactionSource;
    };
    threads?: {
        values: Thread[];
    };
}
/**
 * The type of an `Event`.
 * Note that `ErrorEvent`s do not have a type (hence its undefined),
 * while all other events are required to have one.
 */
type EventType = 'transaction' | 'profile' | 'replay_event' | 'feedback' | undefined;

interface FeedbackContext extends Record<string, unknown> {
    message: string;
    contact_email?: string;
    name?: string;
    replay_id?: string;
    url?: string;
}
/**
 * NOTE: These types are still considered Alpha and subject to change.
 * @hidden
 */
interface FeedbackEvent extends Event {
    type: 'feedback';
    contexts: Event['contexts'] & {
        feedback: FeedbackContext;
    };
}

type ThreadId = string;
type FrameId = number;
type StackId = number;
interface ThreadCpuSample {
    stack_id: StackId;
    thread_id: ThreadId;
    queue_address?: string;
    elapsed_since_start_ns: string;
}
type ThreadCpuStack = FrameId[];
type ThreadCpuFrame = {
    function?: string;
    file?: string;
    lineno?: number;
    colno?: number;
    abs_path?: string;
    platform?: string;
    instruction_addr?: string;
    module?: string;
    in_app?: boolean;
};
interface ThreadCpuProfile {
    samples: ThreadCpuSample[];
    stacks: ThreadCpuStack[];
    frames: ThreadCpuFrame[];
    thread_metadata: Record<ThreadId, {
        name?: string;
        priority?: number;
    }>;
    queue_metadata?: Record<string, {
        label: string;
    }>;
}
interface Profile {
    event_id: string;
    version: string;
    os: {
        name: string;
        version: string;
        build_number?: string;
    };
    runtime: {
        name: string;
        version: string;
    };
    device: {
        architecture: string;
        is_emulator: boolean;
        locale: string;
        manufacturer: string;
        model: string;
    };
    timestamp: string;
    release: string;
    environment: string;
    platform: string;
    profile: ThreadCpuProfile;
    debug_meta?: {
        images: DebugImage[];
    };
    transaction?: {
        name: string;
        id: string;
        trace_id: string;
        active_thread_id: string;
    };
    transactions?: {
        name: string;
        id: string;
        trace_id: string;
        active_thread_id: string;
        relative_start_ns: string;
        relative_end_ns: string;
    }[];
    measurements?: Record<string, {
        unit: MeasurementUnit;
        values: {
            elapsed_since_start_ns: number;
            value: number;
        }[];
    }>;
}

/**
 * NOTE: These types are still considered Beta and subject to change.
 * @hidden
 */
interface ReplayEvent extends Event {
    urls: string[];
    replay_start_timestamp?: number;
    error_ids: string[];
    trace_ids: string[];
    replay_id: string;
    segment_id: number;
    replay_type: ReplayRecordingMode;
}
/**
 * NOTE: These types are still considered Beta and subject to change.
 * @hidden
 */
type ReplayRecordingData = string | Uint8Array;
/**
 * NOTE: These types are still considered Beta and subject to change.
 * @hidden
 */
type ReplayRecordingMode = 'session' | 'buffer';

type DynamicSamplingContext = {
    trace_id: Transaction['traceId'];
    public_key: DsnComponents['publicKey'];
    sample_rate?: string;
    release?: string;
    environment?: string;
    transaction?: string;
    /**
     * @deprecated Functonality for segment has been removed.
     */
    user_segment?: string;
    replay_id?: string;
    sampled?: string;
};
type EnvelopeItemType = 'client_report' | 'user_report' | 'feedback' | 'session' | 'sessions' | 'transaction' | 'attachment' | 'event' | 'profile' | 'replay_event' | 'replay_recording' | 'check_in' | 'statsd' | 'span';
type BaseEnvelopeHeaders = {
    [key: string]: unknown;
    dsn?: string;
    sdk?: SdkInfo;
};
type BaseEnvelopeItemHeaders = {
    [key: string]: unknown;
    type: EnvelopeItemType;
    length?: number;
};
type BaseEnvelopeItem<ItemHeader, P> = [ItemHeader & BaseEnvelopeItemHeaders, P];
type BaseEnvelope<EnvelopeHeader, Item> = [
    EnvelopeHeader & BaseEnvelopeHeaders,
    Array<Item & BaseEnvelopeItem<BaseEnvelopeItemHeaders, unknown>>
];
type EventItemHeaders = {
    type: 'event' | 'transaction' | 'profile' | 'feedback';
};
type AttachmentItemHeaders = {
    type: 'attachment';
    length: number;
    filename: string;
    content_type?: string;
    attachment_type?: AttachmentType;
};
type UserFeedbackItemHeaders = {
    type: 'user_report';
};
type FeedbackItemHeaders = {
    type: 'feedback';
};
type SessionItemHeaders = {
    type: 'session';
};
type SessionAggregatesItemHeaders = {
    type: 'sessions';
};
type ClientReportItemHeaders = {
    type: 'client_report';
};
type ReplayEventItemHeaders = {
    type: 'replay_event';
};
type ReplayRecordingItemHeaders = {
    type: 'replay_recording';
    length: number;
};
type CheckInItemHeaders = {
    type: 'check_in';
};
type StatsdItemHeaders = {
    type: 'statsd';
    length: number;
};
type ProfileItemHeaders = {
    type: 'profile';
};
type SpanItemHeaders = {
    type: 'span';
};
type EventItem = BaseEnvelopeItem<EventItemHeaders, Event>;
type AttachmentItem = BaseEnvelopeItem<AttachmentItemHeaders, string | Uint8Array>;
type UserFeedbackItem = BaseEnvelopeItem<UserFeedbackItemHeaders, UserFeedback>;
type SessionItem = BaseEnvelopeItem<SessionItemHeaders, Session | SerializedSession> | BaseEnvelopeItem<SessionAggregatesItemHeaders, SessionAggregates>;
type ClientReportItem = BaseEnvelopeItem<ClientReportItemHeaders, ClientReport>;
type CheckInItem = BaseEnvelopeItem<CheckInItemHeaders, SerializedCheckIn>;
type ReplayEventItem = BaseEnvelopeItem<ReplayEventItemHeaders, ReplayEvent>;
type ReplayRecordingItem = BaseEnvelopeItem<ReplayRecordingItemHeaders, ReplayRecordingData>;
type StatsdItem = BaseEnvelopeItem<StatsdItemHeaders, string>;
type FeedbackItem = BaseEnvelopeItem<FeedbackItemHeaders, FeedbackEvent>;
type ProfileItem = BaseEnvelopeItem<ProfileItemHeaders, Profile>;
type SpanItem = BaseEnvelopeItem<SpanItemHeaders, Span>;
type EventEnvelopeHeaders = {
    event_id: string;
    sent_at: string;
    trace?: DynamicSamplingContext;
};
type SessionEnvelopeHeaders = {
    sent_at: string;
};
type CheckInEnvelopeHeaders = {
    trace?: DynamicSamplingContext;
};
type ClientReportEnvelopeHeaders = BaseEnvelopeHeaders;
type ReplayEnvelopeHeaders = BaseEnvelopeHeaders;
type StatsdEnvelopeHeaders = BaseEnvelopeHeaders;
type SpanEnvelopeHeaders = BaseEnvelopeHeaders;
type EventEnvelope = BaseEnvelope<EventEnvelopeHeaders, EventItem | AttachmentItem | UserFeedbackItem | FeedbackItem | ProfileItem>;
type SessionEnvelope = BaseEnvelope<SessionEnvelopeHeaders, SessionItem>;
type ClientReportEnvelope = BaseEnvelope<ClientReportEnvelopeHeaders, ClientReportItem>;
type ReplayEnvelope = [ReplayEnvelopeHeaders, [ReplayEventItem, ReplayRecordingItem]];
type CheckInEnvelope = BaseEnvelope<CheckInEnvelopeHeaders, CheckInItem>;
type StatsdEnvelope = BaseEnvelope<StatsdEnvelopeHeaders, StatsdItem>;
type SpanEnvelope = BaseEnvelope<SpanEnvelopeHeaders, SpanItem>;
type Envelope = EventEnvelope | SessionEnvelope | ClientReportEnvelope | ReplayEnvelope | CheckInEnvelope | StatsdEnvelope | SpanEnvelope;

/** A `Request` type compatible with Node, Express, browser, etc., because everything is optional */
type PolymorphicRequest = BaseRequest & BrowserRequest & NodeRequest & ExpressRequest & KoaRequest & NextjsRequest;
type BaseRequest = {
    method?: string;
    url?: string;
};
type BrowserRequest = BaseRequest;
type NodeRequest = BaseRequest & {
    headers?: {
        [key: string]: string | string[] | undefined;
    };
    protocol?: string;
    socket?: {
        encrypted?: boolean;
        remoteAddress?: string;
    };
};
type KoaRequest = NodeRequest & {
    host?: string;
    hostname?: string;
    ip?: string;
    originalUrl?: string;
};
type NextjsRequest = NodeRequest & {
    cookies?: {
        [key: string]: string;
    };
    query?: {
        [key: string]: any;
    };
};
type ExpressRequest = NodeRequest & {
    baseUrl?: string;
    body?: string | {
        [key: string]: any;
    };
    host?: string;
    hostname?: string;
    ip?: string;
    originalUrl?: string;
    route?: {
        path: string;
        stack: [
            {
                name: string;
            }
        ];
    };
    query?: {
        [key: string]: any;
    };
    user?: {
        [key: string]: any;
    };
    _reconstructedRoute?: string;
};

/**
 * Interface holding Transaction-specific properties
 */
interface TransactionContext extends SpanContext {
    /**
     * Human-readable identifier for the transaction
     */
    name: string;
    /**
     * If true, sets the end timestamp of the transaction to the highest timestamp of child spans, trimming
     * the duration of the transaction. This is useful to discard extra time in the transaction that is not
     * accounted for in child spans, like what happens in the idle transaction Tracing integration, where we finish the
     * transaction after a given "idle time" and we don't want this "idle time" to be part of the transaction.
     */
    trimEnd?: boolean | undefined;
    /**
     * If this transaction has a parent, the parent's sampling decision
     */
    parentSampled?: boolean | undefined;
    /**
     * Metadata associated with the transaction, for internal SDK use.
     * @deprecated Use attributes or store data on the scope instead.
     */
    metadata?: Partial<TransactionMetadata>;
}
/**
 * Transaction "Class", inherits Span only has `setName`
 */
interface Transaction extends TransactionContext, Omit<Span, 'setName' | 'name'> {
    /**
     * Human-readable identifier for the transaction.
     * @deprecated Use `spanToJSON(span).description` instead.
     */
    name: string;
    /**
     * The ID of the transaction.
     * @deprecated Use `spanContext().spanId` instead.
     */
    spanId: string;
    /**
     * The ID of the trace.
     * @deprecated Use `spanContext().traceId` instead.
     */
    traceId: string;
    /**
     * Was this transaction chosen to be sent as part of the sample?
     * @deprecated Use `spanIsSampled(transaction)` instead.
     */
    sampled?: boolean | undefined;
    /**
     * @inheritDoc
     */
    startTimestamp: number;
    /**
     * Tags for the transaction.
     * @deprecated Use `getSpanAttributes(transaction)` instead.
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * Data for the transaction.
     * @deprecated Use `getSpanAttributes(transaction)` instead.
     */
    data: {
        [key: string]: any;
    };
    /**
     * Attributes for the transaction.
     * @deprecated Use `getSpanAttributes(transaction)` instead.
     */
    attributes: SpanAttributes;
    /**
     * Metadata about the transaction.
     * @deprecated Use attributes or store data on the scope instead.
     */
    metadata: TransactionMetadata;
    /**
     * The instrumenter that created this transaction.
     *
     * @deprecated This field will be removed in v8.
     */
    instrumenter: Instrumenter;
    /**
     * Set the name of the transaction
     *
     * @deprecated Use `.updateName()` and `.setAttribute()` instead.
     */
    setName(name: string, source?: TransactionMetadata['source']): void;
    /**
     * Set the context of a transaction event.
     * @deprecated Use either `.setAttribute()`, or set the context on the scope before creating the transaction.
     */
    setContext(key: string, context: Context): void;
    /**
     * Set observed measurement for this transaction.
     *
     * @param name Name of the measurement
     * @param value Value of the measurement
     * @param unit Unit of the measurement. (Defaults to an empty string)
     *
     * @deprecated Use top-level `setMeasurement()` instead.
     */
    setMeasurement(name: string, value: number, unit: MeasurementUnit): void;
    /**
     * Returns the current transaction properties as a `TransactionContext`.
     * @deprecated Use `toJSON()` or access the fields directly instead.
     */
    toContext(): TransactionContext;
    /**
     * Updates the current transaction with a new `TransactionContext`.
     * @deprecated Update the fields directly instead.
     */
    updateWithContext(transactionContext: TransactionContext): this;
    /**
     * Set metadata for this transaction.
     * @deprecated Use attributes or store data on the scope instead.
     */
    setMetadata(newMetadata: Partial<TransactionMetadata>): void;
    /**
     * Return the current Dynamic Sampling Context of this transaction
     *
     * @deprecated Use top-level `getDynamicSamplingContextFromSpan` instead.
     */
    getDynamicSamplingContext(): Partial<DynamicSamplingContext>;
    /**
     * Get the profile id from the transaction
     * @deprecated Use `toJSON()` or access the fields directly instead.
     */
    getProfileId(): string | undefined;
}
interface TransactionMetadata {
    /**
     * The sample rate used when sampling this transaction.
     * @deprecated Use `SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE` attribute instead.
     */
    sampleRate?: number;
    /**
     * The Dynamic Sampling Context of a transaction. If provided during transaction creation, its Dynamic Sampling
     * Context Will be frozen
     */
    dynamicSamplingContext?: Partial<DynamicSamplingContext>;
    /** For transactions tracing server-side request handling, the request being tracked. */
    request?: PolymorphicRequest;
    /** Compatibility shim for transitioning to the `RequestData` integration. The options passed to our Express request
     * handler controlling what request data is added to the event.
     * TODO (v8): This should go away
     */
    requestDataOptionsFromExpressHandler?: {
        [key: string]: unknown;
    };
    /** For transactions tracing server-side request handling, the path of the request being tracked. */
    /** TODO: If we rm -rf `instrumentServer`, this can go, too */
    requestPath?: string;
    /**
     * Information on how a transaction name was generated.
     * @deprecated Use `SEMANTIC_ATTRIBUTE_SENTRY_SOURCE` attribute instead.
     */
    source: TransactionSource;
    /**
     * Metadata for the transaction's spans, keyed by spanId.
     * @deprecated This will be removed in v8.
     */
    spanMetadata: {
        [spanId: string]: {
            [key: string]: unknown;
        };
    };
}
/**
 * Contains information about how the name of the transaction was determined. This will be used by the server to decide
 * whether or not to scrub identifiers from the transaction name, or replace the entire name with a placeholder.
 */
type TransactionSource = 
/** User-defined name */
'custom'
/** Raw URL, potentially containing identifiers */
 | 'url'
/** Parametrized URL / route */
 | 'route'
/** Name of the view handling the request */
 | 'view'
/** Named after a software component, such as a function or class name. */
 | 'component'
/** Name of a background task (e.g. a Celery task) */
 | 'task';

type SpanOriginType = 'manual' | 'auto';
type SpanOriginCategory = string;
type SpanOriginIntegrationName = string;
type SpanOriginIntegrationPart = string;
type SpanOrigin = SpanOriginType | `${SpanOriginType}.${SpanOriginCategory}` | `${SpanOriginType}.${SpanOriginCategory}.${SpanOriginIntegrationName}` | `${SpanOriginType}.${SpanOriginCategory}.${SpanOriginIntegrationName}.${SpanOriginIntegrationPart}`;
type SpanAttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;
type SpanAttributes = Partial<{
    'sentry.origin': string;
    'sentry.op': string;
    'sentry.source': string;
    'sentry.sample_rate': number;
}> & Record<string, SpanAttributeValue | undefined>;
type MetricSummary = {
    min: number;
    max: number;
    count: number;
    sum: number;
    tags?: Record<string, Primitive> | undefined;
};
/** This type is aligned with the OpenTelemetry TimeInput type. */
type SpanTimeInput = HrTime | number | Date;
/** A JSON representation of a span. */
interface SpanJSON {
    data?: {
        [key: string]: any;
    };
    description?: string;
    op?: string;
    parent_span_id?: string;
    span_id: string;
    start_timestamp: number;
    status?: string;
    tags?: {
        [key: string]: Primitive;
    };
    timestamp?: number;
    trace_id: string;
    origin?: SpanOrigin;
    _metrics_summary?: Record<string, Array<MetricSummary>>;
    exclusive_time?: number;
}
type TraceFlagNone = 0x0;
type TraceFlagSampled = 0x1;
type TraceFlag = TraceFlagNone | TraceFlagSampled;
interface SpanContextData {
    /**
     * The ID of the trace that this span belongs to. It is worldwide unique
     * with practically sufficient probability by being made as 16 randomly
     * generated bytes, encoded as a 32 lowercase hex characters corresponding to
     * 128 bits.
     */
    traceId: string;
    /**
     * The ID of the Span. It is globally unique with practically sufficient
     * probability by being made as 8 randomly generated bytes, encoded as a 16
     * lowercase hex characters corresponding to 64 bits.
     */
    spanId: string;
    /**
     * Only true if the SpanContext was propagated from a remote parent.
     */
    isRemote?: boolean;
    /**
     * Trace flags to propagate.
     *
     * It is represented as 1 byte (bitmap). Bit to represent whether trace is
     * sampled or not. When set, the least significant bit documents that the
     * caller may have recorded trace data. A caller who does not record trace
     * data out-of-band leaves this flag unset.
     */
    traceFlags: TraceFlag;
}
/** Interface holding all properties that can be set on a Span on creation. */
interface SpanContext {
    /**
     * Description of the Span.
     *
     * @deprecated Use `name` instead.
     */
    description?: string | undefined;
    /**
     * Human-readable identifier for the span. Alias for span.description.
     */
    name?: string | undefined;
    /**
     * Operation of the Span.
     */
    op?: string | undefined;
    /**
     * Completion status of the Span.
     * See: {@sentry/tracing SpanStatus} for possible values
     */
    status?: string | undefined;
    /**
     * Parent Span ID
     */
    parentSpanId?: string | undefined;
    /**
     * Was this span chosen to be sent as part of the sample?
     */
    sampled?: boolean | undefined;
    /**
     * Span ID
     */
    spanId?: string | undefined;
    /**
     * Trace ID
     */
    traceId?: string | undefined;
    /**
     * Tags of the Span.
     * @deprecated Pass `attributes` instead.
     */
    tags?: {
        [key: string]: Primitive;
    };
    /**
     * Data of the Span.
     * @deprecated Pass `attributes` instead.
     */
    data?: {
        [key: string]: any;
    };
    /**
     * Attributes of the Span.
     */
    attributes?: SpanAttributes;
    /**
     * Timestamp in seconds (epoch time) indicating when the span started.
     */
    startTimestamp?: number | undefined;
    /**
     * Timestamp in seconds (epoch time) indicating when the span ended.
     */
    endTimestamp?: number | undefined;
    /**
     * The instrumenter that created this span.
     */
    instrumenter?: Instrumenter | undefined;
    /**
     * The origin of the span, giving context about what created the span.
     */
    origin?: SpanOrigin | undefined;
    /**
     * Exclusive time in milliseconds.
     */
    exclusiveTime?: number;
    /**
     * Measurements of the Span.
     */
    measurements?: Measurements;
}
/** Span holding trace_id, span_id */
interface Span extends Omit<SpanContext, 'op' | 'status' | 'origin'> {
    /**
     * Human-readable identifier for the span. Identical to span.description.
     * @deprecated Use `spanToJSON(span).description` instead.
     */
    name: string;
    /**
     * Operation of the Span.
     *
     * @deprecated Use `startSpan()` functions to set, `span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'op')
     * to update and `spanToJSON().op` to read the op instead
     */
    op?: string | undefined;
    /**
     * The ID of the span.
     * @deprecated Use `spanContext().spanId` instead.
     */
    spanId: string;
    /**
     * Parent Span ID
     *
     * @deprecated Use `spanToJSON(span).parent_span_id` instead.
     */
    parentSpanId?: string | undefined;
    /**
     * The ID of the trace.
     * @deprecated Use `spanContext().traceId` instead.
     */
    traceId: string;
    /**
     * Was this span chosen to be sent as part of the sample?
     * @deprecated Use `isRecording()` instead.
     */
    sampled?: boolean | undefined;
    /**
     * Timestamp in seconds (epoch time) indicating when the span started.
     * @deprecated Use `spanToJSON()` instead.
     */
    startTimestamp: number;
    /**
     * Timestamp in seconds (epoch time) indicating when the span ended.
     * @deprecated Use `spanToJSON()` instead.
     */
    endTimestamp?: number | undefined;
    /**
     * Tags for the span.
     * @deprecated Use `spanToJSON(span).atttributes` instead.
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * Data for the span.
     * @deprecated Use `spanToJSON(span).atttributes` instead.
     */
    data: {
        [key: string]: any;
    };
    /**
     * Attributes for the span.
     * @deprecated Use `spanToJSON(span).atttributes` instead.
     */
    attributes: SpanAttributes;
    /**
     * The transaction containing this span
     * @deprecated Use top level `Sentry.getRootSpan()` instead
     */
    transaction?: Transaction;
    /**
     * The instrumenter that created this span.
     *
     * @deprecated this field will be removed.
     */
    instrumenter: Instrumenter;
    /**
     * Completion status of the Span.
     *
     * See: {@sentry/tracing SpanStatus} for possible values
     *
     * @deprecated Use `.setStatus` to set or update and `spanToJSON()` to read the status.
     */
    status?: string | undefined;
    /**
     * The origin of the span, giving context about what created the span.
     *
     * @deprecated Use `startSpan` function to set and `spanToJSON(span).origin` to read the origin instead.
     */
    origin?: SpanOrigin | undefined;
    /**
     * Get context data for this span.
     * This includes the spanId & the traceId.
     */
    spanContext(): SpanContextData;
    /**
     * Sets the finish timestamp on the current span.
     *
     * @param endTimestamp Takes an endTimestamp if the end should not be the time when you call this function.
     *
     * @deprecated Use `.end()` instead.
     */
    finish(endTimestamp?: number): void;
    /**
     * End the current span.
     */
    end(endTimestamp?: SpanTimeInput): void;
    /**
     * Sets the tag attribute on the current span.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key Tag key
     * @param value Tag value
     * @deprecated Use `setAttribute()` instead.
     */
    setTag(key: string, value: Primitive): this;
    /**
     * Sets the data attribute on the current span
     * @param key Data key
     * @param value Data value
     * @deprecated Use `setAttribute()` instead.
     */
    setData(key: string, value: any): this;
    /**
     * Set a single attribute on the span.
     * Set it to `undefined` to remove the attribute.
     */
    setAttribute(key: string, value: SpanAttributeValue | undefined): void;
    /**
     * Set multiple attributes on the span.
     * Any attribute set to `undefined` will be removed.
     */
    setAttributes(attributes: SpanAttributes): void;
    /**
     * Sets the status attribute on the current span
     * See: {@sentry/tracing SpanStatus} for possible values
     * @param status http code used to set the status
     */
    setStatus(status: string): this;
    /**
     * Sets the status attribute on the current span based on the http code
     * @param httpStatus http code used to set the status
     * @deprecated Use top-level `setHttpStatus()` instead.
     */
    setHttpStatus(httpStatus: number): this;
    /**
     * Set the name of the span.
     *
     * @deprecated Use `updateName()` instead.
     */
    setName(name: string): void;
    /**
     * Update the name of the span.
     */
    updateName(name: string): this;
    /**
     * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.
     * Also the `sampled` decision will be inherited.
     *
     * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
     */
    startChild(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * Determines whether span was successful (HTTP200)
     *
     * @deprecated Use `spanToJSON(span).status === 'ok'` instead.
     */
    isSuccess(): boolean;
    /**
     * Return a traceparent compatible header string.
     * @deprecated Use `spanToTraceHeader()` instead.
     */
    toTraceparent(): string;
    /**
     * Returns the current span properties as a `SpanContext`.
     * @deprecated Use `toJSON()` or access the fields directly instead.
     */
    toContext(): SpanContext;
    /**
     * Updates the current span with a new `SpanContext`.
     * @deprecated Update the fields directly instead.
     */
    updateWithContext(spanContext: SpanContext): this;
    /**
     * Convert the object to JSON for w. spans array info only.
     * @deprecated Use `spanToTraceContext()` util function instead.
     */
    getTraceContext(): TraceContext;
    /**
     * Convert the object to JSON.
     * @deprecated Use `spanToJSON(span)` instead.
     */
    toJSON(): SpanJSON;
    /**
     * If this is span is actually recording data.
     * This will return false if tracing is disabled, this span was not sampled or if the span is already finished.
     */
    isRecording(): boolean;
}

type Context = Record<string, unknown>;
interface Contexts extends Record<string, Context | undefined> {
    app?: AppContext;
    device?: DeviceContext;
    os?: OsContext;
    culture?: CultureContext;
    response?: ResponseContext;
    trace?: TraceContext;
    cloud_resource?: CloudResourceContext;
    state?: StateContext;
}
interface StateContext extends Record<string, unknown> {
    state: {
        type: string;
        value: Record<string, unknown>;
    };
}
interface AppContext extends Record<string, unknown> {
    app_name?: string;
    app_start_time?: string;
    app_version?: string;
    app_identifier?: string;
    build_type?: string;
    app_memory?: number;
}
interface DeviceContext extends Record<string, unknown> {
    name?: string;
    family?: string;
    model?: string;
    model_id?: string;
    arch?: string;
    battery_level?: number;
    orientation?: 'portrait' | 'landscape';
    manufacturer?: string;
    brand?: string;
    screen_resolution?: string;
    screen_height_pixels?: number;
    screen_width_pixels?: number;
    screen_density?: number;
    screen_dpi?: number;
    online?: boolean;
    charging?: boolean;
    low_memory?: boolean;
    simulator?: boolean;
    memory_size?: number;
    free_memory?: number;
    usable_memory?: number;
    storage_size?: number;
    free_storage?: number;
    external_storage_size?: number;
    external_free_storage?: number;
    boot_time?: string;
    processor_count?: number;
    cpu_description?: string;
    processor_frequency?: number;
    device_type?: string;
    battery_status?: string;
    device_unique_identifier?: string;
    supports_vibration?: boolean;
    supports_accelerometer?: boolean;
    supports_gyroscope?: boolean;
    supports_audio?: boolean;
    supports_location_service?: boolean;
}
interface OsContext extends Record<string, unknown> {
    name?: string;
    version?: string;
    build?: string;
    kernel_version?: string;
}
interface CultureContext extends Record<string, unknown> {
    calendar?: string;
    display_name?: string;
    locale?: string;
    is_24_hour_format?: boolean;
    timezone?: string;
}
interface ResponseContext extends Record<string, unknown> {
    type?: string;
    cookies?: string[][] | Record<string, string>;
    headers?: Record<string, string>;
    status_code?: number;
    body_size?: number;
}
interface TraceContext extends Record<string, unknown> {
    data?: {
        [key: string]: any;
    };
    op?: string;
    parent_span_id?: string;
    span_id: string;
    status?: string;
    tags?: {
        [key: string]: Primitive;
    };
    trace_id: string;
    origin?: SpanOrigin;
}
interface CloudResourceContext extends Record<string, unknown> {
    ['cloud.provider']?: string;
    ['cloud.account.id']?: string;
    ['cloud.region']?: string;
    ['cloud.availability_zone']?: string;
    ['cloud.platform']?: string;
    ['host.id']?: string;
    ['host.type']?: string;
}

interface CrontabSchedule {
    type: 'crontab';
    value: string;
}
interface IntervalSchedule {
    type: 'interval';
    value: number;
    unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute';
}
type MonitorSchedule = CrontabSchedule | IntervalSchedule;
interface SerializedCheckIn {
    check_in_id: string;
    monitor_slug: string;
    status: 'in_progress' | 'ok' | 'error';
    duration?: number;
    release?: string;
    environment?: string;
    monitor_config?: {
        schedule: MonitorSchedule;
        checkin_margin?: number;
        max_runtime?: number;
        timezone?: string;
    };
    contexts?: {
        trace?: TraceContext;
    };
}

type TransportMakeRequestResponse = {
    statusCode?: number;
    headers?: {
        [key: string]: string | null;
        'x-sentry-rate-limits': string | null;
        'retry-after': string | null;
    };
};
interface Transport {
    send(request: Envelope): PromiseLike<void | TransportMakeRequestResponse>;
    flush(timeout?: number): PromiseLike<boolean>;
}

interface PanoramaBrowserClientOptions {
    panoramaClient: any;
    /**
     * A function that takes transport options and returns the Transport object which is used to send events to Sentry.
     */
    sentryTransport?: Transport;
    /**
     * Enable debug functionality
     */
    debug?: boolean;
}

declare const createPanoramaBrowserClient: (options: PanoramaBrowserClientOptions) => MonitoringClient;

export { type PanoramaBrowserClientOptions, createPanoramaBrowserClient };
