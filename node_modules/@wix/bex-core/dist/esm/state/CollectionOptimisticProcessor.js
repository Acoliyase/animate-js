import { action, makeObservable } from 'mobx';
import { QueryResultSimulationDefault } from './QueryResultSimulationDefault';
import { CollectionOptimisticProcessorHelpers } from './CollectionOptimisticHelpers';
import { filterPageByPatches, mergePatchedItems, prepareItemsToMergeIntoPage, } from './optimistic-simulation';
import { orderByOrders } from './optimistic-simulation/orderByOrders';
import { orderByMoves } from './optimistic-simulation/orderByMoves';
export class CollectionOptimisticProcessor {
    constructor(params) {
        this.collection = params.collection;
        this.processorHelpers = new CollectionOptimisticProcessorHelpers(this.collection);
        this.optimistic = params.optimistic;
        this.resultSimulationDefault = new QueryResultSimulationDefault({
            collection: this.collection,
        });
        this.predicate = params.predicate ?? this.resultSimulationDefault.predicate;
        this.orderBy = params.orderBy ?? this.resultSimulationDefault.orderBy;
        makeObservable(this, {
            reprocess: action.bound,
            beforeAddNewPages: action.bound,
            beforeSetTotal: action.bound,
        });
        this._register();
    }
    _register() {
        this.collection.emitter.on('beforeAddNewPages', this.beforeAddNewPages);
        this.collection.emitter.on('beforeSetTotal', this.beforeSetTotal);
        this.optimistic.events.on('reprocess', this.reprocess);
    }
    reprocess() {
        this.removeSelectionIfExists();
        this.processorHelpers.reprocess();
    }
    removeSelectionIfExists() {
        const { collection: { itemKey, bulkSelect, result: { originQuery }, }, optimistic: { state: { patches }, }, predicate, } = this;
        const itemPredicate = predicate(originQuery);
        const filterItem = filterPageByPatches(patches, { itemPredicate, itemKey });
        bulkSelect.select.filter(({ item }) => filterItem(item));
    }
    beforeAddNewPages({ pages, currentItemsMap, originQuery, }) {
        const { optimistic: { state, query, _orderByMode }, collection, predicate, orderBy: orderByIteratee, } = this;
        const { itemKey } = collection;
        const { patches } = state;
        const { limit } = originQuery;
        if (!patches.length) {
            return pages;
        }
        const itemPredicate = predicate(originQuery);
        const orders = _orderByMode === 'orders' ? orderByIteratee(originQuery) : [];
        let finalPages = pages;
        const itemToMerge = prepareItemsToMergeIntoPage(patches, {
            itemPredicate,
            currentItemsMap,
        });
        finalPages =
            !itemToMerge.all.size && _orderByMode === 'orders'
                ? finalPages
                : finalPages.map((page, index) => {
                    const pageWithPatchedItems = itemToMerge.all.size
                        ? mergePatchedItems(itemToMerge, {
                            page,
                            limit,
                            itemKey,
                            orders,
                            itemPredicate,
                        })
                        : page.map((item) => ({ item }));
                    return _orderByMode === 'moves'
                        ? orderByMoves({
                            pageWithPatchedItems,
                            pageIndex: index,
                            patches,
                            currentFiltersKeyHash: query.filtersKeyHash,
                            itemKey,
                            toMerge: itemToMerge,
                            itemPredicate,
                            limit,
                        })
                        : orderByOrders(pageWithPatchedItems, itemToMerge, {
                            orders,
                            itemKey,
                            limit,
                        });
                });
        finalPages = finalPages.map((page) => {
            return page.filter(filterPageByPatches(patches, { itemPredicate, itemKey }));
        });
        return finalPages;
    }
    beforeSetTotal({ total, originQuery, }) {
        const { optimistic: { state }, predicate, } = this;
        const { patches } = state;
        if (!patches.length) {
            return total;
        }
        const itemPredicate = predicate(originQuery);
        const processedTotal = patches.reduce((prev, { actionType, patchedItemsEntries, originalItems, originalTotal }) => {
            if (actionType === 'updateAllConst' || actionType === 'deleteAll') {
                const [[key, item] = []] = patchedItemsEntries;
                if (key == null || item == null) {
                    return prev;
                }
                const originalItem = originalItems.get(key);
                if (itemPredicate(item) &&
                    (originalItem == null || !itemPredicate(originalItem))) {
                    return prev + originalTotal;
                }
                if (
                // if action=deleteAll treat the item as filtered out, no need to check predicate
                (actionType === 'deleteAll' || !itemPredicate(item)) &&
                    originalItem != null &&
                    itemPredicate(originalItem)) {
                    return prev - originalTotal;
                }
                return prev;
            }
            const patchedItemsTotal = patchedItemsEntries.reduce((acc, [key, item]) => {
                const originalItem = originalItems.get(key);
                const value = (() => {
                    switch (actionType) {
                        case 'deleteMany':
                            if (originalItem != null && itemPredicate(originalItem)) {
                                return -1;
                            }
                            return 0;
                        case 'updateMany':
                        case 'updateAll':
                        case 'createMany':
                            if (itemPredicate(item) &&
                                (originalItem == null || !itemPredicate(originalItem))) {
                                return 1;
                            }
                            if (!itemPredicate(item) &&
                                originalItem != null &&
                                itemPredicate(originalItem)) {
                                return -1;
                            }
                            return 0;
                    }
                    return 0;
                })();
                return acc + value;
            }, 0);
            return prev + patchedItemsTotal;
        }, total);
        return Math.max(processedTotal, 0);
    }
}
//# sourceMappingURL=CollectionOptimisticProcessor.js.map