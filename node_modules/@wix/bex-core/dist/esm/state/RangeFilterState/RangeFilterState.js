import { EventEmitter } from 'events';
import { action, computed, makeObservable, observable } from 'mobx';
import { getDatesFromPreset, presetToDaysAmount } from './dateRangeUtils';
import { refreshFilter } from '../Filter/refreshFilter';
function isRecord(thing) {
    return thing != null;
}
export class RangeFilterState {
    constructor(params) {
        this._value = this.emptyValue;
        this.events = new EventEmitter();
        this._toArray = (value) => {
            return [value];
        };
        this.name = params.name ?? '';
        this.persistent = params.persistent;
        // this.defaultValue = params.defaultValue;
        this.itemKey = params.itemKey;
        this.itemName = params.itemName;
        this.parse = params.parse;
        this.parsePreset = params.parsePreset ?? (() => this.emptyValue);
        this.isEmptyPreset = params.isEmptyPreset ?? (() => true);
        this.simplify = params.simplify ?? ((value) => value);
        this.matches =
            params.matches ??
                ((item, value) => this.itemName(item) === this.itemName(value));
        this._value = params.initialValue ?? this.emptyValue;
        this.equals = params.equals;
        this.isCustomField = params.isCustomField;
        makeObservable(this, {
            _value: observable.ref,
            persistent: observable.ref,
            isEmpty: computed,
            size: computed,
            value: computed,
            setValue: action,
            changeValue: action,
        });
    }
    get emptyValue() {
        return { from: null, to: null };
    }
    get value() {
        return this._value;
    }
    get toArray() {
        return [this._value];
    }
    get isEmpty() {
        const { from, to, preset } = this._value;
        return !from && from !== 0 && !to && to !== 0 && this.isEmptyPreset(preset);
    }
    get size() {
        return this.isEmpty ? 0 : 1;
    }
    get toQueryString() {
        return this.itemKey(this._value);
    }
    encode(value) {
        if (!this.isEmptyPreset(value.preset)) {
            return {
                preset: value.preset,
            };
        }
        return {
            ...(value.from && { from: this.simplify(value.from) }),
            ...(value.to && { to: this.simplify(value.to) }),
        };
    }
    decode(raw) {
        if (typeof raw === 'string') {
            if (!raw.includes('/') && !this.isEmptyPreset(raw)) {
                return this.parsePreset(raw);
            }
            const [from, to] = raw.split('/').map(this.parse);
            return {
                from,
                to,
            };
        }
        if (isRecord(raw)) {
            const [from, to] = [raw.from, raw.to].map(this.parse);
            const preset = typeof raw.preset === 'string' ? raw.preset : undefined;
            if (!this.isEmptyPreset(preset)) {
                return this.parsePreset(preset);
            }
            return {
                from,
                to,
                preset,
            };
        }
        return this.emptyValue;
    }
    setValue(value, { emitEvents, ...options } = {}) {
        this._value = value;
        if (emitEvents) {
            for (const event of emitEvents) {
                this.events.emit(event, options);
            }
        }
    }
    changeValue(value, { emitEvents = [], ...options } = {}) {
        this.setValue(value, { ...options, emitEvents: ['change', ...emitEvents] });
    }
    remove(items, options = {}) {
        if (items.some((e) => e.from || e.to)) {
            this.setValue(this.emptyValue, options);
        }
    }
    applyFromQueryString(str) {
        this.setValue(this.decode(str));
    }
    refresh(value, options) {
        refreshFilter(this, value, options);
    }
    scheduleRefresh(value) {
        this.changeValue(value, { emitEvents: ['scheduleRefresh'] });
    }
    reset(options = {}) {
        this.setValue(this.emptyValue, options);
    }
    hasDiff(rangeItem) {
        const { value } = this;
        return value.from !== rangeItem.from || value.to !== rangeItem.to;
    }
    clone(params) {
        const { value: initialValue, matches, persistent, itemKey, itemName, parse, name, simplify, isEmptyPreset, parsePreset, equals, } = this;
        return new RangeFilterState({
            initialValue,
            matches,
            persistent,
            itemKey,
            itemName,
            parse,
            name,
            simplify,
            isEmptyPreset,
            parsePreset,
            equals,
            ...params,
        });
    }
}
export const rangeFilter = (params) => new RangeFilterState(params);
const isEmptyDatePreset = (preset) => {
    return !preset || presetToDaysAmount[preset] === undefined;
};
export const toString = (item) => {
    if (!item.preset || isEmptyDatePreset(item.preset)) {
        return [item.from, item.to].map((d) => d?.toISOString()).join('/');
    }
    return item.preset;
};
export const dateRangeFilter = (params = {}) => {
    return new RangeFilterState({
        itemKey: toString,
        itemName: toString,
        parse: (value) => {
            if (typeof value === 'object' && value instanceof Date) {
                return value;
            }
            if (typeof value !== 'string' && typeof value !== 'number') {
                return null;
            }
            const d = new Date(value);
            if (isNaN(d.valueOf())) {
                return null;
            }
            return d;
        },
        parsePreset: getDatesFromPreset,
        isEmptyPreset: isEmptyDatePreset,
        equals: (item1, item2) => {
            if (isEmptyDatePreset(item1.preset) && isEmptyDatePreset(item2.preset)) {
                return (item1.from?.getTime() === item2.from?.getTime() &&
                    item1.to?.getTime() === item2.to?.getTime());
            }
            return item1.preset === item2.preset;
        },
        ...params,
    });
};
export const numberRangeFilter = (params = {}) => {
    return new RangeFilterState({
        itemKey: (item) => `${item.from}/${item.to}`,
        itemName: (item) => {
            const from = typeof item.from === 'number' ? `from ${item.from.toString()}` : '';
            const to = typeof item.to === 'number' ? `to ${item.to.toString()}` : '';
            return `${from} ${to}`;
        },
        parse: (value) => {
            if (typeof value === 'string') {
                const parsed = Number(value);
                return isNaN(parsed) ? null : parsed;
            }
            if (typeof value === 'number') {
                return value;
            }
            return null;
        },
        equals: (item1, item2) => {
            return item1.from === item2.from && item1.to === item2.to;
        },
        ...params,
    });
};
//# sourceMappingURL=RangeFilterState.js.map