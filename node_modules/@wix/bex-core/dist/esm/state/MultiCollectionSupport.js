import { action, computed, makeObservable } from 'mobx';
import { TaskState } from './TaskState';
export class MultiCollectionSupport {
    constructor(params) {
        this.initTask = new TaskState();
        this.retryErrorState = action(() => {
            const { initTask, collections } = this;
            if (initTask.status.isError) {
                initTask.runOnce();
            }
            else {
                collections.forEach((c) => c.retryErrorState());
            }
        });
        this.collections = params.collections;
        makeObservable(this, {
            showInitialLoader: computed,
            showEmptyState: computed,
            showErrorState: computed,
            showRefreshLoader: computed,
            errorStatus: computed,
            hasAvailableItems: computed,
            hasNonPersistentActiveFilters: computed,
            hasNonPersistentCustomFilters: computed,
        });
    }
    get showInitialLoader() {
        return this.collections.some((c) => c.showInitialLoader);
    }
    get showEmptyState() {
        return this.collections.every((collection) => collection.showEmptyState);
    }
    get showErrorState() {
        return this.collections.some((collection) => collection.showErrorState);
    }
    get showRefreshLoader() {
        return this.collections.some((collection) => collection.showRefreshLoader);
    }
    get showLoadingState() {
        return this.showInitialLoader || this.showRefreshLoader;
    }
    get errorStatus() {
        return this.collections
            .map((c) => c.result.status)
            .find((status) => status.isError);
    }
    get hasAvailableItems() {
        return this.collections.some((c) => c.result.hasAvailableItems);
    }
    get hasNonPersistentActiveFilters() {
        return this.collections.some((c) => c.query.hasNonPersistentActiveFilters);
    }
    get hasNonPersistentCustomFilters() {
        return this.collections.some((c) => c.query.hasNonPersistentCustomFilters);
    }
    get resultOriginQuerySearch() {
        return this.collections[0]?.result.originQuery.search;
    }
    get resultOriginQueryRawSearch() {
        return this.collections[0]?.result.originQuery.rawSearch;
    }
    init({ skipFilterListeners = false, } = {}) {
        const { collections, initTask } = this;
        const disposers = [
            ...collections.map((c) => c.init({ skipFilterListeners })),
        ];
        initTask.runOnce(async () => {
            collections.forEach((c) => c.initTask.runOnce());
            await Promise.all(collections.map((c) => c.initTask.status.promise));
        });
        return () => {
            disposers.forEach((d) => d());
        };
    }
}
//# sourceMappingURL=MultiCollectionSupport.js.map