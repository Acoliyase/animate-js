export function trimAddedItemsFromPagePredicate({ addedItems, itemKey, limit, }) {
    const removed = new Set();
    return (item, index, arr) => {
        const key = itemKey(item);
        const isPatched = addedItems.has(key);
        // if item is within a page limit, always include it
        if (index < limit) {
            if (isPatched) {
                // remove added item for later pages not to include it too
                addedItems.delete(key);
                removed.add(key);
            }
            return true;
        }
        // if the previous item in the order was a patched item, the next item still belongs to this page
        const prevItem = arr[index - 1];
        if (prevItem != null && removed.has(itemKey(prevItem))) {
            addedItems.delete(key);
            removed.add(key);
            return true;
        }
        // when item it out of a page limit, include it only if it's item coming from the server ("not patched"). If it's patched but our of a page limit, it means it belongs to the next page.
        return !isPatched;
    };
}
//# sourceMappingURL=trimAddedItemsFromPagePredicate.js.map