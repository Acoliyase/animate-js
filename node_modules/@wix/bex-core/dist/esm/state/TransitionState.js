import { EventEmitter } from 'events';
import { action, makeObservable, observable } from 'mobx';
export class TransitionState {
    constructor(initialValue = false) {
        this.events = new EventEmitter();
        this.show = initialValue;
        this.status = initialValue ? 'entered' : 'exited';
        this.data = null;
        this.nextData = null;
        this.events.on('exited', () => {
            const { events } = this;
            events.emit('exitedAfterNewData');
            events.emit('exitedAfterClickClose');
        });
        makeObservable(this, {
            show: observable.ref,
            status: observable.ref,
            data: observable.ref,
            setShow: action,
            setStatus: action,
            clickClose: action,
            set: action.bound,
            setSync: action.bound,
        });
    }
    setShow(value) {
        this.show = value;
    }
    setStatus(status) {
        this.status = status;
        this.events.emit(status);
    }
    set(data) {
        if (data == null) {
            this.events.emit('dismissed', { dismissMode: 'automatic' });
            this.show = false;
            return;
        }
        this.transitionToNewData(data);
    }
    // does not transition if data already exists
    setSync(data) {
        if (this.show && data != null) {
            this.data = data;
            return;
        }
        this.transitionToNewData(data);
    }
    clickClose(onAfterClose) {
        if (!this.show) {
            return;
        }
        const { events } = this;
        this.show = false;
        this.nextData = undefined;
        events.removeAllListeners('exitedAfterClickClose');
        events.once('exitedAfterClickClose', action(() => {
            events.emit('dismissed', { dismissMode: 'manual' });
            if (!this.show && typeof this.nextData === 'undefined') {
                this.data = null;
                onAfterClose?.();
            }
        }));
    }
    transitionToNewData(data) {
        const { events } = this;
        this.nextData = data;
        if (this.show) {
            this.show = false;
            events.removeAllListeners('exitedAfterNewData');
            events.once('exitedAfterNewData', action(() => {
                events.emit('dismissed', { dismissMode: 'automatic' });
                if (!this.show && this.nextData === data) {
                    this.show = true;
                    this.data = data;
                }
            }));
        }
        else {
            this.show = true;
            this.data = data;
        }
    }
}
//# sourceMappingURL=TransitionState.js.map