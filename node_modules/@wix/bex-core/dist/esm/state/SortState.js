import { EventEmitter } from 'events';
import { action, computed, makeObservable, observable } from 'mobx';
export class SortState {
    constructor(_params) {
        this._value = observable.array([], { deep: true });
        this.events = new EventEmitter();
        makeObservable(this, {
            value: computed,
            setSort: action,
            changeSort: action,
            reset: action,
        });
    }
    reset({ emitChangeEvent } = {}) {
        this._value.clear();
        if (emitChangeEvent) {
            this.events.emit('change');
        }
    }
    _getNextSortOrder(col) {
        const existingSort = this._value.find(({ field }) => field === col.id);
        /**
         * @deprecated always option is deprecated
         */
        if (col.sortMode === 'always') {
            return existingSort?.direction === 'asc' ? 'desc' : 'asc';
        }
        // Get the next sort mode
        if (Array.isArray(col.sortMode)) {
            const currentSortIndex = col.sortMode.indexOf(existingSort?.direction);
            const nextSortIndex = (currentSortIndex + 1) % col.sortMode.length;
            return col.sortMode[nextSortIndex];
        }
        // asc->desc->undefined->asc...
        return existingSort === undefined
            ? 'asc'
            : existingSort.direction === 'desc'
                ? undefined
                : 'desc';
    }
    setSort(col, { forceDirection, emitChangeEvent, multiple, } = {}) {
        const order = forceDirection ?? this._getNextSortOrder(col);
        if (multiple) {
            this._setSortMultiple(col, order);
        }
        else {
            this._setSortSingular(col, order);
        }
        if (emitChangeEvent) {
            this.events.emit('change', { col });
        }
    }
    _setSortSingular(col, direction) {
        this._value.clear();
        if (direction) {
            this._value.push({ field: col.id, direction });
        }
    }
    /**
     * Rules
     * Sort by a new column:
     * - Clear all previous sorts and add a new one
     * Sort by an existing column:
     * - If only 1 column is sorted, the next direction is calculated
     *   with the SortMode in mind (if provided).
     * - If more than 1 column is sorted, only change the direction
     *   asc -> desc, desc -> asc, ignoring the SortMode (if provided).
     */
    _setSortMultiple(col, direction) {
        const sortIndex = this._value.findIndex(({ field }) => field === col.id);
        if (sortIndex === -1) {
            this._setSortSingular(col, direction);
        }
        else {
            const nextDirection = this._value.length > 1
                ? this._value[sortIndex].direction === 'asc'
                    ? 'desc'
                    : 'asc'
                : direction;
            if (this._value.length === 1 && !direction) {
                this._value.clear();
            }
            else if (nextDirection) {
                this._value[sortIndex] = {
                    field: col.id,
                    direction: nextDirection,
                };
            }
        }
    }
    setSortQuery(query, { emitChangeEvent } = {}) {
        this._value.replace(query);
        if (emitChangeEvent) {
            this.events.emit('change');
        }
    }
    changeSort(col, params = {}) {
        this.setSort(col, {
            emitChangeEvent: true,
            ...params,
        });
    }
    get value() {
        return this._value;
    }
    getIsSortDescending(id) {
        const sort = this._value.find(({ field }) => field === id);
        if (sort) {
            return sort.direction === 'desc';
        }
        return undefined;
    }
}
//# sourceMappingURL=SortState.js.map