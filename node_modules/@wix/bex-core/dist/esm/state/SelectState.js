import { action, computed, makeObservable, observable } from 'mobx';
import { selectionStatusWixPatternsPreset } from './SelectionStatusWixPatternsPreset';
import { SelectMapState } from './SelectMapState';
export class SelectState {
    constructor(params) {
        this.map = new SelectMapState();
        this.defaultStatus =
            params.defaultStatus ?? selectionStatusWixPatternsPreset.unchecked;
        makeObservable(this, {
            defaultStatus: observable.ref,
            selectedValues: computed,
            selectedKeys: computed,
            isEmpty: computed,
            isNotEmpty: computed,
            isEmptyEnabledItems: computed,
            isNotEmptyEnabledItems: computed,
            selectedCount: computed,
            toArray: computed,
            selectedArray: computed,
            set: action,
            delete: action,
            toggle: action,
            clear: action,
            syncValues: action,
            finalizeMany: action,
            setMany: action,
            filter: action,
            initSelected: action,
        });
        this.keyGetter = params.keyGetter;
    }
    get startStatus() {
        return this.defaultStatus.start();
    }
    get finalStatus() {
        return this.defaultStatus.final();
    }
    isChecked(key) {
        const { map } = this;
        return Boolean(map.get(key)?.status.isChecked);
    }
    toggle(value, { clear } = {}) {
        const { map, keyGetter, defaultStatus } = this;
        if (clear) {
            this.clear();
        }
        const key = keyGetter(value);
        const entry = map.get(key) ?? { value, status: defaultStatus };
        map.set(key, {
            ...entry,
            status: entry.status.toggle(),
        });
    }
    set(value) {
        const { keyGetter, map, finalStatus } = this;
        const key = keyGetter(value);
        map.set(key, { value, status: finalStatus });
    }
    forceSet(value) {
        const { keyGetter, map, finalStatus } = this;
        const key = keyGetter(value);
        map.forceSet(key, { value, status: finalStatus });
    }
    delete(value) {
        const { keyGetter, map, defaultStatus } = this;
        const key = keyGetter(value);
        map.set(key, {
            value,
            status: defaultStatus.start(),
        });
    }
    deleteKey(key) {
        const { map } = this;
        const entry = map.get(key);
        if (entry) {
            map.set(key, {
                ...entry,
                status: entry.status.start(),
            });
        }
    }
    get selectedCount() {
        return this.selectedArray.length;
    }
    get toArray() {
        return Array.from(this.map.values());
    }
    get selectedArray() {
        return this.toArray.filter(({ status }) => status.isChecked);
    }
    get selectedValues() {
        return this.selectedArray.map(({ value }) => value);
    }
    get selectedKeys() {
        const { keyGetter } = this;
        return this.selectedValues.map(keyGetter);
    }
    clear() {
        const { map } = this;
        map.clear();
    }
    forceSetMany(entries) {
        const { map, keyGetter } = this;
        for (const entry of entries) {
            const key = keyGetter(entry.value);
            map.forceSet(key, entry);
        }
    }
    // backwards compatibility
    setMany(entries) {
        return this.forceSetMany(entries);
    }
    syncValues(values, status = this.defaultStatus) {
        const { map, keyGetter } = this;
        for (const value of values) {
            const key = keyGetter(value);
            const entry = map.get(key);
            const newEntry = entry ? { ...entry, value } : { value, status };
            map.forceSet(key, newEntry);
        }
    }
    initSelected(values) {
        const { map } = this;
        map.clear();
        this.forceSetMany(values.map((value) => ({
            value,
            status: this.finalStatus,
        })));
    }
    finalizeMany(values) {
        const { map, keyGetter, finalStatus } = this;
        for (const value of values) {
            const key = keyGetter(value);
            map.set(key, { value, status: finalStatus });
        }
    }
    startAll() {
        const { map, startStatus } = this;
        const entries = Array.from(map.entries());
        for (const [key, entry] of entries) {
            map.set(key, {
                ...entry,
                status: startStatus,
            });
        }
    }
    filter(predicate) {
        const { map, selectedArray, keyGetter } = this;
        for (const { value, status } of selectedArray) {
            if (!predicate(value)) {
                map.set(keyGetter(value), {
                    value,
                    status: status.start(),
                });
            }
        }
    }
    get isNotEmpty() {
        return !this.isEmpty;
    }
    get isEmpty() {
        const { selectedArray } = this;
        return !selectedArray.length;
    }
    get isNotEmptyEnabledItems() {
        return !this.isEmptyEnabledItems;
    }
    get isEmptyEnabledItems() {
        const { selectedArray } = this;
        const selectedEnabledItems = selectedArray.filter((selectionEntry) => this._map.events
            .listeners('isDisabled')
            .every((listener) => !listener(selectionEntry)));
        return !selectedEnabledItems.length;
    }
    get _map() {
        return this.map;
    }
}
//# sourceMappingURL=SelectState.js.map