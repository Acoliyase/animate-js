import { Chance } from 'chance';
import { escapeRegExp } from 'lodash';
import { InMemoryBackend } from '../InMemoryBackend';
import { nestifyItems } from './nestifyItems';
export function createFolder(chance, { createdAt = chance.date({
    min: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000),
    max: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
}), ...rest } = {}) {
    return {
        id: chance.guid(),
        name: chance.name(),
        createdAt,
        updatedAt: createdAt,
        status: chance.pickone(['visible', 'hidden']),
        ...rest,
    };
}
export const createFoldersBackend = ({ createOne, depth = 4, total = 1000, forceEmptyParentInEachLevel, foldersStaticData, ...params } = {}) => {
    const chance = new Chance();
    const backend = new InMemoryBackend({
        enableTotal: params?.enableTotal,
        createOne: createOne ??
            (foldersStaticData
                ? (i) => {
                    const raw = foldersStaticData[i];
                    return {
                        ...raw,
                        status: raw.status,
                        createdAt: new Date(raw.createdAt),
                        updatedAt: new Date(raw.updatedAt),
                    };
                }
                : () => createFolder(chance)),
        itemKey: (item) => item.id,
        total: foldersStaticData
            ? Math.min(foldersStaticData.length, total)
            : total,
        predicate: (query) => {
            const { search } = query;
            const filters = query.filters ?? {};
            const { id, parentId, folderStatus, updatedAt, level, hasChildren, ancestorId, } = filters;
            const rgx = new RegExp(escapeRegExp(search), 'i');
            return (item) => {
                if (search && !rgx.test(item.name)) {
                    return false;
                }
                if (folderStatus &&
                    folderStatus.length &&
                    folderStatus[0]?.id !== 'all' &&
                    !folderStatus.some((status) => status.id === item.status)) {
                    return false;
                }
                if (item.updatedAt &&
                    updatedAt?.from &&
                    updatedAt.from.valueOf() > item.updatedAt.valueOf()) {
                    return false;
                }
                if (item.updatedAt &&
                    updatedAt?.to &&
                    updatedAt.to.valueOf() < item.updatedAt.valueOf()) {
                    return false;
                }
                if (parentId &&
                    parentId.length &&
                    !parentId.some((parentId) => parentId === 'null'
                        ? item.parentId == null
                        : item.parentId === parentId)) {
                    return false;
                }
                if (ancestorId &&
                    ancestorId.length &&
                    !ancestorId.some((ancestorId) => item.breadcrumbs?.some(({ id }) => id === ancestorId))) {
                    return false;
                }
                if (id && id.length && !id.some((id) => id === item.id)) {
                    return false;
                }
                if (level &&
                    level.length &&
                    !level.some((level) => level === String(item.level))) {
                    return false;
                }
                if (hasChildren && hasChildren[0] === 'true' && !item.childCount) {
                    return false;
                }
                if (hasChildren && hasChildren[0] === 'false' && item.childCount) {
                    return false;
                }
                return true;
            };
        },
        orderBy: (query) => {
            return [...(query.sort ?? [])];
        },
        projection: (query) => (item) => {
            if (!query.fields?.includes('breadcrumbs')) {
                return {
                    ...item,
                    breadcrumbs: undefined,
                };
            }
            return item;
        },
        ...params,
    });
    if (!foldersStaticData) {
        nestifyItems(backend.values, {
            forceEmptyParentInEachLevel,
            depth,
            setDepthOnItem: (item, { depth, parent }) => {
                item.level = depth;
                if (parent) {
                    parent.childCount = (parent.childCount ?? 0) + 1;
                }
            },
        });
    }
    return backend;
};
//# sourceMappingURL=createFoldersBackend.js.map