import { Chance } from 'chance';
import { escapeRegExp, snakeCase } from 'lodash';
import { InMemoryBackend } from '../InMemoryBackend';
export function createProduct(chance, { createdAt = chance.date({
    min: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000),
    max: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
}), ...rest } = {}) {
    return {
        id: chance.guid(),
        name: chance.name(),
        description: chance.sentence(),
        price: chance.integer({ min: 0, max: 10000 }),
        img: chance.url(),
        status: chance.pickone(['available', 'outOfStock']),
        createdAt,
        updatedAt: createdAt,
        country: snakeCase(chance.country({ full: true })),
        ...rest,
    };
}
export const createProductsBackend = ({ createOne, ...params } = {}) => {
    const chance = new Chance();
    return new InMemoryBackend({
        enableTotal: params?.enableTotal,
        createOne: createOne ?? (() => createProduct(chance)),
        itemKey: (item) => item.id,
        total: 1000,
        predicate: (query) => {
            const { search } = query;
            const filters = query.filters ?? {};
            const rgx = new RegExp(escapeRegExp(search), 'i');
            return (item) => {
                if (search && !rgx.test(item.name)) {
                    return false;
                }
                if (filters.productId &&
                    filters.productId.length &&
                    filters.productId.indexOf(item.id) === -1) {
                    return false;
                }
                if (filters.status &&
                    filters.status.length &&
                    filters.status[0]?.id !== 'all' &&
                    !filters.status.some((status) => status.id === item.status)) {
                    return false;
                }
                if (item.updatedAt &&
                    filters.updatedAt?.from &&
                    filters.updatedAt.from.valueOf() > item.updatedAt.valueOf()) {
                    return false;
                }
                if (item.updatedAt &&
                    filters.updatedAt?.to &&
                    filters.updatedAt.to.valueOf() < item.updatedAt.valueOf()) {
                    return false;
                }
                if (item.country &&
                    filters.country &&
                    filters.country.length !== 0 &&
                    !filters.country.some((country) => country.id === item.country)) {
                    return false;
                }
                return true;
            };
        },
        orderBy: (query) => {
            return [...(query.sort ?? [])];
        },
        ...params,
    });
};
//# sourceMappingURL=createProductsBackend.js.map