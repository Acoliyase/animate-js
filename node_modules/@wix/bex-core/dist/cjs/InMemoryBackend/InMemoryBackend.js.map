{"version":3,"names":["_chance","require","_orderBy","_interopRequireDefault","_shuffle","_events","_core","InMemoryBackend","constructor","params","_defineProperty2","default","EventEmitter","Chance","query","fetchDataStartPromises","events","listeners","map","listener","length","Promise","all","simulateAsyncDelay","fetchDataSync","items","forEach","item","delete","itemKey","set","Map","index","values","predicate","_","Math","floor","random","available","shuffle","find","enableTotal","createOne","paginationMode","orderBy","projection","initialTotal","total","delay","min","max","excludeOrdinalFilters","newList","throwError","chance","resolve","setTimeout","integer","Array","fill","getOrderBy","ordinal","_getOrdinal","filters","allItems","orders","itemsAfterOrdering","fieldName","order","size","get","itemsAfterFiltering","filter","offset","cursor","findIndex","value","itemsAfterSlicing","slice","limit","cursorItem","itemsAfterFieldsProjection","deleteAll","isItemDeleted","emit","clear","updateMany","categoriesOrdinal","category","hashQueryKey","Object","fromEntries","entries","key","includes","has","move","moveStartPromises","from","after","array","fromKey","toKey","fromIndex","splice","toIndex","i","len","updateAll","patch","patchedItems","unshift","newItems","push","getRandomItems","count","page","pickset","undefined","exports"],"sources":["../../../src/InMemoryBackend/InMemoryBackend.ts"],"sourcesContent":["import { FiltersMap, RawFilters } from '../model';\nimport { Chance } from 'chance';\nimport orderBy from 'lodash/orderBy';\nimport shuffle from 'lodash/shuffle';\nimport { ListIteratee } from 'lodash';\nimport { EventEmitter } from 'events';\nimport { TypedEmitter } from '../util';\nimport { hashQueryKey } from 'react-query/core';\n\ninterface Order<T> {\n  fieldName: ListIteratee<T>;\n  order: 'asc' | 'desc';\n}\n\ninterface IndexedItem<T> {\n  item: T;\n  index: number;\n}\n\nexport type TransformPatch<T> = (item: T) => Partial<T>;\n\nexport interface BackendQuery<F extends FiltersMap = FiltersMap> {\n  /**\n   * Number of items to fetch for each page\n   */\n  limit: number;\n  /**\n   * The index of the item to start fetching items from.<br>\n   * Relevant for APIs that support offset pagination.<br>\n   * Not available on `CursorQuery`\n   */\n  offset?: number;\n  page?: number;\n  /**\n   * Current search term (defaults to `undefined` for empty search)\n   */\n  search?: string;\n  /**\n   * The `cursor` returned from the server, to be sent back to it in the next call.<br>\n   * Relevant for APIs that support cursor pagination.<br>\n   * Not available on `OffsetQuery`\n   */\n  cursor?: string | null;\n  /**\n   * Current state of the filters. Each key holds the value of the filter, according to its type, defined in [CollectionConfig](./?path=/story/common-hooks--usecollection).\n   */\n  filters?: RawFilters<F>;\n\n  /**\n   * Current sort applied to the collection.\n   */\n  sort?: { fieldName: string; order: 'asc' | 'desc' }[];\n\n  /**\n   * Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned.\n   */\n  fields?: string[];\n  /**\n   * Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned.\n   */\n  fieldsset?: string[];\n}\n\nexport interface Delay {\n  min: number;\n  max: number;\n}\n\ninterface SubmitParams {\n  delay?: Delay;\n  throwError?: () => unknown;\n}\n\ninterface MoveEvent<T, F extends FiltersMap> {\n  from: IndexedItem<T>;\n  after: IndexedItem<T> | null;\n  over: IndexedItem<T>;\n  filters: RawFilters<F>;\n}\n\nexport interface InMemoryBackendParams<T, F extends FiltersMap = FiltersMap> {\n  paginationMode?: 'offset' | 'cursor';\n  /**\n   * A callback function for each item creation\n   */\n  createOne: (index: number) => T;\n  /**\n   * A callback function that accepts an item and returns a unique ID of it. typically `item.id`.\n   */\n  itemKey: (item: T) => string;\n  /**\n   * A function that accepts a subset of [ComputedQuery](./?path=/story/common-types--computedquery) sent by the client and returns another function that accepts an item and should return a boolean that indicates whether the item passes the query filtering or not.\n   */\n  predicate?: (query: BackendQuery<F>) => (item: T) => boolean;\n  /**\n   * A function that accepts a subset of [ComputedQuery](./?path=/story/common-types--computedquery) sent by the client and returns another function that accepts an item and should returns a list of rules to order the items by\n   */\n  orderBy?: (query: BackendQuery<F>) => Order<T>[];\n\n  /**\n   * A function that accepts a subset of [ComputedQuery](./?path=/story/common-types--computedquery) sent by the client and returns a list of fields to project from the item\n   */\n  projection?: (query: BackendQuery<F>) => (item: T) => T;\n  /**\n   * Simulates API latency\n   * @default { min: 0, max: 5 }\n   */\n  delay?: { min: number; max: number };\n  /**\n   * Total number of items to store in the backend\n   */\n  total: number;\n  /**\n   * Enable total for the backend. Defaults to \"true\"\n   */\n  enableTotal?: boolean;\n\n  excludeOrdinalFilters?: string[];\n}\n\nexport class InMemoryBackend<T, F extends FiltersMap = FiltersMap> {\n  readonly createOne: InMemoryBackendParams<T, F>['createOne'];\n  readonly itemKey: InMemoryBackendParams<T, F>['itemKey'];\n  readonly predicate: (query: BackendQuery<F>) => (item: T) => boolean;\n  readonly orderBy?: (query: BackendQuery<F>) => Order<T>[];\n  readonly projection;\n  readonly initialTotal: number;\n  readonly delay: { min: number; max: number };\n  readonly paginationMode;\n  readonly enableTotal?: boolean;\n\n  readonly excludeOrdinalFilters;\n\n  readonly events = new EventEmitter() as TypedEmitter<{\n    updatedMany: () => void;\n    updateAll: () => void;\n    deleteAll: () => void;\n    fetchDataStart: (query: BackendQuery<F>) => void | Promise<void>;\n    moveStart: (events: MoveEvent<T, F>[]) => void | Promise<void>;\n  }>;\n\n  map: Map<string, T>;\n\n  readonly chance = new Chance();\n\n  constructor(params: InMemoryBackendParams<T, F>) {\n    this.enableTotal = params.enableTotal ?? true;\n    this.createOne = params.createOne;\n    this.itemKey = params.itemKey;\n    this.paginationMode = params.paginationMode;\n    this.predicate = params.predicate ?? (() => () => true);\n    this.orderBy = params.orderBy;\n    this.projection = params.projection;\n    this.initialTotal = params.total;\n    this.delay = params.delay ?? { min: 0, max: 5 };\n    this.excludeOrdinalFilters = params.excludeOrdinalFilters ?? [];\n    this.map = new Map<string, T>(\n      this.newList(params.total).map((item) => [this.itemKey(item), item]),\n    );\n  }\n\n  private async simulateAsyncDelay({ delay, throwError }: SubmitParams = {}) {\n    const { chance } = this;\n    await new Promise((resolve) =>\n      setTimeout(resolve, chance.integer(delay ?? this.delay)),\n    ); // simulate async\n\n    await throwError?.();\n  }\n\n  private newList(length: number) {\n    return new Array(length)\n      .fill(null)\n      .map((_, index) => this.createOne(index));\n  }\n\n  fetchDataSync(query: BackendQuery<F>) {\n    const { itemKey, predicate, orderBy: getOrderBy, paginationMode } = this;\n\n    const ordinal = this._getOrdinal(query.filters ?? {});\n\n    const allItems = this.values;\n\n    const orders = getOrderBy?.(query);\n\n    let itemsAfterOrdering;\n\n    if (orders?.length) {\n      itemsAfterOrdering = orderBy(\n        allItems,\n        orders.map(({ fieldName }) => fieldName),\n        orders.map(({ order }) => order),\n      );\n    } else if (ordinal.size) {\n      itemsAfterOrdering = orderBy(\n        allItems,\n        (item) => ordinal.get(itemKey(item)),\n        ['asc'],\n      );\n    } else {\n      itemsAfterOrdering = allItems;\n    }\n\n    const itemsAfterFiltering = itemsAfterOrdering.filter(predicate(query));\n\n    let offset;\n\n    if (paginationMode === 'cursor') {\n      offset = query.cursor\n        ? itemsAfterFiltering.findIndex(\n            (value) => itemKey(value) === query.cursor,\n          )\n        : 0;\n    } else {\n      offset = query.cursor\n        ? itemsAfterFiltering.findIndex(\n            (value) => itemKey(value) === query.cursor,\n          )\n        : query.offset ?? 0;\n    }\n\n    const itemsAfterSlicing = itemsAfterFiltering.slice(\n      offset,\n      offset + query.limit,\n    );\n\n    const cursorItem = itemsAfterFiltering[offset + query.limit] as\n      | T\n      | undefined;\n\n    const itemsAfterFieldsProjection = this.projection\n      ? itemsAfterSlicing.map(this.projection(query))\n      : itemsAfterSlicing;\n\n    return {\n      items: itemsAfterFieldsProjection,\n      ...(this.enableTotal\n        ? { total: itemsAfterFiltering.length, available: allItems.length }\n        : {}),\n      cursor: cursorItem && itemKey(cursorItem),\n    };\n  }\n\n  fetchData = async (query: BackendQuery<F>) => {\n    const fetchDataStartPromises = this.events\n      .listeners('fetchDataStart')\n      .map((listener) => listener(query));\n\n    if (fetchDataStartPromises.length) {\n      await Promise.all(fetchDataStartPromises);\n    }\n\n    await this.simulateAsyncDelay();\n    return this.fetchDataSync(query);\n  };\n\n  deleteMany = async (items: T[], params?: SubmitParams) => {\n    await this.simulateAsyncDelay(params);\n    items.forEach((item) => this.map.delete(this.itemKey(item)));\n  };\n\n  async deleteAll(\n    params: {\n      delay?: Delay;\n      throwError?: () => unknown;\n      filters?: RawFilters<F>;\n    } = {},\n  ) {\n    const { filters = {} } = params;\n\n    await this.simulateAsyncDelay(params);\n    const { predicate, itemKey } = this;\n\n    const isItemDeleted = predicate({\n      filters,\n      limit: 1,\n    });\n\n    for (const item of this.values) {\n      if (isItemDeleted(item)) {\n        this.map.delete(itemKey(item));\n      }\n    }\n\n    this.events.emit('deleteAll');\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n  update = async (item: T) => {\n    await this.simulateAsyncDelay();\n    this.map.set(this.itemKey(item), item);\n  };\n\n  async updateMany(items: T[], params: SubmitParams = {}) {\n    await this.simulateAsyncDelay(params);\n    for (const item of items) {\n      this.map.set(this.itemKey(item), item);\n    }\n    this.events.emit('updatedMany');\n  }\n  readonly categoriesOrdinal: Map<string, Map<string, number>> = new Map();\n\n  _getOrdinal(filters: RawFilters<F>) {\n    const { categoriesOrdinal, excludeOrdinalFilters } = this;\n\n    const category = hashQueryKey([\n      {\n        filters: Object.fromEntries(\n          Object.entries(filters).filter(\n            ([key]) => !excludeOrdinalFilters.includes(key),\n          ),\n        ),\n      },\n    ]);\n\n    const ordinal =\n      categoriesOrdinal.get(category) ?? new Map<string, number>();\n\n    if (!categoriesOrdinal.has(category)) {\n      categoriesOrdinal.set(category, ordinal);\n    }\n\n    return ordinal;\n  }\n\n  async move(\n    events: MoveEvent<T, F>[],\n    params: {\n      delay?: Delay;\n      throwError?: () => unknown;\n    } = {},\n  ) {\n    const { itemKey } = this;\n\n    const moveStartPromises = this.events\n      .listeners('moveStart')\n      .map((listener) => listener(events));\n\n    if (moveStartPromises.length) {\n      await Promise.all(moveStartPromises);\n    }\n\n    await this.simulateAsyncDelay(params);\n\n    for (const { from, after, filters } of events) {\n      const ordinal = this._getOrdinal(filters);\n\n      const array = ordinal.size\n        ? orderBy(this.values.slice(), (item) => ordinal.get(itemKey(item)), [\n            'asc',\n          ])\n        : this.values.slice();\n\n      const fromKey = itemKey(from.item);\n      const toKey = after != null ? itemKey(after.item) : null;\n\n      const fromIndex = array.findIndex((item) => fromKey === itemKey(item));\n      if (fromIndex !== -1) {\n        array.splice(fromIndex, 1);\n      }\n\n      if (toKey != null) {\n        const toIndex = array.findIndex((item) => toKey === itemKey(item));\n        if (toIndex !== -1) {\n          array.splice(toIndex + 1, 0, from.item);\n        }\n      } else {\n        array.splice(0, 0, from.item);\n      }\n\n      ordinal.clear();\n      for (let i = 0, len = array.length; i < len; i++) {\n        ordinal.set(itemKey(array[i]), i);\n      }\n    }\n  }\n\n  async updateAll(\n    patch: TransformPatch<T>,\n    params: {\n      delay?: Delay;\n      throwError?: () => unknown;\n      filters?: RawFilters<F>;\n    } = {},\n  ) {\n    const { filters = {} } = params;\n\n    await this.simulateAsyncDelay(params);\n    const { predicate } = this;\n\n    const itemsAfterFiltering = this.values.filter(\n      predicate({\n        filters,\n        limit: 1,\n      }),\n    );\n\n    const patchedItems = itemsAfterFiltering.map((value) => ({\n      ...value,\n      ...patch(value),\n    }));\n\n    for (const item of patchedItems) {\n      this.map.set(this.itemKey(item), item);\n    }\n\n    this.events.emit('updateAll');\n  }\n\n  async unshift(newItems: T[]) {\n    await this.simulateAsyncDelay();\n    const map = new Map<string, T>();\n\n    for (const item of newItems) {\n      map.set(this.itemKey(item), item);\n    }\n\n    for (const [key, value] of Array.from(this.map.entries())) {\n      map.set(key, value);\n    }\n\n    this.map = map;\n  }\n\n  async push(newItems: T[]) {\n    await this.simulateAsyncDelay();\n\n    for (const item of newItems) {\n      this.map.set(this.itemKey(item), item);\n    }\n  }\n\n  elementAt = (index: number) => this.values[index];\n\n  getRandomItems(\n    count: number,\n    { limit, page }: { limit: number; page: number },\n  ) {\n    const { chance, values } = this;\n    const offset = (page - 1) * limit;\n    return chance.pickset(values.slice(offset, offset + limit), count);\n  }\n\n  randomItem = (predicate = (_: T) => true) => {\n    const index = Math.floor(Math.random() * this.available);\n    return {\n      index,\n      item: shuffle(this.values).find(predicate),\n    };\n  };\n\n  get values() {\n    return Array.from(this.map.values());\n  }\n\n  get available() {\n    return this.map.size;\n  }\n\n  get(key?: string): T | undefined {\n    if (key == null) {\n      return undefined;\n    }\n    return this.map.get(key);\n  }\n}\n"],"mappings":";;;;;;AACA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAC,sBAAA,CAAAF,OAAA;AACA,IAAAG,QAAA,GAAAD,sBAAA,CAAAF,OAAA;AAEA,IAAAI,OAAA,GAAAJ,OAAA;AAEA,IAAAK,KAAA,GAAAL,OAAA;AAiHO,MAAMM,eAAe,CAAuC;EAyBjEC,WAAWA,CAACC,OAAmC,EAAE;IAAA,IAAAC,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA,kBAZ/B,IAAIC,oBAAY,CAAC,CAAC;IAAA,IAAAF,gBAAA,CAAAC,OAAA;IAAA,IAAAD,gBAAA,CAAAC,OAAA,kBAUlB,IAAIE,cAAM,CAAC,CAAC;IAAA,IAAAH,gBAAA,CAAAC,OAAA,qBAoGlB,MAAOG,KAAsB,IAAK;MAC5C,MAAMC,sBAAsB,GAAG,IAAI,CAACC,MAAM,CACvCC,SAAS,CAAC,gBAAgB,CAAC,CAC3BC,GAAG,CAAEC,QAAQ,IAAKA,QAAQ,CAACL,KAAK,CAAC,CAAC;MAErC,IAAIC,sBAAsB,CAACK,MAAM,EAAE;QACjC,MAAMC,OAAO,CAACC,GAAG,CAACP,sBAAsB,CAAC;MAC3C;MAEA,MAAM,IAAI,CAACQ,kBAAkB,CAAC,CAAC;MAC/B,OAAO,IAAI,CAACC,aAAa,CAACV,KAAK,CAAC;IAClC,CAAC;IAAA,IAAAJ,gBAAA,CAAAC,OAAA,sBAEY,OAAOc,KAAU,EAAEhB,MAAqB,KAAK;MACxD,MAAM,IAAI,CAACc,kBAAkB,CAACd,MAAM,CAAC;MACrCgB,KAAK,CAACC,OAAO,CAAEC,IAAI,IAAK,IAAI,CAACT,GAAG,CAACU,MAAM,CAAC,IAAI,CAACC,OAAO,CAACF,IAAI,CAAC,CAAC,CAAC;IAC9D,CAAC;IAAA,IAAAjB,gBAAA,CAAAC,OAAA,kBAgCQ,MAAOgB,IAAO,IAAK;MAC1B,MAAM,IAAI,CAACJ,kBAAkB,CAAC,CAAC;MAC/B,IAAI,CAACL,GAAG,CAACY,GAAG,CAAC,IAAI,CAACD,OAAO,CAACF,IAAI,CAAC,EAAEA,IAAI,CAAC;IACxC,CAAC;IAAA,IAAAjB,gBAAA,CAAAC,OAAA,6BAS8D,IAAIoB,GAAG,CAAC,CAAC;IAAA,IAAArB,gBAAA,CAAAC,OAAA,qBAoI3DqB,KAAa,IAAK,IAAI,CAACC,MAAM,CAACD,KAAK,CAAC;IAAA,IAAAtB,gBAAA,CAAAC,OAAA,sBAWpC,CAACuB,SAAS,GAAIC,CAAI,IAAK,IAAI,KAAK;MAC3C,MAAMH,KAAK,GAAGI,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,IAAI,CAACC,SAAS,CAAC;MACxD,OAAO;QACLP,KAAK;QACLL,IAAI,EAAE,IAAAa,gBAAO,EAAC,IAAI,CAACP,MAAM,CAAC,CAACQ,IAAI,CAACP,SAAS;MAC3C,CAAC;IACH,CAAC;IAlTC,IAAI,CAACQ,WAAW,GAAGjC,OAAM,CAACiC,WAAW,IAAI,IAAI;IAC7C,IAAI,CAACC,SAAS,GAAGlC,OAAM,CAACkC,SAAS;IACjC,IAAI,CAACd,OAAO,GAAGpB,OAAM,CAACoB,OAAO;IAC7B,IAAI,CAACe,cAAc,GAAGnC,OAAM,CAACmC,cAAc;IAC3C,IAAI,CAACV,SAAS,GAAGzB,OAAM,CAACyB,SAAS,KAAK,MAAM,MAAM,IAAI,CAAC;IACvD,IAAI,CAACW,OAAO,GAAGpC,OAAM,CAACoC,OAAO;IAC7B,IAAI,CAACC,UAAU,GAAGrC,OAAM,CAACqC,UAAU;IACnC,IAAI,CAACC,YAAY,GAAGtC,OAAM,CAACuC,KAAK;IAChC,IAAI,CAACC,KAAK,GAAGxC,OAAM,CAACwC,KAAK,IAAI;MAAEC,GAAG,EAAE,CAAC;MAAEC,GAAG,EAAE;IAAE,CAAC;IAC/C,IAAI,CAACC,qBAAqB,GAAG3C,OAAM,CAAC2C,qBAAqB,IAAI,EAAE;IAC/D,IAAI,CAAClC,GAAG,GAAG,IAAIa,GAAG,CAChB,IAAI,CAACsB,OAAO,CAAC5C,OAAM,CAACuC,KAAK,CAAC,CAAC9B,GAAG,CAAES,IAAI,IAAK,CAAC,IAAI,CAACE,OAAO,CAACF,IAAI,CAAC,EAAEA,IAAI,CAAC,CACrE,CAAC;EACH;EAEA,MAAcJ,kBAAkBA,CAAC;IAAE0B,KAAK;IAAEK;EAAyB,CAAC,GAAG,CAAC,CAAC,EAAE;IACzE,MAAM;MAAEC;IAAO,CAAC,GAAG,IAAI;IACvB,MAAM,IAAIlC,OAAO,CAAEmC,OAAO,IACxBC,UAAU,CAACD,OAAO,EAAED,MAAM,CAACG,OAAO,CAACT,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC,CACzD,CAAC,CAAC,CAAC;;IAEH,OAAMK,UAAU,oBAAVA,UAAU,CAAG,CAAC;EACtB;EAEQD,OAAOA,CAACjC,MAAc,EAAE;IAC9B,OAAO,IAAIuC,KAAK,CAACvC,MAAM,CAAC,CACrBwC,IAAI,CAAC,IAAI,CAAC,CACV1C,GAAG,CAAC,CAACiB,CAAC,EAAEH,KAAK,KAAK,IAAI,CAACW,SAAS,CAACX,KAAK,CAAC,CAAC;EAC7C;EAEAR,aAAaA,CAACV,KAAsB,EAAE;IACpC,MAAM;MAAEe,OAAO;MAAEK,SAAS;MAAEW,OAAO,EAAEgB,UAAU;MAAEjB;IAAe,CAAC,GAAG,IAAI;IAExE,MAAMkB,OAAO,GAAG,IAAI,CAACC,WAAW,CAACjD,KAAK,CAACkD,OAAO,IAAI,CAAC,CAAC,CAAC;IAErD,MAAMC,QAAQ,GAAG,IAAI,CAAChC,MAAM;IAE5B,MAAMiC,MAAM,GAAGL,UAAU,oBAAVA,UAAU,CAAG/C,KAAK,CAAC;IAElC,IAAIqD,kBAAkB;IAEtB,IAAID,MAAM,YAANA,MAAM,CAAE9C,MAAM,EAAE;MAClB+C,kBAAkB,GAAG,IAAAtB,gBAAO,EAC1BoB,QAAQ,EACRC,MAAM,CAAChD,GAAG,CAAC,CAAC;QAAEkD;MAAU,CAAC,KAAKA,SAAS,CAAC,EACxCF,MAAM,CAAChD,GAAG,CAAC,CAAC;QAAEmD;MAAM,CAAC,KAAKA,KAAK,CACjC,CAAC;IACH,CAAC,MAAM,IAAIP,OAAO,CAACQ,IAAI,EAAE;MACvBH,kBAAkB,GAAG,IAAAtB,gBAAO,EAC1BoB,QAAQ,EACPtC,IAAI,IAAKmC,OAAO,CAACS,GAAG,CAAC1C,OAAO,CAACF,IAAI,CAAC,CAAC,EACpC,CAAC,KAAK,CACR,CAAC;IACH,CAAC,MAAM;MACLwC,kBAAkB,GAAGF,QAAQ;IAC/B;IAEA,MAAMO,mBAAmB,GAAGL,kBAAkB,CAACM,MAAM,CAACvC,SAAS,CAACpB,KAAK,CAAC,CAAC;IAEvE,IAAI4D,MAAM;IAEV,IAAI9B,cAAc,KAAK,QAAQ,EAAE;MAC/B8B,MAAM,GAAG5D,KAAK,CAAC6D,MAAM,GACjBH,mBAAmB,CAACI,SAAS,CAC1BC,KAAK,IAAKhD,OAAO,CAACgD,KAAK,CAAC,KAAK/D,KAAK,CAAC6D,MACtC,CAAC,GACD,CAAC;IACP,CAAC,MAAM;MACLD,MAAM,GAAG5D,KAAK,CAAC6D,MAAM,GACjBH,mBAAmB,CAACI,SAAS,CAC1BC,KAAK,IAAKhD,OAAO,CAACgD,KAAK,CAAC,KAAK/D,KAAK,CAAC6D,MACtC,CAAC,GACD7D,KAAK,CAAC4D,MAAM,IAAI,CAAC;IACvB;IAEA,MAAMI,iBAAiB,GAAGN,mBAAmB,CAACO,KAAK,CACjDL,MAAM,EACNA,MAAM,GAAG5D,KAAK,CAACkE,KACjB,CAAC;IAED,MAAMC,UAAU,GAAGT,mBAAmB,CAACE,MAAM,GAAG5D,KAAK,CAACkE,KAAK,CAE9C;IAEb,MAAME,0BAA0B,GAAG,IAAI,CAACpC,UAAU,GAC9CgC,iBAAiB,CAAC5D,GAAG,CAAC,IAAI,CAAC4B,UAAU,CAAChC,KAAK,CAAC,CAAC,GAC7CgE,iBAAiB;IAErB,OAAO;MACLrD,KAAK,EAAEyD,0BAA0B;MACjC,IAAI,IAAI,CAACxC,WAAW,GAChB;QAAEM,KAAK,EAAEwB,mBAAmB,CAACpD,MAAM;QAAEmB,SAAS,EAAE0B,QAAQ,CAAC7C;MAAO,CAAC,GACjE,CAAC,CAAC,CAAC;MACPuD,MAAM,EAAEM,UAAU,IAAIpD,OAAO,CAACoD,UAAU;IAC1C,CAAC;EACH;EAoBA,MAAME,SAASA,CACb1E,MAIC,GAAG,CAAC,CAAC,EACN;IACA,MAAM;MAAEuD,OAAO,GAAG,CAAC;IAAE,CAAC,GAAGvD,MAAM;IAE/B,MAAM,IAAI,CAACc,kBAAkB,CAACd,MAAM,CAAC;IACrC,MAAM;MAAEyB,SAAS;MAAEL;IAAQ,CAAC,GAAG,IAAI;IAEnC,MAAMuD,aAAa,GAAGlD,SAAS,CAAC;MAC9B8B,OAAO;MACPgB,KAAK,EAAE;IACT,CAAC,CAAC;IAEF,KAAK,MAAMrD,IAAI,IAAI,IAAI,CAACM,MAAM,EAAE;MAC9B,IAAImD,aAAa,CAACzD,IAAI,CAAC,EAAE;QACvB,IAAI,CAACT,GAAG,CAACU,MAAM,CAACC,OAAO,CAACF,IAAI,CAAC,CAAC;MAChC;IACF;IAEA,IAAI,CAACX,MAAM,CAACqE,IAAI,CAAC,WAAW,CAAC;EAC/B;EAEAC,KAAKA,CAAA,EAAG;IACN,IAAI,CAACpE,GAAG,CAACoE,KAAK,CAAC,CAAC;EAClB;EAOA,MAAMC,UAAUA,CAAC9D,KAAU,EAAEhB,MAAoB,GAAG,CAAC,CAAC,EAAE;IACtD,MAAM,IAAI,CAACc,kBAAkB,CAACd,MAAM,CAAC;IACrC,KAAK,MAAMkB,IAAI,IAAIF,KAAK,EAAE;MACxB,IAAI,CAACP,GAAG,CAACY,GAAG,CAAC,IAAI,CAACD,OAAO,CAACF,IAAI,CAAC,EAAEA,IAAI,CAAC;IACxC;IACA,IAAI,CAACX,MAAM,CAACqE,IAAI,CAAC,aAAa,CAAC;EACjC;EAGAtB,WAAWA,CAACC,OAAsB,EAAE;IAClC,MAAM;MAAEwB,iBAAiB;MAAEpC;IAAsB,CAAC,GAAG,IAAI;IAEzD,MAAMqC,QAAQ,GAAG,IAAAC,kBAAY,EAAC,CAC5B;MACE1B,OAAO,EAAE2B,MAAM,CAACC,WAAW,CACzBD,MAAM,CAACE,OAAO,CAAC7B,OAAO,CAAC,CAACS,MAAM,CAC5B,CAAC,CAACqB,GAAG,CAAC,KAAK,CAAC1C,qBAAqB,CAAC2C,QAAQ,CAACD,GAAG,CAChD,CACF;IACF,CAAC,CACF,CAAC;IAEF,MAAMhC,OAAO,GACX0B,iBAAiB,CAACjB,GAAG,CAACkB,QAAQ,CAAC,IAAI,IAAI1D,GAAG,CAAiB,CAAC;IAE9D,IAAI,CAACyD,iBAAiB,CAACQ,GAAG,CAACP,QAAQ,CAAC,EAAE;MACpCD,iBAAiB,CAAC1D,GAAG,CAAC2D,QAAQ,EAAE3B,OAAO,CAAC;IAC1C;IAEA,OAAOA,OAAO;EAChB;EAEA,MAAMmC,IAAIA,CACRjF,MAAyB,EACzBP,MAGC,GAAG,CAAC,CAAC,EACN;IACA,MAAM;MAAEoB;IAAQ,CAAC,GAAG,IAAI;IAExB,MAAMqE,iBAAiB,GAAG,IAAI,CAAClF,MAAM,CAClCC,SAAS,CAAC,WAAW,CAAC,CACtBC,GAAG,CAAEC,QAAQ,IAAKA,QAAQ,CAACH,MAAM,CAAC,CAAC;IAEtC,IAAIkF,iBAAiB,CAAC9E,MAAM,EAAE;MAC5B,MAAMC,OAAO,CAACC,GAAG,CAAC4E,iBAAiB,CAAC;IACtC;IAEA,MAAM,IAAI,CAAC3E,kBAAkB,CAACd,MAAM,CAAC;IAErC,KAAK,MAAM;MAAE0F,IAAI;MAAEC,KAAK;MAAEpC;IAAQ,CAAC,IAAIhD,MAAM,EAAE;MAC7C,MAAM8C,OAAO,GAAG,IAAI,CAACC,WAAW,CAACC,OAAO,CAAC;MAEzC,MAAMqC,KAAK,GAAGvC,OAAO,CAACQ,IAAI,GACtB,IAAAzB,gBAAO,EAAC,IAAI,CAACZ,MAAM,CAAC8C,KAAK,CAAC,CAAC,EAAGpD,IAAI,IAAKmC,OAAO,CAACS,GAAG,CAAC1C,OAAO,CAACF,IAAI,CAAC,CAAC,EAAE,CACjE,KAAK,CACN,CAAC,GACF,IAAI,CAACM,MAAM,CAAC8C,KAAK,CAAC,CAAC;MAEvB,MAAMuB,OAAO,GAAGzE,OAAO,CAACsE,IAAI,CAACxE,IAAI,CAAC;MAClC,MAAM4E,KAAK,GAAGH,KAAK,IAAI,IAAI,GAAGvE,OAAO,CAACuE,KAAK,CAACzE,IAAI,CAAC,GAAG,IAAI;MAExD,MAAM6E,SAAS,GAAGH,KAAK,CAACzB,SAAS,CAAEjD,IAAI,IAAK2E,OAAO,KAAKzE,OAAO,CAACF,IAAI,CAAC,CAAC;MACtE,IAAI6E,SAAS,KAAK,CAAC,CAAC,EAAE;QACpBH,KAAK,CAACI,MAAM,CAACD,SAAS,EAAE,CAAC,CAAC;MAC5B;MAEA,IAAID,KAAK,IAAI,IAAI,EAAE;QACjB,MAAMG,OAAO,GAAGL,KAAK,CAACzB,SAAS,CAAEjD,IAAI,IAAK4E,KAAK,KAAK1E,OAAO,CAACF,IAAI,CAAC,CAAC;QAClE,IAAI+E,OAAO,KAAK,CAAC,CAAC,EAAE;UAClBL,KAAK,CAACI,MAAM,CAACC,OAAO,GAAG,CAAC,EAAE,CAAC,EAAEP,IAAI,CAACxE,IAAI,CAAC;QACzC;MACF,CAAC,MAAM;QACL0E,KAAK,CAACI,MAAM,CAAC,CAAC,EAAE,CAAC,EAAEN,IAAI,CAACxE,IAAI,CAAC;MAC/B;MAEAmC,OAAO,CAACwB,KAAK,CAAC,CAAC;MACf,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGP,KAAK,CAACjF,MAAM,EAAEuF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAChD7C,OAAO,CAAChC,GAAG,CAACD,OAAO,CAACwE,KAAK,CAACM,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC;MACnC;IACF;EACF;EAEA,MAAME,SAASA,CACbC,KAAwB,EACxBrG,MAIC,GAAG,CAAC,CAAC,EACN;IACA,MAAM;MAAEuD,OAAO,GAAG,CAAC;IAAE,CAAC,GAAGvD,MAAM;IAE/B,MAAM,IAAI,CAACc,kBAAkB,CAACd,MAAM,CAAC;IACrC,MAAM;MAAEyB;IAAU,CAAC,GAAG,IAAI;IAE1B,MAAMsC,mBAAmB,GAAG,IAAI,CAACvC,MAAM,CAACwC,MAAM,CAC5CvC,SAAS,CAAC;MACR8B,OAAO;MACPgB,KAAK,EAAE;IACT,CAAC,CACH,CAAC;IAED,MAAM+B,YAAY,GAAGvC,mBAAmB,CAACtD,GAAG,CAAE2D,KAAK,KAAM;MACvD,GAAGA,KAAK;MACR,GAAGiC,KAAK,CAACjC,KAAK;IAChB,CAAC,CAAC,CAAC;IAEH,KAAK,MAAMlD,IAAI,IAAIoF,YAAY,EAAE;MAC/B,IAAI,CAAC7F,GAAG,CAACY,GAAG,CAAC,IAAI,CAACD,OAAO,CAACF,IAAI,CAAC,EAAEA,IAAI,CAAC;IACxC;IAEA,IAAI,CAACX,MAAM,CAACqE,IAAI,CAAC,WAAW,CAAC;EAC/B;EAEA,MAAM2B,OAAOA,CAACC,QAAa,EAAE;IAC3B,MAAM,IAAI,CAAC1F,kBAAkB,CAAC,CAAC;IAC/B,MAAML,GAAG,GAAG,IAAIa,GAAG,CAAY,CAAC;IAEhC,KAAK,MAAMJ,IAAI,IAAIsF,QAAQ,EAAE;MAC3B/F,GAAG,CAACY,GAAG,CAAC,IAAI,CAACD,OAAO,CAACF,IAAI,CAAC,EAAEA,IAAI,CAAC;IACnC;IAEA,KAAK,MAAM,CAACmE,GAAG,EAAEjB,KAAK,CAAC,IAAIlB,KAAK,CAACwC,IAAI,CAAC,IAAI,CAACjF,GAAG,CAAC2E,OAAO,CAAC,CAAC,CAAC,EAAE;MACzD3E,GAAG,CAACY,GAAG,CAACgE,GAAG,EAAEjB,KAAK,CAAC;IACrB;IAEA,IAAI,CAAC3D,GAAG,GAAGA,GAAG;EAChB;EAEA,MAAMgG,IAAIA,CAACD,QAAa,EAAE;IACxB,MAAM,IAAI,CAAC1F,kBAAkB,CAAC,CAAC;IAE/B,KAAK,MAAMI,IAAI,IAAIsF,QAAQ,EAAE;MAC3B,IAAI,CAAC/F,GAAG,CAACY,GAAG,CAAC,IAAI,CAACD,OAAO,CAACF,IAAI,CAAC,EAAEA,IAAI,CAAC;IACxC;EACF;EAIAwF,cAAcA,CACZC,KAAa,EACb;IAAEpC,KAAK;IAAEqC;EAAsC,CAAC,EAChD;IACA,MAAM;MAAE9D,MAAM;MAAEtB;IAAO,CAAC,GAAG,IAAI;IAC/B,MAAMyC,MAAM,GAAG,CAAC2C,IAAI,GAAG,CAAC,IAAIrC,KAAK;IACjC,OAAOzB,MAAM,CAAC+D,OAAO,CAACrF,MAAM,CAAC8C,KAAK,CAACL,MAAM,EAAEA,MAAM,GAAGM,KAAK,CAAC,EAAEoC,KAAK,CAAC;EACpE;EAUA,IAAInF,MAAMA,CAAA,EAAG;IACX,OAAO0B,KAAK,CAACwC,IAAI,CAAC,IAAI,CAACjF,GAAG,CAACe,MAAM,CAAC,CAAC,CAAC;EACtC;EAEA,IAAIM,SAASA,CAAA,EAAG;IACd,OAAO,IAAI,CAACrB,GAAG,CAACoD,IAAI;EACtB;EAEAC,GAAGA,CAACuB,GAAY,EAAiB;IAC/B,IAAIA,GAAG,IAAI,IAAI,EAAE;MACf,OAAOyB,SAAS;IAClB;IACA,OAAO,IAAI,CAACrG,GAAG,CAACqD,GAAG,CAACuB,GAAG,CAAC;EAC1B;AACF;AAAC0B,OAAA,CAAAjH,eAAA,GAAAA,eAAA","ignoreList":[]}