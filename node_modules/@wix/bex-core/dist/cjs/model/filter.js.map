{"version":3,"names":[],"sources":["../../../src/model/filter.ts"],"sourcesContent":["import { TypedEmitter } from '../util';\n\n/*\nchange - whenever we want to notify that the value was changed, for additional side effects, i.e BI events. For example, when initializing the value, we don't want to emit this event.\nrefresh - the collection should be refreshed as a result of this change\nscheduleRefresh - the collection should schedule a refresh as a result of this change\n */\ntype FilterEvent = 'change' | 'refresh' | 'scheduleRefresh' | 'beforeRefresh';\n\nexport interface ChangeValueOptions {\n  emitEvents?: FilterEvent[];\n  clearResult?: boolean;\n  actionType?: 'add' | 'remove';\n  clickedValueKey?: string;\n}\n\nexport type FilterItem<T> = T extends (infer V)[] ? V : T;\n\nexport interface FilterEventOptions {\n  clearResult?: boolean;\n  actionType?: 'add' | 'remove';\n  clickedValueKey?: string;\n}\n\ninterface FilterEventsSchema {\n  refresh: (opt: FilterEventOptions | undefined) => unknown;\n  beforeRefresh: (opt: FilterEventOptions | undefined) => unknown;\n  change: (opt?: FilterEventOptions) => unknown;\n  scheduleRefresh: (opt?: FilterEventOptions) => unknown;\n}\n\nexport type FilterEvents = TypedEmitter<FilterEventsSchema>;\n\nexport interface Filter<T> {\n  events: TypedEmitter<FilterEventsSchema>;\n  name: string;\n  persistent?: boolean;\n  readonly value: T;\n  readonly toArray: FilterItem<T>[];\n  readonly _toArray: (value: T) => FilterItem<T>[];\n  readonly isEmpty: boolean;\n  readonly toQueryString: string;\n  readonly decode: (value: unknown) => T;\n  readonly encode: (value: T) => unknown;\n  readonly size: number;\n  readonly itemKey: (item: FilterItem<T>) => string;\n  readonly itemName: (item: FilterItem<T>) => string;\n  readonly matches: (item: FilterItem<T>, value: T) => boolean;\n  readonly equals?: (item1: FilterItem<T>, item2: FilterItem<T>) => boolean;\n  readonly isCustomField?: boolean;\n\n  applyFromQueryString(str: string): void;\n  setValue(value: T, options?: ChangeValueOptions): void;\n  changeValue(value: T, options?: ChangeValueOptions): void;\n  refresh(value: T, options?: ChangeValueOptions): void;\n  scheduleRefresh(value: T): void;\n  reset(options?: ChangeValueOptions): void;\n  remove(items: FilterItem<T>[], options?: ChangeValueOptions): void;\n  clone(...args: any[]): Filter<T>;\n  hasDiff(items: T): boolean;\n  _hideFromToolbar?: boolean;\n}\n\nexport interface FilterStateBaseParams<T> {\n  name?: string;\n  /**\n   * Marks the filter as a \"context\" or \"scope\" filter. This makes the filter not be visible in the sub-toolbar tag list, not saved in views, not counted as \"X filters applied\".\n   * @external\n   */\n  persistent?: boolean;\n  /**\n   * The value to initialize the filter with (Optional)\n   * @external\n   */\n  initialValue?: T;\n\n  /**\n   * A callback function that accepts an item and returns a unique ID of it. typically `item.id`.\n   * @external\n   */\n  itemKey: (item: FilterItem<T>) => string;\n  /**\n   * A callback function that accepts an item and returns the item name which is used in many messages through cairo\n   * @external\n   */\n  itemName: (item: FilterItem<T>) => string;\n\n  /**\n   * A function which accepts 2 items and returns true if they are equal\n   * @external\n   */\n  equals?: (item1: FilterItem<T>, item2: FilterItem<T>) => boolean;\n  /**\n   * If the filter is a custom field\n   */\n  isCustomField?: boolean;\n}\n\nexport type FiltersMap = { [key: string]: Filter<any> | undefined };\nexport type OptionalFiltersMap = { [key: string]: undefined };\n"],"mappings":"","ignoreList":[]}