{"version":3,"names":[],"sources":["../../../src/hooks/collectionConfig.ts"],"sourcesContent":["import {\n  CollectionEvents,\n  ComputedQuery,\n  DataResultRaw,\n  Filter,\n  FiltersMap,\n  QueryOptions,\n} from '../model';\nimport type { ExtendedFields } from '../services';\nimport type { FetchTotalFn } from './paginationModeConfig';\n\nexport interface CollectionConfigBase<T, F extends FiltersMap> {\n  /**\n   * Whether to disable \"Select All\" server simulation for bulk selection.\n   * @external\n   */\n  disableAutoSelectAllCount?: boolean;\n  /**\n   * Whether to enable new \"Select All\" logic.\n   * <br> <br>\n   * If `true`: <br>\n   * - Unchecking items after checking \"Select All\" does not fallback to specific selection logic and values. This means in `<bulkActionToolbar />` and `<MultiBulkActionToolbar />`, \"Total Selected\" will show `total - unchecked items` and `isSelectAll` will be true. <br>\n   * - You will receive a list of unchecked IDs.\n   * @external\n   */\n  useNewSelectAllLogic?: boolean;\n  /**\n   * Unique value for each API endpoint consumed in `fetchData`.\n   * @external\n   */\n  queryName: string;\n\n  /**\n   * Entity fqdn.\n   * @external\n   */\n  fqdn?: string;\n\n  /**\n   * The `ExtendedFields` object used to render custom field values\n   * Optional in case your data complies to the type `{ extendedFields: ExtendedFields }`\n   */\n  toExtendedFields?: (item: T) => ExtendedFields | undefined | null;\n\n  /**\n   * Message shown in a toast when fetching from the server fails.\n   * <br> <br>\n   * If the function returns a nullish value, no toast is shown.\n   * @external\n   * @deprecated Instead of using `fetchErrorMessage`, use `errorState` prop in the component, which will show the error message in the card.\n   */\n  fetchErrorMessage?: (params: {\n    err: unknown;\n    isOnline: boolean;\n  }) => string | null | undefined;\n\n  search?: Filter<string>;\n  queryOptions?: QueryOptions;\n  /**\n   * Persist the selected filters, search & sort in the query parameters of the URL.<br/>\n   * For improved readability, sort & columns are formatted in CSV-like formatting, i.e \"?sort=name+desc,price+asc\". Do not use commas and/or spaces for your columns IDs.<br>\n   * Note: The filters from the selected view will be persist, but the actual view will not be selected\n   * @default false\n   */\n  persistQueryToUrl?: boolean;\n  /**\n   * Whether the collection refreshes when different columns are selected.\n   * <br> <br>\n   * Selected columns are passed in `fetchData(query.columns)`.\n   * @default false\n   * @external\n   */\n  refreshOnColumnsChange?: boolean;\n  initialPage?: DataResultRaw<T>;\n  deferInitialLoading?: boolean;\n\n  /**\n   * Preserve or clear selection after applying a new search or filter.\n   * @default preserve\n   * @external\n   */\n  selectionConsistencyMode?: 'preserve' | 'clear';\n  /**\n   * Optional callbacks for various events of the collection state lifecycle\n   * - `onInitialPageFetched` - when the first page of items is ready\n   * - `onSearch` - when fetching new items as a result new search\n   * - `onSearchResults` - when the result of a search is ready\n   * - `onNewPageStart` - when starting to load the next page of items\n   * - `onNewPageAdded` - when the result of the next page is ready\n   * - `onError` - When `fetchData` throws an error. Return `true` from this function if the error was reported and shouldn't be reported again internally.\n   */\n  events?: CollectionEvents<F>;\n}\n\nexport interface CollectionConfigAnyPaginationMode<T, F extends FiltersMap>\n  extends CollectionConfigBase<T, F> {\n  /**\n   * Function that fetches the collection data.<br> <br>\n   * Supported parameters: <br>\n   * - `query`: [object] [ComputedQuery](./com?path=/story/common-models--computedquery) instance.\n   * <br> <br>\n   *\n   * Must return a [DataResultRaw](./?path=/story/common-models--dataresultraw) Promise.\n   * @external\n   */\n  fetchData: (query: ComputedQuery<F>) => Promise<DataResultRaw<T>>;\n  /**\n   * A function that fetches the total number of items in the collection.<br> <br>\n   * Supported parameters: <br>\n   * - `query`: [object] [ComputedQuery](./com?path=/story/common-models--computedquery) of type `CursorQuery`.\n   * <br> <br>\n   * Must return a number Promise.\n   * @external\n   */\n  fetchTotal?: FetchTotalFn;\n  /**\n   * Defines the filters that the collection supports.\n   * <br> <br>\n   * Either an [arrayFilter](./?path=/story/features-filter-factories--arrayfilter) or a [customFilter](./?path=/story/features-filter-factories--customfilter).\n   * @external\n   */\n  filters: F;\n  /**\n   * Used to identify the item in many messages from Wix Patterns.\n   * <br> <br>\n   * For example, '{entity} \"{itemName}\" was deleted successfully' may become 'Contact \"Johnny Doe\" was deleted successfully'.\n   * <br> <br>\n   * If your data has an ID, then `itemKey` will default to this ID.\n   * @external\n   */\n  itemName: (item: T) => string;\n  /**\n   * Unique key within the collection. The item's ID is often used for its key.\n   * <br> <br>\n   * If your data has an ID, then `itemKey` will default to this ID.\n   * @external\n   */\n  itemKey: (item: T) => string;\n  /**\n   * Maximum number of items fetched per page.\n   * @external\n   */\n  limit?: number;\n}\n\nexport interface CollectionConfig<T, F extends FiltersMap>\n  extends CollectionConfigAnyPaginationMode<T, F> {\n  /**\n   * Pagination type supported by `fetchData`.\n   * <br> <br>\n   * Supported values: <br>\n   * - `\"offset\"`: Server accepts `query.offset`. <br>\n   * - `\"cursor\"`: Server returns a cursor when `fetchData` is called.\n   * @default offset\n   * @external\n   */\n  paginationMode?: 'cursor' | 'offset';\n}\n"],"mappings":"","ignoreList":[]}