"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.QueryPendingState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mobx = require("mobx");
var _ConditionalModalState = require("./ConditionalModalState");
var _QueryPendingStateBIReporter = require("./QueryPendingStateBIReporter");
function createPendingFilter(origin) {
  return {
    origin,
    pending: origin.clone()
  };
}
class QueryPendingState {
  get multi() {
    return this.toolbar.multi;
  }
  get toolbarFiltersState() {
    return this.toolbar.toolbarFiltersState;
  }
  constructor(params) {
    (0, _defineProperty2.default)(this, "filters", void 0);
    (0, _defineProperty2.default)(this, "container", void 0);
    (0, _defineProperty2.default)(this, "toolbar", void 0);
    (0, _defineProperty2.default)(this, "discardChangesModal", new _ConditionalModalState.ConditionalModalState());
    (0, _defineProperty2.default)(this, "bi", void 0);
    (0, _defineProperty2.default)(this, "shouldTrackFilter", () => {
      var _this$toolbarFiltersS;
      const panelFilters = (_this$toolbarFiltersS = this.toolbarFiltersState) == null ? void 0 : _this$toolbarFiltersS.panelFilters;
      return ({
        origin
      }) => origin != null && (panelFilters == null ? void 0 : panelFilters.includes(origin));
    });
    this.container = params.container;
    this.toolbar = params.toolbar;
    const allFilters = this.multi.collections.reduce((filters, {
      query
    }) => {
      const {
        search,
        ...queryFilters
      } = query.filters;
      return {
        ...filters,
        ...queryFilters
      };
    }, {});
    this.filters = Object.values(allFilters).filter(filter => filter != null).map(createPendingFilter);
    this.bi = new _QueryPendingStateBIReporter.QueryPendingStateBIReporter(this);
    (0, _mobx.makeObservable)(this, {
      apply: _mobx.action,
      revert: _mobx.action,
      clearSelected: _mobx.action,
      getApplicableFilter: _mobx.action,
      hasChanged: _mobx.computed,
      trackedFilters: _mobx.computed,
      trackedFiltersCount: _mobx.computed
    });
  }
  get trackedFilters() {
    return this.filters.filter(this.shouldTrackFilter());
  }
  get trackedFiltersCount() {
    return this.trackedFilters.reduce((size, {
      pending
    }) => size + pending.size, 0);
  }
  async onCloseFiltersPanelClick() {
    if (!this.hasChanged) {
      return;
    }
    this.discardChangesModal.open(null);
    const {
      result
    } = await this.discardChangesModal.modal.promise();
    if (result === 'confirmed') {
      this.bi.discard();
      this.revert();
    } else if (result === 'declined') {
      this.apply();
    }
    return result;
  }
  getApplicableFilter(filter) {
    var _this$trackedFilters$;
    return ((_this$trackedFilters$ = this.trackedFilters.find(({
      origin
    }) => origin === filter)) == null ? void 0 : _this$trackedFilters$.pending) ?? filter;
  }
  revert() {
    this.trackedFilters.forEach(({
      pending,
      origin
    }) => {
      pending.setValue(origin.value);
    });
  }
  apply() {
    this.bi.apply();
    this.trackedFilters.forEach(({
      pending,
      origin
    }) => {
      origin.setValue(pending.value);
    });
    this.multi.collections.forEach(collection => {
      collection.clearResultAndMoveToStart();
    });
  }
  get hasChanged() {
    return this.trackedFilters.some(({
      pending,
      origin
    }) => pending.hasDiff(origin.value));
  }
  async clearSelected() {
    this.bi.clear();
    this.trackedFilters.forEach(({
      pending
    }) => {
      pending.reset();
    });
  }
  init() {
    const disposers = [this.bi.init(), ...this.filters.map(({
      pending,
      origin
    }) => (0, _mobx.reaction)(() => origin.value, value => {
      pending.setValue(value);
    }, {
      fireImmediately: true
    }))];
    return () => {
      disposers.forEach(d => d());
    };
  }
}
exports.QueryPendingState = QueryPendingState;
//# sourceMappingURL=QueryPendingState.js.map