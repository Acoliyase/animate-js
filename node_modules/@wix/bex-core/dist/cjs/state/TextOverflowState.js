"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.TextOverflowState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mobx = require("mobx");
var _resizeObserverCompat = require("./resizeObserverCompat");
class TextOverflowState {
  constructor(params) {
    (0, _defineProperty2.default)(this, "node", null);
    (0, _defineProperty2.default)(this, "isOverflow", false);
    (0, _defineProperty2.default)(this, "observable", void 0);
    (0, _defineProperty2.default)(this, "_updateIsOverflow", (0, _mobx.action)(() => {
      const {
        node
      } = this;
      if (!node) {
        return;
      }
      this.isOverflow = node.clientWidth + 1 < node.scrollWidth;
    }));
    this.observable = params.observable;
    (0, _mobx.makeObservable)(this, {
      isOverflow: _mobx.observable.ref,
      calculateOverflow: _mobx.action.bound,
      init: _mobx.action
    });
  }
  init(node) {
    this.node = node;
    const disposers = [(0, _mobx.reaction)(this.observable, () => {
      this.calculateOverflow();
    }, {
      fireImmediately: true
    }), (0, _resizeObserverCompat.addResizeObserver)(this.node, this.calculateOverflow)];
    return () => {
      disposers.forEach(disposer => disposer == null ? void 0 : disposer());
    };
  }
  calculateOverflow() {
    requestAnimationFrame(this._updateIsOverflow);
  }
}
exports.TextOverflowState = TextOverflowState;
//# sourceMappingURL=TextOverflowState.js.map