"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.TagsAssignmentState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _v = require("@wix/bex-utils/@wix/bi-logger-os-data/v2");
var _uuid = require("uuid");
var _mobx = require("mobx");
var _CollectionOptimisticActions = require("../CollectionOptimisticActions");
var _TaskState = require("../TaskState");
var _CollectionState = require("../CollectionState");
var _util = require("../../util");
class TagsAssignmentState {
  constructor({
    tagsManagementState,
    entityId,
    origin,
    tagsBIReporter,
    initialTags,
    ...params
  }) {
    var _initialTags$privateT;
    (0, _defineProperty2.default)(this, "tagsManagementState", void 0);
    (0, _defineProperty2.default)(this, "origin", void 0);
    (0, _defineProperty2.default)(this, "tagsBIReporter", void 0);
    (0, _defineProperty2.default)(this, "initTask", new _TaskState.TaskState());
    (0, _defineProperty2.default)(this, "collection", void 0);
    (0, _defineProperty2.default)(this, "optimisticActions", void 0);
    (0, _defineProperty2.default)(this, "entityId", void 0);
    (0, _defineProperty2.default)(this, "initialTags", void 0);
    (0, _defineProperty2.default)(this, "fqdn", void 0);
    (0, _defineProperty2.default)(this, "assignTag", async ({
      tag,
      onSubmit,
      isFromSearch,
      optimisticActionParams
    }) => {
      if (this.assignedTagIds.includes(tag.id)) {
        return;
      }
      const newIndex = this._getNewIndex();
      await this.optimisticActions.createOne({
        id: tag.id,
        index: newIndex
      }, {
        ...optimisticActionParams,
        submit: async _ => {
          await this._assignTag({
            tagIds: this.assignedTagIds,
            tag,
            onSubmit,
            isFromSearch
          });
          return [{
            id: tag.id,
            index: newIndex
          }];
        }
      });
    });
    (0, _defineProperty2.default)(this, "unassignTag", async ({
      tag,
      onSubmit,
      isFromSearch = false,
      optimisticActionParams
    }) => {
      const tagToUnassign = this.collection.result.items.find(t => t.id === tag.id);
      await this.optimisticActions.deleteOne(tagToUnassign, {
        ...optimisticActionParams,
        submit: async () => {
          this._invokeBiOnAssignUnassign({
            actionName: 'Remove',
            tag,
            isFromSearch
          });
          await (onSubmit == null ? void 0 : onSubmit({
            allTags: {
              privateTags: {
                tagIds: this.assignedTagIds.filter(id => id !== tag.id)
              }
            },
            addedTags: {
              privateTags: {
                tagIds: []
              }
            },
            removedTags: {
              privateTags: {
                tagIds: [tag.id]
              }
            }
          }));
        }
      });
    });
    (0, _defineProperty2.default)(this, "createAndAssignTag", async ({
      name,
      id = (0, _uuid.v4)(),
      filteredListSize,
      onSubmit,
      assignOptimisticActionParams,
      createOptimisticActionParams
    }) => {
      const newIndex = this._getNewIndex();
      this.optimisticActions.createOne({
        id,
        index: newIndex
      }, {
        ...assignOptimisticActionParams,
        submit: async _ => {
          const newTag = await this._createAndAssign({
            name,
            id,
            filteredListSize,
            onSubmit,
            createOptimisticActionParams
          });
          return [{
            id: newTag.id,
            index: newIndex
          }];
        }
      });
    });
    (0, _defineProperty2.default)(this, "_assignTag", async ({
      tagIds,
      tag,
      onSubmit,
      isFromSearch
    }) => {
      this._invokeBiOnAssignUnassign({
        actionName: 'Assign',
        tag,
        isFromSearch
      });
      await (onSubmit == null ? void 0 : onSubmit({
        allTags: {
          privateTags: {
            tagIds: Array.from(new Set([...tagIds, tag.id]))
          }
        },
        addedTags: {
          privateTags: {
            tagIds: [tag.id]
          }
        },
        removedTags: {
          privateTags: {
            tagIds: []
          }
        }
      }));
    });
    (0, _defineProperty2.default)(this, "_createAndAssign", async ({
      name,
      id,
      filteredListSize,
      onSubmit,
      createOptimisticActionParams
    }) => {
      const isFromSearch = true;
      let assignError;
      let newTag = this.tagsManagementState.items.find(tag => tag.name === name);
      if (newTag) {
        await this._assignTag({
          tagIds: this.assignedTagIds.filter(tagId => tagId !== id),
          tag: newTag,
          onSubmit,
          isFromSearch
        });
        return newTag;
      }
      newTag = await this._createTag({
        name,
        id,
        filteredListSize,
        isFromSearch,
        createOptimisticActionParams,
        onCreateSuccess: async newTag => {
          try {
            await this._assignTag({
              tagIds: this.assignedTagIds.filter(tagId => tagId !== id),
              tag: newTag,
              onSubmit,
              isFromSearch
            });
          } catch (error) {
            assignError = error;
          }
        }
      });

      // We want to throw assign exception in assign optimistic context so assign tryAgain (and not create) will be triggered
      if (assignError) {
        throw assignError;
      }
      return newTag;
    });
    (0, _defineProperty2.default)(this, "_createTag", async ({
      name,
      id,
      filteredListSize,
      isFromSearch,
      onCreateSuccess,
      createOptimisticActionParams
    }) => {
      return new Promise(async resolve => {
        await this.tagsManagementState.createTag({
          name,
          id,
          filteredListSize,
          origin: this.origin,
          isFromSearch,
          tagsBIReporter: this.tagsBIReporter,
          optimisticActionParams: createOptimisticActionParams,
          onSuccess: async newTag => {
            await (onCreateSuccess == null ? void 0 : onCreateSuccess(newTag));
            resolve(newTag);
          }
        });
      });
    });
    this.tagsManagementState = tagsManagementState;
    this.origin = origin;
    this.tagsBIReporter = tagsBIReporter;
    this.fqdn = params.fqdn;
    this.initialTags = Array.from(new Set((initialTags == null || (_initialTags$privateT = initialTags.privateTags) == null ? void 0 : _initialTags$privateT.tagIds) || [])).map((id, index) => ({
      index,
      id
    }));
    (0, _mobx.makeObservable)(this, {
      initialTags: _mobx.observable,
      init: _mobx.action,
      assignTag: _mobx.action,
      createAndAssignTag: _mobx.action,
      unassignTag: _mobx.action,
      clear: _mobx.action,
      assignedTags: _mobx.computed,
      initialTagIds: _mobx.computed,
      isDirty: _mobx.computed
    });
    this.collection = new _CollectionState.CollectionState({
      ...tagsManagementState.container,
      events: {},
      queryName: [this.fqdnString, origin, entityId].join('/'),
      fetchData: async () => {
        return {
          items: this.initialTags,
          total: this.initialTags.length
        };
      },
      itemKey: tag => tag.id,
      itemName: tag => tag.id,
      filters: {}
    });
    this.optimisticActions = new _CollectionOptimisticActions.CollectionOptimisticActions({
      collection: this.collection,
      container: tagsManagementState.container,
      orderBy: () => [{
        fieldName: ({
          index
        }) => index,
        order: 'asc'
      }]
    });
  }
  init({
    entityId
  }) {
    this.entityId = entityId ?? undefined;
    const {
      collection,
      optimisticActions
    } = this;
    const disposers = [collection.init(), optimisticActions.init()];
    this.initTask.runOnce(async () => {
      await collection.initTask.status.promise;
      this.tagsManagementState.init();
      await this.tagsManagementState.initTask.status.promise;
    });
    return () => {
      disposers.forEach(disposer => disposer());
    };
  }
  get fqdnString() {
    return (0, _util.fqdnToString)(this.fqdn);
  }
  get isLoading() {
    const {
      status
    } = this.tagsManagementState.initTask;
    return status.isIdle || status.isLoading || this.initTask.status.isLoading;
  }
  get isError() {
    return this.tagsManagementState.initTask.status.isError || this.initTask.status.isError;
  }
  retry() {
    this.initTask.runOnce();
  }
  get assignedTags() {
    var _this$collection$resu;
    return (_this$collection$resu = this.collection.result.items) == null ? void 0 : _this$collection$resu.map(({
      id
    }) => {
      return this.tagsManagementState.items.find(tag => tag.id === id);
    }).filter(Boolean);
  }
  get assignedTagIds() {
    const {
      isIdle,
      isLoading
    } = this.collection.status;

    /**
     * During collection fetch, the returned items are 0, which impacts assignedTagIds
     * and sets isDirty to true during the rendering lifecycle, causing flakiness in the UI.
     */
    return isIdle || isLoading ? this.initialTagIds : this.collection.result.items.map(tag => tag.id);
  }
  get initialTagIds() {
    return this.initialTags.map(tag => tag.id);
  }
  clear() {
    this.collection.result.clear();
  }
  get isDirty() {
    if (this.initialTagIds.length !== this.assignedTagIds.length) {
      return true;
    }
    const unassigendTagIds = this.initialTagIds.filter(id => !this.assignedTagIds.includes(id));
    const assignedTagIds = this.assignedTagIds.filter(id => !this.initialTagIds.includes(id));
    return unassigendTagIds.length !== 0 || assignedTagIds.length !== 0;
  }
  _invokeBiOnAssignUnassign({
    actionName,
    tag,
    isFromSearch = false
  }) {
    this.tagsBIReporter.reportBi((0, _v.cairoTagsAssignTag)({
      actionName,
      isFromSearch,
      itemId: this.entityId,
      numItems: 1,
      numTags: this.tagsManagementState.items.length,
      numTagsAssigned: this.assignedTags.length,
      tagName: tag.name,
      origin: this.origin
    }));
  }
  _getNewIndex() {
    const max = Math.max(0, ...this.collection.result.items.map(tag => tag.index));
    return max + 1;
  }
}
exports.TagsAssignmentState = TagsAssignmentState;
//# sourceMappingURL=TagsAssignmentState.js.map