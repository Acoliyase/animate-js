"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.BulkSelectState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _SelectState = require("./SelectState");
var _mobx = require("mobx");
var _snapshot = require("./snapshot");
var _util = require("../util");
var _events = require("events");
class BulkSelectState {
  get allSelected() {
    return this.select.defaultStatus.isChecked;
  }
  get hasUnchecked() {
    return !!this.uncheckedValues.length;
  }
  constructor(params) {
    (0, _defineProperty2.default)(this, "select", void 0);
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    (0, _defineProperty2.default)(this, "collection", void 0);
    (0, _defineProperty2.default)(this, "scrollToTop", void 0);
    (0, _defineProperty2.default)(this, "useNewSelectAllLogic", void 0);
    (0, _defineProperty2.default)(this, "disableAutoSelectAllCount", void 0);
    (0, _defineProperty2.default)(this, "totalSnapshot", void 0);
    (0, _defineProperty2.default)(this, "openModal", () => {
      this.events.emit('openModal');
    });
    (0, _defineProperty2.default)(this, "closeModal", () => {
      this.events.emit('closeModal');
    });
    (0, _defineProperty2.default)(this, "toggleIsSelectAll", (0, _mobx.action)(() => {
      const {
        allSelected,
        select: {
          isEmptyEnabledItems
        }
      } = this;
      if (allSelected || !isEmptyEnabledItems) {
        this.deselectAll();
      } else {
        this.selectAll();
      }
    }));
    this.collection = params.collection;
    this.scrollToTop = params.scrollToTop;
    this.disableAutoSelectAllCount = params.disableAutoSelectAllCount;
    this.useNewSelectAllLogic = params.useNewSelectAllLogic;
    this.select = new _SelectState.SelectState({
      keyGetter: item => item.key
    });
    this.totalSnapshot = new _snapshot.Snapshot({
      expression: () => this.allSelected,
      effect: () => this.collection.result.total
    });
    (0, _mobx.makeObservable)(this, {
      allSelected: _mobx.computed,
      disableAutoSelectAllCount: _mobx.observable.ref,
      selectAll: _mobx.action,
      selectOne: _mobx.action,
      selectOneItem: _mobx.action,
      deselectOne: _mobx.action,
      deselectOneItem: _mobx.action,
      resetToDefaults: _mobx.action.bound,
      hasUnchecked: _mobx.computed,
      selectedIds: _mobx.computed,
      uncheckedIds: _mobx.computed,
      selectedValues: _mobx.computed,
      selectedKeyedItems: _mobx.computed,
      uncheckedValues: _mobx.computed,
      uncheckedInCurrentCollection: _mobx.computed,
      selectedCountOrTotal: _mobx.computed,
      checkedSet: _mobx.computed,
      indeterminateSet: _mobx.computed
    });
  }
  getCollectionItem(key) {
    return this.collection.result._keyedItemsMap.get(key);
  }
  get selectedIds() {
    return this.select.selectedKeys;
  }
  get uncheckedIds() {
    return this.select.toArray.filter(({
      status
    }) => !status.isChecked).map(({
      value
    }) => value.key);
  }
  get selectedCount() {
    return this.select.selectedCount;
  }
  get allSelectedItemsFetched() {
    return this.selectedCountOrTotal <= this.collection.result.items.length;
  }
  get selectedValues() {
    return this.select.selectedValues.map(({
      item
    }) => item);
  }
  get checkedSet() {
    return new Set(this.select.toArray.filter(({
      status
    }) => status.isChecked).map(({
      value
    }) => value.key));
  }
  get indeterminateSet() {
    return new Set(this.select.toArray.filter(({
      status
    }) => status.isIndeterminate).map(({
      value
    }) => value.key));
  }
  get uncheckedValues() {
    return this.select.toArray.filter(({
      status
    }) => !status.isChecked).map(({
      value
    }) => value.item);
  }
  isChecked(key) {
    const {
      select
    } = this;
    return select.isChecked(key);
  }
  selectAll() {
    const {
      select,
      collection
    } = this;
    select.defaultStatus = select.defaultStatus.final();
    const {
      result: {
        keyedItems
      }
    } = collection;
    select.finalizeMany(keyedItems);
  }
  deselectAll() {
    const {
      select
    } = this;
    (0, _mobx.runInAction)(() => {
      select.defaultStatus = select.defaultStatus.start();
    });
    select.startAll();
  }
  selectOneItem(item) {
    const {
      select,
      useNewSelectAllLogic
    } = this;
    select.set(item);
    if (!useNewSelectAllLogic) {
      (0, _mobx.runInAction)(() => {
        select.defaultStatus = select.defaultStatus.start();
      });
    }
  }
  selectOne(key) {
    const {
      collection
    } = this;
    const {
      result
    } = collection;
    const keyedItem = result.get(key);
    if (keyedItem) {
      this.selectOneItem(keyedItem);
    }
  }
  deselectOneItem(keyedItem) {
    const {
      select,
      useNewSelectAllLogic
    } = this;
    select.delete(keyedItem);
    if (!useNewSelectAllLogic) {
      (0, _mobx.runInAction)(() => {
        select.defaultStatus = select.defaultStatus.start();
      });
    }
  }
  deselectOne(key) {
    const {
      collection
    } = this;
    const {
      result
    } = collection;
    const keyedItem = result.get(key);
    if (keyedItem == null) {
      return;
    }
    this.deselectOneItem(keyedItem);
  }
  resetToDefaults() {
    const {
      select
    } = this;
    (0, _mobx.runInAction)(() => {
      select.defaultStatus = select.defaultStatus.start();
    });
    select.clear();
  }
  init() {
    const disposers = [this.totalSnapshot.init(), (0, _util.addEventListener)(this.collection.emitter, 'ready', () => {
      this.totalSnapshot.forceUpdate();
    }), (0, _mobx.reaction)(() => this.collection.result.keyedItems, keyedItems => {
      const {
        select,
        allSelected,
        disableAutoSelectAllCount,
        collection: {
          result: {
            _keyedItemsMap
          }
        }
      } = this;
      if (allSelected && !disableAutoSelectAllCount) {
        select.syncValues(keyedItems);
      } else {
        select.syncValues(select.selectedKeys.map(key => _keyedItemsMap.get(key)).filter(e => e != null));
      }
    })];
    return () => {
      disposers.forEach(disposer => disposer());
    };
  }
  get selectedKeyedItems() {
    return this.selectedIds.map(id => this.collection.result.get(id)).filter(item => !!item);
  }
  get isEmpty() {
    return this.select.isEmpty;
  }
  get uncheckedInCurrentCollection() {
    const {
      uncheckedValues,
      collection
    } = this;
    const {
      itemKey
    } = collection;
    return uncheckedValues.filter(item => collection.result.has(itemKey(item)));
  }
  get selectedCountOrTotal() {
    const {
      allSelected,
      disableAutoSelectAllCount,
      selectedIds,
      useNewSelectAllLogic,
      uncheckedInCurrentCollection,
      collection: {
        result: {
          total
        }
      }
    } = this;
    if (!allSelected || disableAutoSelectAllCount) {
      return selectedIds.length;
    }
    if (useNewSelectAllLogic) {
      return total - uncheckedInCurrentCollection.length;
    }
    return total;
  }
  toggle(keyedItem) {
    this.select.toggle(keyedItem);
  }
}
exports.BulkSelectState = BulkSelectState;
//# sourceMappingURL=BulkSelectState.js.map