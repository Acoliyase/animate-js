"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.toString = exports.rangeFilter = exports.numberRangeFilter = exports.dateRangeFilter = exports.RangeFilterState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _events = require("events");
var _mobx = require("mobx");
var _dateRangeUtils = require("./dateRangeUtils");
var _refreshFilter = require("../Filter/refreshFilter");
function isRecord(thing) {
  return thing != null;
}
class RangeFilterState {
  constructor(params) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "persistent", void 0);
    // defaultValue: string;
    (0, _defineProperty2.default)(this, "itemKey", void 0);
    (0, _defineProperty2.default)(this, "itemName", void 0);
    (0, _defineProperty2.default)(this, "equals", void 0);
    (0, _defineProperty2.default)(this, "isCustomField", void 0);
    (0, _defineProperty2.default)(this, "isEmptyPreset", void 0);
    (0, _defineProperty2.default)(this, "parsePreset", void 0);
    (0, _defineProperty2.default)(this, "parse", void 0);
    (0, _defineProperty2.default)(this, "simplify", void 0);
    (0, _defineProperty2.default)(this, "matches", void 0);
    (0, _defineProperty2.default)(this, "_value", this.emptyValue);
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    (0, _defineProperty2.default)(this, "_toArray", value => {
      return [value];
    });
    this.name = params.name ?? '';
    this.persistent = params.persistent;
    // this.defaultValue = params.defaultValue;
    this.itemKey = params.itemKey;
    this.itemName = params.itemName;
    this.parse = params.parse;
    this.parsePreset = params.parsePreset ?? (() => this.emptyValue);
    this.isEmptyPreset = params.isEmptyPreset ?? (() => true);
    this.simplify = params.simplify ?? (value => value);
    this.matches = params.matches ?? ((item, value) => this.itemName(item) === this.itemName(value));
    this._value = params.initialValue ?? this.emptyValue;
    this.equals = params.equals;
    this.isCustomField = params.isCustomField;
    (0, _mobx.makeObservable)(this, {
      _value: _mobx.observable.ref,
      persistent: _mobx.observable.ref,
      isEmpty: _mobx.computed,
      size: _mobx.computed,
      value: _mobx.computed,
      setValue: _mobx.action,
      changeValue: _mobx.action
    });
  }
  get emptyValue() {
    return {
      from: null,
      to: null
    };
  }
  get value() {
    return this._value;
  }
  get toArray() {
    return [this._value];
  }
  get isEmpty() {
    const {
      from,
      to,
      preset
    } = this._value;
    return !from && from !== 0 && !to && to !== 0 && this.isEmptyPreset(preset);
  }
  get size() {
    return this.isEmpty ? 0 : 1;
  }
  get toQueryString() {
    return this.itemKey(this._value);
  }
  encode(value) {
    if (!this.isEmptyPreset(value.preset)) {
      return {
        preset: value.preset
      };
    }
    return {
      ...(value.from && {
        from: this.simplify(value.from)
      }),
      ...(value.to && {
        to: this.simplify(value.to)
      })
    };
  }
  decode(raw) {
    if (typeof raw === 'string') {
      if (!raw.includes('/') && !this.isEmptyPreset(raw)) {
        return this.parsePreset(raw);
      }
      const [from, to] = raw.split('/').map(this.parse);
      return {
        from,
        to
      };
    }
    if (isRecord(raw)) {
      const [from, to] = [raw.from, raw.to].map(this.parse);
      const preset = typeof raw.preset === 'string' ? raw.preset : undefined;
      if (!this.isEmptyPreset(preset)) {
        return this.parsePreset(preset);
      }
      return {
        from,
        to,
        preset
      };
    }
    return this.emptyValue;
  }
  setValue(value, {
    emitEvents,
    ...options
  } = {}) {
    this._value = value;
    if (emitEvents) {
      for (const event of emitEvents) {
        this.events.emit(event, options);
      }
    }
  }
  changeValue(value, {
    emitEvents = [],
    ...options
  } = {}) {
    this.setValue(value, {
      ...options,
      emitEvents: ['change', ...emitEvents]
    });
  }
  remove(items, options = {}) {
    if (items.some(e => e.from || e.to)) {
      this.setValue(this.emptyValue, options);
    }
  }
  applyFromQueryString(str) {
    this.setValue(this.decode(str));
  }
  refresh(value, options) {
    (0, _refreshFilter.refreshFilter)(this, value, options);
  }
  scheduleRefresh(value) {
    this.changeValue(value, {
      emitEvents: ['scheduleRefresh']
    });
  }
  reset(options = {}) {
    this.setValue(this.emptyValue, options);
  }
  hasDiff(rangeItem) {
    const {
      value
    } = this;
    return value.from !== rangeItem.from || value.to !== rangeItem.to;
  }
  clone(params) {
    const {
      value: initialValue,
      matches,
      persistent,
      itemKey,
      itemName,
      parse,
      name,
      simplify,
      isEmptyPreset,
      parsePreset,
      equals
    } = this;
    return new RangeFilterState({
      initialValue,
      matches,
      persistent,
      itemKey,
      itemName,
      parse,
      name,
      simplify,
      isEmptyPreset,
      parsePreset,
      equals,
      ...params
    });
  }
}
exports.RangeFilterState = RangeFilterState;
const rangeFilter = params => new RangeFilterState(params);
exports.rangeFilter = rangeFilter;
const isEmptyDatePreset = preset => {
  return !preset || _dateRangeUtils.presetToDaysAmount[preset] === undefined;
};
const toString = item => {
  if (!item.preset || isEmptyDatePreset(item.preset)) {
    return [item.from, item.to].map(d => d == null ? void 0 : d.toISOString()).join('/');
  }
  return item.preset;
};
exports.toString = toString;
const dateRangeFilter = (params = {}) => {
  return new RangeFilterState({
    itemKey: toString,
    itemName: toString,
    parse: value => {
      if (typeof value === 'object' && value instanceof Date) {
        return value;
      }
      if (typeof value !== 'string' && typeof value !== 'number') {
        return null;
      }
      const d = new Date(value);
      if (isNaN(d.valueOf())) {
        return null;
      }
      return d;
    },
    parsePreset: _dateRangeUtils.getDatesFromPreset,
    isEmptyPreset: isEmptyDatePreset,
    equals: (item1, item2) => {
      if (isEmptyDatePreset(item1.preset) && isEmptyDatePreset(item2.preset)) {
        var _item1$from, _item2$from, _item1$to, _item2$to;
        return ((_item1$from = item1.from) == null ? void 0 : _item1$from.getTime()) === ((_item2$from = item2.from) == null ? void 0 : _item2$from.getTime()) && ((_item1$to = item1.to) == null ? void 0 : _item1$to.getTime()) === ((_item2$to = item2.to) == null ? void 0 : _item2$to.getTime());
      }
      return item1.preset === item2.preset;
    },
    ...params
  });
};
exports.dateRangeFilter = dateRangeFilter;
const numberRangeFilter = (params = {}) => {
  return new RangeFilterState({
    itemKey: item => `${item.from}/${item.to}`,
    itemName: item => {
      const from = typeof item.from === 'number' ? `from ${item.from.toString()}` : '';
      const to = typeof item.to === 'number' ? `to ${item.to.toString()}` : '';
      return `${from} ${to}`;
    },
    parse: value => {
      if (typeof value === 'string') {
        const parsed = Number(value);
        return isNaN(parsed) ? null : parsed;
      }
      if (typeof value === 'number') {
        return value;
      }
      return null;
    },
    equals: (item1, item2) => {
      return item1.from === item2.from && item1.to === item2.to;
    },
    ...params
  });
};
exports.numberRangeFilter = numberRangeFilter;
//# sourceMappingURL=RangeFilterState.js.map