"use strict";

exports.__esModule = true;
exports.mergePatchedItems = mergePatchedItems;
function mergePatchedItems(toMerge, {
  page,
  itemKey,
  orders,
  itemPredicate
}) {
  const itemsToMerge = toMerge.all;

  // merge items into page. replace if already exists in page. order by original if `keepPosition=true`
  const pageWithPatchedItemsMapTmp = new Map();
  for (const [key, {
    item,
    optimisticPatch
  }] of Array.from(itemsToMerge.entries())) {
    const {
      keepPosition,
      originalItems
    } = optimisticPatch;
    const originalItem = originalItems.get(key);
    // if `order` is empty (can't simulate ordering) and keepPosition=true and item didn't match current filtering before update
    // skip on pushing the item into the page
    if (!orders.length && keepPosition && originalItem != null && itemPredicate(originalItem)) {
      continue;
    }
    if (!itemPredicate(item)) {
      continue;
    }
    pageWithPatchedItemsMapTmp.set(key, {
      item
    });
  }

  // place "type=createMany" items first
  const pageWithPatchedItemsMap = new Map();
  for (const key of toMerge.created.keys()) {
    if (pageWithPatchedItemsMapTmp.has(key)) {
      pageWithPatchedItemsMap.set(key, {
        item: pageWithPatchedItemsMapTmp.get(key).item
      });
      pageWithPatchedItemsMapTmp.delete(key);
    }
  }
  for (const [key, {
    item
  }] of Array.from(pageWithPatchedItemsMapTmp.entries())) {
    pageWithPatchedItemsMap.set(key, {
      item
    });
  }
  for (const item of page) {
    const key = itemKey(item);
    const toInsert = itemsToMerge.get(key);
    if (toInsert && toInsert.optimisticPatch.keepPosition) {
      pageWithPatchedItemsMap.delete(key);
      pageWithPatchedItemsMap.set(key, {
        item: toInsert.item,
        orderByItem: item
      });
    } else if (!toInsert) {
      pageWithPatchedItemsMap.set(key, {
        item
      });
    }
  }
  return Array.from(pageWithPatchedItemsMap.values());
}
//# sourceMappingURL=mergePatchedItems.js.map