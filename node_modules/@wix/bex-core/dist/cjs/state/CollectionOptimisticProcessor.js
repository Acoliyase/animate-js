"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.CollectionOptimisticProcessor = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mobx = require("mobx");
var _QueryResultSimulationDefault = require("./QueryResultSimulationDefault");
var _CollectionOptimisticHelpers = require("./CollectionOptimisticHelpers");
var _optimisticSimulation = require("./optimistic-simulation");
var _orderByOrders = require("./optimistic-simulation/orderByOrders");
var _orderByMoves = require("./optimistic-simulation/orderByMoves");
class CollectionOptimisticProcessor {
  constructor(params) {
    (0, _defineProperty2.default)(this, "collection", void 0);
    (0, _defineProperty2.default)(this, "processorHelpers", void 0);
    (0, _defineProperty2.default)(this, "optimistic", void 0);
    (0, _defineProperty2.default)(this, "resultSimulationDefault", void 0);
    (0, _defineProperty2.default)(this, "predicate", void 0);
    (0, _defineProperty2.default)(this, "orderBy", void 0);
    this.collection = params.collection;
    this.processorHelpers = new _CollectionOptimisticHelpers.CollectionOptimisticProcessorHelpers(this.collection);
    this.optimistic = params.optimistic;
    this.resultSimulationDefault = new _QueryResultSimulationDefault.QueryResultSimulationDefault({
      collection: this.collection
    });
    this.predicate = params.predicate ?? this.resultSimulationDefault.predicate;
    this.orderBy = params.orderBy ?? this.resultSimulationDefault.orderBy;
    (0, _mobx.makeObservable)(this, {
      reprocess: _mobx.action.bound,
      beforeAddNewPages: _mobx.action.bound,
      beforeSetTotal: _mobx.action.bound
    });
    this._register();
  }
  _register() {
    this.collection.emitter.on('beforeAddNewPages', this.beforeAddNewPages);
    this.collection.emitter.on('beforeSetTotal', this.beforeSetTotal);
    this.optimistic.events.on('reprocess', this.reprocess);
  }
  reprocess() {
    this.removeSelectionIfExists();
    this.processorHelpers.reprocess();
  }
  removeSelectionIfExists() {
    const {
      collection: {
        itemKey,
        bulkSelect,
        result: {
          originQuery
        }
      },
      optimistic: {
        state: {
          patches
        }
      },
      predicate
    } = this;
    const itemPredicate = predicate(originQuery);
    const filterItem = (0, _optimisticSimulation.filterPageByPatches)(patches, {
      itemPredicate,
      itemKey
    });
    bulkSelect.select.filter(({
      item
    }) => filterItem(item));
  }
  beforeAddNewPages({
    pages,
    currentItemsMap,
    originQuery
  }) {
    const {
      optimistic: {
        state,
        query,
        _orderByMode
      },
      collection,
      predicate,
      orderBy: orderByIteratee
    } = this;
    const {
      itemKey
    } = collection;
    const {
      patches
    } = state;
    const {
      limit
    } = originQuery;
    if (!patches.length) {
      return pages;
    }
    const itemPredicate = predicate(originQuery);
    const orders = _orderByMode === 'orders' ? orderByIteratee(originQuery) : [];
    let finalPages = pages;
    const itemToMerge = (0, _optimisticSimulation.prepareItemsToMergeIntoPage)(patches, {
      itemPredicate,
      currentItemsMap
    });
    finalPages = !itemToMerge.all.size && _orderByMode === 'orders' ? finalPages : finalPages.map((page, index) => {
      const pageWithPatchedItems = itemToMerge.all.size ? (0, _optimisticSimulation.mergePatchedItems)(itemToMerge, {
        page,
        limit,
        itemKey,
        orders,
        itemPredicate
      }) : page.map(item => ({
        item
      }));
      return _orderByMode === 'moves' ? (0, _orderByMoves.orderByMoves)({
        pageWithPatchedItems,
        pageIndex: index,
        patches,
        currentFiltersKeyHash: query.filtersKeyHash,
        itemKey,
        toMerge: itemToMerge,
        itemPredicate,
        limit
      }) : (0, _orderByOrders.orderByOrders)(pageWithPatchedItems, itemToMerge, {
        orders,
        itemKey,
        limit
      });
    });
    finalPages = finalPages.map(page => {
      return page.filter((0, _optimisticSimulation.filterPageByPatches)(patches, {
        itemPredicate,
        itemKey
      }));
    });
    return finalPages;
  }
  beforeSetTotal({
    total,
    originQuery
  }) {
    const {
      optimistic: {
        state
      },
      predicate
    } = this;
    const {
      patches
    } = state;
    if (!patches.length) {
      return total;
    }
    const itemPredicate = predicate(originQuery);
    const processedTotal = patches.reduce((prev, {
      actionType,
      patchedItemsEntries,
      originalItems,
      originalTotal
    }) => {
      if (actionType === 'updateAllConst' || actionType === 'deleteAll') {
        const [[key, item] = []] = patchedItemsEntries;
        if (key == null || item == null) {
          return prev;
        }
        const originalItem = originalItems.get(key);
        if (itemPredicate(item) && (originalItem == null || !itemPredicate(originalItem))) {
          return prev + originalTotal;
        }
        if (
        // if action=deleteAll treat the item as filtered out, no need to check predicate
        (actionType === 'deleteAll' || !itemPredicate(item)) && originalItem != null && itemPredicate(originalItem)) {
          return prev - originalTotal;
        }
        return prev;
      }
      const patchedItemsTotal = patchedItemsEntries.reduce((acc, [key, item]) => {
        const originalItem = originalItems.get(key);
        const value = (() => {
          switch (actionType) {
            case 'deleteMany':
              if (originalItem != null && itemPredicate(originalItem)) {
                return -1;
              }
              return 0;
            case 'updateMany':
            case 'updateAll':
            case 'createMany':
              if (itemPredicate(item) && (originalItem == null || !itemPredicate(originalItem))) {
                return 1;
              }
              if (!itemPredicate(item) && originalItem != null && itemPredicate(originalItem)) {
                return -1;
              }
              return 0;
          }
          return 0;
        })();
        return acc + value;
      }, 0);
      return prev + patchedItemsTotal;
    }, total);
    return Math.max(processedTotal, 0);
  }
}
exports.CollectionOptimisticProcessor = CollectionOptimisticProcessor;
//# sourceMappingURL=CollectionOptimisticProcessor.js.map