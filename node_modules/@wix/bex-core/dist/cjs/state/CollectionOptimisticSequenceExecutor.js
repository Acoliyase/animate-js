"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.CollectionOptimisticSequenceExecutor = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _PromisesSequence = require("./PromisesSequence");
var _events = require("events");
class CollectionOptimisticSequenceExecutor {
  constructor(params) {
    (0, _defineProperty2.default)(this, "showToast", void 0);
    (0, _defineProperty2.default)(this, "translate", void 0);
    (0, _defineProperty2.default)(this, "errorMonitor", void 0);
    (0, _defineProperty2.default)(this, "onRollback", void 0);
    (0, _defineProperty2.default)(this, "seq", new _PromisesSequence.PromisesSequence());
    (0, _defineProperty2.default)(this, "removeToast", null);
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    this.showToast = params.showToast;
    this.translate = params.translate;
    this.errorMonitor = params.errorMonitor;
    this.onRollback = params.onRollback;
  }
  removeAndShowToast(toastConfig) {
    const {
      removeToast,
      showToast
    } = this;
    removeToast == null || removeToast();
    this.removeToast = showToast(toastConfig).remove;
  }
  async sequence(params) {
    const {
      seq,
      errorMonitor,
      translate: t,
      onRollback
    } = this;
    const {
      submit,
      onEventuallyUpdated
    } = params;
    try {
      await seq.enqueue(async () => {
        await submit();
        onEventuallyUpdated == null || onEventuallyUpdated();
      });
    } catch (err) {
      console.error(err);
      errorMonitor.captureException(err);
      const errorToast = onRollback(err);
      if (errorToast) {
        this.removeAndShowToast({
          ...errorToast,
          type: 'ERROR',
          timeout: 'NONE',
          action: {
            uiType: 'LINK',
            text: t('cairo.toast.retry'),
            removeToastOnClick: true,
            ...errorToast.action,
            onClick: () => {
              var _this$removeToast, _errorToast$action;
              (_this$removeToast = this.removeToast) == null || _this$removeToast.call(this);
              this.removeToast = null;
              (_errorToast$action = errorToast.action) == null || _errorToast$action.onClick == null || _errorToast$action.onClick();
            }
          }
        });
        const currentToast = this.removeToast;
        new Promise(resolve => setTimeout(resolve, 12000)).then(() => {
          if (currentToast === this.removeToast) {
            currentToast == null || currentToast();
          }
        });
      }
    }
  }
}
exports.CollectionOptimisticSequenceExecutor = CollectionOptimisticSequenceExecutor;
//# sourceMappingURL=CollectionOptimisticSequenceExecutor.js.map