"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.SelectState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mobx = require("mobx");
var _SelectionStatusWixPatternsPreset = require("./SelectionStatusWixPatternsPreset");
var _SelectMapState = require("./SelectMapState");
class SelectState {
  constructor(params) {
    (0, _defineProperty2.default)(this, "keyGetter", void 0);
    (0, _defineProperty2.default)(this, "defaultStatus", void 0);
    (0, _defineProperty2.default)(this, "map", new _SelectMapState.SelectMapState());
    this.defaultStatus = params.defaultStatus ?? _SelectionStatusWixPatternsPreset.selectionStatusWixPatternsPreset.unchecked;
    (0, _mobx.makeObservable)(this, {
      defaultStatus: _mobx.observable.ref,
      selectedValues: _mobx.computed,
      selectedKeys: _mobx.computed,
      isEmpty: _mobx.computed,
      isNotEmpty: _mobx.computed,
      isEmptyEnabledItems: _mobx.computed,
      isNotEmptyEnabledItems: _mobx.computed,
      selectedCount: _mobx.computed,
      toArray: _mobx.computed,
      selectedArray: _mobx.computed,
      set: _mobx.action,
      delete: _mobx.action,
      toggle: _mobx.action,
      clear: _mobx.action,
      syncValues: _mobx.action,
      finalizeMany: _mobx.action,
      setMany: _mobx.action,
      filter: _mobx.action,
      initSelected: _mobx.action
    });
    this.keyGetter = params.keyGetter;
  }
  get startStatus() {
    return this.defaultStatus.start();
  }
  get finalStatus() {
    return this.defaultStatus.final();
  }
  isChecked(key) {
    var _map$get;
    const {
      map
    } = this;
    return Boolean((_map$get = map.get(key)) == null ? void 0 : _map$get.status.isChecked);
  }
  toggle(value, {
    clear
  } = {}) {
    const {
      map,
      keyGetter,
      defaultStatus
    } = this;
    if (clear) {
      this.clear();
    }
    const key = keyGetter(value);
    const entry = map.get(key) ?? {
      value,
      status: defaultStatus
    };
    map.set(key, {
      ...entry,
      status: entry.status.toggle()
    });
  }
  set(value) {
    const {
      keyGetter,
      map,
      finalStatus
    } = this;
    const key = keyGetter(value);
    map.set(key, {
      value,
      status: finalStatus
    });
  }
  forceSet(value) {
    const {
      keyGetter,
      map,
      finalStatus
    } = this;
    const key = keyGetter(value);
    map.forceSet(key, {
      value,
      status: finalStatus
    });
  }
  delete(value) {
    const {
      keyGetter,
      map,
      defaultStatus
    } = this;
    const key = keyGetter(value);
    map.set(key, {
      value,
      status: defaultStatus.start()
    });
  }
  deleteKey(key) {
    const {
      map
    } = this;
    const entry = map.get(key);
    if (entry) {
      map.set(key, {
        ...entry,
        status: entry.status.start()
      });
    }
  }
  get selectedCount() {
    return this.selectedArray.length;
  }
  get toArray() {
    return Array.from(this.map.values());
  }
  get selectedArray() {
    return this.toArray.filter(({
      status
    }) => status.isChecked);
  }
  get selectedValues() {
    return this.selectedArray.map(({
      value
    }) => value);
  }
  get selectedKeys() {
    const {
      keyGetter
    } = this;
    return this.selectedValues.map(keyGetter);
  }
  clear() {
    const {
      map
    } = this;
    map.clear();
  }
  forceSetMany(entries) {
    const {
      map,
      keyGetter
    } = this;
    for (const entry of entries) {
      const key = keyGetter(entry.value);
      map.forceSet(key, entry);
    }
  }

  // backwards compatibility
  setMany(entries) {
    return this.forceSetMany(entries);
  }
  syncValues(values, status = this.defaultStatus) {
    const {
      map,
      keyGetter
    } = this;
    for (const value of values) {
      const key = keyGetter(value);
      const entry = map.get(key);
      const newEntry = entry ? {
        ...entry,
        value
      } : {
        value,
        status
      };
      map.forceSet(key, newEntry);
    }
  }
  initSelected(values) {
    const {
      map
    } = this;
    map.clear();
    this.forceSetMany(values.map(value => ({
      value,
      status: this.finalStatus
    })));
  }
  finalizeMany(values) {
    const {
      map,
      keyGetter,
      finalStatus
    } = this;
    for (const value of values) {
      const key = keyGetter(value);
      map.set(key, {
        value,
        status: finalStatus
      });
    }
  }
  startAll() {
    const {
      map,
      startStatus
    } = this;
    const entries = Array.from(map.entries());
    for (const [key, entry] of entries) {
      map.set(key, {
        ...entry,
        status: startStatus
      });
    }
  }
  filter(predicate) {
    const {
      map,
      selectedArray,
      keyGetter
    } = this;
    for (const {
      value,
      status
    } of selectedArray) {
      if (!predicate(value)) {
        map.set(keyGetter(value), {
          value,
          status: status.start()
        });
      }
    }
  }
  get isNotEmpty() {
    return !this.isEmpty;
  }
  get isEmpty() {
    const {
      selectedArray
    } = this;
    return !selectedArray.length;
  }
  get isNotEmptyEnabledItems() {
    return !this.isEmptyEnabledItems;
  }
  get isEmptyEnabledItems() {
    const {
      selectedArray
    } = this;
    const selectedEnabledItems = selectedArray.filter(selectionEntry => this._map.events.listeners('isDisabled').every(listener => !listener(selectionEntry)));
    return !selectedEnabledItems.length;
  }
  get _map() {
    return this.map;
  }
}
exports.SelectState = SelectState;
//# sourceMappingURL=SelectState.js.map