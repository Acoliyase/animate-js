"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.SortState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _events = require("events");
var _mobx = require("mobx");
class SortState {
  constructor(_params) {
    (0, _defineProperty2.default)(this, "_value", _mobx.observable.array([], {
      deep: true
    }));
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    (0, _mobx.makeObservable)(this, {
      value: _mobx.computed,
      setSort: _mobx.action,
      changeSort: _mobx.action,
      reset: _mobx.action
    });
  }
  reset({
    emitChangeEvent
  } = {}) {
    this._value.clear();
    if (emitChangeEvent) {
      this.events.emit('change');
    }
  }
  _getNextSortOrder(col) {
    const existingSort = this._value.find(({
      field
    }) => field === col.id);

    /**
     * @deprecated always option is deprecated
     */
    if (col.sortMode === 'always') {
      return (existingSort == null ? void 0 : existingSort.direction) === 'asc' ? 'desc' : 'asc';
    }

    // Get the next sort mode
    if (Array.isArray(col.sortMode)) {
      const currentSortIndex = col.sortMode.indexOf(existingSort == null ? void 0 : existingSort.direction);
      const nextSortIndex = (currentSortIndex + 1) % col.sortMode.length;
      return col.sortMode[nextSortIndex];
    }

    // asc->desc->undefined->asc...
    return existingSort === undefined ? 'asc' : existingSort.direction === 'desc' ? undefined : 'desc';
  }
  setSort(col, {
    forceDirection,
    emitChangeEvent,
    multiple
  } = {}) {
    const order = forceDirection ?? this._getNextSortOrder(col);
    if (multiple) {
      this._setSortMultiple(col, order);
    } else {
      this._setSortSingular(col, order);
    }
    if (emitChangeEvent) {
      this.events.emit('change', {
        col
      });
    }
  }
  _setSortSingular(col, direction) {
    this._value.clear();
    if (direction) {
      this._value.push({
        field: col.id,
        direction
      });
    }
  }

  /**
   * Rules
   * Sort by a new column:
   * - Clear all previous sorts and add a new one
   * Sort by an existing column:
   * - If only 1 column is sorted, the next direction is calculated
   *   with the SortMode in mind (if provided).
   * - If more than 1 column is sorted, only change the direction
   *   asc -> desc, desc -> asc, ignoring the SortMode (if provided).
   */
  _setSortMultiple(col, direction) {
    const sortIndex = this._value.findIndex(({
      field
    }) => field === col.id);
    if (sortIndex === -1) {
      this._setSortSingular(col, direction);
    } else {
      const nextDirection = this._value.length > 1 ? this._value[sortIndex].direction === 'asc' ? 'desc' : 'asc' : direction;
      if (this._value.length === 1 && !direction) {
        this._value.clear();
      } else if (nextDirection) {
        this._value[sortIndex] = {
          field: col.id,
          direction: nextDirection
        };
      }
    }
  }
  setSortQuery(query, {
    emitChangeEvent
  } = {}) {
    this._value.replace(query);
    if (emitChangeEvent) {
      this.events.emit('change');
    }
  }
  changeSort(col, params = {}) {
    this.setSort(col, {
      emitChangeEvent: true,
      ...params
    });
  }
  get value() {
    return this._value;
  }
  getIsSortDescending(id) {
    const sort = this._value.find(({
      field
    }) => field === id);
    if (sort) {
      return sort.direction === 'desc';
    }
    return undefined;
  }
}
exports.SortState = SortState;
//# sourceMappingURL=SortState.js.map