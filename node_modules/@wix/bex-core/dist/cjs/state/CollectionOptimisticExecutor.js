"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.CollectionOptimisticExecutor = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _util = require("../util");
class CollectionOptimisticExecutor {
  constructor(params) {
    (0, _defineProperty2.default)(this, "showToast", void 0);
    (0, _defineProperty2.default)(this, "translate", void 0);
    (0, _defineProperty2.default)(this, "errorMonitor", void 0);
    (0, _defineProperty2.default)(this, "lodash", void 0);
    (0, _defineProperty2.default)(this, "container", void 0);
    (0, _defineProperty2.default)(this, "removeToast", null);
    (0, _defineProperty2.default)(this, "_actions", []);
    (0, _defineProperty2.default)(this, "scheduleExecution", void 0);
    this.showToast = params.showToast;
    this.translate = params.translate;
    this.errorMonitor = params.errorMonitor;
    this.lodash = params.lodash;
    this.container = params.container;
    this.executePending = this.executePending.bind(this);
    this.scheduleExecution = params.batchWait ? this.lodash.throttle(this.executePending, params.batchWait, {
      leading: false,
      trailing: true
    }) : this.executePending;
  }
  removeAndShowToast(toastConfig) {
    const {
      removeToast,
      showToast
    } = this;
    removeToast == null || removeToast();
    this.removeToast = showToast(toastConfig).remove;
  }
  rollback(actions, onRollback) {
    this._actions = this._actions.filter(action => actions.indexOf(action) === -1);
    onRollback();
  }
  getSuccessToast(actions, {
    onRollback,
    successToast,
    showUndoToast,
    showUndoSuccessToast,
    onUndo
  }) {
    const {
      container,
      showToast,
      translate: t
    } = this;
    let resolveUndoTimeoutPromise = null;
    const state = {};
    if (showUndoToast) {
      state.undoToast = {
        timeoutPromises: [new Promise(_resolve => {
          resolveUndoTimeoutPromise = _resolve;
        }), new Promise(resolve => setTimeout(resolve, 6000))],
        removeNavigationListener: (0, _util.addEventListener)(container.events, 'navigation', () => ({
          title: t('cairo.dragAndDrop.leaveSite.modal.title')
        }))
      };
    }
    if (successToast) {
      this.removeAndShowToast({
        action: showUndoToast ? {
          text: t('cairo.toast.undo'),
          uiType: 'LINK',
          onClick: () => {
            resolveUndoTimeoutPromise == null || resolveUndoTimeoutPromise({
              status: 'undone'
            });
            this.rollback(actions, onRollback);
            onUndo == null || onUndo();
            if (showUndoSuccessToast) {
              showToast({
                type: 'STANDARD',
                priority: 'LOW',
                biName: `cairo-undone`,
                message: t('cairo.toast.undone')
              });
            }
          },
          removeToastOnClick: true
        } : undefined,
        ...(typeof successToast === 'string' ? {
          message: successToast,
          biName: `cairo-undo`
        } : successToast),
        type: 'SUCCESS'
      });
    }
    return state;
  }
  async _execute(params) {
    const {
      successToastState,
      submit,
      errorToast: errorToastFn,
      onTryAgain,
      onError,
      onRollback,
      eventuallyUpdated,
      onEventuallyUpdated,
      actions
    } = params;
    const {
      errorMonitor,
      translate: t
    } = this;
    const {
      undoToast
    } = successToastState;
    try {
      if (undoToast) {
        const undoResult = await Promise.race(undoToast.timeoutPromises);
        undoToast.removeNavigationListener();
        if ((undoResult == null ? void 0 : undoResult.status) === 'undone') {
          return undoResult;
        }
      }
      const submitPromise = await submit(actions);
      const updateServerAfterPromise = typeof eventuallyUpdated === 'number' ? await Promise.all([submitPromise, new Promise(resolve => setTimeout(resolve, eventuallyUpdated))]).then(() => submitPromise) : submitPromise;
      const result = await updateServerAfterPromise;
      await (onEventuallyUpdated == null ? void 0 : onEventuallyUpdated());
      return {
        result,
        status: 'success'
      };
    } catch (err) {
      console.error(err);
      errorMonitor.captureException(err);
      this.rollback(actions, onRollback);
      onError == null || onError(err);
      if (errorToastFn) {
        const onRetryClick = () => {
          var _this$removeToast;
          onTryAgain == null || onTryAgain();
          (_this$removeToast = this.removeToast) == null || _this$removeToast.call(this);
          this.execute(actions, params);
        };
        const errorToast = errorToastFn(err, {
          retry: onRetryClick
        });
        const requestId = (0, _util.isHttpError)(err) ? err.requestId : undefined;
        const toastConfig = {
          action: {
            uiType: 'LINK',
            text: t('cairo.toast.retry'),
            onClick: onRetryClick,
            removeToastOnClick: true
          },
          ...(typeof errorToast === 'string' ? {
            message: errorToast,
            biName: `cairo-error-toast`
          } : errorToast),
          type: 'ERROR',
          details: requestId ? {
            requestId
          } : undefined
        };
        if (toastConfig.action) {
          toastConfig.action.uiType = 'LINK';
          toastConfig.action.removeToastOnClick = true;
        }
        this.removeAndShowToast(toastConfig);
      }
      return {
        status: 'error',
        err
      };
    }
  }
  async executePending(params) {
    const {
      _actions: actions
    } = this;
    this._actions = [];
    return this._execute({
      ...params,
      actions
    });
  }
  execute(actions, params) {
    const {
      showUndoToast,
      showUndoSuccessToast,
      successToast,
      onRollback,
      onUndo
    } = params;
    this._actions = [...this._actions, ...actions];
    const successToastState = this.getSuccessToast(actions, {
      onRollback,
      successToast,
      showUndoToast,
      showUndoSuccessToast,
      onUndo
    });
    this.scheduleExecution({
      ...params,
      successToastState
    });
  }
}
exports.CollectionOptimisticExecutor = CollectionOptimisticExecutor;
//# sourceMappingURL=CollectionOptimisticExecutor.js.map