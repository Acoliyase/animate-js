"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.TagsService = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _http = require("@wix/bex-utils/@wix/ambassador-os-tags-v1-tag/http");
class TagsService {
  constructor({
    container
  }) {
    (0, _defineProperty2.default)(this, "container", void 0);
    this.container = container;
  }
  get httpClient() {
    return this.container.httpClient;
  }
  getContextFunction(accountFn, siteFn) {
    return this.container.contextType === 'ACCOUNT' ? accountFn : siteFn;
  }
  async listTags(request, errorCodesMap) {
    const fn = this.getContextFunction(_http.listTagsForAccount, _http.listTags);
    const {
      data: {
        tags = []
      }
    } = await this.container.errorHandler.withErrorHandler(() => this.httpClient.request(fn(request)), {
      errorCodesMap
    });
    return tags.filter(({
      id,
      name
    }) => id && name);
  }
  async createTag(request, errorCodesMap) {
    // We cannot use getContextFunction because createTagForAccount and createTag have different return signatures due to error handling
    if (this.container.contextType === 'SITE') {
      const {
        data: {
          tag
        }
      } = await this.container.errorHandler.withErrorHandler(() => this.httpClient.request((0, _http.createTag)(request)), {
        errorCodesMap
      });
      return tag;
    } else {
      const {
        data: {
          tag
        }
      } = await this.container.errorHandler.withErrorHandler(() => this.httpClient.request((0, _http.createTagForAccount)(request)), {
        errorCodesMap
      });
      return tag;
    }
  }
  async updateTag(request) {
    const fn = this.getContextFunction(_http.updateTagForAccount, _http.updateTag);
    const {
      data: {
        tag
      }
    } = await this.container.errorHandler.withErrorHandler(() => this.httpClient.request(fn(request)), {
      errorCodesMap: {}
    });
    return tag;
  }
  async deleteTag(request) {
    const fn = this.getContextFunction(_http.deleteTagForAccount, _http.deleteTag);
    return this.container.errorHandler.withErrorHandler(() => this.httpClient.request(fn(request)), {
      errorCodesMap: {}
    });
  }
}
exports.TagsService = TagsService;
//# sourceMappingURL=tagsService.js.map