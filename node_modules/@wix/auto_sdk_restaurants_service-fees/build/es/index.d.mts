import { HttpClient, NonNullablePaths, EventDefinition, MaybeContext, BuildRESTFunction, BuildEventDefinition } from '@wix/sdk-types';
import { Order, CalculateServiceFeesOptions, CalculateServiceFeesResponse, Rule, UpdateRule, ListRulesOptions, ListRulesResponse, RulesQueryBuilder, BulkCreateRulesOptions, BulkCreateRulesResponse, MaskedRule, BulkUpdateRulesOptions, BulkUpdateRulesResponse, BulkDeleteRulesResponse, BulkUpdateRuleTagsOptions, BulkUpdateRuleTagsResponse, BulkUpdateRuleTagsApplicationErrors, BulkUpdateRuleTagsByFilterOptions, BulkUpdateRuleTagsByFilterResponse, BulkUpdateRuleTagsByFilterApplicationErrors, RuleCreatedEnvelope, RuleDeletedEnvelope, RuleUpdatedEnvelope } from './index.typings.mjs';
export { ActionEvent, ApplicationError, BaseEventMetadata, BulkActionMetadata, BulkCreateRulesRequest, BulkDeleteRulesRequest, BulkRuleResult, BulkUpdateRuleTagsByFilterRequest, BulkUpdateRuleTagsRequest, BulkUpdateRuleTagsResult, BulkUpdateRulesRequest, CalculateServiceFeesRequest, CalculatedFee, CommonBulkActionMetadata, CommonItemMetadata, CommonMoney, Condition, ConditionTree, ConditionTreeLeftConditionNodeOneOf, ConditionTreeRightConditionNodeOneOf, ConditionType, ConditionTypeWithLiterals, ConditionValueOneOf, ConditionsType, ConditionsTypeWithLiterals, CreateRuleRequest, CreateRuleResponse, CursorPaging, CursorPagingMetadata, CursorQuery, CursorQueryPagingMethodOneOf, Cursors, DeleteRuleRequest, DeleteRuleResponse, DeliveryLogistics, DomainEvent, DomainEventBodyOneOf, Empty, EntityCreatedEvent, EntityDeletedEvent, EntityUpdatedEvent, EventMetadata, ExpectedFieldType, ExpectedFieldTypeWithLiterals, ExpectedType, ExtendedFields, GetRuleRequest, GetRuleResponse, IdentificationData, IdentificationDataIdOneOf, ItemMetadata, List, ListRulesRequest, Locale, MessageEnvelope, Money, Operation, OperationWithLiterals, Operator, OperatorWithLiterals, Platform, PlatformValue, PlatformValueWithLiterals, PriceSummary, QueryRulesRequest, QueryRulesResponse, RestoreInfo, RoundingStrategy, RoundingStrategyWithLiterals, RuleConditionTypeOptionsOneOf, RuleConditionsOneOf, RuleRequirementsOneOf, RuleTaxesOneOf, RuleValueOneOf, RulesQueryResult, ShippingInformation, SortOrder, SortOrderWithLiterals, Sorting, TagList, Tags, Type, TypeWithLiterals, UpdateRuleRequest, UpdateRuleResponse, Value, ValueWithLiterals, WebhookIdentityType, WebhookIdentityTypeWithLiterals, _Number } from './index.typings.mjs';

declare function calculateServiceFees$1(httpClient: HttpClient): CalculateServiceFeesSignature;
interface CalculateServiceFeesSignature {
    /**
     * The `calculateServiceFees()` function returns a Promise that resolves to an array containing the calculated fees.
     *
     *
     * The specified order information is evaluated against all rules created for the site. If the rule conditions are met, the service fee set in the rule is applied. Otherwise, no service fee is added.
     * @param - Order information needed to evaluate the rules and calculate the relevant fees.
     */
    (order: NonNullablePaths<Order, `currency` | `priceSummary`, 2>, options?: CalculateServiceFeesOptions): Promise<NonNullablePaths<CalculateServiceFeesResponse, `calculatedFees` | `calculatedFees.${number}.ruleId` | `calculatedFees.${number}.name` | `calculatedFees.${number}.fee.value` | `calculatedFees.${number}.fee.currency`, 5>>;
}
declare function createRule$1(httpClient: HttpClient): CreateRuleSignature;
interface CreateRuleSignature {
    /**
     * The `createRule()` function returns a Promise that resolves to the created rule.
     *
     *
     * To create multiple rules at once, use the `bulkCreateRules()` function.
     * @param - Rule to create.
     * @returns Created rule
     */
    (rule: NonNullablePaths<Rule, `enabled` | `name`, 2>): Promise<NonNullablePaths<Rule, `amount.value` | `amount.currency` | `fixedFee.value` | `fixedFee.currency` | `condition.number.value` | `condition.number.operation` | `condition.list.values` | `condition.path` | `condition.orderFieldPath` | `condition.expectedType.value` | `condition.expectedFieldType` | `conditionTree.operator` | `conditionsType` | `conditionType` | `roundingStrategy` | `tags.privateTags.tagIds`, 4>>;
}
declare function getRule$1(httpClient: HttpClient): GetRuleSignature;
interface GetRuleSignature {
    /**
     * The `createRule()` function returns a Promise that resolves to the retrieved rule.
     * @param - ID of the rule to retrieve.
     * @returns The retrieved rule.
     */
    (ruleId: string): Promise<NonNullablePaths<Rule, `amount.value` | `amount.currency` | `fixedFee.value` | `fixedFee.currency` | `condition.number.value` | `condition.number.operation` | `condition.list.values` | `condition.path` | `condition.orderFieldPath` | `condition.expectedType.value` | `condition.expectedFieldType` | `conditionTree.operator` | `conditionsType` | `conditionType` | `roundingStrategy` | `tags.privateTags.tagIds`, 4>>;
}
declare function updateRule$1(httpClient: HttpClient): UpdateRuleSignature;
interface UpdateRuleSignature {
    /**
     * The `updateRule()` function returns a Promise that resolves to the updated rule.
     *
     *
     * Each time the task is updated, `revision` increments by 1. The existing `revision` must be included when updating the task. This ensures you're working with the latest task and prevents unintended overwrites.
     *
     * To update multiple rules at once, use the `bulkUpdateRules()` function.
     * @param - Rule ID.
     * @returns Updated rule.
     */
    (_id: string, rule: NonNullablePaths<UpdateRule, `revision`, 2>): Promise<NonNullablePaths<Rule, `amount.value` | `amount.currency` | `fixedFee.value` | `fixedFee.currency` | `condition.number.value` | `condition.number.operation` | `condition.list.values` | `condition.path` | `condition.orderFieldPath` | `condition.expectedType.value` | `condition.expectedFieldType` | `conditionTree.operator` | `conditionsType` | `conditionType` | `roundingStrategy` | `tags.privateTags.tagIds`, 4>>;
}
declare function deleteRule$1(httpClient: HttpClient): DeleteRuleSignature;
interface DeleteRuleSignature {
    /**
     * The `deleteRule()` function returns a Promise that resolves to void.
     *
     *
     * To delete multiple rules at once, use the `bulkDeleteRules()` function.
     * @param - ID of the rule to delete.
     */
    (ruleId: string): Promise<void>;
}
declare function listRules$1(httpClient: HttpClient): ListRulesSignature;
interface ListRulesSignature {
    /**
     * The `listRules()` function returns a Promise that resolves to an array of the retrieved rules.
     *
     *
     * You can filter by location or app that the rules are associated with.
     */
    (options?: ListRulesOptions): Promise<NonNullablePaths<ListRulesResponse, `rules` | `rules.${number}.amount.value` | `rules.${number}.amount.currency` | `rules.${number}.fixedFee.value` | `rules.${number}.fixedFee.currency` | `rules.${number}.condition.number.value` | `rules.${number}.condition.number.operation` | `rules.${number}.condition.path` | `rules.${number}.condition.orderFieldPath` | `rules.${number}.condition.expectedType.value` | `rules.${number}.condition.expectedFieldType` | `rules.${number}.conditionTree.operator` | `rules.${number}.conditionsType` | `rules.${number}.conditionType` | `rules.${number}.roundingStrategy`, 6>>;
}
declare function queryRules$1(httpClient: HttpClient): QueryRulesSignature;
interface QueryRulesSignature {
    /**
     * Creates a query to retrieve a list of rules.
     *
     *
     * The `queryRules()` function builds a query to retrieve a list of up to 1,000 rules and returns a `RulesQueryBuilder` object.
     *
     * The returned object contains the query definition which is typically used to run the query using the [`find()`](/service-fees/rules-query-builder/find) function.
     *
     * You can refine the query by chaining `RulesQueryBuilder` functions onto the query. `RulesQueryBuilder` functions enable you to sort, filter, and control the results that `queryRules()` returns. The functions that are chained to `queryRules()` are applied in the order they are called.
     *
     * `queryRules()` runs with the following `RulesQueryBuilder` defaults that you can override:
     *
     * * [`limit(50)`](/service-fees/rules-query-builder/limit)
     * * [`ascending('entityId')`](/service-fees/rules-query-builder/ascending)
     *
     * The following `QueryRulesBuilder` functions are supported for the `queryRules()` function. For a full description of the Rules object, see the object returned for the [`items`](/service-fees/rules-query-result/items) property in `RulesQueryResult`.
     */
    (): RulesQueryBuilder;
}
declare function bulkCreateRules$1(httpClient: HttpClient): BulkCreateRulesSignature;
interface BulkCreateRulesSignature {
    /**
     * The `bulkCreateRules()` function returns a Promise that resolves to the created rules.
     *
     *
     * To create only one rule, use the `createRule()` function.
     * @param - Rules to create.
     */
    (rules: Rule[], options?: BulkCreateRulesOptions): Promise<NonNullablePaths<BulkCreateRulesResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.rule.amount.value` | `results.${number}.rule.amount.currency` | `results.${number}.rule.fixedFee.value` | `results.${number}.rule.fixedFee.currency` | `results.${number}.rule.condition.path` | `results.${number}.rule.condition.orderFieldPath` | `results.${number}.rule.condition.expectedFieldType` | `results.${number}.rule.conditionTree.operator` | `results.${number}.rule.conditionsType` | `results.${number}.rule.conditionType` | `results.${number}.rule.roundingStrategy` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
}
declare function bulkUpdateRules$1(httpClient: HttpClient): BulkUpdateRulesSignature;
interface BulkUpdateRulesSignature {
    /**
     * The `bulkUpdateRules()` function returns a Promise that resolves to the updated rules.
     *
     *
     * Each time the task is updated, `revision` increments by 1. The existing `revision` must be included when updating the task. This ensures you're working with the latest task and prevents unintended overwrites.
     *
     * To update only one rule, use the `updateRule()` function.
     * @param - Masked rules to update.
     */
    (rules: MaskedRule[], options?: BulkUpdateRulesOptions): Promise<NonNullablePaths<BulkUpdateRulesResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.rule.amount.value` | `results.${number}.rule.amount.currency` | `results.${number}.rule.fixedFee.value` | `results.${number}.rule.fixedFee.currency` | `results.${number}.rule.condition.path` | `results.${number}.rule.condition.orderFieldPath` | `results.${number}.rule.condition.expectedFieldType` | `results.${number}.rule.conditionTree.operator` | `results.${number}.rule.conditionsType` | `results.${number}.rule.conditionType` | `results.${number}.rule.roundingStrategy` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
}
declare function bulkDeleteRules$1(httpClient: HttpClient): BulkDeleteRulesSignature;
interface BulkDeleteRulesSignature {
    /**
     * The `bulkDeleteRules()` function returns a Promise that resolves to the deleted rules.
     *
     *
     * To delete only one rule, use the `deleteRule()` function.
     * @param - IDs of the rules to delete.
     */
    (ruleIds: string[]): Promise<NonNullablePaths<BulkDeleteRulesResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `results.${number}.rule.amount.value` | `results.${number}.rule.amount.currency` | `results.${number}.rule.fixedFee.value` | `results.${number}.rule.fixedFee.currency` | `results.${number}.rule.condition.path` | `results.${number}.rule.condition.orderFieldPath` | `results.${number}.rule.condition.expectedFieldType` | `results.${number}.rule.conditionTree.operator` | `results.${number}.rule.conditionsType` | `results.${number}.rule.conditionType` | `results.${number}.rule.roundingStrategy` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6>>;
}
declare function bulkUpdateRuleTags$1(httpClient: HttpClient): BulkUpdateRuleTagsSignature;
interface BulkUpdateRuleTagsSignature {
    /**
     * Synchronously update tags on multiple rules.
     * If you specify a tag in both `assignTags` and `unassignTags`, it is assigned.
     * @param - IDs of the rules to update tags for.
     */
    (ruleIds: string[], options?: BulkUpdateRuleTagsOptions): Promise<NonNullablePaths<BulkUpdateRuleTagsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
        __applicationErrorsType?: BulkUpdateRuleTagsApplicationErrors;
    }>;
}
declare function bulkUpdateRuleTagsByFilter$1(httpClient: HttpClient): BulkUpdateRuleTagsByFilterSignature;
interface BulkUpdateRuleTagsByFilterSignature {
    /**
     * Asynchronously update tags on multiple rules according to the specified filter.
     * If a filter isn't specified, this method updates all rules.
     * If you specify a tag in both `assignTags` and `unassignTags`, it is assigned.
     * @param - Filter that determines which rules to update tags for.
     */
    (filter: Record<string, any>, options?: BulkUpdateRuleTagsByFilterOptions): Promise<NonNullablePaths<BulkUpdateRuleTagsByFilterResponse, `jobId`, 2> & {
        __applicationErrorsType?: BulkUpdateRuleTagsByFilterApplicationErrors;
    }>;
}
declare const onRuleCreated$1: EventDefinition<RuleCreatedEnvelope, "wix.service.fees.v1.rule_created">;
declare const onRuleDeleted$1: EventDefinition<RuleDeletedEnvelope, "wix.service.fees.v1.rule_deleted">;
declare const onRuleUpdated$1: EventDefinition<RuleUpdatedEnvelope, "wix.service.fees.v1.rule_updated">;

declare const calculateServiceFees: MaybeContext<BuildRESTFunction<typeof calculateServiceFees$1> & typeof calculateServiceFees$1>;
declare const createRule: MaybeContext<BuildRESTFunction<typeof createRule$1> & typeof createRule$1>;
declare const getRule: MaybeContext<BuildRESTFunction<typeof getRule$1> & typeof getRule$1>;
declare const updateRule: MaybeContext<BuildRESTFunction<typeof updateRule$1> & typeof updateRule$1>;
declare const deleteRule: MaybeContext<BuildRESTFunction<typeof deleteRule$1> & typeof deleteRule$1>;
declare const listRules: MaybeContext<BuildRESTFunction<typeof listRules$1> & typeof listRules$1>;
declare const queryRules: MaybeContext<BuildRESTFunction<typeof queryRules$1> & typeof queryRules$1>;
declare const bulkCreateRules: MaybeContext<BuildRESTFunction<typeof bulkCreateRules$1> & typeof bulkCreateRules$1>;
declare const bulkUpdateRules: MaybeContext<BuildRESTFunction<typeof bulkUpdateRules$1> & typeof bulkUpdateRules$1>;
declare const bulkDeleteRules: MaybeContext<BuildRESTFunction<typeof bulkDeleteRules$1> & typeof bulkDeleteRules$1>;
declare const bulkUpdateRuleTags: MaybeContext<BuildRESTFunction<typeof bulkUpdateRuleTags$1> & typeof bulkUpdateRuleTags$1>;
declare const bulkUpdateRuleTagsByFilter: MaybeContext<BuildRESTFunction<typeof bulkUpdateRuleTagsByFilter$1> & typeof bulkUpdateRuleTagsByFilter$1>;
/** */
declare const onRuleCreated: BuildEventDefinition<typeof onRuleCreated$1> & typeof onRuleCreated$1;
/** */
declare const onRuleDeleted: BuildEventDefinition<typeof onRuleDeleted$1> & typeof onRuleDeleted$1;
/** */
declare const onRuleUpdated: BuildEventDefinition<typeof onRuleUpdated$1> & typeof onRuleUpdated$1;

export { BulkCreateRulesOptions, BulkCreateRulesResponse, BulkDeleteRulesResponse, BulkUpdateRuleTagsApplicationErrors, BulkUpdateRuleTagsByFilterApplicationErrors, BulkUpdateRuleTagsByFilterOptions, BulkUpdateRuleTagsByFilterResponse, BulkUpdateRuleTagsOptions, BulkUpdateRuleTagsResponse, BulkUpdateRulesOptions, BulkUpdateRulesResponse, CalculateServiceFeesOptions, CalculateServiceFeesResponse, ListRulesOptions, ListRulesResponse, MaskedRule, Order, Rule, RuleCreatedEnvelope, RuleDeletedEnvelope, RuleUpdatedEnvelope, RulesQueryBuilder, UpdateRule, bulkCreateRules, bulkDeleteRules, bulkUpdateRuleTags, bulkUpdateRuleTagsByFilter, bulkUpdateRules, calculateServiceFees, createRule, deleteRule, getRule, listRules, onRuleCreated, onRuleDeleted, onRuleUpdated, queryRules, updateRule };
