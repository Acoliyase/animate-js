"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeoutError = void 0;
const colorText_1 = require("../colorText");
class TimeoutError extends Error {
    constructor(params) {
        const { awaiterName, message, fn, cause, timeout, id } = params;
        const timeoutError = Object.create(Object.getPrototypeOf(cause), Object.getOwnPropertyDescriptors(cause));
        // 10000 => 10_000, 1000000 => 1_000_000
        const formattedTimeout = timeout
            .toString()
            .split('')
            .reverse()
            .reduce((acc, current, index) => {
            const shouldAddUnderscore = index % 3 === 0 && index !== 0;
            return current + (shouldAddUnderscore ? '_' : '') + acc;
        }, '');
        if (message) {
            timeoutError.message = message;
        }
        const messageSection = colorText_1.colorText.red(awaiterName + (id ? ` [id=${id}]` : '') + ` [timeout=${formattedTimeout}]`);
        const functionBody = fn
            .toString()
            .replace('/* istanbul ignore next */', '')
            .replace(/(\/\* eslint-disable-next-line.*\*\/)/, '\n$1')
            .replace(/cov_.*;/gi, '')
            .replace(/\s{2,}/g, '\n')
            .split('\n')
            .map((line, i, lines) => (i !== 0 && i !== lines.length - 1 ? `  ${line}` : line))
            .join('\n');
        const functionBodySection = `\n${colorText_1.colorText.yellow('Function')}\n${functionBody}`;
        const errorsSection = `\n${colorText_1.colorText.yellow('Error')}\n${timeoutError}`;
        super(messageSection + functionBodySection + errorsSection);
        this.cause = cause;
    }
}
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map