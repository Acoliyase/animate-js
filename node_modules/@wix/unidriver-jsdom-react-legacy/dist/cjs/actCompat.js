"use strict";
/* eslint-disable
@typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return,
@typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-unsafe-call,
@typescript-eslint/no-unsafe-argument
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.act = void 0;
const tslib_1 = require("tslib");
/* This file is taken from @testing-library/react (https://github.com/testing-library/react-testing-library/blob/main/src/act-compat.js)
react@16 doesn't have exported act, this file solves it, taking it from react when possible
*/
const react_1 = tslib_1.__importDefault(require("react"));
const test_utils_1 = tslib_1.__importDefault(require("react-dom/test-utils"));
const reactAct = typeof react_1.default.act === 'function' ? react_1.default.act : test_utils_1.default.act;
function getGlobalThis() {
    if (typeof globalThis !== 'undefined') {
        return globalThis;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
}
function setIsReactActEnvironment(isReactActEnvironment) {
    getGlobalThis().IS_REACT_ACT_ENVIRONMENT = isReactActEnvironment;
}
function getIsReactActEnvironment() {
    return getGlobalThis().IS_REACT_ACT_ENVIRONMENT;
}
function withGlobalActEnvironment(actImplementation) {
    return (callback) => {
        const previousActEnvironment = getIsReactActEnvironment();
        setIsReactActEnvironment(true);
        try {
            // The return value of `act` is always a thenable.
            let callbackNeedsToBeAwaited = false;
            const actResult = actImplementation(() => {
                const result = callback();
                if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
                    callbackNeedsToBeAwaited = true;
                }
                return result;
            });
            if (callbackNeedsToBeAwaited) {
                const thenable = actResult;
                return {
                    then: (resolve, reject) => {
                        thenable.then((returnValue) => {
                            setIsReactActEnvironment(previousActEnvironment);
                            resolve(returnValue);
                        }, (error) => {
                            setIsReactActEnvironment(previousActEnvironment);
                            reject(error);
                        });
                    },
                };
            }
            else {
                setIsReactActEnvironment(previousActEnvironment);
                return actResult;
            }
        }
        catch (error) {
            // Can't be a `finally {}` block since we don't know if we have to immediately restore IS_REACT_ACT_ENVIRONMENT
            // or if we have to await the callback first.
            setIsReactActEnvironment(previousActEnvironment);
            throw error;
        }
    };
}
const act = withGlobalActEnvironment(reactAct);
exports.act = act;
//# sourceMappingURL=actCompat.js.map