import { action } from 'mobx';
export const sortableItemTestEvents = ({ id, disabled, state, }) => {
    return {
        onPointerDown: () => {
            if (disabled?.draggable) {
                return;
            }
            state.onDragStart({ active: { id } });
        },
        onPointerUp: async () => {
            if (disabled?.droppable || state.activeId == null) {
                return;
            }
            const isCancelled = await state.beforeDrop({
                active: {
                    id: state.activeId,
                },
                over: {
                    id,
                },
            });
            if (isCancelled) {
                return;
            }
            state.onDragEnd({
                over: {
                    id,
                },
            });
        },
        onMouseMove: (event) => {
            if (disabled?.droppable || state.activeId == null) {
                return;
            }
            state.onDragMove({
                active: { id: state.activeId },
                delta: {
                    x: event.nativeEvent.clientX,
                },
            });
            state.onDragOver({
                over: {
                    id,
                },
            });
        },
        onKeyDown: (e) => {
            const keyboardCodes = state.keyboardCodes;
            if (state.status === 'start' ||
                (state.status === 'over' &&
                    keyboardCodes.move.includes(e.nativeEvent.code))) {
                state.onDragOver({
                    over: {
                        id,
                    },
                });
                return;
            }
        },
    };
};
export const dragHandleTestEvents = ({ id, state, }) => {
    return {
        onKeyDown: action((e) => {
            state.handleEvents?.onKeyDown?.(e);
            const keyboardCodes = state.keyboardCodes;
            if (state.status === 'start' || state.status === 'over') {
                if (keyboardCodes.end.includes(e.nativeEvent.code)) {
                    if (state.activeId == null) {
                        return;
                    }
                    state.beforeDrop({
                        active: { id: state.activeId },
                        over: { id: state.overId },
                    });
                    state.onDragEnd({ over: { id: state.overId } });
                    return;
                }
                if (keyboardCodes.cancel.includes(e.nativeEvent.code)) {
                    state.onDragCancel();
                    return;
                }
            }
            if (keyboardCodes.start.includes(e.nativeEvent.code)) {
                state.onDragStart({ active: { id } });
                return;
            }
        }),
    };
};
//# sourceMappingURL=dndTestEventHandlers.js.map