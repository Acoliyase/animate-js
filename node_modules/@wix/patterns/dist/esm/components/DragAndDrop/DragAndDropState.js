import { action, computed, makeObservable, observable, reaction } from 'mobx';
import { subtract } from '@wix/wix-style-react-incubator/dnd-kit/utilities';
import { hasExceededDistance } from './hasExceededDistance';
import { haveIntersection } from './rectIntersection';
import { EventEmitter } from 'events';
import { v4 as uuid } from 'uuid';
import { emptyRect, RectState } from '../../state/RectState';
export class DragAndDropState {
    constructor(params) {
        this.events = new EventEmitter();
        this.status = null;
        this.activeId = null;
        this._moveDelta = { x: 0 };
        this.overId = null;
        this.droppingId = null;
        this.droppedId = null;
        this._dropAnimationId = null;
        this.reorderModeState = null;
        this._isHandleActive = false;
        this._isKeyboardDragging = false;
        this._moveId = '';
        this._endType = null;
        this._baseAnimation = {
            duration: 250,
            easing: 'cubic-bezier(0.33, 1, 0.68, 1)',
        };
        this.sortableAnimation = {
            ...this._baseAnimation,
        };
        this.dropAnimation = {
            duration: 75,
            easing: 'cubic-bezier(0.33, 1, 0.68, 1)',
            sideEffects: () => {
                this._dropAnimationId = this.droppingId;
                return () => {
                    this.onDropAnimationEnd();
                };
            },
        };
        this.activationConstraint = {
            distance: 1,
        };
        this.keyboardCodes = {
            start: ['Space', 'Enter'],
            cancel: ['Escape', 'Tab'],
            end: ['Space', 'Enter'],
            move: ['ArrowDown'],
        };
        // Should be triggered before `onDragStart` for correct BI
        this.handleEvents = {
            onPointerDown: action(() => {
                this._isHandleActive = true;
            }),
            onKeyDown: action((e) => {
                const { keyboardCodes } = this;
                if (keyboardCodes.start.includes(e.nativeEvent.code)) {
                    this._isHandleActive = true;
                    this._isKeyboardDragging = true;
                    return;
                }
            }),
        };
        this.containerEvents = {
            onPointerDown: action(() => {
                this._isKeyboardDragging = false;
            }),
        };
        this.onDropAnimationEnd = action(() => {
            if (this.droppingId && this.activeId === this.droppingId) {
                this.activeId = null;
                this._isHandleActive = false;
                this.droppedId = this.droppingId;
                this.droppingId = null;
                this._dropAnimationId = null;
                this.events.emit('dropAnimationEnd');
                this._onDragEndBi?.({
                    endType: this._endType,
                });
                this.scheduleIdle();
            }
        });
        this._onGlobalKeydown = action((e) => {
            const { keyboardCodes, activeId } = this;
            if (activeId == null) {
                return;
            }
            if (keyboardCodes.cancel.includes(e.code)) {
                this._endType = 'clicked ESC';
                return;
            }
        });
        this.attachDisabledDragAttempt = (itemId, downEvent, axis) => {
            const state = {
                onDragAttemptEnd: null,
            };
            const coordinates = {
                x: downEvent.x,
                y: downEvent.y,
            };
            const onMouseUp = () => {
                if (state.onDragAttemptEnd) {
                    state.onDragAttemptEnd();
                    state.onDragAttemptEnd = null;
                }
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            const onMove = this.container.lodash.throttle((moveEvent) => {
                const delta = subtract({ x: moveEvent.x, y: moveEvent.y }, coordinates);
                // for detecting drag attempt use larger activation constraint (10px instead of 1px)
                if (process.env.NODE_ENV !== 'test' &&
                    !hasExceededDistance({ delta, measurement: 10, axis })) {
                    return;
                }
                document.removeEventListener('mousemove', onMove);
                state.onDragAttemptEnd = this.bi?.onAttemptDragStart(itemId) ?? null;
            }, 200);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onMouseUp);
        };
        this._maybeShowErrorToast = (shouldCancel, dragEndEvent) => {
            const { container } = this;
            if (shouldCancel && typeof shouldCancel === 'object') {
                this.bi?.onMoveCancelled?.(dragEndEvent);
                container.showToast?.({
                    ...shouldCancel,
                    type: 'ERROR',
                    biName: 'cairo-drag-and-drop-external-logic-error',
                });
            }
        };
        this.container = params.container;
        this.state = params.state;
        this.collection = params.collection;
        this.overlayRect = new RectState({ container: this.container });
        this.events.setMaxListeners(100);
        this.bi = params.bi;
        // We have an issue with pptr where `dropAnimation.sideEffects` is not being called.
        // This ensures `onDropAnimationEnd` will be called eventually, even if `dropAnimation.sideEffects` wasn't called.
        this.scheduleDropEnd = this.container.lodash.debounce(() => {
            // Do not call `onDropAnimationEnd` if _dropAnimationId was set, meaning that `dropAnimation.sideEffects` worked as expected
            if (this._dropAnimationId && this._dropAnimationId === this.droppingId) {
                return;
            }
            this.onDropAnimationEnd();
        }, this.dropAnimation.duration);
        this.scheduleIdle = this.container.lodash.debounce(action(() => {
            if (this.status === 'end' || this.status === 'cancel') {
                this.status = null;
                this._isKeyboardDragging = false;
                this._onDragEndBi = null;
                this._endType = null;
            }
        }), 500);
        this.move = params.move;
        this.nullAnnouncements = {
            onDragStart: () => undefined,
            onDragMove: () => undefined,
            onDragOver: () => undefined,
            onDragEnd: () => undefined,
            onDragCancel: () => undefined,
            listAttributes: () => {
                const { translate: t } = this.container;
                return {
                    'aria-label': t('cairo.dragAndDrop.list-aria-label.sr'),
                };
            },
            ...(params.announcements ?? {}),
        };
        makeObservable(this, {
            activeId: observable.ref,
            overlayRect: observable.ref,
            overId: observable.ref,
            _moveDelta: observable.ref,
            status: observable.ref,
            onDragStart: action,
            init: action,
            beforeDrop: action,
            onDragEnd: action,
            onDragMove: action,
            onDragOver: action,
            onDragCancel: action,
            focusDragHandleIfDropped: action,
            active: computed,
            isActiveRectOutsideContainer: computed,
            over: computed,
            activeIndex: computed,
            isActive: computed,
            droppingId: observable.ref,
            isDropping: computed,
            _isHandleActive: observable.ref,
            reorderModeState: observable.ref,
        });
    }
    get active() {
        const { activeId, collection } = this;
        return activeId != null ? collection.getKeyedItem(activeId) : null;
    }
    get over() {
        const { overId, collection } = this;
        return overId != null ? collection.getKeyedItem(overId) : null;
    }
    get isDropping() {
        return this.droppingId != null;
    }
    get activeIndex() {
        return this.active?.index;
    }
    get isActive() {
        return this.activeId != null;
    }
    onDragMove(event) {
        const { active } = event;
        this._moveDelta = event.delta;
        Object.assign(this.overlayRect.rect, active.rect?.current.translated);
    }
    onDragStart(event) {
        const { events } = this;
        const { active } = event;
        this.status = 'start';
        Object.assign(this.overlayRect.rect, active.rect?.current.translated);
        this.activeId = event.active.id;
        this.overId = this.activeId;
        this._moveId = uuid();
        this._onDragEndBi = this.bi?.onDragStart();
        events.emit('dragStart');
    }
    get isActiveRectOutsideContainer() {
        const { state: { containerRect }, overlayRect: { rect: overlayRect }, } = this;
        if (overlayRect.width == null || containerRect == null) {
            return false;
        }
        return !haveIntersection(overlayRect, containerRect);
    }
    async beforeDrop(event) {
        this.droppingId = this.activeId;
        this.overId = event.over?.id;
        const { active } = event;
        if (active == null) {
            return false;
        }
        const cancelResult = await this.onCancel?.();
        if (cancelResult) {
            return true;
        }
        const rect = active.rect?.current?.translated;
        const container = this.state.containerRect;
        if (rect == null || container == null) {
            return false;
        }
        const shouldCancel = !haveIntersection(rect, container);
        if (shouldCancel) {
            this._endType = 'drop outside';
        }
        return shouldCancel;
    }
    _createDragEndEvent() {
        const { active, collection, overId } = this;
        const { query } = collection;
        if (active == null || overId == null || overId === active.id) {
            return null;
        }
        const from = collection.getKeyedItem(active.id);
        const over = collection.getKeyedItem(overId);
        if (from == null || over == null) {
            return null;
        }
        const after = over.index === 0
            ? null
            : over.index < from.index
                ? collection.getKeyedItemByIndex(over.index - 1)
                : over;
        return {
            moveId: this._moveId,
            from,
            over,
            after,
            query: collection.originQuery,
            filtersKeyHash: query.filtersKeyHash,
            isFromHandle: Boolean(this._isHandleActive),
        };
    }
    _createSimpleDragEndEvent(event) {
        const simplifyIndexedItem = (keyedItem) => ({
            id: keyedItem.id,
            item: keyedItem.item,
            index: keyedItem.index,
        });
        return {
            from: simplifyIndexedItem(event.from),
            after: event.after != null ? simplifyIndexedItem(event.after) : null,
            over: simplifyIndexedItem(event.over),
            filters: event.query.filters,
        };
    }
    onDragCancel() {
        this.status = 'cancel';
        Object.assign(this.overlayRect.rect, emptyRect());
        this.droppingId = this.activeId;
        this.scheduleDropEnd();
    }
    onDragOver(event) {
        this.status = 'over';
        this.overId = event.over?.id;
    }
    onDragEnd(event) {
        this.status = 'end';
        this.overId = event.over?.id;
        Object.assign(this.overlayRect.rect, emptyRect());
        this.move(event);
        this.scheduleDropEnd();
    }
    get isDisabled() {
        const { dragAndDropCategories } = this.state;
        const { query: { hasActiveSort, filtersArray }, } = this.collection;
        const activeFiltersNames = filtersArray
            .filter((filter) => !filter.isEmpty)
            .map((filter) => filter.name);
        if (hasActiveSort) {
            return true;
        }
        if (activeFiltersNames.length) {
            return (dragAndDropCategories == null ||
                !dragAndDropCategories.some((combination) => activeFiltersNames.length === combination.length &&
                    activeFiltersNames.every((name) => combination.includes(name))));
        }
        if (dragAndDropCategories) {
            const hasEmptyCombination = dragAndDropCategories.some((combination) => !combination.length);
            return !hasEmptyCombination;
        }
        return false;
    }
    init() {
        document.addEventListener('keydown', this._onGlobalKeydown);
        const disposers = [
            reaction(() => this.active, (keyedItem) => {
                this.state.forceRenderIndexes = keyedItem
                    ? [keyedItem.index]
                    : undefined;
            }, {
                fireImmediately: true,
            }),
        ];
        return () => {
            document.removeEventListener('keydown', this._onGlobalKeydown);
            disposers.forEach((dispose) => dispose());
        };
    }
    focusDragHandleIfDropped(id, element) {
        const { status, droppedId, droppingId } = this;
        if ((status === 'end' || status === 'cancel') &&
            droppingId == null &&
            droppedId === id &&
            element) {
            element.focus({
                preventScroll: true,
            });
        }
    }
    get reportBi() {
        return this.state.reportBi;
    }
}
//# sourceMappingURL=DragAndDropState.js.map