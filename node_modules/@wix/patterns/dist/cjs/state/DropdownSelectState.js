"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.DropdownSelectState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bexCore = require("@wix/bex-core");
var _mobx = require("mobx");
var _events = require("@wix/bex-core/events");
class DropdownSelectState {
  constructor(params) {
    (0, _defineProperty2.default)(this, "container", void 0);
    (0, _defineProperty2.default)(this, "toolbar", void 0);
    (0, _defineProperty2.default)(this, "select", void 0);
    (0, _defineProperty2.default)(this, "_filter", void 0);
    (0, _defineProperty2.default)(this, "dropdown", new _bexCore.ToggleState());
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    (0, _defineProperty2.default)(this, "toKeyedItem", (item, index) => {
      const {
        filter
      } = this;
      const key = filter.itemKey(item);
      return {
        id: key,
        key,
        item,
        index,
        indexWithinPage: index,
        pageIndex: 0
      };
    });
    this.container = params.container;
    this.toolbar = params.toolbar;
    this.select = params.select ?? new _bexCore.SelectState({
      keyGetter: value => value.key
    });
    this._filter = params.filter;
    (0, _mobx.makeObservable)(this, {
      filterKeyedItems: _mobx.computed,
      filterKeyedItemsMap: _mobx.computed,
      finalFilterKeyedItems: _mobx.computed,
      finalFilterKeyedItemsMap: _mobx.computed,
      selectedItems: (0, _mobx.computed)({
        keepAlive: true
      }),
      set: _mobx.action,
      delete: _mobx.action,
      deleteKey: _mobx.action,
      init: _mobx.action.bound,
      clear: _mobx.action.bound,
      syncSelectedItems: _mobx.action.bound,
      syncSelectedItemsIfChanged: _mobx.action.bound
    });
    this.syncSelectedItems();
  }
  get filterKeyedItemsMap() {
    return new Map(this.filterKeyedItems.map(e => [e.key, e]));
  }
  get filter() {
    return this.toolbar.getPendingFilter(this._filter);
  }
  get hasPendingFilter() {
    return this._filter !== this.filter;
  }
  get finalFilterKeyedItems() {
    const {
      _filter
    } = this;
    return _filter.value.map(this.toKeyedItem);
  }
  get finalFilterKeyedItemsMap() {
    return new Map(this.finalFilterKeyedItems.map(e => [e.key, e]));
  }
  get filterKeyedItems() {
    const {
      filter
    } = this;
    return filter.value.map(this.toKeyedItem);
  }
  syncSelectedItems() {
    const {
      select,
      events
    } = this;
    select.clear();
    select.finalizeMany(this.filterKeyedItems);
    events.emit('syncSelectedItems');
  }
  syncSelectedItemsIfChanged() {
    const {
      selectedItems,
      filter
    } = this;
    if (filter.value !== selectedItems) {
      this.syncSelectedItems();
    }
  }
  get selectedItems() {
    const {
      select
    } = this;
    return select.selectedValues.map(({
      item
    }) => item);
  }
  set(item) {
    const {
      select
    } = this;
    select.set(item);
    this.refreshIfChanged({
      actionType: 'add',
      clickedValueKey: item.key
    });
  }
  setSingle(item) {
    const {
      select
    } = this;
    select.clear();
    this.set(item);
  }
  clear() {
    const {
      select
    } = this;
    select.clear();
    this.refreshIfChanged({
      actionType: 'remove',
      clickedValueKey: ''
    });
  }
  delete(item) {
    const {
      select
    } = this;
    select.delete(item);
    this.refreshIfChanged({
      actionType: 'remove',
      clickedValueKey: item.key
    });
  }
  deleteKey(key) {
    const {
      select
    } = this;
    select.deleteKey(key);
    this.refreshIfChanged({
      actionType: 'remove',
      clickedValueKey: key
    });
  }
  refreshIfChanged(options = {}) {
    const {
      selectedItems,
      filter
    } = this;
    if (filter == null) {
      return;
    }
    if (filter.value === selectedItems) {
      return;
    }
    filter.setValue(selectedItems, {
      emitEvents: ['change', 'beforeRefresh', 'refresh'],
      ...options
    });
  }
  close() {
    const {
      dropdown,
      events
    } = this;
    dropdown.setOff();
    events.emit('close');
  }
  closeAndChangeSelectedItems() {
    this.close();
    const {
      selectedItems,
      filter
    } = this;
    if (filter.value === selectedItems) {
      return;
    }
    filter.setValue(selectedItems, {
      emitEvents: ['change', 'beforeRefresh', 'refresh'],
      actionType: 'add'
    });
  }
  init() {
    const {
      filter
    } = this;
    const disposers = [(0, _mobx.reaction)(() => filter == null ? void 0 : filter.value, this.syncSelectedItemsIfChanged)];
    return () => {
      disposers.forEach(d => d());
    };
  }
}
exports.DropdownSelectState = DropdownSelectState;
//# sourceMappingURL=DropdownSelectState.js.map