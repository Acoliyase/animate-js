"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.DateRangePickerState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bexCore = require("@wix/bex-core");
var _mobx = require("mobx");
var _events = require("@wix/bex-core/events");
class DateRangePickerState {
  get filter() {
    return this.toolbar.getPendingFilter(this._filter);
  }
  set selectedPreset(preset) {
    this._selectedPreset = this._mode === 'ONLY_CUSTOM' ? _bexCore.DateRangePreset.CUSTOM : preset;
  }
  get selectedPreset() {
    return this._mode === 'ONLY_CUSTOM' ? _bexCore.DateRangePreset.CUSTOM : this._selectedPreset;
  }
  constructor(params) {
    (0, _defineProperty2.default)(this, "translate", void 0);
    (0, _defineProperty2.default)(this, "_filter", void 0);
    (0, _defineProperty2.default)(this, "dropdown", new _bexCore.ToggleState());
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    (0, _defineProperty2.default)(this, "toolbar", void 0);
    (0, _defineProperty2.default)(this, "from", null);
    (0, _defineProperty2.default)(this, "to", null);
    (0, _defineProperty2.default)(this, "isFromTimeSet", false);
    (0, _defineProperty2.default)(this, "isToTimeSet", false);
    (0, _defineProperty2.default)(this, "_mode", void 0);
    (0, _defineProperty2.default)(this, "_selectedPreset", _bexCore.DateRangePreset.NONE);
    (0, _defineProperty2.default)(this, "filterByTime", void 0);
    this.toolbar = params.toolbar;
    this.translate = params.translate;
    this._filter = params.filter;
    this.filterByTime = params.filterByTime ?? false;
    this._mode = params.mode;
    (0, _mobx.makeObservable)(this, {
      from: _mobx.observable,
      to: _mobx.observable,
      isFromTimeSet: _mobx.observable.ref,
      isToTimeSet: _mobx.observable.ref,
      _selectedPreset: _mobx.observable,
      init: _mobx.action.bound,
      clear: _mobx.action.bound,
      onFromSelected: _mobx.action.bound,
      onToSelected: _mobx.action.bound,
      onFromTimeSelected: _mobx.action.bound,
      onToTimeSelected: _mobx.action.bound,
      onPresetChanged: _mobx.action.bound
    });
  }
  clearTime() {
    this.isFromTimeSet = false;
    this.isToTimeSet = false;
  }
  clear() {
    this.from = null;
    this.to = null;
    this.clearTime();
    this.refreshIfChanged({
      actionType: 'remove'
    });
  }
  remove() {
    this.selectedPreset = _bexCore.DateRangePreset.NONE;
    this.clear();
  }
  convertToBIFormat(from, to) {
    return `${this.filter.itemKey({
      from,
      to
    })}, ${this.selectedPreset}`;
  }
  refreshIfChanged(options = {}) {
    const {
      from,
      to,
      filter
    } = this;
    if (filter.itemKey(filter.value) !== filter.itemKey({
      from,
      to
    })) {
      filter.setValue({
        from,
        to,
        preset: this.selectedPreset
      }, {
        emitEvents: ['change', 'beforeRefresh', 'refresh'],
        ...options
      });
      return true;
    }
    return false;
  }
  close() {
    const {
      dropdown,
      events
    } = this;
    dropdown.setOff();
    events.emit('close');
  }
  init() {
    const {
      filter
    } = this;
    const disposer = (0, _mobx.reaction)(() => filter.value, () => {
      var _filter$value$from, _this$from, _filter$value$to, _this$to;
      if (!filter.value.from && !filter.value.to) {
        if (filter.value.preset && filter.value.preset !== _bexCore.DateRangePreset.CUSTOM && filter.value.preset !== _bexCore.DateRangePreset.NONE) {
          this.onPresetChanged(filter.value.preset);
          return;
        }
        filter.value.preset ? this.clear() : this.remove();
        return;
      }
      if (((_filter$value$from = filter.value.from) == null ? void 0 : _filter$value$from.valueOf()) === ((_this$from = this.from) == null ? void 0 : _this$from.valueOf()) && ((_filter$value$to = filter.value.to) == null ? void 0 : _filter$value$to.valueOf()) === ((_this$to = this.to) == null ? void 0 : _this$to.valueOf())) {
        return;
      }
      if (filter.value.preset && filter.value.preset !== _bexCore.DateRangePreset.CUSTOM) {
        this.onPresetChanged(filter.value.preset);
        return;
      }
      this.from = filter.value.from;
      this.to = filter.value.to;
      this.selectedPreset = _bexCore.DateRangePreset.CUSTOM;
      this.isFromTimeSet = !!this.from;
      this.isToTimeSet = !!this.to;
    }, {
      fireImmediately: true
    });
    return () => {
      disposer();
    };
  }
  onPresetChanged(newPreset) {
    this.selectedPreset = newPreset;
    if (this.selectedPreset === _bexCore.DateRangePreset.CUSTOM) {
      if (!this.from && !this.to) {
        return;
      }
      this.filter.setValue({
        from: this.from,
        to: this.to,
        preset: this.selectedPreset
      }, {
        emitEvents: ['change']
      });
      return;
    }
    if (this.selectedPreset === _bexCore.DateRangePreset.NONE) {
      return this.clear();
    }
    const {
      from,
      to
    } = (0, _bexCore.getDatesFromPreset)(this.selectedPreset);
    this.from = from;
    this.to = to;
    this.isFromTimeSet = true;
    this.isToTimeSet = true;
    this.refreshIfChanged({
      actionType: 'add',
      clickedValueKey: this.convertToBIFormat(from, to)
    });
  }
  onDateSelected(newDate, curDate, isInvalid, isTimeSet, type) {
    if (!newDate) {
      return {
        date: null,
        isTimeSet: false
      };
    }
    const timeDate = new Date(type === 'from' ? newDate.setHours(0, 0, 0, 0) : newDate.setHours(23, 59, 59, 999));
    // takes the current selected date, and copies its time selection to the new selected date
    const resDate = curDate ? new Date(newDate.setHours(curDate.getHours(), curDate.getMinutes())) : timeDate;
    if (isInvalid(resDate)) {
      return {
        date: timeDate,
        isTimeSet: false
      };
    }
    return {
      date: resDate,
      isTimeSet
    };
  }
  onFromSelected(from) {
    const {
      isTimeSet,
      date
    } = this.onDateSelected(from, this.from, d => !!(this.to && d > this.to), this.isFromTimeSet, 'from');
    this.from = date;
    this.isFromTimeSet = isTimeSet;
  }
  onToSelected(to) {
    const {
      isTimeSet,
      date
    } = this.onDateSelected(to, this.to, d => !!(this.from && d < this.from), this.isToTimeSet, 'to');
    this.to = date;
    this.isToTimeSet = isTimeSet;
  }
  onTimeSelected(newTime, curDate) {
    const fromCpy = new Date(curDate);
    return {
      isTimeSet: !!newTime,
      date: new Date(newTime ? fromCpy.setHours(newTime.getHours(), newTime.getMinutes()) : fromCpy.setHours(0, 0))
    };
  }
  onFromTimeSelected(fromTime) {
    if (!this.from) {
      return;
    }
    const {
      isTimeSet,
      date
    } = this.onTimeSelected(fromTime, this.from);
    this.isFromTimeSet = isTimeSet;
    this.from = date;
    this.refreshIfChanged({
      actionType: 'add',
      clickedValueKey: this.convertToBIFormat(this.from, this.to)
    });
  }
  onToTimeSelected(toTime) {
    if (!this.to) {
      return;
    }
    const {
      isTimeSet,
      date
    } = this.onTimeSelected(toTime, this.to);
    this.isToTimeSet = isTimeSet;
    this.to = date;
    this.refreshIfChanged({
      actionType: 'add',
      clickedValueKey: this.convertToBIFormat(this.from, this.to)
    });
  }
  onFromClosed() {
    this.refreshIfChanged({
      actionType: 'add',
      clickedValueKey: this.convertToBIFormat(this.from, this.to)
    });
  }
  onToClosed() {
    this.refreshIfChanged({
      actionType: 'add',
      clickedValueKey: this.convertToBIFormat(this.from, this.to)
    });
  }
  static _isBiggerOrSameDate(date1, date2) {
    return date1.getFullYear() > date2.getFullYear() || date1.getFullYear() === date2.getFullYear() && date1.getMonth() > date2.getMonth() || date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() >= date2.getDate();
  }
  static _isBiggerDate(date1, date2) {
    return date1.getFullYear() > date2.getFullYear() || date1.getFullYear() === date2.getFullYear() && date1.getMonth() > date2.getMonth() || date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() > date2.getDate();
  }
  filterDateFrom(date) {
    return !this.to || DateRangePickerState._isBiggerOrSameDate(this.to, date);
  }
  filterDateTo(date) {
    return !this.from || DateRangePickerState._isBiggerOrSameDate(date, this.from);
  }
  filterDateTimeFrom(date) {
    if (!this.from) {
      return false;
    }
    return !this.isToTimeSet || !this.to || DateRangePickerState._isBiggerDate(this.to, this.from) || this.to.getHours() * 60 + this.to.getMinutes() >= date.getHours() * 60 + date.getMinutes();
  }
  filterDateTimeTo(date) {
    if (!this.to) {
      return false;
    }
    return !this.isFromTimeSet || !this.from || DateRangePickerState._isBiggerDate(this.to, this.from) || this.from.getHours() * 60 + this.from.getMinutes() <= date.getHours() * 60 + date.getMinutes();
  }
}
exports.DateRangePickerState = DateRangePickerState;
//# sourceMappingURL=DateRangePickerState.js.map