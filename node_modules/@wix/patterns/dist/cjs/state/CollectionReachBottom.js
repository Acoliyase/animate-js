"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.CollectionReachBottom = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _reachBottomListener = require("../reach-bottom-listener");
class CollectionReachBottom {
  constructor(params) {
    (0, _defineProperty2.default)(this, "collection", void 0);
    (0, _defineProperty2.default)(this, "reachBottom", void 0);
    (0, _defineProperty2.default)(this, "triggerListenerIfReached", () => {
      return this.reachBottom.triggerListenerIfReached();
    });
    (0, _defineProperty2.default)(this, "waitForScrollIdle", () => {
      const {
        reachBottom
      } = this;
      // if currently scrolling, return a promise for when the scrolling is idle
      if (!reachBottom.isScrolling) {
        return;
      }
      return new Promise(resolve => {
        reachBottom.events.once('idle', resolve);
      });
    });
    const {
      reachBottomParams,
      lodash
    } = params;
    this.collection = params.collection;
    this.reachBottom = new _reachBottomListener.ReachBottomListener({
      onReachBottom: this.collection.fetchNextPageIfNeeded,
      delay: 200,
      // this constance is a naive heuristic: amount of pixels covered in 250ms (avg server latency) when scrolling 1 pixel per millisecond (avg scrolling speed)
      offsetPX: 250,
      lodash,
      ...reachBottomParams,
      container: (reachBottomParams == null ? void 0 : reachBottomParams.container) ?? new _reachBottomListener.ScrollableWindow()
    });
  }
  subscribe() {
    const {
      reachBottom
    } = this;
    reachBottom.subscribe();
  }
  unsubscribe() {
    const {
      reachBottom,
      collection
    } = this;
    collection.beforeSetData = undefined;
    reachBottom.unsubscribe();
  }
}
exports.CollectionReachBottom = CollectionReachBottom;
//# sourceMappingURL=CollectionReachBottom.js.map