"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.CollectionViewsQueryCompareHelper = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _isEqual = _interopRequireDefault(require("lodash/isEqual"));
var _mobx = require("mobx");
class CollectionViewsQueryCompareHelper {
  get views() {
    return this.collectionViews.views;
  }
  constructor(params) {
    (0, _defineProperty2.default)(this, "collectionViews", void 0);
    (0, _defineProperty2.default)(this, "table", void 0);
    this.table = params.table;
    this.collectionViews = params.collectionViews;
    (0, _mobx.makeObservable)(this, {
      currentViewBase: _mobx.computed,
      isSelectedColumnsChanged: _mobx.computed,
      isSortChanged: _mobx.computed,
      isFiltersChanged: _mobx.computed,
      viewBaseSortDirections: _mobx.computed,
      viewBaseSelectedColumns: _mobx.computed,
      viewBaseFilters: _mobx.computed,
      nonEmptyViewFiltersKeys: _mobx.computed
    });
  }
  get isSelectedColumnsChanged() {
    const {
      collectionViews
    } = this;
    return this.isColumnsChanged(collectionViews.currentViewColumnsOrDefaultColumns, this.viewBaseSelectedColumns);
  }
  isColumnsChanged(columns1, columns2) {
    if (!columns1 || !columns2) {
      return false;
    }
    if (columns1.length !== columns2.length) {
      return true;
    }
    return columns1.some((column, index) => column.id !== columns2[index].id || column.isSelected !== columns2[index].isSelected);
  }
  get isSortChanged() {
    var _currentView$sortDire;
    const currentView = this.views.currentView;
    if (!currentView) {
      return true;
    }
    const sortDirections = this.viewBaseSortDirections;
    return !currentView.sortDirections && !sortDirections ? false : ((_currentView$sortDire = currentView.sortDirections) == null ? void 0 : _currentView$sortDire.length) !== (sortDirections == null ? void 0 : sortDirections.length) || (currentView.sortDirections ?? []).some((sort, i) => (sortDirections == null ? void 0 : sortDirections[i].columnId) !== sort.columnId || (sortDirections == null ? void 0 : sortDirections[i].direction) !== sort.direction);
  }
  get isFiltersChanged() {
    const currentView = this.views.currentView;
    if (!currentView) {
      return true;
    }
    const {
      viewFiltersInCurrentQuery: filters
    } = this;
    const filterKeys = this.nonEmptyViewFiltersKeys;
    const viewAndQueryFiltersKeys = Array.from(new Set([...filterKeys, ...Object.keys(filters)]));
    return filterKeys.length !== Object.keys(filters).length || viewAndQueryFiltersKeys.some(filterName => {
      var _currentView$filters, _this$table$collectio;
      const filter = filters == null ? void 0 : filters[filterName];
      if (!filter) {
        return false;
      }
      const rawFilterValueFromView = (_currentView$filters = currentView.filters) == null || (_currentView$filters = _currentView$filters[filterName]) == null ? void 0 : _currentView$filters.value;
      const currentViewFilterValue = filter.decode(rawFilterValueFromView);
      const appliedFilterValue = filter.value;

      // equals accepts non empty filters
      if (currentViewFilterValue === undefined || appliedFilterValue === undefined) {
        return currentViewFilterValue !== appliedFilterValue;
      }
      const equals = ((_this$table$collectio = this.table.collection.query.filters) == null || (_this$table$collectio = _this$table$collectio[filterName]) == null ? void 0 : _this$table$collectio.equals) ?? _isEqual.default;
      return !equals(currentViewFilterValue, appliedFilterValue);
    });
  }
  get nonEmptyViewFiltersKeys() {
    const currentView = this.views.currentView;
    if (!currentView) {
      return [];
    }
    return Object.keys(currentView.filters ?? {}).reduce((acc, filterName) => {
      var _currentView$filters2;
      const rawFilterValueFromView = (_currentView$filters2 = currentView.filters) == null || (_currentView$filters2 = _currentView$filters2[filterName]) == null ? void 0 : _currentView$filters2.value;
      const filter = this.table.collection.query.filters[filterName];
      if (!filter) {
        return acc;
      }
      const currentViewFilterValue = filter.decode(rawFilterValueFromView);
      return filter.clone({
        initialValue: currentViewFilterValue
      }).isEmpty ? acc : acc.concat(filterName);
    }, []);
  }
  get currentViewBase() {
    return {
      filters: this.viewBaseFilters,
      sortDirections: this.viewBaseSortDirections,
      selectedColumns: this.viewBaseSelectedColumns
    };
  }
  get viewBaseSortDirections() {
    const sortState = this.table.collection.query.sort;
    const sortDirections = sortState.value.map(v => ({
      columnId: v.field,
      direction: v.direction === 'asc' ? 'Ascending' : 'Descending'
    }));
    return sortDirections.length === 0 ? undefined : sortDirections;
  }
  get viewBaseSelectedColumns() {
    return this.table.selectedColumns.value;
  }
  get viewFiltersInCurrentQuery() {
    return this.table.collection.query.activeFiltersEntries.reduce((acc, [filterName, filter]) => {
      return {
        ...acc,
        [filterName]: filter
      };
    }, {});
  }
  get viewBaseFilters() {
    const {
      table: {
        collection: {
          query
        }
      },
      views: {
        currentView
      }
    } = this;
    const {
      activeFiltersEntries
    } = query;
    const newFilters = activeFiltersEntries.reduce((acc, [filterName, filter]) => {
      return {
        ...acc,
        [filterName]: {
          value: filter.encode(filter.value)
        }
      };
    }, {});
    const existingFiltersErase = Object.keys((currentView == null ? void 0 : currentView.filters) ?? {}).reduce((acc, filterName) => {
      acc[filterName] = null;
      return acc;
    }, {});
    return {
      ...existingFiltersErase,
      ...newFilters
    };
  }
}
exports.CollectionViewsQueryCompareHelper = CollectionViewsQueryCompareHelper;
//# sourceMappingURL=CollectionViewsQueryCompareHelper.js.map