"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.CollectionDragAndDropBI = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bexCore = require("@wix/bex-core");
var _bi = require("@wix/bex-core/bi");
var _mobx = require("mobx");
const withoutDefaults = (0, _bexCore.withoutIrrelevant)();
class CollectionDragAndDropBI {
  constructor(params) {
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "collection", void 0);
    (0, _defineProperty2.default)(this, "getCollectionSnapshot", void 0);
    (0, _defineProperty2.default)(this, "getBulkSelectCount", void 0);
    (0, _defineProperty2.default)(this, "getPendingMovePatchesCount", void 0);
    (0, _defineProperty2.default)(this, "startTime", 0);
    (0, _defineProperty2.default)(this, "onAttemptDragStart", (0, _mobx.action)(itemId => {
      if (!this.dnd) {
        return () => {};
      }
      const {
        reportBi,
        dnd,
        collection,
        getBulkSelectCount
      } = this;
      const {
        _isHandleActive
      } = dnd;
      const {
        query: {
          search
        }
      } = collection;
      const item = collection.getKeyedItem(itemId);
      const startTime = performance.now();
      reportBi(withoutDefaults(_bi.cairoDragItem)({
        itemId,
        itemIndex: item == null ? void 0 : item.index,
        isFromHandle: _isHandleActive,
        numItemsBefore: getBulkSelectCount(),
        searchQuery: search.value,
        isFromSearch: !search.isEmpty
      }));
      return (0, _mobx.action)(() => {
        reportBi(withoutDefaults(_bi.cairoDragItemEndDrop)({
          isFromHandle: _isHandleActive,
          itemId,
          itemIndexBefore: item == null ? void 0 : item.index,
          duration: Math.round(performance.now() - startTime),
          endType: 'drag disabled',
          numItemsBefore: getBulkSelectCount(),
          searchQuery: search.value,
          isFromSearch: !search.isEmpty
        }));
      });
    }));
    this.state = params.state;
    this.collection = params.collection;
    this.getCollectionSnapshot = params.getCollectionSnapshot;
    this.getBulkSelectCount = params.getBulkSelectCount;
    this.getPendingMovePatchesCount = params.getPendingMovePatchesCount;
  }
  get dnd() {
    return this.state._dnd;
  }
  get reportBi() {
    return this.state.reportBi;
  }
  onDragStart() {
    if (!this.dnd) {
      return;
    }
    const {
      reportBi,
      dnd,
      collection,
      getBulkSelectCount
    } = this;
    const {
      active,
      _isHandleActive
    } = dnd;
    const {
      query: {
        search
      }
    } = collection;
    if (active == null) {
      return;
    }
    this.startTime = performance.now();
    reportBi(withoutDefaults(_bi.cairoDragItem)({
      itemId: active.key,
      itemIndex: active.index,
      isFromHandle: _isHandleActive,
      numItemsBefore: getBulkSelectCount(),
      searchQuery: search.value,
      isFromSearch: !search.isEmpty,
      dragAndDropID: dnd._moveId
    }));
    return params => {
      const {
        startTime
      } = this;
      const {
        overId
      } = dnd;
      const activeAfter = collection.getKeyedItem(active.key);
      reportBi(withoutDefaults(_bi.cairoDragItemEndDrop)({
        isFromHandle: _isHandleActive,
        itemId: active.key,
        duration: Math.round(performance.now() - startTime),
        endType: params.endType ?? (overId === active.key ? 'drop back' : 'drop succeeded'),
        numItemsBefore: getBulkSelectCount(),
        itemIndexBefore: active.index,
        itemIndexAfter: activeAfter == null ? void 0 : activeAfter.index,
        dragAndDropID: dnd._moveId
      }));
    };
  }
  onMoveFailure(params) {
    const {
      reportBi,
      getBulkSelectCount
    } = this;
    const {
      reason,
      patches
    } = params;
    const errorPatch = patches[0];
    if (!(errorPatch != null && errorPatch.move)) {
      if (process.env.NODE_ENV !== 'production') {
        throw new Error('Missing move data in patch');
      }
      return;
    }
    const {
      from,
      over,
      moveId,
      isFromHandle
    } = errorPatch.move;
    reportBi(withoutDefaults(_bi.cairoDragActionUnsuccessfulUpdateInServer)({
      ...errorPatch.collectionSnapshot,
      numItemsBefore: getBulkSelectCount(),
      numOfWaitingUpdates: patches.length,
      timeFromEndDrag: Date.now() - errorPatch.createdAt,
      itemIndexBefore: from.index,
      itemIndexAfter: over.index,
      errorType: reason,
      itemId: from.key,
      dragAndDropID: moveId,
      wasFromHandle: isFromHandle
    }));
  }
  onMoveCancelled(move) {
    const {
      reportBi,
      getCollectionSnapshot,
      getBulkSelectCount,
      getPendingMovePatchesCount
    } = this;
    const {
      from,
      over,
      moveId,
      isFromHandle
    } = move;
    reportBi(withoutDefaults(_bi.cairoDragActionUnsuccessfulUpdateInServer)({
      ...((getCollectionSnapshot == null ? void 0 : getCollectionSnapshot()) ?? {}),
      numItemsBefore: getBulkSelectCount(),
      numOfWaitingUpdates: getPendingMovePatchesCount() ?? 0,
      timeFromEndDrag: 0,
      itemIndexBefore: from.index,
      itemIndexAfter: over.index,
      errorType: 'External logic',
      itemId: from.key,
      dragAndDropID: moveId,
      wasFromHandle: isFromHandle
    }));
  }
  onMoveRetry(params) {
    const {
      reportBi,
      collection
    } = this;
    const {
      patches
    } = params;
    const {
      query: {
        search
      }
    } = collection;
    const errorPatch = patches[0];
    reportBi(withoutDefaults(_bi.cairoTryAgainClicked)({
      ...errorPatch.collectionSnapshot,
      isFromSearch: !search.isEmpty,
      numOfWaitingUpdates: patches.length,
      actionName: 'drag'
    }));
  }
}
exports.CollectionDragAndDropBI = CollectionDragAndDropBI;
//# sourceMappingURL=CollectionDragAndDropBI.js.map