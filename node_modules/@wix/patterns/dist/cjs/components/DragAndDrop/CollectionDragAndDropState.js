"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.CollectionDragAndDropState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bexCore = require("@wix/bex-core");
var _mobx = require("mobx");
var _DragAndDropState = require("./DragAndDropState");
var _CollectionDragAndDropBI = require("./CollectionDragAndDropBI");
var _createOptimisticActionsOrderByModeReaction = require("../../state/DragAndDrop/createOptimisticActionsOrderByModeReaction");
class CollectionDragAndDropState {
  constructor(params) {
    (0, _defineProperty2.default)(this, "dnd", void 0);
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "bi", void 0);
    (0, _defineProperty2.default)(this, "dragAndDropCancel", void 0);
    (0, _defineProperty2.default)(this, "_onCancel", async () => {
      var _this$dragAndDropCanc;
      const {
        dnd
      } = this;
      const dragEndEvent = dnd._createDragEndEvent();
      if (dragEndEvent == null) {
        return false;
      }
      const shouldCancel = await ((_this$dragAndDropCanc = this.dragAndDropCancel) == null ? void 0 : _this$dragAndDropCanc.call(this, dnd._createSimpleDragEndEvent(dragEndEvent)));
      if (!shouldCancel) {
        return false;
      }
      dnd._maybeShowErrorToast(shouldCancel, dragEndEvent);
      return true;
    });
    const {
      state
    } = params;
    const {
      collection
    } = state;
    this.state = state;
    this.bi = new _CollectionDragAndDropBI.CollectionDragAndDropBI({
      state,
      collection,
      getCollectionSnapshot: state.getCollectionSnapshot,
      getPendingMovePatchesCount: () => {
        var _collection$_optimist;
        return (_collection$_optimist = collection._optimisticActions) == null ? void 0 : _collection$_optimist.pendingMovePatches.length;
      },
      getBulkSelectCount: () => collection.bulkSelect.selectedCount
    });
    this.dnd = new _DragAndDropState.DragAndDropState({
      state: this.state,
      bi: this.bi,
      collection: params.state.collection,
      container: params.container,
      move: () => this._collectionMove(),
      announcements: {
        dragHandleLabel: id => {
          var _this$collection$getK;
          const {
            translate: t
          } = params.container;
          const {
            itemName
          } = this.collection;
          const item = (_this$collection$getK = this.collection.getKeyedItem(id)) == null ? void 0 : _this$collection$getK.item;
          return t('cairo.dragAndDrop.button-role-label.sr', {
            itemName: item ? itemName(item) : ''
          });
        },
        itemDescription: id => {
          var _this$collection$getK2;
          const {
            itemName
          } = this.collection;
          const item = (_this$collection$getK2 = this.collection.getKeyedItem(id)) == null ? void 0 : _this$collection$getK2.item;
          return item ? itemName(item) : '';
        }
      }
    });
    this.dnd.onCancel = this._onCancel;
    (0, _mobx.makeObservable)(this, {
      _collectionMove: _mobx.action
    });
  }
  get collection() {
    return this.state.collection;
  }
  get optimisticActions() {
    return this.collection._optimisticActions;
  }
  init() {
    const {
      optimisticActions,
      dnd,
      bi,
      collection
    } = this;
    const {
      container
    } = dnd;
    const {
      translate: t
    } = container;
    const disposers = [dnd.init(), (0, _createOptimisticActionsOrderByModeReaction.createOptimisticActionsOrderByModeReaction)(dnd, collection), (0, _bexCore.addEventListener)(container.events, 'navigation', () => {
      if (optimisticActions != null && optimisticActions.hasRunningSequence) {
        const patches = optimisticActions.pendingMovePatches;
        return {
          title: t('cairo.dragAndDrop.leaveSite.modal.title'),
          content: t('cairo.dragAndDrop.leaveSite.modal.description'),
          onResume: (0, _mobx.action)(() => {
            bi.onMoveFailure({
              reason: 'Left page',
              patches
            });
          })
        };
      }
      return null;
    }), ...(optimisticActions ? [(0, _bexCore.addEventListener)(optimisticActions.events, 'dragAndDropSequenceError', ({
      patches
    }) => {
      bi.onMoveFailure({
        reason: 'Update failed',
        patches
      });
    }), (0, _bexCore.addEventListener)(optimisticActions.events, 'dragAndDropSequenceRetry', ({
      patches
    }) => {
      bi.onMoveRetry({
        patches
      });
    })] : [])];
    const onWindowClosedDuringSequence = () => {
      if (optimisticActions != null && optimisticActions.hasRunningSequence) {
        bi.onMoveFailure({
          reason: 'Window closed',
          patches: optimisticActions.pendingMovePatches
        });
      }
    };
    window.addEventListener('unload', onWindowClosedDuringSequence);
    return (0, _mobx.action)(() => {
      disposers.forEach(d => d());
      window.removeEventListener('unload', onWindowClosedDuringSequence);
    });
  }
  _collectionMove() {
    var _this$state$getCollec, _this$state;
    const {
      onSubmit,
      reorderModeState
    } = this.dnd;
    const {
      optimisticActions
    } = this;
    if (optimisticActions == null) {
      return;
    }
    const dragEndEvent = this.dnd._createDragEndEvent();
    if (dragEndEvent == null) {
      return;
    }
    optimisticActions.move(dragEndEvent, {
      onTryAgain: async () => {
        await (reorderModeState == null ? void 0 : reorderModeState.onBulkSubmit());
      },
      submit: reorderModeState ? () => reorderModeState == null ? void 0 : reorderModeState.onSubmit : onSubmit ? event => onSubmit(this.dnd._createSimpleDragEndEvent(event)) : undefined,
      collectionSnapshot: ((_this$state$getCollec = (_this$state = this.state).getCollectionSnapshot) == null ? void 0 : _this$state$getCollec.call(_this$state)) ?? {}
    });
  }
}
exports.CollectionDragAndDropState = CollectionDragAndDropState;
//# sourceMappingURL=CollectionDragAndDropState.js.map