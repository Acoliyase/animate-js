"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.DragAndDropState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mobx = require("mobx");
var _utilities = require("@wix/wix-style-react-incubator/dnd-kit/utilities");
var _hasExceededDistance = require("./hasExceededDistance");
var _rectIntersection = require("./rectIntersection");
var _events = require("events");
var _uuid = require("uuid");
var _RectState = require("../../state/RectState");
class DragAndDropState {
  constructor(params) {
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "container", void 0);
    (0, _defineProperty2.default)(this, "collection", void 0);
    (0, _defineProperty2.default)(this, "events", new _events.EventEmitter());
    (0, _defineProperty2.default)(this, "status", null);
    (0, _defineProperty2.default)(this, "activeId", null);
    (0, _defineProperty2.default)(this, "overlayRect", void 0);
    (0, _defineProperty2.default)(this, "_moveDelta", {
      x: 0
    });
    (0, _defineProperty2.default)(this, "overId", null);
    (0, _defineProperty2.default)(this, "droppingId", null);
    (0, _defineProperty2.default)(this, "droppedId", null);
    (0, _defineProperty2.default)(this, "_dropAnimationId", null);
    (0, _defineProperty2.default)(this, "scheduleDropEnd", void 0);
    (0, _defineProperty2.default)(this, "scheduleIdle", void 0);
    (0, _defineProperty2.default)(this, "move", void 0);
    (0, _defineProperty2.default)(this, "onSubmit", void 0);
    (0, _defineProperty2.default)(this, "onBulkSubmit", void 0);
    (0, _defineProperty2.default)(this, "onCancel", void 0);
    (0, _defineProperty2.default)(this, "reorderModeState", null);
    (0, _defineProperty2.default)(this, "bi", void 0);
    (0, _defineProperty2.default)(this, "_isHandleActive", false);
    (0, _defineProperty2.default)(this, "_isKeyboardDragging", false);
    (0, _defineProperty2.default)(this, "_moveId", '');
    (0, _defineProperty2.default)(this, "_onDragEndBi", void 0);
    (0, _defineProperty2.default)(this, "_endType", null);
    (0, _defineProperty2.default)(this, "_baseAnimation", {
      duration: 250,
      easing: 'cubic-bezier(0.33, 1, 0.68, 1)'
    });
    (0, _defineProperty2.default)(this, "sortableAnimation", {
      ...this._baseAnimation
    });
    (0, _defineProperty2.default)(this, "dropAnimation", {
      duration: 75,
      easing: 'cubic-bezier(0.33, 1, 0.68, 1)',
      sideEffects: () => {
        this._dropAnimationId = this.droppingId;
        return () => {
          this.onDropAnimationEnd();
        };
      }
    });
    (0, _defineProperty2.default)(this, "activationConstraint", {
      distance: 1
    });
    (0, _defineProperty2.default)(this, "keyboardCodes", {
      start: ['Space', 'Enter'],
      cancel: ['Escape', 'Tab'],
      end: ['Space', 'Enter'],
      move: ['ArrowDown']
    });
    (0, _defineProperty2.default)(this, "nullAnnouncements", void 0);
    // Should be triggered before `onDragStart` for correct BI
    (0, _defineProperty2.default)(this, "handleEvents", {
      onPointerDown: (0, _mobx.action)(() => {
        this._isHandleActive = true;
      }),
      onKeyDown: (0, _mobx.action)(e => {
        const {
          keyboardCodes
        } = this;
        if (keyboardCodes.start.includes(e.nativeEvent.code)) {
          this._isHandleActive = true;
          this._isKeyboardDragging = true;
          return;
        }
      })
    });
    (0, _defineProperty2.default)(this, "containerEvents", {
      onPointerDown: (0, _mobx.action)(() => {
        this._isKeyboardDragging = false;
      })
    });
    (0, _defineProperty2.default)(this, "onDropAnimationEnd", (0, _mobx.action)(() => {
      if (this.droppingId && this.activeId === this.droppingId) {
        var _this$_onDragEndBi;
        this.activeId = null;
        this._isHandleActive = false;
        this.droppedId = this.droppingId;
        this.droppingId = null;
        this._dropAnimationId = null;
        this.events.emit('dropAnimationEnd');
        (_this$_onDragEndBi = this._onDragEndBi) == null || _this$_onDragEndBi.call(this, {
          endType: this._endType
        });
        this.scheduleIdle();
      }
    }));
    (0, _defineProperty2.default)(this, "_onGlobalKeydown", (0, _mobx.action)(e => {
      const {
        keyboardCodes,
        activeId
      } = this;
      if (activeId == null) {
        return;
      }
      if (keyboardCodes.cancel.includes(e.code)) {
        this._endType = 'clicked ESC';
        return;
      }
    }));
    (0, _defineProperty2.default)(this, "attachDisabledDragAttempt", (itemId, downEvent, axis) => {
      const state = {
        onDragAttemptEnd: null
      };
      const coordinates = {
        x: downEvent.x,
        y: downEvent.y
      };
      const onMouseUp = () => {
        if (state.onDragAttemptEnd) {
          state.onDragAttemptEnd();
          state.onDragAttemptEnd = null;
        }
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      const onMove = this.container.lodash.throttle(moveEvent => {
        var _this$bi;
        const delta = (0, _utilities.subtract)({
          x: moveEvent.x,
          y: moveEvent.y
        }, coordinates);

        // for detecting drag attempt use larger activation constraint (10px instead of 1px)
        if (process.env.NODE_ENV !== 'test' && !(0, _hasExceededDistance.hasExceededDistance)({
          delta,
          measurement: 10,
          axis
        })) {
          return;
        }
        document.removeEventListener('mousemove', onMove);
        state.onDragAttemptEnd = ((_this$bi = this.bi) == null ? void 0 : _this$bi.onAttemptDragStart(itemId)) ?? null;
      }, 200);
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onMouseUp);
    });
    (0, _defineProperty2.default)(this, "_maybeShowErrorToast", (shouldCancel, dragEndEvent) => {
      const {
        container
      } = this;
      if (shouldCancel && typeof shouldCancel === 'object') {
        var _this$bi2;
        (_this$bi2 = this.bi) == null || _this$bi2.onMoveCancelled == null || _this$bi2.onMoveCancelled(dragEndEvent);
        container.showToast == null || container.showToast({
          ...shouldCancel,
          type: 'ERROR',
          biName: 'cairo-drag-and-drop-external-logic-error'
        });
      }
    });
    this.container = params.container;
    this.state = params.state;
    this.collection = params.collection;
    this.overlayRect = new _RectState.RectState({
      container: this.container
    });
    this.events.setMaxListeners(100);
    this.bi = params.bi;

    // We have an issue with pptr where `dropAnimation.sideEffects` is not being called.
    // This ensures `onDropAnimationEnd` will be called eventually, even if `dropAnimation.sideEffects` wasn't called.
    this.scheduleDropEnd = this.container.lodash.debounce(() => {
      // Do not call `onDropAnimationEnd` if _dropAnimationId was set, meaning that `dropAnimation.sideEffects` worked as expected
      if (this._dropAnimationId && this._dropAnimationId === this.droppingId) {
        return;
      }
      this.onDropAnimationEnd();
    }, this.dropAnimation.duration);
    this.scheduleIdle = this.container.lodash.debounce((0, _mobx.action)(() => {
      if (this.status === 'end' || this.status === 'cancel') {
        this.status = null;
        this._isKeyboardDragging = false;
        this._onDragEndBi = null;
        this._endType = null;
      }
    }), 500);
    this.move = params.move;
    this.nullAnnouncements = {
      onDragStart: () => undefined,
      onDragMove: () => undefined,
      onDragOver: () => undefined,
      onDragEnd: () => undefined,
      onDragCancel: () => undefined,
      listAttributes: () => {
        const {
          translate: t
        } = this.container;
        return {
          'aria-label': t('cairo.dragAndDrop.list-aria-label.sr')
        };
      },
      ...(params.announcements ?? {})
    };
    (0, _mobx.makeObservable)(this, {
      activeId: _mobx.observable.ref,
      overlayRect: _mobx.observable.ref,
      overId: _mobx.observable.ref,
      _moveDelta: _mobx.observable.ref,
      status: _mobx.observable.ref,
      onDragStart: _mobx.action,
      init: _mobx.action,
      beforeDrop: _mobx.action,
      onDragEnd: _mobx.action,
      onDragMove: _mobx.action,
      onDragOver: _mobx.action,
      onDragCancel: _mobx.action,
      focusDragHandleIfDropped: _mobx.action,
      active: _mobx.computed,
      isActiveRectOutsideContainer: _mobx.computed,
      over: _mobx.computed,
      activeIndex: _mobx.computed,
      isActive: _mobx.computed,
      droppingId: _mobx.observable.ref,
      isDropping: _mobx.computed,
      _isHandleActive: _mobx.observable.ref,
      reorderModeState: _mobx.observable.ref
    });
  }
  get active() {
    const {
      activeId,
      collection
    } = this;
    return activeId != null ? collection.getKeyedItem(activeId) : null;
  }
  get over() {
    const {
      overId,
      collection
    } = this;
    return overId != null ? collection.getKeyedItem(overId) : null;
  }
  get isDropping() {
    return this.droppingId != null;
  }
  get activeIndex() {
    var _this$active;
    return (_this$active = this.active) == null ? void 0 : _this$active.index;
  }
  get isActive() {
    return this.activeId != null;
  }
  onDragMove(event) {
    var _active$rect;
    const {
      active
    } = event;
    this._moveDelta = event.delta;
    Object.assign(this.overlayRect.rect, (_active$rect = active.rect) == null ? void 0 : _active$rect.current.translated);
  }
  onDragStart(event) {
    var _active$rect2, _this$bi3;
    const {
      events
    } = this;
    const {
      active
    } = event;
    this.status = 'start';
    Object.assign(this.overlayRect.rect, (_active$rect2 = active.rect) == null ? void 0 : _active$rect2.current.translated);
    this.activeId = event.active.id;
    this.overId = this.activeId;
    this._moveId = (0, _uuid.v4)();
    this._onDragEndBi = (_this$bi3 = this.bi) == null ? void 0 : _this$bi3.onDragStart();
    events.emit('dragStart');
  }
  get isActiveRectOutsideContainer() {
    const {
      state: {
        containerRect
      },
      overlayRect: {
        rect: overlayRect
      }
    } = this;
    if (overlayRect.width == null || containerRect == null) {
      return false;
    }
    return !(0, _rectIntersection.haveIntersection)(overlayRect, containerRect);
  }
  async beforeDrop(event) {
    var _event$over, _this$onCancel, _active$rect3;
    this.droppingId = this.activeId;
    this.overId = (_event$over = event.over) == null ? void 0 : _event$over.id;
    const {
      active
    } = event;
    if (active == null) {
      return false;
    }
    const cancelResult = await ((_this$onCancel = this.onCancel) == null ? void 0 : _this$onCancel.call(this));
    if (cancelResult) {
      return true;
    }
    const rect = (_active$rect3 = active.rect) == null || (_active$rect3 = _active$rect3.current) == null ? void 0 : _active$rect3.translated;
    const container = this.state.containerRect;
    if (rect == null || container == null) {
      return false;
    }
    const shouldCancel = !(0, _rectIntersection.haveIntersection)(rect, container);
    if (shouldCancel) {
      this._endType = 'drop outside';
    }
    return shouldCancel;
  }
  _createDragEndEvent() {
    const {
      active,
      collection,
      overId
    } = this;
    const {
      query
    } = collection;
    if (active == null || overId == null || overId === active.id) {
      return null;
    }
    const from = collection.getKeyedItem(active.id);
    const over = collection.getKeyedItem(overId);
    if (from == null || over == null) {
      return null;
    }
    const after = over.index === 0 ? null : over.index < from.index ? collection.getKeyedItemByIndex(over.index - 1) : over;
    return {
      moveId: this._moveId,
      from,
      over,
      after,
      query: collection.originQuery,
      filtersKeyHash: query.filtersKeyHash,
      isFromHandle: Boolean(this._isHandleActive)
    };
  }
  _createSimpleDragEndEvent(event) {
    const simplifyIndexedItem = keyedItem => ({
      id: keyedItem.id,
      item: keyedItem.item,
      index: keyedItem.index
    });
    return {
      from: simplifyIndexedItem(event.from),
      after: event.after != null ? simplifyIndexedItem(event.after) : null,
      over: simplifyIndexedItem(event.over),
      filters: event.query.filters
    };
  }
  onDragCancel() {
    this.status = 'cancel';
    Object.assign(this.overlayRect.rect, (0, _RectState.emptyRect)());
    this.droppingId = this.activeId;
    this.scheduleDropEnd();
  }
  onDragOver(event) {
    var _event$over2;
    this.status = 'over';
    this.overId = (_event$over2 = event.over) == null ? void 0 : _event$over2.id;
  }
  onDragEnd(event) {
    var _event$over3;
    this.status = 'end';
    this.overId = (_event$over3 = event.over) == null ? void 0 : _event$over3.id;
    Object.assign(this.overlayRect.rect, (0, _RectState.emptyRect)());
    this.move(event);
    this.scheduleDropEnd();
  }
  get isDisabled() {
    const {
      dragAndDropCategories
    } = this.state;
    const {
      query: {
        hasActiveSort,
        filtersArray
      }
    } = this.collection;
    const activeFiltersNames = filtersArray.filter(filter => !filter.isEmpty).map(filter => filter.name);
    if (hasActiveSort) {
      return true;
    }
    if (activeFiltersNames.length) {
      return dragAndDropCategories == null || !dragAndDropCategories.some(combination => activeFiltersNames.length === combination.length && activeFiltersNames.every(name => combination.includes(name)));
    }
    if (dragAndDropCategories) {
      const hasEmptyCombination = dragAndDropCategories.some(combination => !combination.length);
      return !hasEmptyCombination;
    }
    return false;
  }
  init() {
    document.addEventListener('keydown', this._onGlobalKeydown);
    const disposers = [(0, _mobx.reaction)(() => this.active, keyedItem => {
      this.state.forceRenderIndexes = keyedItem ? [keyedItem.index] : undefined;
    }, {
      fireImmediately: true
    })];
    return () => {
      document.removeEventListener('keydown', this._onGlobalKeydown);
      disposers.forEach(dispose => dispose());
    };
  }
  focusDragHandleIfDropped(id, element) {
    const {
      status,
      droppedId,
      droppingId
    } = this;
    if ((status === 'end' || status === 'cancel') && droppingId == null && droppedId === id && element) {
      element.focus({
        preventScroll: true
      });
    }
  }
  get reportBi() {
    return this.state.reportBi;
  }
}
exports.DragAndDropState = DragAndDropState;
//# sourceMappingURL=DragAndDropState.js.map