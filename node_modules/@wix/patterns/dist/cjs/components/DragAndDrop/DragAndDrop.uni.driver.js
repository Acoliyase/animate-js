"use strict";

exports.__esModule = true;
exports.DragAndDropUniDriver = DragAndDropUniDriver;
var _unidriver = require("../../unidriver");
const {
  fireEvent = null
} = process.env.NODE_ENV === 'test' ? (() => {
  try {
    return require('@testing-library/react');
  } catch {}
  return null;
})() || (() => {
  try {
    // eslint-disable-next-line import/no-extraneous-dependencies
    return require('@testing-library/dom');
  } catch {}
  return null;
})() : {};
function DragAndDropUniDriver(base) {
  return {
    ...(0, _unidriver.baseUniDriverFactory)(base),
    escapeDrag: async (source, {
      key: code = 'Escape'
    } = {}) => {
      const sourceNative = await source.getNative();
      const {
        page
      } = sourceNative;
      if (page != null && page.evaluate) {} else if (process.env.NODE_ENV === 'test') {
        fireEvent.keyDown(sourceNative, {
          code
        });
      }
    },
    startKeyboardDrag: async source => {
      const sourceNative = await source.getNative();
      const {
        page
      } = sourceNative;
      if (page != null && page.evaluate) {} else if (fireEvent) {
        fireEvent.keyDown(sourceNative, {
          code: 'Enter'
        });
      }
    },
    dragOverKeyboard: async target => {
      const targetNative = await target.getNative();
      const {
        page
      } = targetNative;
      if (page != null && page.evaluate) {} else if (fireEvent) {
        fireEvent.keyDown(targetNative, {
          code: 'ArrowDown'
        });
      }
    },
    endKeyboardDrag: async target => {
      const targetNative = await target.getNative();
      const {
        page
      } = targetNative;
      if (page != null && page.evaluate) {} else if (fireEvent) {
        return fireEvent.keyDown(targetNative, {
          code: 'Enter'
        });
      }
    },
    dragStart: async (source, options = {}) => {
      const sourceNative = await source.getNative();
      const page = options.page ?? sourceNative.page;
      if (page != null && page.evaluate) {
        const sourceBox = await sourceNative.element.boundingBox();
        await page.mouse.move(options.x ?? sourceBox.x + sourceBox.width / 2, options.y ?? sourceBox.y + sourceBox.height / 2);
        await page.mouse.down();
      } else if (fireEvent) {
        fireEvent.pointerDown(sourceNative);
      }
    },
    dragMove: async () => {
      await document.dispatchEvent(new Event('mousemove'));
    },
    dragEnd: async (target, options = {}) => {
      const targetNative = await target.getNative();
      const page = options.page ?? targetNative.page;
      if (page != null && page.evaluate) {
        await (page == null ? void 0 : page.mouse.up());
      } else if (fireEvent) {
        fireEvent.pointerUp(targetNative);
        await document.dispatchEvent(new Event('mouseup'));
      }
    },
    dragOver: async (source, target, {
      dragPointRatio = {
        x: 2,
        y: 2
      },
      dropPointRatio = {
        x: 2,
        y: 2
      },
      steps = 3
    } = {}) => {
      const sourceRow = await source.getNative();
      const targetRow = await target.getNative();
      if (source.type === 'puppeteer') {
        const {
          page
        } = sourceRow;
        await source.hover();
        const sourceBox = await sourceRow.element.boundingBox();
        const targetBox = await targetRow.element.boundingBox();
        await page.mouse.move(sourceBox.x + sourceBox.width / dragPointRatio.x, sourceBox.y + sourceBox.height / dragPointRatio.y);
        await page.mouse.down();
        await new Promise(resolve => setTimeout(resolve, 100));
        await page.mouse.move(targetBox.x + targetBox.width / dropPointRatio.x, targetBox.y + targetBox.height / dropPointRatio.y, {
          steps
        });
        await new Promise(resolve => setTimeout(resolve, 100));
        await page.mouse.up();
        await new Promise(resolve => setTimeout(resolve, 100)); // wait for drop animation to complete
      } else if (fireEvent) {
        fireEvent.pointerDown(sourceRow);
        document.dispatchEvent(new Event('mousemove'));
        fireEvent.pointerUp(targetRow);
      }
    },
    moveOver: async (target, options = {}) => {
      const targetRow = await target.getNative();
      const page = options.page ?? targetRow.page;
      const pixels = options.pixels ?? 0;
      if (page != null && page.evaluate) {
        const targetBox = await targetRow.element.boundingBox();
        for (let i = 0; i < 2; i++) {
          var _options$delta;
          await page.mouse.move(Math.max(((_options$delta = options.delta) == null ? void 0 : _options$delta.x) ?? targetBox.x - pixels, 0), Math.max(targetBox.y + targetBox.height - pixels, 0));
        }
      } else if (fireEvent) {
        var _options$delta2;
        fireEvent.mouseMove(targetRow, {
          clientX: ((_options$delta2 = options.delta) == null ? void 0 : _options$delta2.x) ?? 0
        });
      }
    },
    moveAny: async (source, options) => {
      const sourceNative = await source.getNative();
      const page = (options == null ? void 0 : options.page) ?? sourceNative.page;
      if (page != null && page.evaluate) {
        const sourceBox = await sourceNative.element.boundingBox();
        const steps = (options == null ? void 0 : options.steps) ?? 3;
        for (let i = steps; i >= 0; i--) {
          await page.mouse.move(((options == null ? void 0 : options.x) ?? sourceBox.x + sourceBox.width / 2) - i * 10, ((options == null ? void 0 : options.y) ?? sourceBox.y + sourceBox.height / 2) - (options != null && options.vertical ? i * 10 : 0));
          await new Promise(resolve => setTimeout(resolve, (options == null ? void 0 : options.delay) ?? 2000));
        }
      }
    }
  };
}
//# sourceMappingURL=DragAndDrop.uni.driver.js.map