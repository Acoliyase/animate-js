"use strict";

exports.__esModule = true;
exports.createUseIsDropDisabled = void 0;
var _useSelector = require("../../useSelector");
/**
 * Factory function to create a custom hook `useIsDropDisabled` that determines
 * whether the drop is disabled for a given node based on drag-and-drop state.
 */
const createUseIsDropDisabled = state => {
  return targetNodeId => {
    var _state$nestedState$ge, _state$nestedState$ge2, _state$nestedState$ge3, _state$nestedState$ge4, _nextItem$item$state;
    // Get the ID of the currently active (dragged) item
    const activeItemId = (0, _useSelector.useSelector)(() => state.dnd.activeId);

    // If there's no active (dragged) item, disable dropping
    if (!activeItemId) {
      return true;
    }

    // Retrieve the state of the active (dragged) item and the target (hovered) item
    const activeItemState = (_state$nestedState$ge = state.nestedState.getKeyedItem(activeItemId)) == null ? void 0 : _state$nestedState$ge.item.state;
    const targetItemState = (_state$nestedState$ge2 = state.nestedState.getKeyedItem(targetNodeId.toString())) == null ? void 0 : _state$nestedState$ge2.item.state;

    // If either the active or target node is missing, disable dropping
    if (!activeItemState || !targetItemState) {
      return true;
    }
    const activeKeyedItem = state.dnd.collection.getKeyedItem(activeItemId);
    const targetKeyedItem = state.dnd.collection.getKeyedItem(targetNodeId.toString());
    if (!activeKeyedItem || !targetKeyedItem) {
      return true;
    }

    // If levels contain the same entity, dropping is always allowed
    if (state.isSameEntityAsOtherLevels) {
      return false;
    }

    // Get the index of the active (dragged) item and the target (hovered) item in the nested state
    const activeItemIndex = ((_state$nestedState$ge3 = state.nestedState.getKeyedItem(activeItemId)) == null ? void 0 : _state$nestedState$ge3.index) || 0;
    const targetItemIndex = ((_state$nestedState$ge4 = state.nestedState.getKeyedItem(targetNodeId.toString())) == null ? void 0 : _state$nestedState$ge4.index) || 0;

    // Get the previous and next items relative to the target item
    const previousItem = activeItemIndex >= targetItemIndex ? state.nestedState.keyedItems[targetItemIndex - 1] : state.nestedState.keyedItems[targetItemIndex];
    const nextItem = activeItemIndex <= targetItemIndex ? state.nestedState.keyedItems[targetItemIndex + 1] : state.nestedState.keyedItems[targetItemIndex];

    // Check if the dragged item is moving down to a sublevel
    const isMovingDownToSublevel = targetItemState.childrenDepth === activeItemState.childrenDepth - 1 && nextItem != null && nextItem.item.state.childrenDepth >= activeItemState.childrenDepth && targetItemIndex === (previousItem == null ? void 0 : previousItem.index);
    if (isMovingDownToSublevel) {
      return false;
    }

    // Check if the dragged item is moving up to a sublevel
    const isMovingUpToSubLevel = targetItemState.childrenDepth === activeItemState.childrenDepth - 1 && (previousItem == null ? void 0 : previousItem.item.state.childrenDepth) === activeItemState.childrenDepth && (nextItem == null || nextItem.item.state.childrenDepth < activeItemState.childrenDepth) && targetItemIndex === (nextItem == null ? void 0 : nextItem.index);
    if (isMovingUpToSubLevel) {
      return false;
    }

    // Determine if the target item has children
    const targetItemHasChildren = targetItemState.childrenDepth + 1 === (nextItem == null || (_nextItem$item$state = nextItem.item.state) == null ? void 0 : _nextItem$item$state.childrenDepth);

    // Check if the dragged item is on the same level without children
    const isSameLevelWithoutChildren = !targetItemHasChildren && targetItemState.childrenDepth === activeItemState.childrenDepth;
    if (isSameLevelWithoutChildren) {
      return false;
    }

    // Check if the dragged item is moving to the next level after a node without children
    const isNextLevelWithoutChildren = !targetItemHasChildren && (previousItem == null ? void 0 : previousItem.item.state.childrenDepth) === activeItemState.childrenDepth - 1;
    if (isNextLevelWithoutChildren) {
      return false;
    }

    // Check if the dragged item is stepping out to the same level (not entering a sublevel)
    const isStepOutToSameLevel = !targetItemHasChildren && previousItem != null && previousItem.item.state.childrenDepth >= activeItemState.childrenDepth + 1 && (nextItem == null || nextItem.item.state.childrenDepth <= activeItemState.childrenDepth);
    if (isStepOutToSameLevel) {
      return false;
    }
    return true;
  };
};
exports.createUseIsDropDisabled = createUseIsDropDisabled;
//# sourceMappingURL=createUseIsDropDisabled.js.map