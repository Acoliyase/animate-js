"use strict";

exports.__esModule = true;
exports.sortableItemTestEvents = exports.dragHandleTestEvents = void 0;
var _mobx = require("mobx");
const sortableItemTestEvents = ({
  id,
  disabled,
  state
}) => {
  return {
    onPointerDown: () => {
      if (disabled != null && disabled.draggable) {
        return;
      }
      state.onDragStart({
        active: {
          id
        }
      });
    },
    onPointerUp: async () => {
      if (disabled != null && disabled.droppable || state.activeId == null) {
        return;
      }
      const isCancelled = await state.beforeDrop({
        active: {
          id: state.activeId
        },
        over: {
          id
        }
      });
      if (isCancelled) {
        return;
      }
      state.onDragEnd({
        over: {
          id
        }
      });
    },
    onMouseMove: event => {
      if (disabled != null && disabled.droppable || state.activeId == null) {
        return;
      }
      state.onDragMove({
        active: {
          id: state.activeId
        },
        delta: {
          x: event.nativeEvent.clientX
        }
      });
      state.onDragOver({
        over: {
          id
        }
      });
    },
    onKeyDown: e => {
      const keyboardCodes = state.keyboardCodes;
      if (state.status === 'start' || state.status === 'over' && keyboardCodes.move.includes(e.nativeEvent.code)) {
        state.onDragOver({
          over: {
            id
          }
        });
        return;
      }
    }
  };
};
exports.sortableItemTestEvents = sortableItemTestEvents;
const dragHandleTestEvents = ({
  id,
  state
}) => {
  return {
    onKeyDown: (0, _mobx.action)(e => {
      var _state$handleEvents;
      (_state$handleEvents = state.handleEvents) == null || _state$handleEvents.onKeyDown == null || _state$handleEvents.onKeyDown(e);
      const keyboardCodes = state.keyboardCodes;
      if (state.status === 'start' || state.status === 'over') {
        if (keyboardCodes.end.includes(e.nativeEvent.code)) {
          if (state.activeId == null) {
            return;
          }
          state.beforeDrop({
            active: {
              id: state.activeId
            },
            over: {
              id: state.overId
            }
          });
          state.onDragEnd({
            over: {
              id: state.overId
            }
          });
          return;
        }
        if (keyboardCodes.cancel.includes(e.nativeEvent.code)) {
          state.onDragCancel();
          return;
        }
      }
      if (keyboardCodes.start.includes(e.nativeEvent.code)) {
        state.onDragStart({
          active: {
            id
          }
        });
        return;
      }
    })
  };
};
exports.dragHandleTestEvents = dragHandleTestEvents;
//# sourceMappingURL=dndTestEventHandlers.js.map