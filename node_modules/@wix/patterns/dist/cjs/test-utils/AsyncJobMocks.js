"use strict";

exports.__esModule = true;
exports.anAsyncJob = void 0;
exports.asyncJobMocks = asyncJobMocks;
exports.resolveAsyncJob = exports.rejectAsyncJob = void 0;
var _chance = require("chance");
var _http = require("@wix/bex-utils/@wix/ambassador-infra-asyncjobs-v1-async-job/http");
const chance = new _chance.Chance();
const anAsyncJob = (overrides = {}) => ({
  id: `${chance.word()}_${chance.integer({
    min: 0,
    max: 1000
  })}`,
  status: 'FINISHED',
  ...overrides
});
exports.anAsyncJob = anAsyncJob;
const resolveAsyncJob = ({
  whenRequest,
  job,
  spy,
  persist = true
}) => {
  const request = whenRequest(_http.getAsyncJob).reply(200, async () => {
    if (spy) {
      spy();
    }
    const data = {
      job
    };
    return data;
  });
  if (persist) {
    return request.persist();
  }
  return request;
};
exports.resolveAsyncJob = resolveAsyncJob;
const rejectAsyncJob = ({
  whenRequest,
  persist = true
}) => {
  const request = whenRequest(_http.getAsyncJob).reply(400, async () => {
    return new Promise((_, reject) => window.setTimeout(() => {
      return reject(new Error('Async job failed'));
    }, 0));
  });
  if (persist) {
    return request.persist();
  }
  return request;
};
exports.rejectAsyncJob = rejectAsyncJob;
function asyncJobMocks(whenRequest) {
  return {
    mocks: [whenRequest(_http.getAsyncJob).reply(200, async () => {
      const res = {
        job: anAsyncJob()
      };
      return res;
    }).persist()]
  };
}
//# sourceMappingURL=AsyncJobMocks.js.map