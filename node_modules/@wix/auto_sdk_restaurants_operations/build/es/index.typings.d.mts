import { NonNullablePaths } from '@wix/sdk-types';

/**
 * An operation is a service a restaurant offers that includes various aspects of its online ordering.
 * You can define default fulfillments, service fees, and scheduling requirements for each operation.
 */
interface Operation extends OperationOnlineOrderingStatusOptionsOneOf {
    /** Options for online ordering status. Required when `onlineOrderingStatus` is `PAUSED_UNTIL`. */
    pausedUntilOptions?: OnlineOrderingPausedUntilOptions;
    /**
     * Operation ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number. Increments by 1 each time the operation is updated.
     * To prevent conflicting changes,
     * the existing `revision` must be specified when updating an operation.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the operation was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the operation was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Operation name. */
    name?: string | null;
    /**
     * Whether the operation is the default operation. <br />
     * Default: `false`.
     */
    default?: boolean | null;
    /**
     * IDs of the fulfillment methods ([SDK](https://dev.wix.com/docs/sdk/backend-modules/restaurants/wix-restaurants-new/fulfillment-methods/introduction) | [REST](https://dev.wix.com/docs/rest/api-reference/wix-restaurants/fulfillment-methods/introduction)) associated with the operation.
     * @format GUID
     * @maxSize 500
     */
    fulfillmentIds?: string[] | null;
    /** Online ordering status of the operation. <br /> */
    onlineOrderingStatus?: OnlineOrderingStatusTypeWithLiterals;
    /** Default fulfillment type of the operation. */
    defaultFulfillmentType?: FulfillmentTypeWithLiterals;
    /** Information about when an order can be placed for. */
    orderScheduling?: OrderScheduling;
    /**
     * ID of the operation group this operation belongs to.
     * @format GUID
     * @immutable
     */
    operationGroupId?: string | null;
    /**
     * ID of the business location ([SDK](https://dev.wix.com/docs/sdk/backend-modules/restaurants/wix-restaurants-new/about-business-locations) | [REST](https://dev.wix.com/docs/rest/business-solutions/restaurants/wix-restaurants-new/about-business-locations)) of this operation.
     * @format GUID
     * @immutable
     * @readonly
     */
    businessLocationId?: string | null;
    /** Extended fields. */
    extendedFields?: ExtendedFields;
    /** Tags ([SDK](https://dev.wix.com/docs/sdk/backend-modules/tags/tags/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/tags/introduction)) used to classify and sort different types of operations. */
    tags?: Tags;
}
/** @oneof */
interface OperationOnlineOrderingStatusOptionsOneOf {
    /** Options for online ordering status. Required when `onlineOrderingStatus` is `PAUSED_UNTIL`. */
    pausedUntilOptions?: OnlineOrderingPausedUntilOptions;
}
/** Information about when an order can be placed for. */
interface Scheduling extends SchedulingSchedulingOptionsOneOf {
    /** Options for scheduling. Required when `type` is `ASAP`. */
    asapOptions?: AsapScheduling;
    /** Options for scheduling. Required when `type` is `PREORDER`. */
    preorderOptions?: PreorderScheduling;
    /**
     * Scheduling type. <br />
     * - When `ASAP`, `asapOptions` is a required field.
     * - When `PREORDER`, `preorderOptions` is a required field.
     */
    type?: SchedulingTypeWithLiterals;
}
/** @oneof */
interface SchedulingSchedulingOptionsOneOf {
    /** Options for scheduling. Required when `type` is `ASAP`. */
    asapOptions?: AsapScheduling;
    /** Options for scheduling. Required when `type` is `PREORDER`. */
    preorderOptions?: PreorderScheduling;
}
/** Scheduling type enum. */
declare enum SchedulingType {
    /** Unknown scheduling type. */
    UNKNOWN_SCHEDULING = "UNKNOWN_SCHEDULING",
    /** Orders can be scheduled for the future and to be handled immediately. */
    ASAP = "ASAP",
    /** Orders can be scheduled only for the future. */
    PREORDER = "PREORDER"
}
/** @enumType */
type SchedulingTypeWithLiterals = SchedulingType | 'UNKNOWN_SCHEDULING' | 'ASAP' | 'PREORDER';
/** Options for scheduling. Required if `type` is `ASAP`. */
interface AsapScheduling extends AsapSchedulingPreparationTimeOneOf, AsapSchedulingAsapPreorderOneOf {
    /** Options for preparation time. Required when `type` is `MAX_TIME`. */
    maxOptions?: TimeDuration;
    /** Options for preparation time. Required when `type` is `TIME_RANGE`. */
    rangeOptions?: TimeDurationRange;
    /** Information for when orders must be made a set number of business days in advance. */
    businessDaysPreorderOptions?: BusinessDaysPreorder;
    /** How to define the time needed to prepare an order. */
    type?: PreparationTimeTypeWithLiterals;
    /**
     * Indication of whether it is possible to place an order for a later time on the same day.
     * @deprecated Indication of whether it is possible to place an order for a later time on the same day.
     * @replacedBy asap_preorder_type
     * @targetRemovalDate 2023-12-28
     */
    allowSameDayPreorder?: boolean | null;
    /** The type of preorder allowed for the ASAP scheduling. */
    asapPreorderType?: AsapPreorderTypeWithLiterals;
}
/** @oneof */
interface AsapSchedulingPreparationTimeOneOf {
    /** Options for preparation time. Required when `type` is `MAX_TIME`. */
    maxOptions?: TimeDuration;
    /** Options for preparation time. Required when `type` is `TIME_RANGE`. */
    rangeOptions?: TimeDurationRange;
}
/** @oneof */
interface AsapSchedulingAsapPreorderOneOf {
    /** Information for when orders must be made a set number of business days in advance. */
    businessDaysPreorderOptions?: BusinessDaysPreorder;
}
/** Preparation time type enum. */
declare enum PreparationTimeType {
    /** Unknown preparation time type. */
    UNKNOWN_PREPARATION_TIME = "UNKNOWN_PREPARATION_TIME",
    /** Preparation time that is bounded by a maximum time. */
    MAX = "MAX",
    /** Preparation time that is bounded by a range of times. */
    RANGE = "RANGE"
}
/** @enumType */
type PreparationTimeTypeWithLiterals = PreparationTimeType | 'UNKNOWN_PREPARATION_TIME' | 'MAX' | 'RANGE';
/** Time duration. */
interface TimeDuration {
    /** Unit of time for the duration. */
    timeUnit?: TimeUnitWithLiterals;
    /** Duration value. Unit of time specified in `timeUnit`. */
    duration?: number | null;
}
/** Time unit enum. */
declare enum TimeUnit {
    /** Unknown time unit. */
    UNKNOWN_TIME_UNIT = "UNKNOWN_TIME_UNIT",
    /** Minutes time unit. */
    MINUTES = "MINUTES",
    /** Hours time unit. */
    HOURS = "HOURS",
    /** Days time unit. */
    DAYS = "DAYS"
}
/** @enumType */
type TimeUnitWithLiterals = TimeUnit | 'UNKNOWN_TIME_UNIT' | 'MINUTES' | 'HOURS' | 'DAYS';
/** Time range for preparation. */
interface TimeDurationRange {
    /** Time unit for the time range. */
    timeUnit?: TimeUnitWithLiterals;
    /**
     * Minimum duration value. Unit of time specified in `timeUnit`.
     * @min 1
     */
    minDuration?: number | null;
    /**
     * Maximum duration value. Unit of time specified in `timeUnit`.
     * @min 1
     */
    maxDuration?: number | null;
}
/** Asap preorder type enum. */
declare enum AsapPreorderType {
    /** Unknown ASAP preorder type. */
    UNKNOWN_ASAP_PREORDER = "UNKNOWN_ASAP_PREORDER",
    /** Doesn't allow preorder. */
    NO_PREORDER = "NO_PREORDER",
    /** Allows preorder for a maximum specified number of business days in advance. */
    BUSINESS_DAYS_PREORDER = "BUSINESS_DAYS_PREORDER"
}
/** @enumType */
type AsapPreorderTypeWithLiterals = AsapPreorderType | 'UNKNOWN_ASAP_PREORDER' | 'NO_PREORDER' | 'BUSINESS_DAYS_PREORDER';
/** Information for when orders must be made a set number of business days in advance. */
interface BusinessDaysPreorder {
    /**
     * Maximum number of business days an order can be scheduled in advance.
     *
     * When `0`, an order can be scheduled only until the end of the current business day.
     * For any other value, the order can be scheduled for the end of the business day in that many days.
     * For example, `5` means the order can be scheduled for any time before the end of the 5th business day from today (where today is "day 0").
     */
    businessDays?: number | null;
}
/** Order pacing configuration for ASAP scheduling */
interface AsapOrderPacing extends AsapOrderPacingPacingAvailabilityOneOf {
    /** Custom availability pattern for when pacing should be active */
    scheduleOptions?: WeeklyActivePeriods;
    /** Whether order pacing is enabled for ASAP orders */
    enabled?: boolean | null;
    /**
     * Maximum number of orders allowed within the pacing window
     * @min 1
     * @max 1000
     */
    maxOrdersInWindow?: number | null;
    /** Type of pacing window duration (currently only 15-minute supported) */
    windowType?: AsapPacingWindowTypeWithLiterals;
    /** When the pacing should be active */
    activationType?: ActivationTypeWithLiterals;
}
/** @oneof */
interface AsapOrderPacingPacingAvailabilityOneOf {
    /** Custom availability pattern for when pacing should be active */
    scheduleOptions?: WeeklyActivePeriods;
}
/** ASAP pacing duration type enum */
declare enum AsapPacingWindowType {
    /** Unknown ASAP pacing duration type */
    UNKNOWN_ASAP_PACING_DURATION = "UNKNOWN_ASAP_PACING_DURATION",
    /** Fixed 15-minute window */
    FIXED_15_MINUTE = "FIXED_15_MINUTE"
}
/** @enumType */
type AsapPacingWindowTypeWithLiterals = AsapPacingWindowType | 'UNKNOWN_ASAP_PACING_DURATION' | 'FIXED_15_MINUTE';
/** Defines when pacing should be active */
declare enum ActivationType {
    /** Unknown pacing schedule type */
    UNKNOWN_SCHEDULE = "UNKNOWN_SCHEDULE",
    /** Pacing is active 24/7 */
    ALWAYS_ACTIVE = "ALWAYS_ACTIVE",
    /** Pacing follows custom availability pattern */
    SCHEDULE = "SCHEDULE"
}
/** @enumType */
type ActivationTypeWithLiterals = ActivationType | 'UNKNOWN_SCHEDULE' | 'ALWAYS_ACTIVE' | 'SCHEDULE';
interface WeeklyActivePeriods {
    /**
     * A list of active periods for the days of the week.
     * @maxSize 7
     */
    activePeriods?: ActivePeriod[];
}
interface ActivePeriod {
    /** The day of week this active period relates to. */
    dayOfWeek?: EntitiesDayOfWeekWithLiterals;
    /**
     * A list of active time ranges.
     * @maxSize 50
     */
    timeRanges?: TimeOfDayRange[];
}
declare enum EntitiesDayOfWeek {
    /** Monday. */
    MON = "MON",
    /** Tuesday. */
    TUE = "TUE",
    /** Wednesday. */
    WED = "WED",
    /** Thursday. */
    THU = "THU",
    /** Friday. */
    FRI = "FRI",
    /** Saturday. */
    SAT = "SAT",
    /** Sunday. */
    SUN = "SUN"
}
/** @enumType */
type EntitiesDayOfWeekWithLiterals = EntitiesDayOfWeek | 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT' | 'SUN';
interface TimeOfDayRange {
    /** The start time in time of day representation. */
    startTime?: TimeOfDay;
    /** The end time in time of day representation. */
    endTime?: TimeOfDay;
}
interface TimeOfDay {
    /**
     * Hours. <br />
     * Min: `0`. <br />
     * Max: `23`.
     */
    hours?: number;
    /**
     * Minutes. <br />
     * Min: `0`. <br />
     * Max: `23`.
     */
    minutes?: number;
}
/** Information about preorders. */
interface PreorderScheduling {
    method?: PreorderMethod;
    /**
     * Configuration of the fulfillment times. <br />
     * Currently, only `TIME_WINDOWS` is supported.
     */
    fulfillmentTimesDisplay?: FulfillmentTimesDisplayConfig;
}
/** Method for `PREORDER` scheduling type. */
interface PreorderMethod extends PreorderMethodMethodOptionsOneOf {
    /** Options for the method. Required when `type` is `TIME_BOUNDED`. */
    timeBoundedOptions?: TimeBounded;
    /** Options for the method. Required when `type` is `WEEKLY_SCHEDULE`. */
    weeklyScheduleOptions?: WeeklySchedule;
    /**
     * Type of time frame for how long in advance preorders can be made. <br />
     * - When `TIME_BOUNDED`, `timeBoundedOptions` is a required field.
     * - When `WEEKLY_SCHEDULE`, `weeklyScheduleOptions` is a required field.
     */
    type?: MethodTypeWithLiterals;
}
/** @oneof */
interface PreorderMethodMethodOptionsOneOf {
    /** Options for the method. Required when `type` is `TIME_BOUNDED`. */
    timeBoundedOptions?: TimeBounded;
    /** Options for the method. Required when `type` is `WEEKLY_SCHEDULE`. */
    weeklyScheduleOptions?: WeeklySchedule;
}
/** Day of the week and time of the day. */
interface DayAndTime {
    /** Day of the week. */
    dayOfWeek?: EntitiesDayOfWeekWithLiterals;
    /** Time of the day. */
    timeOfDay?: TimeOfDay;
}
/** Preorder method type enum. */
declare enum MethodType {
    /** Unknown preorder method type. */
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    /** Preorder time has a minimum and a maximum. */
    TIME_BOUNDED = "TIME_BOUNDED",
    /** Preorders have a weekly schedule with a weekly cutoff time. */
    WEEKLY_SCHEDULE = "WEEKLY_SCHEDULE"
}
/** @enumType */
type MethodTypeWithLiterals = MethodType | 'UNKNOWN_TYPE' | 'TIME_BOUNDED' | 'WEEKLY_SCHEDULE';
/** Information about the time range when preorders are time bounded. */
interface TimeBounded {
    /** Minimum time required to schedule the order. */
    minTimeInAdvance?: TimeDuration;
    /** Maximum time allowed to schedule the order. */
    maxTimeInAdvance?: TimeDuration;
}
/** Options for the method. Required when `type` is `WEEKLY_SCHEDULE`. */
interface WeeklySchedule {
    /**
     * The weekly schedule cutoff time. <br />
     * Orders placed before the cutoff time are scheduled for the current week. <br />
     * Orders placed after the cutoff time are scheduled for the next week.
     */
    cutOffTime?: DayAndTime;
}
/** Way by which fulfillment times should be displayed. */
interface FulfillmentTimesDisplayConfig extends FulfillmentTimesDisplayConfigFulfillmentTimesDisplayOptionsOneOf {
    /** Options for fulfillment time. Required when `fulfillmentTimesType` is `TIME_WINDOWS`. */
    timeWindowsOptions?: TimeDuration;
    /**
     * Type of the fulfillment times. <br />
     * When `TIME_WINDOWS`, `timeWindowsOptions` is a required field.
     */
    type?: FulfillmentTimesTypeWithLiterals;
}
/** @oneof */
interface FulfillmentTimesDisplayConfigFulfillmentTimesDisplayOptionsOneOf {
    /** Options for fulfillment time. Required when `fulfillmentTimesType` is `TIME_WINDOWS`. */
    timeWindowsOptions?: TimeDuration;
}
/** The fulfillment times type enum. */
declare enum FulfillmentTimesType {
    /** Unknown fulfillment times type. */
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    /** Display fulfillment times as time windows. */
    TIME_WINDOWS = "TIME_WINDOWS"
}
/** @enumType */
type FulfillmentTimesTypeWithLiterals = FulfillmentTimesType | 'UNKNOWN_TYPE' | 'TIME_WINDOWS';
/** Order pacing configuration for preorder scheduling */
interface PreOrderPacing extends PreOrderPacingPacingAvailabilityOneOf {
    /** Custom availability pattern for when pacing should be active */
    scheduleOptions?: WeeklyActiveDays;
    /** Whether order pacing is enabled for preorder */
    enabled?: boolean | null;
    /**
     * Maximum number of orders allowed within the pacing window
     * @min 1
     * @max 1000
     */
    maxOrdersInWindow?: number | null;
    /** Type of pacing window (currently only daily supported) */
    windowType?: PreorderPacingWindowTypeWithLiterals;
    /** When the pacing should be active */
    activationType?: ActivationTypeWithLiterals;
}
/** @oneof */
interface PreOrderPacingPacingAvailabilityOneOf {
    /** Custom availability pattern for when pacing should be active */
    scheduleOptions?: WeeklyActiveDays;
}
/** Preorder pacing window type enum */
declare enum PreorderPacingWindowType {
    /** Unknown preorder pacing window type */
    UNKNOWN_PREORDER_PACING_WINDOW = "UNKNOWN_PREORDER_PACING_WINDOW",
    /** Daily pacing window */
    DAILY = "DAILY"
}
/** @enumType */
type PreorderPacingWindowTypeWithLiterals = PreorderPacingWindowType | 'UNKNOWN_PREORDER_PACING_WINDOW' | 'DAILY';
interface WeeklyActiveDays {
    /**
     * A list of active days of the week.
     * @maxSize 7
     */
    activeDays?: EntitiesDayOfWeekWithLiterals[];
}
/** Online ordering status enum. */
declare enum OnlineOrderingStatusType {
    /** Online ordering status is not defined. */
    UNDEFINED_ONLINE_ORDERING_STATUS = "UNDEFINED_ONLINE_ORDERING_STATUS",
    /** Operation currently accepts online orders. */
    ENABLED = "ENABLED",
    /** Operation currently does not accept online orders. */
    DISABLED = "DISABLED",
    /** Operation currently does not accept online orders, but will accept online orders from a specified time and date. When applied, `pausedUntilOptions` is a required field. */
    PAUSED_UNTIL = "PAUSED_UNTIL"
}
/** @enumType */
type OnlineOrderingStatusTypeWithLiterals = OnlineOrderingStatusType | 'UNDEFINED_ONLINE_ORDERING_STATUS' | 'ENABLED' | 'DISABLED' | 'PAUSED_UNTIL';
/** Options for online ordering status. Required when `onlineOrderingStatus` is `PAUSED_UNTIL`. */
interface OnlineOrderingPausedUntilOptions {
    /**
     * Date and time until which online ordering is paused. <br />
     *
     * Before the specified time, behavior is the same as when `onlineOrderingStatus` is `DISABLED`. <br />
     *
     * After the specified time, behavior is the same as when `onlineOrderingStatus` is `ENABLED`. <br />
     *
     * Passing the time does not trigger any changes to value of any properties.
     */
    time?: Date | null;
}
/** Fulfillment type enum. */
declare enum FulfillmentType {
    /** Undefined fulfillment type. */
    UNDEFINED_FULFILLMENT_TYPE = "UNDEFINED_FULFILLMENT_TYPE",
    /** Pickup fulfillment. The customer picks up the order from the restaurant. */
    PICKUP = "PICKUP",
    /** Delivery fulfillment. The restaurant, or a representative, delivers the order to the customer. */
    DELIVERY = "DELIVERY"
}
/** @enumType */
type FulfillmentTypeWithLiterals = FulfillmentType | 'UNDEFINED_FULFILLMENT_TYPE' | 'PICKUP' | 'DELIVERY';
/** Information about when an order can be placed for. */
interface OrderScheduling extends OrderSchedulingOrderSchedulingOptionsOneOf {
    /** Options for scheduling. Required if `type` is `ASAP`. */
    asapOptions?: AsapOrderScheduling;
    /** Options for scheduling. Required if `type` is `PREORDER`. */
    preorderOptions?: PreorderScheduling;
    /**
     * Scheduling type. <br />
     * - When `ASAP`, `asapOptions` is a required field.
     * - When `PREORDER`, `preorderOptions` is a required field.
     */
    type?: SchedulingTypeWithLiterals;
}
/** @oneof */
interface OrderSchedulingOrderSchedulingOptionsOneOf {
    /** Options for scheduling. Required if `type` is `ASAP`. */
    asapOptions?: AsapOrderScheduling;
    /** Options for scheduling. Required if `type` is `PREORDER`. */
    preorderOptions?: PreorderScheduling;
}
interface AsapOrderScheduling extends AsapOrderSchedulingAsapFutureHandlingOptionsOneOf {
    /** Options for future handling. Required when `asapFutureHandlingType` is `BUSINESS_DAYS_AHEAD_HANDLING`. */
    businessDaysAheadHandlingOptions?: BusinessDaysAheadHandling;
    /**
     * Amount of time needed to prepare the order. <br />
     * - When `MAX_TIME`, `maxTimeOptions` is a required field.
     * - When `MAX_RANGE`, `timeRangeOptions` is a required field.
     */
    preparationTime?: PreparationTime;
    /**
     * Defines if and how non-immediate orders should be handled. <br />
     * When this value is `BUSINESS_DAYS_AHEAD_HANDLING`, `businessDaysAheadHandlingOptions` is a required field.
     */
    asapFutureHandlingType?: AsapFutureHandlingTypeWithLiterals;
}
/** @oneof */
interface AsapOrderSchedulingAsapFutureHandlingOptionsOneOf {
    /** Options for future handling. Required when `asapFutureHandlingType` is `BUSINESS_DAYS_AHEAD_HANDLING`. */
    businessDaysAheadHandlingOptions?: BusinessDaysAheadHandling;
}
interface PreparationTime extends PreparationTimeTimeSpecificationOneOf {
    /** Options for preparation time. Required when `type` is `MAX_TIME`. */
    maxTimeOptions?: TimeDuration;
    /** Options for preparation time. Required when `type` is `TIME_RANGE`. */
    timeRangeOptions?: TimeDurationRange;
    /** Preparation time type. */
    type?: PreparationTimePreparationTimeTypeWithLiterals;
}
/** @oneof */
interface PreparationTimeTimeSpecificationOneOf {
    /** Options for preparation time. Required when `type` is `MAX_TIME`. */
    maxTimeOptions?: TimeDuration;
    /** Options for preparation time. Required when `type` is `TIME_RANGE`. */
    timeRangeOptions?: TimeDurationRange;
}
/** Preparation time type enum. */
declare enum PreparationTimePreparationTimeType {
    UNKNOWN_PREPARATION_TIME = "UNKNOWN_PREPARATION_TIME",
    MAX_TIME = "MAX_TIME",
    TIME_RANGE = "TIME_RANGE"
}
/** @enumType */
type PreparationTimePreparationTimeTypeWithLiterals = PreparationTimePreparationTimeType | 'UNKNOWN_PREPARATION_TIME' | 'MAX_TIME' | 'TIME_RANGE';
declare enum AsapFutureHandlingType {
    /** Unknown asap future handling type. */
    UNKNOWN_ASAP_FUTURE_HANDLING = "UNKNOWN_ASAP_FUTURE_HANDLING",
    /** No future handling. */
    NO_FUTURE_HANDLING = "NO_FUTURE_HANDLING",
    /** Allows future orders for up to a specified number of business days ahead. */
    BUSINESS_DAYS_AHEAD_HANDLING = "BUSINESS_DAYS_AHEAD_HANDLING"
}
/** @enumType */
type AsapFutureHandlingTypeWithLiterals = AsapFutureHandlingType | 'UNKNOWN_ASAP_FUTURE_HANDLING' | 'NO_FUTURE_HANDLING' | 'BUSINESS_DAYS_AHEAD_HANDLING';
interface BusinessDaysAheadHandling {
    /**
     * Number of business days ahead for which orders can be scheduled. <br />
     * Setting the `daysCount` to 0 means that orders can be scheduled until the end of the current business day.
     */
    daysCount?: number | null;
}
interface BusinessLocationDetails {
    /**
     * Location name.
     * @maxLength 150
     * @readonly
     */
    name?: string | null;
    /**
     * Whether the location is archived.
     *
     * Archived locations are hidden and ignored on restaurants site pages, and marked as archived in the dashboard.
     * @readonly
     */
    archived?: boolean | null;
    /**
     * Whether this location is the default location for the business.
     * @readonly
     */
    default?: boolean | null;
    /**
     * Business Location Address.
     * @readonly
     */
    address?: V1Address;
    /**
     * Time zone in [Time Zone Database](https://www.iana.org/time-zones) format.
     * @readonly
     * @maxLength 50
     */
    timeZone?: string | null;
}
interface V1Address {
    /**
     * 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
     * @format COUNTRY
     */
    country?: string | null;
    /**
     * Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format.
     * @maxLength 100
     */
    subdivision?: string | null;
    /**
     * City name.
     * @maxLength 100
     */
    city?: string | null;
    /**
     * Postal or zip code.
     * @maxLength 20
     */
    postalCode?: string | null;
    /** Street address. Includes street name, number, and apartment number in separate fields. */
    streetAddress?: V1StreetAddress;
    /**
     * Full address of the location.
     * @maxLength 1000
     */
    formatted?: string | null;
    /**
     * Extra information that helps finding the location.
     * @maxLength 500
     */
    hint?: string | null;
    /** Geographic coordinates of location. */
    location?: V1AddressLocation;
}
/** Street address. Includes street name, number, and apartment number in separate fields. */
interface V1StreetAddress {
    /**
     * Street number.
     * @maxLength 20
     */
    number?: string;
    /**
     * Street name.
     * @maxLength 100
     */
    name?: string;
    /**
     * Apartment number.
     * @maxLength 20
     */
    apt?: string;
}
/** Address Geolocation */
interface V1AddressLocation {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number | null;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
/**
 * Common object for tags.
 * Should be use as in this example:
 * message Foo {
 * string id = 1;
 * ...
 * Tags tags = 5
 * }
 * example of taggable entity
 * {
 * id: "123"
 * tags: {
 * tags: {
 * tag_ids:["11","22"]
 * },
 * private_tags: {
 * tag_ids: ["33", "44"]
 * }
 * }
 * }
 */
interface Tags {
    /** Tags that require an additional permission in order to access them, normally not given to site members or visitors. */
    privateTags?: TagList;
    /** Tags that are exposed to anyone who has access to the labeled entity itself, including site members and visitors. */
    tags?: TagList;
}
interface TagList {
    /**
     * List of tag IDs
     * @maxSize 100
     * @maxLength 5
     */
    tagIds?: string[];
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
    /**
     * tell us why you're invalidating the cache. You don't need to add your app name
     * @maxLength 256
     */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** Invalidate by custom tag. Tags used in BO invalidation are disabled for this endpoint (more info: https://wix-bo.com/dev/clear-ssr-cache) */
    customTag?: CustomTag;
}
interface App {
    /**
     * The AppDefId
     * @minLength 1
     */
    appDefId?: string;
    /**
     * The instance Id
     * @format GUID
     */
    instanceId?: string;
}
interface Page {
    /**
     * the msid the page is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Page ID
     * @minLength 1
     */
    pageId?: string;
}
interface URI {
    /**
     * the msid the URI is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes
     * @minLength 1
     */
    uriPath?: string;
}
interface File {
    /**
     * the msid the file is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by filename (for media files such as PDFs)
     * @minLength 1
     * @maxLength 256
     */
    fileName?: string;
}
interface CustomTag {
    /**
     * the msid the tag is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Tag to invalidate by
     * @minLength 1
     * @maxLength 256
     */
    tag?: string;
}
interface DeliveryProfileConfiguredForOperation {
    /** Operation */
    operation?: Operation;
}
interface OperationsDataCloningCompleted {
}
interface CreateOperationRequest {
    /** Operation to create. */
    operation: Operation;
}
interface CreateOperationResponse {
    /** Created operation. */
    operation?: Operation;
}
interface GetOperationRequest {
    /**
     * ID of the operation to retrieve.
     * @format GUID
     */
    operationId: string;
}
interface GetOperationResponse {
    /** Retrieved operation. */
    operation?: Operation;
}
interface UpdateOperationRequest {
    /** Operation to update. */
    operation: Operation;
}
interface UpdateOperationResponse {
    /** Updated operation. */
    operation?: Operation;
}
interface DeleteOperationRequest {
    /**
     * ID of the operation to delete.
     * @format GUID
     */
    operationId: string;
}
interface DeleteOperationResponse {
}
interface QueryOperationRequest {
    /** Query options. */
    query: CursorQuery;
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     * See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language)
     * for more information.
     *
     * For a detailed list of supported filters, see
     * [Supported Filters](https://dev.wix.com/docs/rest/api-reference/wix-restaurants/operations/operations/supported-filters-and-sorting).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     * @maxSize 4
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Supported properties:
     * - `id`
     * - `createdDate`
     * - `updatedDate`
     * - `name`
     * @maxLength 64
     */
    fieldName?: string;
    /**
     * Sort order. Use `ASC` for ascending order or `DESC` for descending order. <br />
     *
     * Default: `ASC`
     */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface QueryOperationResponse {
    /** Retrieved operations. */
    operations?: Operation[];
    /** Metadata of the paginated results. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface ListOperationsRequest {
}
interface ListOperationsResponse {
    /** Retrieved operations. */
    operations?: Operation[];
}
interface ListOperationIdsRequest {
    /**
     * metasite id
     * @format GUID
     */
    metasiteId?: string;
}
interface ListOperationIdsResponse {
    /**
     * List of operation ids
     * @format GUID
     */
    operationIds?: string[];
}
interface ListOperationsInternalRequest {
    /**
     * metasite id
     * @format GUID
     */
    metasiteId?: string;
}
interface ListOperationsInternalResponse {
    /** List of operations */
    operations?: Operation[];
}
interface ListAvailableFulfillmentOptionsRequest {
    /**
     * Operation ID. Returned fulfillment options will belong to this operation.
     * @format GUID
     */
    operationId: string;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
/** Physical address */
interface CommonAddress extends CommonAddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
/** @oneof */
interface CommonAddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
}
interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
}
interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
interface Subdivision {
    /** Short subdivision code. */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
declare enum SubdivisionType {
    UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
    /** State */
    ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
    /** County */
    ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
    /** City/town */
    ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
    /** Neighborhood/quarter */
    ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
    /** Street/block */
    ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
    /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
    COUNTRY = "COUNTRY"
}
/** @enumType */
type SubdivisionTypeWithLiterals = SubdivisionType | 'UNKNOWN_SUBDIVISION_TYPE' | 'ADMINISTRATIVE_AREA_LEVEL_1' | 'ADMINISTRATIVE_AREA_LEVEL_2' | 'ADMINISTRATIVE_AREA_LEVEL_3' | 'ADMINISTRATIVE_AREA_LEVEL_4' | 'ADMINISTRATIVE_AREA_LEVEL_5' | 'COUNTRY';
interface ListAvailableFulfillmentOptionsResponse {
    /** Whether pickup fulfillment method is configured for the requested operation. */
    pickupConfigured?: boolean;
    /** Whether delivery fulfillment method is configured for the requested operation. */
    deliveryConfigured?: boolean;
    /** List of the available fulfillment options. */
    fulfillmentOptions?: FulfillmentOption[];
    /** Whether availability exceptions block the fulfillment options. */
    blockedByAvailabilityExceptions?: boolean | null;
    /** Whether availability exceptions from type = PAUSED_ORDERING block the fulfillment options. */
    blockedByPausedOrdering?: boolean | null;
}
/** Fulfillment method that is currently available to fulfill orders, given its availability and the operation's scheduling configurations. */
interface FulfillmentOption extends FulfillmentOptionFulfillmentTimeOptionsOneOf, FulfillmentOptionFulfillmentTimesDisplayOptionsOneOf, FulfillmentOptionFulfillmentTypeOptionsOneOf {
    /** Fulfillment time has a maximum time. */
    maxTimeOptions?: number;
    /** Fulfillment time is limited by a range. */
    durationRangeOptions?: DurationRange;
    /** Options for fulfillment time. Required when `type` is `TIME_WINDOWS`. */
    timeWindowsOptions?: TimeWindowDisplayConfig;
    /** Information about pickup fulfillment types. */
    pickupOptions?: PickupDetails;
    /** Information about delivery fulfillment types. */
    deliveryOptions?: DeliveryDetails;
    /**
     * Fulfillment method ID.
     * @format GUID
     */
    _id?: string | null;
    /** Fulfillment option type. */
    type?: FulfillmentTypeWithLiterals;
    /**
     * Minimum order price to qualify for the fulfillment option.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    minOrderPrice?: string | null;
    /**
     * Fee for using the fulfillment option.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    fee?: string | null;
    /** Availability of the fulfillment option. */
    availability?: FulfillmentOptionAvailability;
    /**
     * Fulfillment time type.
     * Relevant only to ASAP operations.
     */
    fulfillmentTimeType?: FulfillmentTimeTypeWithLiterals;
    /** Fulfillment times display type. Relevant to preorder operations. */
    fulfillmentTimesDisplayType?: FulfillmentTimesDisplayTypeWithLiterals;
    /**
     * Minimum order price for free fulfillment.
     * If order price exceeds this amount, the given `fee` is waived.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    freeFulfillmentPriceThreshold?: string | null;
    /**
     * Instructions for the fulfillment.
     * @maxLength 250
     */
    instructions?: string | null;
    /** @format GUID */
    businessLocationId?: string | null;
}
/** @oneof */
interface FulfillmentOptionFulfillmentTimeOptionsOneOf {
    /** Fulfillment time has a maximum time. */
    maxTimeOptions?: number;
    /** Fulfillment time is limited by a range. */
    durationRangeOptions?: DurationRange;
}
/** @oneof */
interface FulfillmentOptionFulfillmentTimesDisplayOptionsOneOf {
    /** Options for fulfillment time. Required when `type` is `TIME_WINDOWS`. */
    timeWindowsOptions?: TimeWindowDisplayConfig;
}
/** @oneof */
interface FulfillmentOptionFulfillmentTypeOptionsOneOf {
    /** Information about pickup fulfillment types. */
    pickupOptions?: PickupDetails;
    /** Information about delivery fulfillment types. */
    deliveryOptions?: DeliveryDetails;
}
/** Availability of the fulfillment option. */
interface FulfillmentOptionAvailability {
    /** Date and time at which the fulfillment option's availability starts. */
    startTime?: Date | null;
    /** Date and time at which the fulfillment option's availability ends. */
    endTime?: Date | null;
    /**
     * List of available times for the days of the week.
     * All the specified times must be within the range between `startTime` and `endTime`.
     */
    availableTimes?: DayOfWeekAvailability[];
    /** List of availability exceptions that override the availability defined in `availableTimes`. */
    exceptions?: AvailabilityException[];
    /** Timezone for which the available times are given. */
    timeZone?: string | null;
    /** Whether it's possible to submit an order for as soon as possible handling. */
    asapHandlingAvailable?: boolean;
    /** Whether it's possible to submit an order for future handling. */
    futureHandlingAvailable?: boolean | null;
}
interface DayOfWeekAvailability {
    /** The day of week this availability relates to. */
    dayOfWeek?: EntitiesDayOfWeekWithLiterals;
    /** A list of time ranges during which the fulfillment should be available. */
    timeRanges?: TimeOfDayRange[];
}
interface AvailabilityException {
    /** The start time of the availability exception. */
    startTime?: Date | null;
    /** The end time of the availability exception. */
    endTime?: Date | null;
    /** An indication whether the exception makes the [`start_time`, `end_time`] range available. */
    available?: boolean;
    /** The reason for the exception. */
    reason?: string | null;
}
/** Fulfillment time type enum. */
declare enum FulfillmentTimeType {
    /** Undefined fulfillment time type. */
    UNDEFINED_FULFILLMENT_TIME = "UNDEFINED_FULFILLMENT_TIME",
    /** Fulfillment time has a maximum. */
    MAX_TIME = "MAX_TIME",
    /** Fulfillment time has a minimum and a maximum. */
    DURATION_RANGE = "DURATION_RANGE"
}
/** @enumType */
type FulfillmentTimeTypeWithLiterals = FulfillmentTimeType | 'UNDEFINED_FULFILLMENT_TIME' | 'MAX_TIME' | 'DURATION_RANGE';
/** Duration range. */
interface DurationRange {
    /** Minimum duration in minutes. */
    minDuration?: number;
    /** Maximum duration in minutes. */
    maxDuration?: number;
}
/** Fulfillment times display type enum. */
declare enum FulfillmentTimesDisplayType {
    /** Undefined fulfillment times display type. */
    UNDEFINED_FULFILLMENT_TIMES_DISPLAY = "UNDEFINED_FULFILLMENT_TIMES_DISPLAY",
    /** Fulfillment times are displayed as a list of time windows. */
    TIME_WINDOWS = "TIME_WINDOWS"
}
/** @enumType */
type FulfillmentTimesDisplayTypeWithLiterals = FulfillmentTimesDisplayType | 'UNDEFINED_FULFILLMENT_TIMES_DISPLAY' | 'TIME_WINDOWS';
/** Time window. */
interface TimeWindowDisplayConfig {
    /** Time window duration in minutes. */
    durationInMinutes?: number;
}
/** Information about pickup fulfillment types. */
interface PickupDetails {
    /** Pickup address. This is the restaurant's address. */
    address?: CommonAddress;
}
/** Information about delivery fulfillment types. */
interface DeliveryDetails {
    /**
     * Delivery provider app id.
     * @format GUID
     */
    deliveryProviderAppId?: string | null;
    /**
     * Pickup instructions for couriers.
     * @maxLength 250
     */
    courierPickupInstructions?: string | null;
    /** how much time it takes to deliver the order in minutes. */
    deliveryTimeInMinutes?: number | null;
}
interface ListFirstAvailableTimeSlotForFulfillmentTypesRequest {
    /**
     * Operation ID.
     * Returned fulfillment options will belong to this operation.
     * @format GUID
     */
    operationId: string;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
interface ListFirstAvailableTimeSlotForFulfillmentTypesResponse {
    /**
     * List of available time slots for each fulfillment type.
     *
     * Each time slot is the first available time slot for the given fulfillment type.
     * A delivery fulfillment type is returned only if the delivery address is provided.
     */
    timeSlots?: FulfillmentTimeSlot[];
}
interface FulfillmentTimeSlot {
    /** Start time and date of the time slot. */
    startTime?: Date | null;
    /** End time and date of the time slot. */
    endTime?: Date | null;
    /** Type of the fulfillment. */
    fulfilmentType?: FulfillmentTypeWithLiterals;
    /** Whether the time slot starts now. */
    startsNow?: boolean;
    /**
     * Details for each fulfillment option of the time slot.
     * @maxSize 500
     */
    fulfillmentDetails?: FulfillmentDetails[];
    /** Address of the fulfillment. */
    fulfillmentAddress?: FulfillmentAddress;
}
declare enum TimeSlotStatus {
    /** The time slot is available for ordering. */
    AVAILABLE = "AVAILABLE",
    /** The time slot is blocked by pacing. applicable for Preorder */
    BLOCKED = "BLOCKED"
}
/** @enumType */
type TimeSlotStatusWithLiterals = TimeSlotStatus | 'AVAILABLE' | 'BLOCKED';
/** Details about the fulfillment option. */
interface FulfillmentDetails extends FulfillmentDetailsFulfillmentTimeOptionsOneOf {
    /** Fulfillment time has a maximum. */
    maxTimeOptions?: number;
    /** Fulfillment time has a minimum and a maximum. */
    durationRangeOptions?: DurationRange;
    /**
     * Fee for using this fulfillment.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    fee?: string | null;
    /**
     * Minimum order price to qualify for using this fulfillment.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    minOrderPrice?: string | null;
    /** Fulfillment time type. Only be relevant to `ASAP` operations. */
    fulfillmentTimeType?: FulfillmentTimeTypeWithLiterals;
    /**
     * Minimum order price for free fulfillment.
     * If order price exceeds this amount, the given `fee` is waived.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    freeFulfillmentPriceThreshold?: string | null;
}
/** @oneof */
interface FulfillmentDetailsFulfillmentTimeOptionsOneOf {
    /** Fulfillment time has a maximum. */
    maxTimeOptions?: number;
    /** Fulfillment time has a minimum and a maximum. */
    durationRangeOptions?: DurationRange;
}
/**
 * Details on the address of the fulfillment.
 * For pickup it will the address to take the order from.
 * For delivery it will be the address to deliver the order to.
 */
interface FulfillmentAddress {
    /** Pickup address. This is the address of the restaurant. */
    address?: CommonAddress;
}
interface CalculateFirstAvailableTimeSlotPerFulfillmentTypeRequest {
    /**
     * Operation ID.
     * @format GUID
     */
    operationId: string;
    /**
     * Delivery address.
     *
     * The response includes a time slot with the delivery fulfillment type only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
}
interface CalculateFirstAvailableTimeSlotPerFulfillmentTypeResponse {
    /**
     * First available time slot for each fulfillment type.
     *
     * Each time slot is the first available time slot for the given fulfillment type.
     * @maxSize 2
     */
    timeslotsPerFulfillmentType?: TimeSlotForFulfillment[];
}
interface TimeSlotForFulfillment {
    /** Time Slot details. */
    timeSlot?: TimeSlot;
    /**
     * Details for each available fulfillment option in the time slot.
     * @maxSize 500
     */
    fulfillmentInfo?: FulfillmentInfo[];
    /** Fulfillment type. */
    fulfilmentType?: FulfillmentTypeWithLiterals;
}
interface TimeSlot {
    /** Start time and date of the time slot in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format. */
    startTime?: Date | null;
    /** End time and date of the time slot in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format. */
    endTime?: Date | null;
    /** Order scheduling type used by the operation. */
    orderSchedulingType?: OrderSchedulingTypeWithLiterals;
}
declare enum OrderSchedulingType {
    /** Immediate ordering. */
    ASAP = "ASAP",
    /** Scheduled ordering. */
    PREORDER = "PREORDER"
}
/** @enumType */
type OrderSchedulingTypeWithLiterals = OrderSchedulingType | 'ASAP' | 'PREORDER';
declare enum TimeSlotForFulfillmentTimeSlotStatus {
    /** The time slot is available for ordering. */
    AVAILABLE = "AVAILABLE",
    /** The time slot is blocked by pacing restrictions. Applicable only for `PREORDER` scheduling. */
    BLOCKED = "BLOCKED"
}
/** @enumType */
type TimeSlotForFulfillmentTimeSlotStatusWithLiterals = TimeSlotForFulfillmentTimeSlotStatus | 'AVAILABLE' | 'BLOCKED';
/** Details about the fulfillment option. */
interface FulfillmentInfo extends FulfillmentInfoFulfillmentTimeOneOf {
    /** Maximum time to fulfill the order. */
    maxTime?: number;
    /** Time range in which to fulfill the order. */
    durationRange?: DurationRange;
    /**
     * Fee for using this fulfillment option.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    fee?: string | null;
    /**
     * Minimum order price to qualify for using this fulfillment option.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    minOrderPrice?: string | null;
    /**
     * Minimum order price to qualify for free fulfillment.
     * If the order price exceeds this amount, the `fee` is waived.
     * @decimalValue options { gte:0.00, maxScale:3 }
     */
    freeFulfillmentPriceThreshold?: string | null;
    /**
     * Details on the address of the fulfillment.
     * For pickup fulfillment types, this is the address to take the order from.
     * For delivery fulfillment types, this is the address to deliver the order to.
     */
    address?: CommonAddress;
}
/** @oneof */
interface FulfillmentInfoFulfillmentTimeOneOf {
    /** Maximum time to fulfill the order. */
    maxTime?: number;
    /** Time range in which to fulfill the order. */
    durationRange?: DurationRange;
}
interface ListFirstAvailableTimeSlotsForOperationsRequest {
    /**
     * Operation ID.
     * Returned fulfillment options will belong to this operation.
     * @format GUID
     * @maxSize 100
     */
    operationIds: string[];
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
interface ListFirstAvailableTimeSlotsForOperationsResponse {
    /**
     * List of available time slots for each operation.
     * @maxSize 100
     */
    timeSlots?: OperationTimeSlot[];
}
interface OperationTimeSlot {
    /**
     * Operation ID.
     * @format GUID
     */
    operationId?: string;
    /**
     * List of available time slots for each fulfillment type.
     * @maxSize 100
     */
    timeSlots?: FulfillmentTimeSlot[];
}
interface CalculateFirstAvailableTimeSlotsPerOperationRequest {
    /**
     * Operation IDs.
     * @format GUID
     * @maxSize 100
     */
    operationIds: string[];
    /**
     * Delivery address.
     *
     * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
}
interface CalculateFirstAvailableTimeSlotsPerOperationResponse {
    /**
     * First available time slot of each fulfillment type for each operation.
     *
     * A time slot with the delivery fulfillment type is returned only if a delivery address was specified.
     * @maxSize 100
     */
    timeSlotsPerOperation?: TimeSlotForOperation[];
}
interface TimeSlotForOperation {
    /**
     * Operation ID.
     * @format GUID
     */
    operationId?: string;
    /**
     * Available time slots of each fulfillment type for this operation.
     * @maxSize 2
     */
    timeslotsPerFulfillmentType?: TimeSlotForFulfillment[];
}
interface ListFirstAvailableTimeSlotsForMenusRequest {
    /**
     * Operation ID.
     * Returned timeslots that are belong to this operation.
     * @format GUID
     */
    operationId: string | null;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
    /** Cursor paging */
    cursorPaging?: CursorPaging;
}
interface ListFirstAvailableTimeSlotsForMenusResponse {
    /**
     * List of available time slots for each menu.
     * For each menu will be returned the first available time slot for each fulfillment type.
     * @maxSize 100
     */
    timeSlotsPerMenu?: FirstFulfillmentTimeSlotsPerMenu[];
    /**
     * Cursor to next request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
interface FirstFulfillmentTimeSlotsPerMenu {
    /**
     * Menu ID.
     * @format GUID
     */
    menuId?: string | null;
    /**
     * List of available time slots for each fulfillment type.
     * @maxSize 2
     */
    timeslotsPerFulfillmentType?: FulfillmentTimeSlot[];
}
interface CalculateFirstAvailableTimeSlotsPerMenuRequest {
    /**
     * Operation ID.
     * @format GUID
     */
    operationId: string | null;
    /**
     * Delivery address.
     *
     * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
    /** Cursor paging. */
    cursorPaging?: CursorPaging;
    /** Only retrieve time slots for menus with online ordering enabled. */
    onlyOnlineOrderingEnabled?: boolean | null;
}
interface CalculateFirstAvailableTimeSlotsPerMenuResponse {
    /**
     * First available time slot of each fulfillment type for each menu.
     *
     * A time slot with the delivery fulfillment type is returned only if a delivery address was specified.
     * @maxSize 100
     */
    timeSlotsPerMenu?: FulfillmentTimeSlotsPerMenu[];
    /**
     * Metadata for the paginated results.
     * @deprecated Metadata for the paginated results.
     * @targetRemovalDate 2025-08-31
     */
    pagingMetadata?: PagingMetadata;
    /** Metadata for the paginated results. */
    cursorPagingMetadata?: CursorPagingMetadata;
}
interface FulfillmentTimeSlotsPerMenu {
    /**
     * Menu ID.
     * @format GUID
     */
    menuId?: string | null;
    /**
     * Available time slots of each fulfillment type for this menu.
     * @maxSize 2
     */
    timeslotsPerFulfillmentType?: TimeSlotForFulfillment[];
}
interface PagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
}
interface CalculateFirstAvailableTimeSlotsForItemRequest {
    /** @format GUID */
    operationId: string | null;
    /**
     * Menu ID to get the first available time slots for.
     * @format GUID
     */
    menuId: string | null;
    /**
     * Section ID to get the first available time slots for.
     * @format GUID
     */
    sectionId: string | null;
    /**
     * Item ID to get the first available time slots for.
     * @format GUID
     */
    itemId: string | null;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
interface CalculateFirstAvailableTimeSlotsForItemResponse {
    /**
     * First available time slot of each fulfillment type.
     *
     * A time slot with the delivery fulfillment type is returned only if a delivery address was specified.
     */
    timeslotsPerFulfillmentType?: TimeSlotForFulfillment[];
    /** Metadata for the paginated results. */
    cursorPagingMetadata?: CursorPagingMetadata;
}
interface ListAvailableTimeSlotsForDateRequest {
    /**
     * Operation ID.
     * The returned fulfillment options will belong to this operation.
     * @format GUID
     */
    operationId: string;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
    /** Date and time to get the available time slots for. */
    date: _Date;
}
interface _Date {
    /**
     * The day of the month.
     * @min 1
     * @max 31
     */
    day?: number;
    /**
     * The month of the year.
     * @min 1
     * @max 12
     */
    month?: number;
    /**
     * The year of the date.
     * @min 2023
     * @max 2200
     */
    year?: number;
}
interface ListAvailableTimeSlotsForDateResponse {
    /** List of the available time slots in the requested date. */
    timeSlots?: FulfillmentTimeSlot[];
}
interface CalculateAvailableTimeSlotsForDateRequest {
    /**
     * Operation ID.
     * @format GUID
     */
    operationId: string;
    /**
     * Delivery address.
     *
     * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
    /** Date and time to get the available time slots for. */
    date: _Date;
}
interface CalculateAvailableTimeSlotsForDateResponse {
    /**
     * Available time slots of each fulfillment type for the specified date.
     *
     * A time slot with the delivery fulfillment type is returned only if a delivery address was specified.
     * @maxSize 2
     */
    timeslotsPerFulfillmentType?: TimeSlotForFulfillment[];
}
interface ListAvailableDatesInRangeRequest {
    /**
     * Operation ID.
     * The returned fulfillment options will belong to this operation.
     * @format GUID
     */
    operationId: string;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
    /** Start date and time of the range. */
    from: _Date;
    /** End date and time of the range. */
    until: _Date;
}
interface ListAvailableDatesInRangeResponse {
    /** List of the available dates in descending order for each fulfillment type. */
    availableDates?: FulfillmentTypeAvailableDates[];
}
/** Available dates for a given fulfillment type. */
interface FulfillmentTypeAvailableDates {
    /** Fulfillment type. */
    fulfilmentType?: FulfillmentTypeWithLiterals;
    /**
     * Available dates in descending order (most recent first).
     *
     * Contains all dates that have at least one available time slot for this fulfillment type.
     * @minSize 1
     * @maxSize 100
     */
    dates?: _Date[];
}
interface CalculateAvailableDatesInRangeRequest {
    /**
     * Operation ID.
     * @format GUID
     */
    operationId: string;
    /**
     * Delivery address.
     *
     * Delivery fulfillment methods are only considered when calculating date availability if a delivery address is specified.
     */
    deliveryAddress?: CommonAddress;
    /** Start date and time of the range. */
    from: _Date;
    /** End date and time of the range. */
    until: _Date;
}
interface CalculateAvailableDatesInRangeResponse {
    /**
     * Available dates of each fulfillment type within the specified time range.
     *
     * Contains all dates that have at least one available time slot.
     */
    availableDatesPerFulfillmentType?: FulfillmentTypeAvailableDates[];
}
interface GetExpectedFulfillmentSelectionRequest {
    /**
     * Operation ID. The returned fulfillment will belong to this operation.
     * @format GUID
     */
    operationId?: string;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
    /** Start time and date of the time slot. */
    timeslotStartTime?: Date | null;
    /** End time and date of the time slot. */
    timeslotEndTime?: Date | null;
    /** Type of fulfillment. */
    fulfilmentType?: FulfillmentTypeWithLiterals;
    /** Whether it is possible to submit an order to be prepared asap. */
    canSubmitOrderForNow?: boolean | null;
}
interface GetExpectedFulfillmentSelectionResponse {
    /** Expected fulfillment option. */
    expectedFulfillmentSelections?: FulfillmentOption[];
}
interface UpdateImmutableFieldsRequest {
    /** Immutable fields to update. */
    immutableFields?: ImmutableFields;
}
interface ImmutableFields {
    /**
     * operation id
     * @format GUID
     */
    _id?: string;
    /**
     * operation group id
     * @format GUID
     */
    operationGroupId?: string | null;
    /**
     * business location id
     * @format GUID
     */
    businessLocationId?: string | null;
}
interface UpdateImmutableFieldsResponse {
    /** Updated operation. */
    operation?: Operation;
}
interface ValidateOperationAddressRequest {
    /**
     * The ID of the operation to validate
     * @format GUID
     */
    operationId: string;
}
/** Response message for address validation */
interface ValidateOperationAddressResponse {
    /** Whether the address is valid */
    valid?: boolean;
    /**
     * List of violations if the address is invalid
     * @maxSize 5
     */
    violations?: AddressViolation[];
}
/** Represents a specific violation in the address */
interface AddressViolation {
    /** The type of violation */
    type?: ViolationTypeWithLiterals;
}
/** Type of violation found in the address */
declare enum ViolationType {
    UNKNOWN = "UNKNOWN",
    NO_ADDRESS = "NO_ADDRESS",
    MISSING_FORMATTED_ADDRESS = "MISSING_FORMATTED_ADDRESS",
    INVALID_GEOCODE = "INVALID_GEOCODE",
    MISSING_COUNTRY = "MISSING_COUNTRY",
    MISSING_SUBDIVISION = "MISSING_SUBDIVISION"
}
/** @enumType */
type ViolationTypeWithLiterals = ViolationType | 'UNKNOWN' | 'NO_ADDRESS' | 'MISSING_FORMATTED_ADDRESS' | 'INVALID_GEOCODE' | 'MISSING_COUNTRY' | 'MISSING_SUBDIVISION';
interface UpdateDeliveryRegionsRequest {
    /**
     * Country code for delivery destinations (e.g., "US", "CA")
     * @maxLength 150
     */
    countryCode?: string;
    /**
     * Optional subdivision for delivery destinations (e.g., state, province)
     * @maxLength 150
     */
    subdivision?: string | null;
}
interface UpdateDeliveryRegionsResponse {
}
interface BulkUpdateOperationTagsRequest {
    /**
     * IDs of the operations to update tags for.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    operationIds: string[];
    /** Tags to assign to the operations. */
    assignTags?: Tags;
    /** Tags to unassign from the operations. */
    unassignTags?: Tags;
}
interface BulkUpdateOperationTagsResponse {
    /**
     * Results of the bulk update.
     * @minSize 1
     * @maxSize 100
     */
    results?: BulkUpdateOperationTagsResult[];
    /** Metadata for the bulk update. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface ItemMetadata {
    /**
     * Item ID. Should always be available, unless it's impossible (for example, when failing to create an item).
     * @format GUID
     */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkUpdateOperationTagsResult {
    /** Metadata for the updated operation. */
    itemMetadata?: ItemMetadata;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateOperationTagsByFilterRequest {
    /** Filter that determines which operations to update tags for. */
    filter: Record<string, any> | null;
    /** Tags to assign to the operations. */
    assignTags?: Tags;
    /** Tags to unassign from the operations. */
    unassignTags?: Tags;
}
interface BulkUpdateOperationTagsByFilterResponse {
    /**
     * Job ID. Pass this ID to Get Async Job ([SDK](https://dev.wix.com/docs/sdk/backend-modules/async-jobs/get-async-job) | [REST](https://dev.wix.com/docs/rest/business-management/async-job/get-async-job)) to track the job's status.
     * @format GUID
     */
    jobId?: string;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
/** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
interface SitePropertiesNotification {
    /** The site ID for which this update notification applies. */
    metasiteId?: string;
    /** The actual update event. */
    event?: SitePropertiesEvent;
    /**
     * A convenience set of mappings from the MetaSite ID to its constituent services.
     * @maxSize 500
     */
    translations?: Translation[];
    /** Context of the notification */
    changeContext?: ChangeContext;
}
/** The actual update event for a particular notification. */
interface SitePropertiesEvent {
    /** Version of the site's properties represented by this update. */
    version?: number;
    /** Set of properties that were updated - corresponds to the fields in "properties". */
    fields?: string[];
    /** Updated properties. */
    properties?: Properties;
}
interface Properties {
    /** Site categories. */
    categories?: Categories;
    /** Site locale. */
    locale?: Locale;
    /**
     * Site language.
     *
     * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
     */
    language?: string | null;
    /**
     * Site currency format used to bill customers.
     *
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    paymentCurrency?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Fax number. */
    fax?: string | null;
    /** Address. */
    address?: Address;
    /** Site display name. */
    siteDisplayName?: string | null;
    /** Business name. */
    businessName?: string | null;
    /** Path to the site's logo in Wix Media (without Wix Media base URL). */
    logo?: string | null;
    /** Site description. */
    description?: string | null;
    /**
     * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /** Supported languages of a site and the primary language. */
    multilingual?: Multilingual;
    /** Cookie policy the Wix user defined for their site (before the site visitor interacts with/limits it). */
    consentPolicy?: ConsentPolicy;
    /**
     * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
     *
     * Site business type.
     */
    businessConfig?: string | null;
    /** External site URL that uses Wix as its headless business solution. */
    externalSiteUrl?: string | null;
    /** Track clicks analytics. */
    trackClicksAnalytics?: boolean;
}
interface Categories {
    /** Primary site category. */
    primary?: string;
    /**
     * Secondary site category.
     * @maxSize 50
     */
    secondary?: string[];
    /** Business Term Id */
    businessTermId?: string | null;
}
interface Locale {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
    country?: string;
}
interface Address {
    /** Street name. */
    street?: string;
    /** City name. */
    city?: string;
    /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
    country?: string;
    /** State. */
    state?: string;
    /**
     * Zip or postal code.
     * @maxLength 20
     */
    zip?: string;
    /** Extra information to be displayed in the address. */
    hint?: AddressHint;
    /** Whether this address represents a physical location. */
    isPhysical?: boolean;
    /** Google-formatted version of this address. */
    googleFormattedAddress?: string;
    /** Street number. */
    streetNumber?: string;
    /** Apartment number. */
    apartmentNumber?: string;
    /** Geographic coordinates of location. */
    coordinates?: GeoCoordinates;
}
/**
 * Extra information on displayed addresses.
 * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
 * Free text. In addition, the user can state where to display the additional description - before, after, or instead of the address string.
 */
interface AddressHint {
    /** Extra text displayed next to, or instead of, the actual address. */
    text?: string;
    /** Where the extra text should be displayed. */
    placement?: PlacementTypeWithLiterals;
}
/** Where the extra text should be displayed: before, after or instead of the actual address. */
declare enum PlacementType {
    BEFORE = "BEFORE",
    AFTER = "AFTER",
    REPLACE = "REPLACE"
}
/** @enumType */
type PlacementTypeWithLiterals = PlacementType | 'BEFORE' | 'AFTER' | 'REPLACE';
/** Geocoordinates for a particular address. */
interface GeoCoordinates {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number;
}
/** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
interface BusinessSchedule {
    /**
     * Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods.
     * @maxSize 100
     */
    periods?: TimePeriod[];
    /**
     * Exceptions to the business's regular hours. The business can be open or closed during the exception.
     * @maxSize 100
     */
    specialHourPeriod?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the business is regularly open or the service is available. */
interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeekWithLiterals;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeekWithLiterals;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     *
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
/** Enumerates the days of the week. */
declare enum DayOfWeek {
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY",
    SUNDAY = "SUNDAY"
}
/** @enumType */
type DayOfWeekWithLiterals = DayOfWeek | 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY';
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /**
     * Whether the business is closed (or the service is not available) during the exception.
     *
     * Default: `true`.
     */
    isClosed?: boolean;
    /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
    comment?: string;
}
interface Multilingual {
    /**
     * Supported languages list.
     * @maxSize 200
     */
    supportedLanguages?: SupportedLanguage[];
    /** Whether to redirect to user language. */
    autoRedirect?: boolean;
}
interface SupportedLanguage {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Locale. */
    locale?: Locale;
    /** Whether the supported language is the primary language for the site. */
    isPrimary?: boolean;
    /** Language icon. */
    countryCode?: string;
    /** How the language will be resolved. For internal use. */
    resolutionMethod?: ResolutionMethodWithLiterals;
    /** Whether the supported language is the primary language for site visitors. */
    isVisitorPrimary?: boolean | null;
}
declare enum ResolutionMethod {
    QUERY_PARAM = "QUERY_PARAM",
    SUBDOMAIN = "SUBDOMAIN",
    SUBDIRECTORY = "SUBDIRECTORY"
}
/** @enumType */
type ResolutionMethodWithLiterals = ResolutionMethod | 'QUERY_PARAM' | 'SUBDOMAIN' | 'SUBDIRECTORY';
interface ConsentPolicy {
    /** Whether the site uses cookies that are essential to site operation. Always `true`. */
    essential?: boolean | null;
    /** Whether the site uses cookies that affect site performance and other functional measurements. */
    functional?: boolean | null;
    /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
    analytics?: boolean | null;
    /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
    advertising?: boolean | null;
    /** CCPA compliance flag. */
    dataToThirdParty?: boolean | null;
}
/** A single mapping from the MetaSite ID to a particular service. */
interface Translation {
    /** The service type. */
    serviceType?: string;
    /** The application definition ID; this only applies to services of type ThirdPartyApps. */
    appDefId?: string;
    /** The instance ID of the service. */
    instanceId?: string;
}
interface ChangeContext extends ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: V4SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
/** @oneof */
interface ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: V4SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
interface PropertiesChange {
}
interface V4SiteCreated {
    /** Origin template site id. */
    originTemplateId?: string | null;
}
interface SiteCloned {
    /** Origin site id. */
    originMetaSiteId?: string;
}
interface MetaSiteSpecialEvent extends MetaSiteSpecialEventPayloadOneOf {
    /** Emitted on a meta site creation. */
    siteCreated?: SiteCreated;
    /** Emitted on a meta site transfer completion. */
    siteTransferred?: SiteTransferred;
    /** Emitted on a meta site deletion. */
    siteDeleted?: SiteDeleted;
    /** Emitted on a meta site restoration. */
    siteUndeleted?: SiteUndeleted;
    /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
    sitePublished?: SitePublished;
    /** Emitted on a meta site unpublish. */
    siteUnpublished?: SiteUnpublished;
    /** Emitted when meta site is marked as template. */
    siteMarkedAsTemplate?: SiteMarkedAsTemplate;
    /** Emitted when meta site is marked as a WixSite. */
    siteMarkedAsWixSite?: SiteMarkedAsWixSite;
    /** Emitted when an application is provisioned (installed). */
    serviceProvisioned?: ServiceProvisioned;
    /** Emitted when an application is removed (uninstalled). */
    serviceRemoved?: ServiceRemoved;
    /** Emitted when meta site name (URL slug) is changed. */
    siteRenamedPayload?: SiteRenamed;
    /** Emitted when meta site was permanently deleted. */
    hardDeleted?: SiteHardDeleted;
    /** Emitted on a namespace change. */
    namespaceChanged?: NamespaceChanged;
    /** Emitted when Studio is attached. */
    studioAssigned?: StudioAssigned;
    /** Emitted when Studio is detached. */
    studioUnassigned?: StudioUnassigned;
    /**
     * Emitted when one of the URLs is changed. After this event you may call `urls-server` to fetch
     * the actual URL.
     *
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1732520791210559?thread_ts=1732027914.294059&cid=C0UHEBPFT
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1744115197619459
     */
    urlChanged?: SiteUrlChanged;
    /** Site is marked as PurgedExternally */
    sitePurgedExternally?: SitePurgedExternally;
    /** Emitted when Odeditor is attached. */
    odeditorAssigned?: OdeditorAssigned;
    /** Emitted when Odeditor is detached. */
    odeditorUnassigned?: OdeditorUnassigned;
    /** Emitted when Picasso is attached. */
    picassoAssigned?: PicassoAssigned;
    /** Emitted when Picasso is detached. */
    picassoUnassigned?: PicassoUnassigned;
    /** Emitted when Wixel is attached. */
    wixelAssigned?: WixelAssigned;
    /** Emitted when Wixel is detached. */
    wixelUnassigned?: WixelUnassigned;
    /** Emitted when StudioTwo is attached. */
    studioTwoAssigned?: StudioTwoAssigned;
    /** Emitted when StudioTwo is detached. */
    studioTwoUnassigned?: StudioTwoUnassigned;
    /**
     * A meta site id.
     * @format GUID
     */
    metaSiteId?: string;
    /** A meta site version. Monotonically increasing. */
    version?: string;
    /** A timestamp of the event. */
    timestamp?: string;
    /**
     * TODO(meta-site): Change validation once validations are disabled for consumers
     * More context: https://wix.slack.com/archives/C0UHEBPFT/p1720957844413149 and https://wix.slack.com/archives/CFWKX325T/p1728892152855659
     * @maxSize 4000
     */
    assets?: Asset[];
}
/** @oneof */
interface MetaSiteSpecialEventPayloadOneOf {
    /** Emitted on a meta site creation. */
    siteCreated?: SiteCreated;
    /** Emitted on a meta site transfer completion. */
    siteTransferred?: SiteTransferred;
    /** Emitted on a meta site deletion. */
    siteDeleted?: SiteDeleted;
    /** Emitted on a meta site restoration. */
    siteUndeleted?: SiteUndeleted;
    /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
    sitePublished?: SitePublished;
    /** Emitted on a meta site unpublish. */
    siteUnpublished?: SiteUnpublished;
    /** Emitted when meta site is marked as template. */
    siteMarkedAsTemplate?: SiteMarkedAsTemplate;
    /** Emitted when meta site is marked as a WixSite. */
    siteMarkedAsWixSite?: SiteMarkedAsWixSite;
    /** Emitted when an application is provisioned (installed). */
    serviceProvisioned?: ServiceProvisioned;
    /** Emitted when an application is removed (uninstalled). */
    serviceRemoved?: ServiceRemoved;
    /** Emitted when meta site name (URL slug) is changed. */
    siteRenamedPayload?: SiteRenamed;
    /** Emitted when meta site was permanently deleted. */
    hardDeleted?: SiteHardDeleted;
    /** Emitted on a namespace change. */
    namespaceChanged?: NamespaceChanged;
    /** Emitted when Studio is attached. */
    studioAssigned?: StudioAssigned;
    /** Emitted when Studio is detached. */
    studioUnassigned?: StudioUnassigned;
    /**
     * Emitted when one of the URLs is changed. After this event you may call `urls-server` to fetch
     * the actual URL.
     *
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1732520791210559?thread_ts=1732027914.294059&cid=C0UHEBPFT
     * See: https://wix.slack.com/archives/C0UHEBPFT/p1744115197619459
     */
    urlChanged?: SiteUrlChanged;
    /** Site is marked as PurgedExternally */
    sitePurgedExternally?: SitePurgedExternally;
    /** Emitted when Odeditor is attached. */
    odeditorAssigned?: OdeditorAssigned;
    /** Emitted when Odeditor is detached. */
    odeditorUnassigned?: OdeditorUnassigned;
    /** Emitted when Picasso is attached. */
    picassoAssigned?: PicassoAssigned;
    /** Emitted when Picasso is detached. */
    picassoUnassigned?: PicassoUnassigned;
    /** Emitted when Wixel is attached. */
    wixelAssigned?: WixelAssigned;
    /** Emitted when Wixel is detached. */
    wixelUnassigned?: WixelUnassigned;
    /** Emitted when StudioTwo is attached. */
    studioTwoAssigned?: StudioTwoAssigned;
    /** Emitted when StudioTwo is detached. */
    studioTwoUnassigned?: StudioTwoUnassigned;
}
interface Asset {
    /**
     * An application definition id (app_id in dev-center). For legacy reasons may be UUID or a string (from Java Enum).
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * An instance id. For legacy reasons may be UUID or a string.
     * @maxLength 200
     */
    instanceId?: string;
    /** An application state. */
    state?: StateWithLiterals;
}
declare enum State {
    UNKNOWN = "UNKNOWN",
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    PENDING = "PENDING",
    DEMO = "DEMO"
}
/** @enumType */
type StateWithLiterals = State | 'UNKNOWN' | 'ENABLED' | 'DISABLED' | 'PENDING' | 'DEMO';
interface SiteCreated {
    /**
     * A template identifier (empty if not created from a template).
     * @maxLength 36
     */
    originTemplateId?: string;
    /**
     * An account id of the owner.
     * @format GUID
     */
    ownerId?: string;
    /** A context in which meta site was created. */
    context?: SiteCreatedContextWithLiterals;
    /**
     * A meta site id from which this site was created.
     *
     * In case of a creation from a template it's a template id.
     * In case of a site duplication ("Save As" in dashboard or duplicate in UM) it's an id of a source site.
     * @format GUID
     */
    originMetaSiteId?: string | null;
    /**
     * A meta site name (URL slug).
     * @maxLength 20
     */
    siteName?: string;
    /** A namespace. */
    namespace?: NamespaceWithLiterals;
}
declare enum SiteCreatedContext {
    /** A valid option, we don't expose all reasons why site might be created. */
    OTHER = "OTHER",
    /** A meta site was created from template. */
    FROM_TEMPLATE = "FROM_TEMPLATE",
    /** A meta site was created by copying of the transfferred meta site. */
    DUPLICATE_BY_SITE_TRANSFER = "DUPLICATE_BY_SITE_TRANSFER",
    /** A copy of existing meta site. */
    DUPLICATE = "DUPLICATE",
    /** A meta site was created as a transfferred site (copy of the original), old flow, should die soon. */
    OLD_SITE_TRANSFER = "OLD_SITE_TRANSFER",
    /** deprecated A meta site was created for Flash editor. */
    FLASH = "FLASH"
}
/** @enumType */
type SiteCreatedContextWithLiterals = SiteCreatedContext | 'OTHER' | 'FROM_TEMPLATE' | 'DUPLICATE_BY_SITE_TRANSFER' | 'DUPLICATE' | 'OLD_SITE_TRANSFER' | 'FLASH';
declare enum Namespace {
    UNKNOWN_NAMESPACE = "UNKNOWN_NAMESPACE",
    /** Default namespace for UGC sites. MetaSites with this namespace will be shown in a user's site list by default. */
    WIX = "WIX",
    /** ShoutOut stand alone product. These are siteless (no actual Wix site, no HtmlWeb). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    SHOUT_OUT = "SHOUT_OUT",
    /** MetaSites created by the Albums product, they appear as part of the Albums app. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    ALBUMS = "ALBUMS",
    /** Part of the WixStores migration flow, a user tries to migrate and gets this site to view and if the user likes it then stores removes this namespace and deletes the old site with the old stores. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    WIX_STORES_TEST_DRIVE = "WIX_STORES_TEST_DRIVE",
    /** Hotels standalone (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    HOTELS = "HOTELS",
    /** Clubs siteless MetaSites, a club without a wix website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    CLUBS = "CLUBS",
    /** A partially created ADI website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    ONBOARDING_DRAFT = "ONBOARDING_DRAFT",
    /** AppBuilder for AppStudio / shmite (c). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    DEV_SITE = "DEV_SITE",
    /** LogoMaker websites offered to the user after logo purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    LOGOS = "LOGOS",
    /** VideoMaker websites offered to the user after video purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
    VIDEO_MAKER = "VIDEO_MAKER",
    /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
    PARTNER_DASHBOARD = "PARTNER_DASHBOARD",
    /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
    DEV_CENTER_COMPANY = "DEV_CENTER_COMPANY",
    /**
     * A draft created by HTML editor on open. Upon "first save" it will be moved to be of WIX domain.
     *
     * Meta site with this namespace will *not* be shown in a user's site list by default.
     */
    HTML_DRAFT = "HTML_DRAFT",
    /**
     * the user-journey for Fitness users who want to start from managing their business instead of designing their website.
     * Will be accessible from Site List and will not have a website app.
     * Once the user attaches a site, the site will become a regular wixsite.
     */
    SITELESS_BUSINESS = "SITELESS_BUSINESS",
    /** Belongs to "strategic products" company. Supports new product in the creator's economy space. */
    CREATOR_ECONOMY = "CREATOR_ECONOMY",
    /** It is to be used in the Business First efforts. */
    DASHBOARD_FIRST = "DASHBOARD_FIRST",
    /** Bookings business flow with no site. */
    ANYWHERE = "ANYWHERE",
    /** Namespace for Headless Backoffice with no editor */
    HEADLESS = "HEADLESS",
    /**
     * Namespace for master site that will exist in parent account that will be referenced by subaccounts
     * The site will be used for account level CSM feature for enterprise
     */
    ACCOUNT_MASTER_CMS = "ACCOUNT_MASTER_CMS",
    /** Rise.ai Siteless account management for Gift Cards and Store Credit. */
    RISE = "RISE",
    /**
     * As part of the branded app new funnel, users now can create a meta site that will be branded app first.
     * There's a blank site behind the scene but it's blank).
     * The Mobile company will be the owner of this namespace.
     */
    BRANDED_FIRST = "BRANDED_FIRST",
    /** Nownia.com Siteless account management for Ai Scheduling Assistant. */
    NOWNIA = "NOWNIA",
    /**
     * UGC Templates are templates that are created by users for personal use and to sale to other users.
     * The Partners company owns this namespace.
     */
    UGC_TEMPLATE = "UGC_TEMPLATE",
    /** Codux Headless Sites */
    CODUX = "CODUX",
    /** Bobb - AI Design Creator. */
    MEDIA_DESIGN_CREATOR = "MEDIA_DESIGN_CREATOR",
    /**
     * Shared Blog Site is a unique single site across Enterprise account,
     * This site will hold all Blog posts related to the Marketing product.
     */
    SHARED_BLOG_ENTERPRISE = "SHARED_BLOG_ENTERPRISE",
    /** Standalone forms (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    STANDALONE_FORMS = "STANDALONE_FORMS",
    /** Standalone events (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
    STANDALONE_EVENTS = "STANDALONE_EVENTS",
    /** MIMIR - Siteless account for MIMIR Ai Job runner. */
    MIMIR = "MIMIR",
    /** Wix Twins platform. */
    TWINS = "TWINS",
    /** Wix Nano. */
    NANO = "NANO"
}
/** @enumType */
type NamespaceWithLiterals = Namespace | 'UNKNOWN_NAMESPACE' | 'WIX' | 'SHOUT_OUT' | 'ALBUMS' | 'WIX_STORES_TEST_DRIVE' | 'HOTELS' | 'CLUBS' | 'ONBOARDING_DRAFT' | 'DEV_SITE' | 'LOGOS' | 'VIDEO_MAKER' | 'PARTNER_DASHBOARD' | 'DEV_CENTER_COMPANY' | 'HTML_DRAFT' | 'SITELESS_BUSINESS' | 'CREATOR_ECONOMY' | 'DASHBOARD_FIRST' | 'ANYWHERE' | 'HEADLESS' | 'ACCOUNT_MASTER_CMS' | 'RISE' | 'BRANDED_FIRST' | 'NOWNIA' | 'UGC_TEMPLATE' | 'CODUX' | 'MEDIA_DESIGN_CREATOR' | 'SHARED_BLOG_ENTERPRISE' | 'STANDALONE_FORMS' | 'STANDALONE_EVENTS' | 'MIMIR' | 'TWINS' | 'NANO';
/** Site transferred to another user. */
interface SiteTransferred {
    /**
     * A previous owner id (user that transfers meta site).
     * @format GUID
     */
    oldOwnerId?: string;
    /**
     * A new owner id (user that accepts meta site).
     * @format GUID
     */
    newOwnerId?: string;
}
/** Soft deletion of the meta site. Could be restored. */
interface SiteDeleted {
    /** A deletion context. */
    deleteContext?: DeleteContext;
}
interface DeleteContext {
    /** When the meta site was deleted. */
    dateDeleted?: Date | null;
    /** A status. */
    deleteStatus?: DeleteStatusWithLiterals;
    /**
     * A reason (flow).
     * @maxLength 255
     */
    deleteOrigin?: string;
    /**
     * A service that deleted it.
     * @maxLength 255
     */
    initiatorId?: string | null;
}
declare enum DeleteStatus {
    UNKNOWN = "UNKNOWN",
    TRASH = "TRASH",
    DELETED = "DELETED",
    PENDING_PURGE = "PENDING_PURGE",
    PURGED_EXTERNALLY = "PURGED_EXTERNALLY"
}
/** @enumType */
type DeleteStatusWithLiterals = DeleteStatus | 'UNKNOWN' | 'TRASH' | 'DELETED' | 'PENDING_PURGE' | 'PURGED_EXTERNALLY';
/** Restoration of the meta site. */
interface SiteUndeleted {
}
/** First publish of a meta site. Or subsequent publish after unpublish. */
interface SitePublished {
}
interface SiteUnpublished {
    /**
     * A list of URLs previously associated with the meta site.
     * @maxLength 4000
     * @maxSize 10000
     */
    urls?: string[];
}
interface SiteMarkedAsTemplate {
}
interface SiteMarkedAsWixSite {
}
/**
 * Represents a service provisioned a site.
 *
 * Note on `origin_instance_id`:
 * There is no guarantee that you will be able to find a meta site using `origin_instance_id`.
 * This is because of the following scenario:
 *
 * Imagine you have a template where a third-party application (TPA) includes some stub data,
 * such as a product catalog. When you create a site from this template, you inherit this
 * default product catalog. However, if the template's product catalog is modified,
 * your site will retain the catalog as it was at the time of site creation. This ensures that
 * your site remains consistent with what you initially received and does not include any
 * changes made to the original template afterward.
 * To ensure this, the TPA on the template gets a new instance_id.
 */
interface ServiceProvisioned {
    /**
     * Either UUID or EmbeddedServiceType.
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * Not only UUID. Something here could be something weird.
     * @maxLength 36
     */
    instanceId?: string;
    /**
     * An instance id from which this instance is originated.
     * @maxLength 36
     */
    originInstanceId?: string;
    /**
     * A version.
     * @maxLength 500
     */
    version?: string | null;
    /**
     * The origin meta site id
     * @format GUID
     */
    originMetaSiteId?: string | null;
}
interface ServiceRemoved {
    /**
     * Either UUID or EmbeddedServiceType.
     * @maxLength 36
     */
    appDefId?: string;
    /**
     * Not only UUID. Something here could be something weird.
     * @maxLength 36
     */
    instanceId?: string;
    /**
     * A version.
     * @maxLength 500
     */
    version?: string | null;
}
/** Rename of the site. Meaning, free public url has been changed as well. */
interface SiteRenamed {
    /**
     * A new meta site name (URL slug).
     * @maxLength 20
     */
    newSiteName?: string;
    /**
     * A previous meta site name (URL slug).
     * @maxLength 255
     */
    oldSiteName?: string;
}
/**
 * Hard deletion of the meta site.
 *
 * Could not be restored. Therefore it's desirable to cleanup data.
 */
interface SiteHardDeleted {
    /** A deletion context. */
    deleteContext?: DeleteContext;
}
interface NamespaceChanged {
    /** A previous namespace. */
    oldNamespace?: NamespaceWithLiterals;
    /** A new namespace. */
    newNamespace?: NamespaceWithLiterals;
}
/** Assigned Studio editor */
interface StudioAssigned {
}
/** Unassigned Studio editor */
interface StudioUnassigned {
}
/**
 * Fired in case site URLs were changed in any way: new secondary domain, published, account slug rename, site rename etc.
 *
 * This is an internal event, it's not propagated in special events, because it's non-actionable. If you need to keep up
 * with sites and its urls, you need to listen to another topic/event. Read about it:
 *
 * https://bo.wix.com/wix-docs/rest/meta-site/meta-site---urls-service
 */
interface SiteUrlChanged {
}
/**
 * Used at the end of the deletion flow for both draft sites and when a user deletes a site.
 * Consumed by other teams to remove relevant data.
 */
interface SitePurgedExternally {
    /**
     * @maxLength 2048
     * @maxSize 100
     * @deprecated
     * @targetRemovalDate 2025-04-15
     */
    appDefId?: string[];
}
/** Assigned Odeditor */
interface OdeditorAssigned {
}
/** Unassigned Odeditor */
interface OdeditorUnassigned {
}
/** Assigned Picasso editor */
interface PicassoAssigned {
}
/** Unassigned Picasso */
interface PicassoUnassigned {
}
/** Assigned Wixel */
interface WixelAssigned {
}
/** Unassigned Wixel */
interface WixelUnassigned {
}
/** Assigned StudioTwo */
interface StudioTwoAssigned {
}
/** Unassigned StudioTwo */
interface StudioTwoUnassigned {
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
/** @docsIgnore */
type BulkUpdateOperationTagsApplicationErrors = {
    code?: 'EMPTY_ASSIGN_AND_UNASSIGN_LISTS';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type BulkUpdateOperationTagsByFilterApplicationErrors = {
    code?: 'EMPTY_ASSIGN_AND_UNASSIGN_LISTS';
    description?: string;
    data?: Record<string, any>;
};
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface OperationCreatedEnvelope {
    entity: Operation;
    metadata: EventMetadata;
}
/**
 * Triggered when an operation is created.
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId RESTAURANTS.OPERATION_READ
 * @webhook
 * @eventType wix.restaurants.operations.v1.operation_created
 * @serviceIdentifier wix.restaurants.operations.v1.OperationsService
 * @slug created
 * @documentationMaturity preview
 */
declare function onOperationCreated(handler: (event: OperationCreatedEnvelope) => void | Promise<void>): void;
interface OperationDeletedEnvelope {
    entity: Operation;
    metadata: EventMetadata;
}
/**
 * Triggered when an operation is deleted.
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId RESTAURANTS.OPERATION_READ
 * @webhook
 * @eventType wix.restaurants.operations.v1.operation_deleted
 * @serviceIdentifier wix.restaurants.operations.v1.OperationsService
 * @slug deleted
 * @documentationMaturity preview
 */
declare function onOperationDeleted(handler: (event: OperationDeletedEnvelope) => void | Promise<void>): void;
interface OperationUpdatedEnvelope {
    entity: Operation;
    metadata: EventMetadata;
}
/**
 * Triggered when an operation is updated.
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId RESTAURANTS.OPERATION_READ
 * @webhook
 * @eventType wix.restaurants.operations.v1.operation_updated
 * @serviceIdentifier wix.restaurants.operations.v1.OperationsService
 * @slug updated
 * @documentationMaturity preview
 */
declare function onOperationUpdated(handler: (event: OperationUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a new operation.
 * @param operation - Operation to create.
 * @public
 * @documentationMaturity preview
 * @requiredField operation
 * @permissionId RESTAURANTS.OPERATION_CREATE
 * @applicableIdentity APP
 * @returns Created operation.
 * @fqn wix.restaurants.operations.v1.OperationsService.CreateOperation
 * @deprecated
 * @replacedBy wix.restaurants.v1.OperationGroupService.CreateOperationGroup
 * @targetRemovalDate 2025-08-31
 */
declare function createOperation(operation: Operation): Promise<NonNullablePaths<Operation, `fulfillmentIds` | `onlineOrderingStatus` | `defaultFulfillmentType` | `orderScheduling.asapOptions.preparationTime.maxTimeOptions.timeUnit` | `orderScheduling.asapOptions.preparationTime.timeRangeOptions.timeUnit` | `orderScheduling.asapOptions.preparationTime.type` | `orderScheduling.asapOptions.asapFutureHandlingType` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.dayOfWeek` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.timeOfDay.hours` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.timeOfDay.minutes` | `orderScheduling.preorderOptions.method.type` | `orderScheduling.preorderOptions.fulfillmentTimesDisplay.type` | `orderScheduling.type` | `tags.privateTags.tagIds`, 8>>;
/**
 * Retrieves an operation.
 * @param operationId - ID of the operation to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @returns Retrieved operation.
 * @fqn wix.restaurants.operations.v1.OperationsService.GetOperation
 */
declare function getOperation(operationId: string): Promise<NonNullablePaths<Operation, `fulfillmentIds` | `onlineOrderingStatus` | `defaultFulfillmentType` | `orderScheduling.asapOptions.preparationTime.maxTimeOptions.timeUnit` | `orderScheduling.asapOptions.preparationTime.timeRangeOptions.timeUnit` | `orderScheduling.asapOptions.preparationTime.type` | `orderScheduling.asapOptions.asapFutureHandlingType` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.dayOfWeek` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.timeOfDay.hours` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.timeOfDay.minutes` | `orderScheduling.preorderOptions.method.type` | `orderScheduling.preorderOptions.fulfillmentTimesDisplay.type` | `orderScheduling.type` | `tags.privateTags.tagIds`, 8>>;
/**
 * Updates an operation.
 *
 * If you update part of the `orderScheduling` property, the whole object is overwritten,
 * so you must include the entire object unless you are not updating `orderScheduling` at all. <br />
 *
 * Each time the operation is updated,
 * `revision` increments by 1.
 * The current `revision` must be passed when updating the operation.
 * This ensures you're working with the latest operation
 * and prevents unintended overwrites.
 * @param _id - Operation ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField operation
 * @requiredField operation.revision
 * @permissionId RESTAURANTS.OPERATION_UPDATE
 * @applicableIdentity APP
 * @returns Updated operation.
 * @fqn wix.restaurants.operations.v1.OperationsService.UpdateOperation
 */
declare function updateOperation(_id: string, operation: NonNullablePaths<UpdateOperation, `revision`, 2>): Promise<NonNullablePaths<Operation, `fulfillmentIds` | `onlineOrderingStatus` | `defaultFulfillmentType` | `orderScheduling.asapOptions.preparationTime.maxTimeOptions.timeUnit` | `orderScheduling.asapOptions.preparationTime.timeRangeOptions.timeUnit` | `orderScheduling.asapOptions.preparationTime.type` | `orderScheduling.asapOptions.asapFutureHandlingType` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.dayOfWeek` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.timeOfDay.hours` | `orderScheduling.preorderOptions.method.weeklyScheduleOptions.cutOffTime.timeOfDay.minutes` | `orderScheduling.preorderOptions.method.type` | `orderScheduling.preorderOptions.fulfillmentTimesDisplay.type` | `orderScheduling.type` | `tags.privateTags.tagIds`, 8>>;
interface UpdateOperation {
    /** Options for online ordering status. Required when `onlineOrderingStatus` is `PAUSED_UNTIL`. */
    pausedUntilOptions?: OnlineOrderingPausedUntilOptions;
    /**
     * Operation ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number. Increments by 1 each time the operation is updated.
     * To prevent conflicting changes,
     * the existing `revision` must be specified when updating an operation.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the operation was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the operation was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Operation name. */
    name?: string | null;
    /**
     * Whether the operation is the default operation. <br />
     * Default: `false`.
     */
    default?: boolean | null;
    /**
     * IDs of the fulfillment methods ([SDK](https://dev.wix.com/docs/sdk/backend-modules/restaurants/wix-restaurants-new/fulfillment-methods/introduction) | [REST](https://dev.wix.com/docs/rest/api-reference/wix-restaurants/fulfillment-methods/introduction)) associated with the operation.
     * @format GUID
     * @maxSize 500
     */
    fulfillmentIds?: string[] | null;
    /** Online ordering status of the operation. <br /> */
    onlineOrderingStatus?: OnlineOrderingStatusTypeWithLiterals;
    /** Default fulfillment type of the operation. */
    defaultFulfillmentType?: FulfillmentTypeWithLiterals;
    /** Information about when an order can be placed for. */
    orderScheduling?: OrderScheduling;
    /**
     * ID of the operation group this operation belongs to.
     * @format GUID
     * @immutable
     */
    operationGroupId?: string | null;
    /**
     * ID of the business location ([SDK](https://dev.wix.com/docs/sdk/backend-modules/restaurants/wix-restaurants-new/about-business-locations) | [REST](https://dev.wix.com/docs/rest/business-solutions/restaurants/wix-restaurants-new/about-business-locations)) of this operation.
     * @format GUID
     * @immutable
     * @readonly
     */
    businessLocationId?: string | null;
    /** Extended fields. */
    extendedFields?: ExtendedFields;
    /** Tags ([SDK](https://dev.wix.com/docs/sdk/backend-modules/tags/tags/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/tags/introduction)) used to classify and sort different types of operations. */
    tags?: Tags;
}
/**
 * Deletes an operation.
 * @param operationId - ID of the operation to delete.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_DELETE
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.DeleteOperation
 * @deprecated
 * @replacedBy wix.restaurants.v1.OperationGroupService.DeleteOperationGroup
 * @targetRemovalDate 2025-08-31
 */
declare function deleteOperation(operationId: string): Promise<void>;
/**
 * Creates a query to retrieve a list of operations.
 *
 * The `queryOperations()` function builds a query to retrieve a list of operations and returns an `OperationsQueryBuilder` object.
 *
 * The returned object contains the query definition, which is used to run the query using the [`find()`](/operations/operations-query-builder/find) function.
 *
 * You can refine the query by chaining `OperationsQueryBuilder` functions onto the query. `OperationsQueryBuilder` functions enable you to filter, sort, and control the results that `queryOperations()` returns.
 *
 * `queryOperations()` runs with the following `OperationsQueryBuilder` defaults, which you can override:
 *
 * * [`limit(50)`](/operations/operations-query-builder/limit)
 * * [`ascending('entityId')`](/operations/operations-methods-query-builder/ascending)
 *
 * The following `OperationsQueryBuilder` functions are supported for `queryOperations()`. For a full description of the operations object, see the object returned for the [`items`](/operations/operations-query-result/items) property in `OperationsQueryResult`.
 * @public
 * @documentationMaturity preview
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.QueryOperation
 */
declare function queryOperation(): OperationsQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface OperationsQueryResult extends QueryCursorResult {
    items: Operation[];
    query: OperationsQueryBuilder;
    next: () => Promise<OperationsQueryResult>;
    prev: () => Promise<OperationsQueryResult>;
}
interface OperationsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'default' | 'fulfillmentIds' | 'onlineOrderingStatus' | 'defaultFulfillmentType' | 'businessLocationId' | 'businessLocationDetails.archived', value: any) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'default' | 'fulfillmentIds' | 'onlineOrderingStatus' | 'defaultFulfillmentType' | 'businessLocationId' | 'businessLocationDetails.archived', value: any) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'businessLocationId', value: any) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'businessLocationId', value: any) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'businessLocationId', value: any) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'businessLocationId', value: any) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | 'name' | 'businessLocationId', value: string) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'default' | 'fulfillmentIds' | 'onlineOrderingStatus' | 'defaultFulfillmentType' | 'businessLocationId' | 'businessLocationDetails.archived', value: any[]) => OperationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasAll: (propertyName: 'fulfillmentIds', value: any[]) => OperationsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'default' | 'fulfillmentIds' | 'onlineOrderingStatus' | 'defaultFulfillmentType' | 'businessLocationId' | 'businessLocationDetails.archived', value: any) => OperationsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'name' | 'default' | 'fulfillmentIds' | 'onlineOrderingStatus' | 'defaultFulfillmentType' | 'businessLocationId' | 'businessLocationDetails.archived', value: boolean) => OperationsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_id' | '_createdDate' | '_updatedDate' | 'name' | 'profileId' | 'default' | 'fulfillmentIds' | 'onlineOrderingStatus' | 'defaultFulfillmentType' | 'businessLocationId' | 'businessLocationDetails.archived'>) => OperationsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_id' | '_createdDate' | '_updatedDate' | 'name' | 'profileId' | 'default' | 'fulfillmentIds' | 'onlineOrderingStatus' | 'defaultFulfillmentType' | 'businessLocationId' | 'businessLocationDetails.archived'>) => OperationsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => OperationsQueryBuilder;
    /** @param cursor - A pointer to specific record
     * @documentationMaturity preview
     */
    skipTo: (cursor: string) => OperationsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<OperationsQueryResult>;
}
/**
 * Retrieves a list of operations.
 * The result will be sorted by created date in ascending order.
 * @public
 * @documentationMaturity preview
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.ListOperations
 */
declare function listOperations(): Promise<NonNullablePaths<ListOperationsResponse, `operations` | `operations.${number}.onlineOrderingStatus` | `operations.${number}.defaultFulfillmentType` | `operations.${number}.orderScheduling.asapOptions.asapFutureHandlingType` | `operations.${number}.orderScheduling.type`, 6>>;
/**
 * Retrieves a list of available fulfillment options.
 *
 * What makes a fulfillment option available is whether you can submit an order given the scheduling configurations and the fulfillment method's availability.
 * When a delivery address is not provided in the input, our system retrieves a list encompassing all types of fulfillment methods.
 * Conversely, if a delivery address` is given, the response may includes non-delivery fulfillment options along with delivery fulfillment methods that are applicable to the given address, ensuring the address falls within the defined delivery area of these methods.
 * @param operationId - Operation ID. Returned fulfillment options will belong to this operation.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.ListAvailableFulfillmentOptions
 */
declare function listAvailableFulfillmentOptions(operationId: string, options?: ListAvailableFulfillmentOptions): Promise<NonNullablePaths<ListAvailableFulfillmentOptionsResponse, `pickupConfigured` | `deliveryConfigured` | `fulfillmentOptions` | `fulfillmentOptions.${number}.maxTimeOptions` | `fulfillmentOptions.${number}.durationRangeOptions.minDuration` | `fulfillmentOptions.${number}.durationRangeOptions.maxDuration` | `fulfillmentOptions.${number}.timeWindowsOptions.durationInMinutes` | `fulfillmentOptions.${number}.type` | `fulfillmentOptions.${number}.availability.asapHandlingAvailable` | `fulfillmentOptions.${number}.fulfillmentTimeType` | `fulfillmentOptions.${number}.fulfillmentTimesDisplayType`, 5>>;
interface ListAvailableFulfillmentOptions {
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
/**
 * Retrieves a list of available time slots for each fulfillment type.
 *
 * Each time slot is the first available time slot for the given fulfillment type.
 * @param operationId - Operation ID.
 * Returned fulfillment options will belong to this operation.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.ListFirstAvailableTimeSlotForFulfillmentTypes
 * @deprecated
 * @replacedBy wix.restaurants.operations.v1.OperationsService.CalculateFirstAvailableTimeSlotPerFulfillmentType
 * @targetRemovalDate 2025-08-31
 */
declare function listFirstAvailableTimeSlotForFulfillmentTypes(operationId: string, options?: ListFirstAvailableTimeSlotForFulfillmentTypesOptions): Promise<NonNullablePaths<ListFirstAvailableTimeSlotForFulfillmentTypesResponse, `timeSlots` | `timeSlots.${number}.fulfilmentType` | `timeSlots.${number}.startsNow`, 4>>;
interface ListFirstAvailableTimeSlotForFulfillmentTypesOptions {
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
/**
 * Retrieves the first available time slot of each fulfillment type for a specified operation.
 *
 * The response includes a time slot with the delivery fulfillment type only if you specify a delivery address.
 * Only fulfillment methods capable of delivering to the specified address are considered when calculating time slot availability.
 * @param operationId - Operation ID.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.CalculateFirstAvailableTimeSlotPerFulfillmentType
 */
declare function calculateFirstAvailableTimeSlotPerFulfillmentType(operationId: string, options?: CalculateFirstAvailableTimeSlotPerFulfillmentTypeOptions): Promise<NonNullablePaths<CalculateFirstAvailableTimeSlotPerFulfillmentTypeResponse, `timeslotsPerFulfillmentType` | `timeslotsPerFulfillmentType.${number}.timeSlot.orderSchedulingType` | `timeslotsPerFulfillmentType.${number}.fulfilmentType`, 5>>;
interface CalculateFirstAvailableTimeSlotPerFulfillmentTypeOptions {
    /**
     * Delivery address.
     *
     * The response includes a time slot with the delivery fulfillment type only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
}
/**
 * Retrieves a list of available time slots for each fulfillment type.
 *
 * Each time slot is the first available time slot for the given fulfillment type.
 * @param operationIds - Operation ID.
 * Returned fulfillment options will belong to this operation.
 * @public
 * @documentationMaturity preview
 * @requiredField operationIds
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.ListFirstAvailableTimeSlotsForOperations
 * @deprecated
 * @replacedBy wix.restaurants.operations.v1.OperationsService.CalculateFirstAvailableTimeSlotsPerOperation
 * @targetRemovalDate 2025-08-31
 */
declare function listFirstAvailableTimeSlotsForOperations(operationIds: string[], options?: ListFirstAvailableTimeSlotsForOperationsOptions): Promise<NonNullablePaths<ListFirstAvailableTimeSlotsForOperationsResponse, `timeSlots` | `timeSlots.${number}.operationId`, 4>>;
interface ListFirstAvailableTimeSlotsForOperationsOptions {
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
/**
 * Retrieves the first available time slot of each fulfillment type for each specified operation.
 *
 * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
 * Only fulfillment methods capable of delivering to the specified address are considered when calculating time slot availability.
 * @param operationIds - Operation IDs.
 * @public
 * @documentationMaturity preview
 * @requiredField operationIds
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.CalculateFirstAvailableTimeSlotsPerOperation
 */
declare function calculateFirstAvailableTimeSlotsPerOperation(operationIds: string[], options?: CalculateFirstAvailableTimeSlotsPerOperationOptions): Promise<NonNullablePaths<CalculateFirstAvailableTimeSlotsPerOperationResponse, `timeSlotsPerOperation` | `timeSlotsPerOperation.${number}.operationId`, 4>>;
interface CalculateFirstAvailableTimeSlotsPerOperationOptions {
    /**
     * Delivery address.
     *
     * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
}
/**
 * For each menu, retrieves the first available time slots for each fulfillment type.
 * @param operationId - Operation ID.
 * Returned timeslots that are belong to this operation.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.ListFirstAvailableTimeSlotsForMenus
 * @deprecated
 * @replacedBy wix.restaurants.operations.v1.OperationsService.CalculateFirstAvailableTimeSlotsPerMenu
 * @targetRemovalDate 2025-08-31
 */
declare function listFirstAvailableTimeSlotsForMenus(operationId: string, options?: ListFirstAvailableTimeSlotsForMenusOptions): Promise<NonNullablePaths<ListFirstAvailableTimeSlotsForMenusResponse, `timeSlotsPerMenu`, 2>>;
interface ListFirstAvailableTimeSlotsForMenusOptions {
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
    /** Cursor paging */
    cursorPaging?: CursorPaging;
}
/**
 * Retrieves the first available time slot of each fulfillment type for each specified menu.
 *
 * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
 * Only fulfillment methods capable of delivering to the specified address are considered when calculating time slot availability.
 * @param operationId - Operation ID.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.CalculateFirstAvailableTimeSlotsPerMenu
 */
declare function calculateFirstAvailableTimeSlotsPerMenu(operationId: string, options?: CalculateFirstAvailableTimeSlotsPerMenuOptions): Promise<NonNullablePaths<CalculateFirstAvailableTimeSlotsPerMenuResponse, `timeSlotsPerMenu`, 2>>;
interface CalculateFirstAvailableTimeSlotsPerMenuOptions {
    /**
     * Delivery address.
     *
     * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
    /** Cursor paging. */
    cursorPaging?: CursorPaging;
    /** Only retrieve time slots for menus with online ordering enabled. */
    onlyOnlineOrderingEnabled?: boolean | null;
}
/**
 * Retrieves the first available time slot of each fulfillment type for a spastic Item.
 *
 * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
 * Only fulfillment methods capable of delivering to the specified address are considered when calculating time slot availability.
 * @param menuId - Menu ID to get the first available time slots for.
 * @public
 * @documentationMaturity preview
 * @requiredField menuId
 * @requiredField operationId
 * @requiredField options.itemId
 * @requiredField options.sectionId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.CalculateFirstAvailableTimeSlotsForItem
 */
declare function calculateFirstAvailableTimeSlotsForItem(operationId: string, menuId: string, options?: NonNullablePaths<CalculateFirstAvailableTimeSlotsForItemOptions, `itemId` | `sectionId`, 2>): Promise<NonNullablePaths<CalculateFirstAvailableTimeSlotsForItemResponse, `timeslotsPerFulfillmentType` | `timeslotsPerFulfillmentType.${number}.timeSlot.orderSchedulingType` | `timeslotsPerFulfillmentType.${number}.fulfilmentType`, 5>>;
interface CalculateFirstAvailableTimeSlotsForItemOptions {
    /**
     * Section ID to get the first available time slots for.
     * @format GUID
     */
    sectionId: string | null;
    /**
     * Item ID to get the first available time slots for.
     * @format GUID
     */
    itemId: string | null;
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
}
/**
 * Retrieves a list of the available time slots for a given date.
 * @param operationId - Operation ID.
 * The returned fulfillment options will belong to this operation.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @requiredField options.date
 * @requiredField options.date.day
 * @requiredField options.date.month
 * @requiredField options.date.year
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.ListAvailableTimeSlotsForDate
 * @deprecated
 * @replacedBy wix.restaurants.operations.v1.OperationsService.CalculateAvailableTimeSlotsForDate
 * @targetRemovalDate 2025-08-31
 */
declare function listAvailableTimeSlotsForDate(operationId: string, options?: NonNullablePaths<ListAvailableTimeSlotsForDateOptions, `date` | `date.day` | `date.month` | `date.year`, 3>): Promise<NonNullablePaths<ListAvailableTimeSlotsForDateResponse, `timeSlots` | `timeSlots.${number}.fulfilmentType` | `timeSlots.${number}.startsNow`, 4>>;
interface ListAvailableTimeSlotsForDateOptions {
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
    /** Date and time to get the available time slots for. */
    date: _Date;
}
/**
 * Retrieves all available time slots of each fulfillment type for the specified date.
 *
 * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
 * Only fulfillment methods capable of delivering to the specified address are considered when calculating time slot availability.
 * @param operationId - Operation ID.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @requiredField options.date
 * @requiredField options.date.day
 * @requiredField options.date.month
 * @requiredField options.date.year
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.CalculateAvailableTimeSlotsForDate
 */
declare function calculateAvailableTimeSlotsForDate(operationId: string, options?: NonNullablePaths<CalculateAvailableTimeSlotsForDateOptions, `date` | `date.day` | `date.month` | `date.year`, 3>): Promise<NonNullablePaths<CalculateAvailableTimeSlotsForDateResponse, `timeslotsPerFulfillmentType` | `timeslotsPerFulfillmentType.${number}.timeSlot.orderSchedulingType` | `timeslotsPerFulfillmentType.${number}.fulfilmentType`, 5>>;
interface CalculateAvailableTimeSlotsForDateOptions {
    /**
     * Delivery address.
     *
     * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
     */
    deliveryAddress?: CommonAddress;
    /** Date and time to get the available time slots for. */
    date: _Date;
}
/**
 * Retrieves a list of the available dates in a given time range.
 *
 * A date is considered available if it has at least one available time slot.
 * @param operationId - Operation ID.
 * The returned fulfillment options will belong to this operation.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @requiredField options.from
 * @requiredField options.until
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.ListAvailableDatesInRange
 * @deprecated
 * @replacedBy wix.restaurants.operations.v1.OperationsService.CalculateAvailableDatesInRange
 * @targetRemovalDate 2025-08-31
 */
declare function listAvailableDatesInRange(operationId: string, options?: NonNullablePaths<ListAvailableDatesInRangeOptions, `from` | `until`, 2>): Promise<NonNullablePaths<ListAvailableDatesInRangeResponse, `availableDates` | `availableDates.${number}.fulfilmentType`, 4>>;
interface ListAvailableDatesInRangeOptions {
    /**
     * Delivery address. Optional.
     *
     * If provided, the returned delivery fulfillment options will be able to deliver to this address.
     */
    deliveryAddress?: CommonAddress;
    /** Start date and time of the range. */
    from: _Date;
    /** End date and time of the range. */
    until: _Date;
}
/**
 * Retrieves all available dates of each fulfillment type within the specified time range.
 *
 * A date is considered available if it has at least one available time slot.
 *
 * The response includes time slots with delivery fulfillment types only if you specify a delivery address.
 * Only fulfillment methods capable of delivering to the specified address are considered when calculating time slot availability.
 * @param operationId - Operation ID.
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @requiredField options.from
 * @requiredField options.until
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.CalculateAvailableDatesInRange
 */
declare function calculateAvailableDatesInRange(operationId: string, options?: NonNullablePaths<CalculateAvailableDatesInRangeOptions, `from` | `until`, 2>): Promise<NonNullablePaths<CalculateAvailableDatesInRangeResponse, `availableDatesPerFulfillmentType` | `availableDatesPerFulfillmentType.${number}.fulfilmentType`, 4>>;
interface CalculateAvailableDatesInRangeOptions {
    /**
     * Delivery address.
     *
     * Delivery fulfillment methods are only considered when calculating date availability if a delivery address is specified.
     */
    deliveryAddress?: CommonAddress;
    /** Start date and time of the range. */
    from: _Date;
    /** End date and time of the range. */
    until: _Date;
}
/**
 * Validates an operation's address
 *
 * Checks if the address linked to the operation (stored in business_location_details) is valid.
 * An address is considered valid if it has:
 * 1. A non-empty formatted address
 * 2. Valid geocode coordinates (not 0,0)
 * 3. A non-empty country field
 *
 * If the address is invalid, the response includes specific violations.
 * @param operationId - The ID of the operation to validate
 * @public
 * @documentationMaturity preview
 * @requiredField operationId
 * @permissionId RESTAURANTS.OPERATION_READ
 * @applicableIdentity APP
 * @returns Response message for address validation
 * @fqn wix.restaurants.operations.v1.OperationsService.ValidateOperationAddress
 */
declare function validateOperationAddress(operationId: string): Promise<NonNullablePaths<ValidateOperationAddressResponse, `valid` | `violations` | `violations.${number}.type`, 4>>;
/**
 * Synchronously update tags on multiple operations.
 * If you specify a tag in both `assignTags` and `unassignTags`, it is assigned.
 * @param operationIds - IDs of the operations to update tags for.
 * @public
 * @documentationMaturity preview
 * @requiredField operationIds
 * @permissionId RESTAURANTS.OPERATION_UPDATE_TAGS
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.BulkUpdateOperationTags
 */
declare function bulkUpdateOperationTags(operationIds: string[], options?: BulkUpdateOperationTagsOptions): Promise<NonNullablePaths<BulkUpdateOperationTagsResponse, `results` | `results.${number}.itemMetadata.originalIndex` | `results.${number}.itemMetadata.success` | `results.${number}.itemMetadata.error.code` | `results.${number}.itemMetadata.error.description` | `bulkActionMetadata.totalSuccesses` | `bulkActionMetadata.totalFailures` | `bulkActionMetadata.undetailedFailures`, 6> & {
    __applicationErrorsType?: BulkUpdateOperationTagsApplicationErrors;
}>;
interface BulkUpdateOperationTagsOptions {
    /** Tags to assign to the operations. */
    assignTags?: Tags;
    /** Tags to unassign from the operations. */
    unassignTags?: Tags;
}
/**
 * Asynchronously update tags on multiple operations according to the specified filter.
 * If a filter isn't specified, this method updates all operations.
 * If you specify a tag in both `assignTags` and `unassignTags`, it is assigned.
 * @param filter - Filter that determines which operations to update tags for.
 * @public
 * @documentationMaturity preview
 * @requiredField filter
 * @permissionId RESTAURANTS.OPERATION_UPDATE_TAGS
 * @applicableIdentity APP
 * @fqn wix.restaurants.operations.v1.OperationsService.BulkUpdateOperationTagsByFilter
 */
declare function bulkUpdateOperationTagsByFilter(filter: Record<string, any>, options?: BulkUpdateOperationTagsByFilterOptions): Promise<NonNullablePaths<BulkUpdateOperationTagsByFilterResponse, `jobId`, 2> & {
    __applicationErrorsType?: BulkUpdateOperationTagsByFilterApplicationErrors;
}>;
interface BulkUpdateOperationTagsByFilterOptions {
    /** Tags to assign to the operations. */
    assignTags?: Tags;
    /** Tags to unassign from the operations. */
    unassignTags?: Tags;
}

export { type ActionEvent, ActivationType, type ActivationTypeWithLiterals, type ActivePeriod, type Address, type AddressHint, type AddressLocation, type AddressViolation, type App, type ApplicationError, AsapFutureHandlingType, type AsapFutureHandlingTypeWithLiterals, type AsapOrderPacing, type AsapOrderPacingPacingAvailabilityOneOf, type AsapOrderScheduling, type AsapOrderSchedulingAsapFutureHandlingOptionsOneOf, AsapPacingWindowType, type AsapPacingWindowTypeWithLiterals, AsapPreorderType, type AsapPreorderTypeWithLiterals, type AsapScheduling, type AsapSchedulingAsapPreorderOneOf, type AsapSchedulingPreparationTimeOneOf, type Asset, type AvailabilityException, type BaseEventMetadata, type BulkActionMetadata, type BulkUpdateOperationTagsApplicationErrors, type BulkUpdateOperationTagsByFilterApplicationErrors, type BulkUpdateOperationTagsByFilterOptions, type BulkUpdateOperationTagsByFilterRequest, type BulkUpdateOperationTagsByFilterResponse, type BulkUpdateOperationTagsOptions, type BulkUpdateOperationTagsRequest, type BulkUpdateOperationTagsResponse, type BulkUpdateOperationTagsResult, type BusinessDaysAheadHandling, type BusinessDaysPreorder, type BusinessLocationDetails, type BusinessSchedule, type CalculateAvailableDatesInRangeOptions, type CalculateAvailableDatesInRangeRequest, type CalculateAvailableDatesInRangeResponse, type CalculateAvailableTimeSlotsForDateOptions, type CalculateAvailableTimeSlotsForDateRequest, type CalculateAvailableTimeSlotsForDateResponse, type CalculateFirstAvailableTimeSlotPerFulfillmentTypeOptions, type CalculateFirstAvailableTimeSlotPerFulfillmentTypeRequest, type CalculateFirstAvailableTimeSlotPerFulfillmentTypeResponse, type CalculateFirstAvailableTimeSlotsForItemOptions, type CalculateFirstAvailableTimeSlotsForItemRequest, type CalculateFirstAvailableTimeSlotsForItemResponse, type CalculateFirstAvailableTimeSlotsPerMenuOptions, type CalculateFirstAvailableTimeSlotsPerMenuRequest, type CalculateFirstAvailableTimeSlotsPerMenuResponse, type CalculateFirstAvailableTimeSlotsPerOperationOptions, type CalculateFirstAvailableTimeSlotsPerOperationRequest, type CalculateFirstAvailableTimeSlotsPerOperationResponse, type Categories, type ChangeContext, type ChangeContextPayloadOneOf, type CommonAddress, type CommonAddressStreetOneOf, type ConsentPolicy, type CreateOperationRequest, type CreateOperationResponse, type CursorPaging, type CursorPagingMetadata, type CursorQuery, type CursorQueryPagingMethodOneOf, type Cursors, type CustomTag, type DayAndTime, DayOfWeek, type DayOfWeekAvailability, type DayOfWeekWithLiterals, type DeleteContext, type DeleteOperationRequest, type DeleteOperationResponse, DeleteStatus, type DeleteStatusWithLiterals, type DeliveryDetails, type DeliveryProfileConfiguredForOperation, type DomainEvent, type DomainEventBodyOneOf, type DurationRange, type Empty, EntitiesDayOfWeek, type EntitiesDayOfWeekWithLiterals, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type ExtendedFields, type File, type FirstFulfillmentTimeSlotsPerMenu, type FulfillmentAddress, type FulfillmentDetails, type FulfillmentDetailsFulfillmentTimeOptionsOneOf, type FulfillmentInfo, type FulfillmentInfoFulfillmentTimeOneOf, type FulfillmentOption, type FulfillmentOptionAvailability, type FulfillmentOptionFulfillmentTimeOptionsOneOf, type FulfillmentOptionFulfillmentTimesDisplayOptionsOneOf, type FulfillmentOptionFulfillmentTypeOptionsOneOf, type FulfillmentTimeSlot, type FulfillmentTimeSlotsPerMenu, FulfillmentTimeType, type FulfillmentTimeTypeWithLiterals, type FulfillmentTimesDisplayConfig, type FulfillmentTimesDisplayConfigFulfillmentTimesDisplayOptionsOneOf, FulfillmentTimesDisplayType, type FulfillmentTimesDisplayTypeWithLiterals, FulfillmentTimesType, type FulfillmentTimesTypeWithLiterals, FulfillmentType, type FulfillmentTypeAvailableDates, type FulfillmentTypeWithLiterals, type GeoCoordinates, type GetExpectedFulfillmentSelectionRequest, type GetExpectedFulfillmentSelectionResponse, type GetOperationRequest, type GetOperationResponse, type IdentificationData, type IdentificationDataIdOneOf, type ImmutableFields, type InvalidateCache, type InvalidateCacheGetByOneOf, type ItemMetadata, type ListAvailableDatesInRangeOptions, type ListAvailableDatesInRangeRequest, type ListAvailableDatesInRangeResponse, type ListAvailableFulfillmentOptions, type ListAvailableFulfillmentOptionsRequest, type ListAvailableFulfillmentOptionsResponse, type ListAvailableTimeSlotsForDateOptions, type ListAvailableTimeSlotsForDateRequest, type ListAvailableTimeSlotsForDateResponse, type ListFirstAvailableTimeSlotForFulfillmentTypesOptions, type ListFirstAvailableTimeSlotForFulfillmentTypesRequest, type ListFirstAvailableTimeSlotForFulfillmentTypesResponse, type ListFirstAvailableTimeSlotsForMenusOptions, type ListFirstAvailableTimeSlotsForMenusRequest, type ListFirstAvailableTimeSlotsForMenusResponse, type ListFirstAvailableTimeSlotsForOperationsOptions, type ListFirstAvailableTimeSlotsForOperationsRequest, type ListFirstAvailableTimeSlotsForOperationsResponse, type ListOperationIdsRequest, type ListOperationIdsResponse, type ListOperationsInternalRequest, type ListOperationsInternalResponse, type ListOperationsRequest, type ListOperationsResponse, type Locale, type MessageEnvelope, type MetaSiteSpecialEvent, type MetaSiteSpecialEventPayloadOneOf, MethodType, type MethodTypeWithLiterals, type Multilingual, Namespace, type NamespaceChanged, type NamespaceWithLiterals, type OdeditorAssigned, type OdeditorUnassigned, type OnlineOrderingPausedUntilOptions, OnlineOrderingStatusType, type OnlineOrderingStatusTypeWithLiterals, type Operation, type OperationCreatedEnvelope, type OperationDeletedEnvelope, type OperationOnlineOrderingStatusOptionsOneOf, type OperationTimeSlot, type OperationUpdatedEnvelope, type OperationsDataCloningCompleted, type OperationsQueryBuilder, type OperationsQueryResult, type OrderScheduling, type OrderSchedulingOrderSchedulingOptionsOneOf, OrderSchedulingType, type OrderSchedulingTypeWithLiterals, type Page, type PagingMetadata, type PicassoAssigned, type PicassoUnassigned, type PickupDetails, PlacementType, type PlacementTypeWithLiterals, type PreOrderPacing, type PreOrderPacingPacingAvailabilityOneOf, type PreorderMethod, type PreorderMethodMethodOptionsOneOf, PreorderPacingWindowType, type PreorderPacingWindowTypeWithLiterals, type PreorderScheduling, type PreparationTime, PreparationTimePreparationTimeType, type PreparationTimePreparationTimeTypeWithLiterals, type PreparationTimeTimeSpecificationOneOf, PreparationTimeType, type PreparationTimeTypeWithLiterals, type Properties, type PropertiesChange, type QueryOperationRequest, type QueryOperationResponse, ResolutionMethod, type ResolutionMethodWithLiterals, type RestoreInfo, type Scheduling, type SchedulingSchedulingOptionsOneOf, SchedulingType, type SchedulingTypeWithLiterals, type ServiceProvisioned, type ServiceRemoved, type SiteCloned, type SiteCreated, SiteCreatedContext, type SiteCreatedContextWithLiterals, type SiteDeleted, type SiteHardDeleted, type SiteMarkedAsTemplate, type SiteMarkedAsWixSite, type SitePropertiesEvent, type SitePropertiesNotification, type SitePublished, type SitePurgedExternally, type SiteRenamed, type SiteTransferred, type SiteUndeleted, type SiteUnpublished, type SiteUrlChanged, SortOrder, type SortOrderWithLiterals, type Sorting, type SpecialHourPeriod, State, type StateWithLiterals, type StreetAddress, type StudioAssigned, type StudioTwoAssigned, type StudioTwoUnassigned, type StudioUnassigned, type Subdivision, SubdivisionType, type SubdivisionTypeWithLiterals, type SupportedLanguage, type TagList, type Tags, type TimeBounded, type TimeDuration, type TimeDurationRange, type TimeOfDay, type TimeOfDayRange, type TimePeriod, type TimeSlot, type TimeSlotForFulfillment, TimeSlotForFulfillmentTimeSlotStatus, type TimeSlotForFulfillmentTimeSlotStatusWithLiterals, type TimeSlotForOperation, TimeSlotStatus, type TimeSlotStatusWithLiterals, TimeUnit, type TimeUnitWithLiterals, type TimeWindowDisplayConfig, type Translation, type URI, type UpdateDeliveryRegionsRequest, type UpdateDeliveryRegionsResponse, type UpdateImmutableFieldsRequest, type UpdateImmutableFieldsResponse, type UpdateOperation, type UpdateOperationRequest, type UpdateOperationResponse, type V1Address, type V1AddressLocation, type V1StreetAddress, type V4SiteCreated, type ValidateOperationAddressRequest, type ValidateOperationAddressResponse, ViolationType, type ViolationTypeWithLiterals, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, type WeeklyActiveDays, type WeeklyActivePeriods, type WeeklySchedule, type WixelAssigned, type WixelUnassigned, type _Date, bulkUpdateOperationTags, bulkUpdateOperationTagsByFilter, calculateAvailableDatesInRange, calculateAvailableTimeSlotsForDate, calculateFirstAvailableTimeSlotPerFulfillmentType, calculateFirstAvailableTimeSlotsForItem, calculateFirstAvailableTimeSlotsPerMenu, calculateFirstAvailableTimeSlotsPerOperation, createOperation, deleteOperation, getOperation, listAvailableDatesInRange, listAvailableFulfillmentOptions, listAvailableTimeSlotsForDate, listFirstAvailableTimeSlotForFulfillmentTypes, listFirstAvailableTimeSlotsForMenus, listFirstAvailableTimeSlotsForOperations, listOperations, onOperationCreated, onOperationDeleted, onOperationUpdated, queryOperation, updateOperation, validateOperationAddress };
