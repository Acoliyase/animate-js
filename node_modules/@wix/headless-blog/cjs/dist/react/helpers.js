import React from 'react';
export function isValidChildren(children) {
    return (React.isValidElement(children) ||
        typeof children === 'string' ||
        (Array.isArray(children) &&
            children.every((c) => React.isValidElement(c) || typeof c === 'string')));
}
const trimSlashes = (path) => path.replace(/^\/+|\/+$/g, '');
export function isActiveCategory(currentPathname, categoryPageBaseUrl, category) {
    if (!currentPathname)
        return false;
    const isCustom = category.isCustom ?? false;
    const slug = category.slug ?? '';
    const currentPathWithTrimmedSlash = trimSlashes(currentPathname);
    const categoryPathWithTrimmedSlash = trimSlashes(isCustom ? slug : `${categoryPageBaseUrl}${slug}`);
    return currentPathWithTrimmedSlash === categoryPathWithTrimmedSlash;
}
export function useIntersectionObserver(forwardedRef) {
    const [element, setElement] = React.useState(null);
    const [isVisible, setIsVisible] = React.useState(false);
    // Set up intersection observer for lazy loading
    React.useEffect(() => {
        if (!element)
            return;
        const observer = new IntersectionObserver((entries) => {
            const [entry] = entries;
            if (entry && entry.isIntersecting && !isVisible) {
                setIsVisible(true);
                observer.disconnect(); // Only load once
            }
        }, {
            rootMargin: '100px', // Start loading when 100px away from viewport
            threshold: 0.1, // Trigger when 10% visible
        });
        observer.observe(element);
        return () => observer.disconnect();
    }, [element, isVisible]);
    // Combined ref to handle both forwarded ref and observer ref
    const ref = React.useCallback((el) => {
        setElement(el);
        if (typeof forwardedRef === 'function') {
            forwardedRef(el);
        }
        else if (forwardedRef) {
            forwardedRef.current = el;
        }
    }, [forwardedRef]);
    return { ref, element, isVisible };
}
