import { jsx as _jsx } from "react/jsx-runtime";
import { AsChildSlot } from '@wix/headless-utils/react';
import { useService } from '@wix/services-manager-react';
import React from 'react';
import { CommentsServiceDefinition, } from '../services/comments-service.js';
import * as CoreComments from './core/Comments.js';
import { isValidChildren } from './helpers.js';
export * as Form from './CommentForm.js';
export const CommentContext = React.createContext(null);
CommentContext.displayName = 'Comment.CommentContext';
/**
 * Hook to access the current comment context.
 * Must be used within a Comment.Root or Comment.ReplyItemRepeater component.
 *
 * @returns The comment context containing comment data, replies, and delete function
 * @throws Error if used outside of Comment.Root
 */
export function useCommentContext() {
    const context = React.useContext(CommentContext);
    if (!context) {
        throw new Error('useCommentContext must be used within a Comment.Root component');
    }
    return context;
}
/**
 * Root component for rendering a single comment.
 * Provides comment context to all child components.
 *
 * @component
 * @example
 * ```tsx
 * <Comment.Root comment={comment}>
 *   <Comment.Author />
 *   <Comment.Content />
 *   <Comment.CommentDate />
 * </Comment.Root>
 * ```
 */
export const Root = React.forwardRef((props, ref) => {
    const { comment, children, className, asChild, currentMemberId } = props;
    const attributes = {
        'data-testid': "comment" /* TestIds.root */,
        'data-comment-id': comment._id,
    };
    return (_jsx(CoreComments.Comment, { commentId: comment._id || '', children: ({ replies, deleteComment }) => {
            const contextValue = {
                comment,
                replies,
                deleteComment,
                currentMemberId,
            };
            return (_jsx(CommentContext.Provider, { value: contextValue, children: _jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, customElement: children, customElementProps: { comment, replies }, ...attributes, children: children }) }, comment._id));
        } }));
});
Root.displayName = 'Comment.Root';
/**
 * Displays the comment content with rich text support.
 *
 * @component
 * @example
 * ```tsx
 * // Custom rendering with asChild
 * <Comment.Content asChild>
 *   {({ content }) => (
 *     <div className="comment-content">
 *       <RicosViewer content={content} />
 *     </div>
 *   )}
 * </Comment.Content>
 * ```
 */
export const Content = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { comment } = useCommentContext();
    if (!comment?.content)
        return null;
    const attributes = {
        'data-testid': "comment-content" /* TestIds.content */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { content: comment.content.richContent } }));
});
Content.displayName = 'Comment.Content';
/**
 * Displays the comment author's name.
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Comment.Author />
 *
 * // Custom rendering with asChild
 * <Comment.Author asChild>
 *   {({ author }) => author?.profile?.nickname ?? 'Unknown'} />}
 * </Comment.Author>
 * ```
 */
export const Author = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { comment } = useCommentContext();
    const author = comment?.resolvedFields?.author;
    const attributes = {
        'data-testid': "comment-author" /* TestIds.author */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { author }, children: _jsx("span", { children: author?.profile?.nickname ?? 'Unknown' }) }));
});
Author.displayName = 'Comment.Author';
/**
 * Displays the comment date in a formatted way.
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Comment.CommentDate />
 *
 * // With custom locale
 * <Comment.CommentDate locale="en-US" />
 *
 * // Custom rendering with asChild
 * <Comment.CommentDate asChild>
 *   {({ commentDate }) => <RelativeDate date={commentDate} />}
 * </Comment.CommentDate>
 * ```
 */
export const CommentDate = React.forwardRef((props, ref) => {
    const { asChild, children, className, locale } = props;
    const { comment } = useCommentContext();
    const commentDate = comment?.commentDate || comment?._createdDate;
    if (!commentDate)
        return null;
    const formattedDate = new Date(commentDate).toLocaleDateString(locale || 'en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
    });
    const dateTimeString = typeof commentDate === 'string' ? commentDate : commentDate.toISOString();
    const attributes = {
        'data-testid': "comment-date" /* TestIds.commentDate */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { commentDate: dateTimeString }, content: formattedDate, children: _jsx("time", { dateTime: dateTimeString, children: formattedDate }) }));
});
CommentDate.displayName = 'Comment.CommentDate';
/**
 * Renders if the current member is the owner of the comment.
 *
 * @component
 * @example
 * ```tsx
 * <Comment.Owner>
 *   <Comment.Action.Delete />
 * </Comment.Owner>
 * ```
 */
export const Owner = (props) => {
    const { children } = props;
    const { currentMemberId, comment } = useCommentContext();
    if (!currentMemberId ||
        !comment.author?.memberId ||
        comment.author.memberId !== currentMemberId) {
        return null;
    }
    return children;
};
Owner.displayName = 'Comment.Owner';
/**
 * Displays or provides access to the comment status (PUBLISHED, PENDING, DELETED, etc.).
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Comment.Status />
 *
 * // Conditional rendering with asChild
 * <Comment.Status asChild>
 *   {({ status }) => (
 *     status === 'PENDING' ? <span>Awaiting approval</span> : null
 *   )}
 * </Comment.Status>
 * ```
 */
export const Status = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { comment } = useCommentContext();
    if (!comment?.status)
        return null;
    const status = comment.status;
    const attributes = {
        'data-testid': "comment-status" /* TestIds.status */,
        'data-status': status,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { status }, children: _jsx("span", { children: status }) }));
});
Status.displayName = 'Comment.Status';
/**
 * Container for comment replies with empty state support.
 * Follows List Container Level pattern from architecture rules.
 * Always renders if there are total replies, even if no replies are loaded initially.
 *
 * @component
 * @example
 * ```tsx
 * <Comment.ReplyItems>
 *   <Comment.ReplyItemRepeater>
 *     <Comment.Author />
 *     <Comment.Content />
 *   </Comment.ReplyItemRepeater>
 *   <Comment.LoadMoreReplies />
 * </Comment.ReplyItems>
 * ```
 */
export const ReplyItems = React.forwardRef((props, ref) => {
    const { children, className } = props;
    const { comment } = useCommentContext();
    return (_jsx(CoreComments.Comment, { commentId: comment._id || '', children: ({ parentComment }) => {
            if ((parentComment?.replyCount ?? 0) === 0)
                return null;
            const attributes = {
                'data-testid': "comment-reply-items" /* TestIds.replyItems */,
            };
            return (_jsx("div", { ...attributes, ref: ref, className: className, children: children }));
        } }));
});
ReplyItems.displayName = 'Comment.ReplyItems';
/**
 * Repeater component that renders all replies to a comment.
 * Follows Repeater Level pattern from architecture rules.
 * Note: Repeater components do NOT support asChild as per architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * <Comment.ReplyItems>
 *   <Comment.ReplyItemRepeater>
 *     <Comment.Author />
 *     <Comment.Content />
 *   </Comment.ReplyItemRepeater>
 * </Comment.ReplyItems>
 * ```
 */
export const ReplyItemRepeater = React.forwardRef((props, _ref) => {
    const { children } = props;
    const { comment, currentMemberId } = useCommentContext();
    return (_jsx(CoreComments.Comment, { commentId: comment._id || '', children: ({ replies }) => replies.map((reply) => {
            return (_jsx(Root, { comment: reply, currentMemberId: currentMemberId, children: children }, reply._id));
        }) }));
});
ReplyItemRepeater.displayName = 'Comment.ReplyItemRepeater';
/**
 * Displays the parent comment when the current comment is a reply to another reply.
 * Only renders if the parent is not a top-level comment.
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Comment.ParentComment>
 *   <Comment.Author />
 *   <Comment.Content />
 * </Comment.ParentComment>
 *
 * // Custom rendering with asChild
 * <Comment.ParentComment asChild>
 *   {({ comment: parentComment }) => (
 *     <div>
 *       Replying to: <CommentPreview comment={parentComment} />
 *     </div>
 *   )}
 * </Comment.ParentComment>
 * ```
 */
export const ParentComment = React.forwardRef((props, ref) => {
    const { children, asChild, className } = props;
    const service = useService(CommentsServiceDefinition);
    const comments = service.getComments();
    const { comment, currentMemberId } = useCommentContext();
    if (!comment.parentComment?._id)
        return null;
    const parentCommentInRoot = comments.find((c) => c._id === comment.parentComment?._id);
    // Only relevant if parent comment a reply, not a top-level comment
    if (parentCommentInRoot)
        return null;
    return (_jsx(CoreComments.Comment, { commentId: comment.parentComment?._id || '', children: ({ comment }) => {
            if (!comment)
                return null;
            return (_jsx(Root, { comment: comment, ref: ref, asChild: asChild, className: className, currentMemberId: currentMemberId, children: children }, comment._id));
        } }));
});
ParentComment.displayName = 'Comment.ParentComment';
/**
 * Button to load more replies when there are additional pages.
 * Only renders when there are more replies to load.
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Comment.LoadMoreReplies />
 *
 * // Custom rendering with asChild
 * <Comment.LoadMoreReplies asChild>
 *   {({ hasNextPage, isLoading, loadNextPage }) => (
 *     <button onClick={loadNextPage} disabled={isLoading}>
 *       {isLoading ? 'Loading...' : 'Show more replies'}
 *     </button>
 *   )}
 * </Comment.LoadMoreReplies>
 * ```
 */
export const LoadMoreReplies = React.forwardRef((props, ref) => {
    const { asChild, children, className, loadingState } = props;
    const { comment } = useCommentContext();
    const commentId = comment._id;
    if (!commentId)
        return null;
    return (_jsx(CoreComments.Comment, { commentId: commentId, children: ({ hasNextPage, loadNextPage, isLoading, parentComment, replies }) => {
            if ((parentComment?.replyCount ?? 0) === 0)
                return null;
            const attributes = {
                'data-testid': "comment-load-more-replies" /* TestIds.loadMoreReplies */,
                'data-loading': isLoading,
            };
            return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: {
                    hasNextPage,
                    isLoading,
                    loadNextPage,
                    replies,
                }, content: isLoading && loadingState ? loadingState : undefined, children: _jsx("button", { onClick: loadNextPage, disabled: isLoading, children: "Load replies" }) }));
        } }));
});
LoadMoreReplies.displayName = 'Comment.LoadMoreReplies';
const DeleteAction = React.forwardRef((props, ref) => {
    const { asChild, children, className, onDelete } = props;
    const { deleteComment } = useCommentContext();
    const attributes = {
        'data-testid': "comment-action-delete" /* TestIds.actionDelete */,
    };
    const handleDelete = React.useCallback(async () => {
        if (onDelete && !onDelete())
            return;
        await deleteComment();
    }, [deleteComment, onDelete]);
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, onClick: handleDelete, customElement: children, customElementProps: { deleteComment }, children: isValidChildren(children) ? children : _jsx("button", { children: "Delete" }) }));
});
DeleteAction.displayName = 'Comment.Action.Delete';
export const Action = {
    Delete: DeleteAction,
};
