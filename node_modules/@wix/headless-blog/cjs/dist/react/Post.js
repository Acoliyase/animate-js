import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import { AsChildSlot } from '@wix/headless-utils/react';
import React from 'react';
import * as BlogCategories from './Categories.js';
import * as CoreBlogPost from './core/Post.js';
import { createServicesMap } from '@wix/services-manager';
import { WixServices } from '@wix/services-manager-react';
import { BlogPostService, BlogPostServiceDefinition, } from '../services/blog-post-service.js';
import { Root as CommentsRoot } from './Comments.js';
import { isValidChildren } from './helpers.js';
/** https://manage.wix.com/apps/14bcded7-0066-7c35-14d7-466cb3f09103/extensions/dynamic/wix-vibe-component?component-id=cb293890-7b26-4bcf-8c87-64f624c59158 */
const HTML_CODE_TAG = 'blog.post';
const PostContext = React.createContext(null);
PostContext.displayName = 'Blog.Post.PostContext';
export function usePostContext() {
    const context = React.useContext(PostContext);
    if (!context) {
        throw new Error('usePostContext must be used within a BlogPost.Root component');
    }
    return context;
}
/**
 * Root container for blog post that provides post context to all child components.
 * Supports both service-driven and prop-driven post data.
 * Follows Container Level pattern from architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * import { Blog } from '@wix/blog/components';
 * import { RicosViewer } from '@/components/ui/ricos-viewer';
 *
 * // Service-driven (gets post from BlogPostService)
 * function BlogPostPage() {
 *   return (
 *     <Blog.Post.Root emptyState={<div>Post not found</div>}>
 *       <article>
 *         <Blog.Post.Title />
 *         <Blog.Post.PublishDate locale="en-US" />
 *         <Blog.Post.Content>
 *           {RicosViewer}
 *         </Blog.Post.Content>
 *         <Blog.Post.TagItems>
 *           <Blog.Post.TagItemRepeater>
 *             <Blog.Tag.Label />
 *           </Blog.Post.TagItemRepeater>
 *         </Blog.Post.TagItems>
 *         <Blog.Post.CategoryItems>
 *           <Blog.Categories.CategoryItemRepeater>
 *             <Blog.Category.Link baseUrl="/category/" />
 *           </Blog.Categories.CategoryItemRepeater>
 *         </Blog.Post.CategoryItems>
 *       </article>
 *     </Blog.Post.Root>
 *   );
 * }
 *
 * // Prop-driven (provide post data directly)
 * function BlogPostCard({ post }) {
 *   return (
 *     <Blog.Post.Root post={post} emptyState={<div>Post not found</div>}>
 *       <article>
 *         ... same as service-driven example
 *       </article>
 *     </Blog.Post.Root>
 *   );
 * }
 * ```
 */
export const Root = React.forwardRef((props, ref) => {
    const { asChild, children, className, post: providedPost, emptyState, fallbackImageUrl, blogPostServiceConfig, } = props;
    const renderRoot = (post, olderPost, newerPost) => {
        const contextValue = {
            post,
            coverImageUrl: post?.resolvedFields?.coverImageUrl || fallbackImageUrl,
            olderPost,
            newerPost,
        };
        const attributes = {
            'data-component-tag': HTML_CODE_TAG,
            'data-testid': "blog-post-root" /* TestIds.root */,
            'data-post-id': post._id,
            'data-post-slug': post.slug,
            'data-post-pinned': post.pinned,
            'data-has-cover-image': !!contextValue.coverImageUrl,
        };
        return (_jsx(PostContext.Provider, { value: contextValue, children: _jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, customElement: children, customElementProps: { post }, ...attributes, children: children }) }));
    };
    // If post is provided via props, use it directly
    if (providedPost) {
        return renderRoot(providedPost);
    }
    // Otherwise, use service to get post data
    if (!blogPostServiceConfig) {
        throw new Error('blogPostServiceConfig is required');
    }
    return (_jsx(WixServices
    // key: Ensure we re-render the component when the post changes
    , { servicesMap: createServicesMap().addService(BlogPostServiceDefinition, BlogPostService, blogPostServiceConfig), children: _jsx(CoreBlogPost.Root, { children: ({ post, olderPost, newerPost }) => {
                if (!post) {
                    return emptyState || null;
                }
                return renderRoot(post, olderPost, newerPost);
            } }) }, blogPostServiceConfig.post._id));
});
Root.displayName = 'Blog.Post.Root';
export const CoverImage = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { post, coverImageUrl } = usePostContext();
    const alt = post?.resolvedFields?.coverImageAlt || post?.title || '';
    if (!coverImageUrl)
        return null;
    const attributes = {
        'data-testid': "blog-post-cover-image" /* TestIds.coverImage */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { imageUrl: coverImageUrl, alt }, children: _jsx("img", { src: coverImageUrl, alt: alt }) }));
});
CoverImage.displayName = 'Blog.Post.CoverImage';
/**
 * Creates a link to the full blog post with customizable rendering.
 *
 * @component
 * @example
 * ```tsx
 * // Default link
 * <Blog.Post.Link baseUrl="/blog/" />
 *
 * // Custom rendering with asChild
 * <Blog.Post.Link baseUrl="/blog/" asChild>
 *   {({ href }) => (
 *     <Link to={href} className="block hover:shadow-lg transition-shadow">
 *       <Blog.Post.Title />
 *       <Blog.Post.Excerpt />
 *     </Link>
 *   )}
 * </Blog.Post.Link>
 * ```
 */
export const Link = React.forwardRef((props, ref) => {
    const { asChild, children, className, baseUrl = '' } = props;
    const { post } = usePostContext();
    const slug = post?.slug;
    if (!slug)
        return null;
    const href = `${baseUrl}${slug}`;
    const attributes = {
        'data-testid': "blog-post-link" /* TestIds.link */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { href, slug }, content: children, children: _jsx("a", { href: href, children: isValidChildren(children) ? children : slug }) }));
});
Link.displayName = 'Blog.Post.Link';
/**
 * Displays the post excerpt within feed context.
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Blog.Post.Excerpt />
 *
 * // Custom styling with line clamping
 * <Blog.Post.Excerpt className="text-gray-600 line-clamp-3" />
 *
 * // Custom rendering with asChild
 * <Blog.Post.Excerpt asChild>
 *   {({ excerpt }) => (
 *     <p className="post-excerpt">{excerpt.substring(0, 100)}...</p>
 *   )}
 * </Blog.Post.Excerpt>
 * ```
 */
export const Excerpt = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { post } = usePostContext();
    if (!post?.excerpt)
        return null;
    const excerpt = post.excerpt;
    const attributes = {
        'data-testid': "blog-post-excerpt" /* TestIds.excerpt */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { excerpt }, content: excerpt, children: _jsx("p", { children: excerpt }) }));
});
Excerpt.displayName = 'Blog.Post.Excerpt';
/**
 * Displays the blog post title with customizable rendering.
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Blog.Post.Title />
 *
 * // Custom styling
 * <Blog.Post.Title className="text-4xl font-bold text-gray-900" />
 *
 * // Custom rendering with asChild
 * <Blog.Post.Title asChild>
 *   {({ title }) => <h1 className="blog-title">{title}</h1>}
 * </Blog.Post.Title>
 * ```
 */
export const Title = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { post } = usePostContext();
    if (!post?.title)
        return null;
    const title = post.title;
    const attributes = {
        'data-testid': "blog-post-title" /* TestIds.title */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { title }, content: title, children: _jsx("h1", { children: title }) }));
});
Title.displayName = 'Blog.Post.Title';
/**
 * Exposes blog post rich content, only available if `blogPostServiceConfig` is provided to `Blog.Post.Root`. Use `Blog.Post.Excerpt` to display the post excerpt otherwise.
 *
 * @component
 * @example
 * ```tsx
 * import { RicosViewer } from '@/components/ui/ricos-viewer';
 *
 * // Default rendering with built-in Ricos viewer
 * <Blog.Post.Content>
 *   {RicosViewer}
 * </Blog.Post.Content>
 *
 * // Custom styling
 * <Blog.Post.Content className="prose max-w-[60ch] mx-auto">
 *   {RicosViewer}
 * </Blog.Post.Content>
 *
 * // Custom rendering with asChild
 * <Blog.Post.Content asChild>
 *   {({ content }) => (
 *     <div className="custom-content-wrapper">
 *       <RicosViewer content={content} />
 *     </div>
 *   )}
 * </Blog.Post.Content>
 * ```
 */
export const Content = React.forwardRef((props, ref) => {
    const { children, className } = props;
    const { post } = usePostContext();
    const asChild = true;
    const content = post?.richContent;
    const pricingPlanIds = post?.pricingPlanIds ?? [];
    if (!content)
        return null;
    const attributes = {
        'data-testid': "blog-post-content" /* TestIds.content */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { content, pricingPlanIds } }));
});
Content.displayName = 'Blog.Post.Content';
/**
 * Displays the blog post publish date with localization support.
 *
 * @component
 * @example
 * ```tsx
 * // Default rendering
 * <Blog.Post.PublishDate locale="en-US" />
 *
 * // Custom styling and locale
 * <Blog.Post.PublishDate
 *   locale="fr-FR"
 *   className="text-gray-500 text-sm"
 * />
 *
 * // Custom rendering with asChild
 * <Blog.Post.PublishDate locale="en-US" asChild>
 *   {({ formattedDate, publishDate }) => (
 *     <time dateTime={publishDate} className="published-date">
 *       Published on {formattedDate}
 *     </time>
 *   )}
 * </Blog.Post.PublishDate>
 * ```
 */
export const PublishDate = React.forwardRef((props, ref) => {
    const { asChild, children, className, locale } = props;
    const { post } = usePostContext();
    const publishDate = post?.firstPublishedDate;
    if (!publishDate)
        return null;
    const formattedDate = new Date(publishDate).toLocaleDateString(locale ?? 'en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
    });
    // Ensure publishDate is a string for dateTime attribute
    const dateTimeString = typeof publishDate === 'string' ? publishDate : publishDate.toISOString();
    const attributes = {
        'data-testid': "blog-post-publish-date" /* TestIds.publishDate */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { publishDate: dateTimeString, formattedDate }, content: formattedDate, children: _jsx("time", { dateTime: dateTimeString, children: formattedDate }) }));
});
PublishDate.displayName = 'Blog.Post.PublishDate';
export const ReadingTime = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { post } = usePostContext();
    const readingTime = post?.minutesToRead ?? 0;
    if (readingTime <= 0)
        return null;
    const attributes = {
        'data-testid': "blog-post-reading-time" /* TestIds.readingTime */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { readingTime }, content: readingTime, children: _jsx("span", { children: readingTime }) }));
});
ReadingTime.displayName = 'Blog.Post.ReadingTime';
const PostCategoriesContext = React.createContext(null);
PostCategoriesContext.displayName = 'Blog.Post.PostCategoriesContext';
export function usePostCategoriesContext() {
    const context = React.useContext(PostCategoriesContext);
    if (!context) {
        throw new Error('usePostCategoriesContext must be used within a BlogPost.Categories component');
    }
    return context;
}
const CategoryRepeaterContext = React.createContext(null);
CategoryRepeaterContext.displayName = 'Blog.Post.CategoryRepeaterContext';
export function useCategoryRepeaterContext() {
    const context = React.useContext(CategoryRepeaterContext);
    if (!context) {
        throw new Error('useCategoryContext must be used within a BlogPost.CategoryRepeater component');
    }
    return context;
}
const PostTagsContext = React.createContext(null);
PostTagsContext.displayName = 'Blog.Post.PostTagsContext';
export function usePostTagsContext() {
    const context = React.useContext(PostTagsContext);
    if (!context) {
        throw new Error('usePostTagsContext must be used within a BlogPost.Tags component');
    }
    return context;
}
const TagRepeaterContext = React.createContext(null);
TagRepeaterContext.displayName = 'Blog.Post.TagRepeaterContext';
export function useTagRepeaterContext() {
    const context = React.useContext(TagRepeaterContext);
    if (!context) {
        throw new Error('useTagContext must be used within a BlogPost.TagRepeater component');
    }
    return context;
}
/**
 * Container for post categories that provides categories context to all child components.
 * Does not render if no categories are available.
 * Follows Container Level pattern from architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * <Blog.Post.CategoryItems>
 *   <Blog.Post.CategoryRepeater>
 *     <Blog.Categories.Label />
 *   </Blog.Post.CategoryRepeater>
 * </Blog.Post.CategoryItems>
 * ```
 */
export const CategoryItems = React.forwardRef((props, ref) => {
    const { children, className } = props;
    const { post } = usePostContext();
    const categories = post?.resolvedFields?.categories || [];
    const hasCategories = categories.length > 0;
    if (!hasCategories)
        return null;
    const contextValue = {
        categories,
    };
    const attributes = {
        'data-testid': "blog-post-categories" /* TestIds.categories */,
    };
    return (_jsx(PostCategoriesContext.Provider, { value: contextValue, children: _jsx(BlogCategories.Root, { categories: categories, asChild: true, children: _jsx("div", { ...attributes, ref: ref, className: className, children: children }) }) }));
});
CategoryItems.displayName = 'Blog.Post.Categories';
/**
 * Container for post tags that provides tags context to all child components.
 * Does not render if no tags are available.
 * Follows Container Level pattern from architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * <Blog.Post.TagItems>
 *   <Blog.Post.TagRepeater>
 *     <Blog.Tag.Label />
 *   </Blog.Post.TagRepeater>
 * </Blog.Post.TagItems>
 * ```
 */
export const TagItems = React.forwardRef((props, ref) => {
    const { children, className } = props;
    const { post } = usePostContext();
    const postTags = post?.resolvedFields?.tags || [];
    const hasTags = postTags.length > 0;
    if (!hasTags)
        return null;
    const contextValue = {
        tags: postTags,
    };
    const attributes = {
        'data-testid': "blog-post-tags" /* TestIds.tags */,
    };
    return (_jsx(PostTagsContext.Provider, { value: contextValue, children: _jsx("div", { ...attributes, ref: ref, className: className, children: children }) }));
});
TagItems.displayName = 'Blog.Post.Tags';
/**
 * Repeater component that creates individual tag contexts for each tag.
 * Follows Repeater Level pattern from architecture rules.
 * Note: Repeater components do NOT support asChild as per architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * <Blog.Post.TagItems>
 *   <Blog.Post.TagItemRepeater>
 *     <Blog.Tag.Label />
 *   </Blog.Post.TagItemRepeater>
 * </Blog.Post.TagItems>
 * ```
 */
export const TagItemRepeater = React.forwardRef((props, _ref) => {
    const { children } = props;
    const { tags } = usePostTagsContext();
    if (tags.length === 0)
        return null;
    return (_jsx(_Fragment, { children: tags.map((tag, index) => {
            const contextValue = {
                tag,
                index,
                amount: tags.length,
            };
            return (_jsx(TagRepeaterContext.Provider, { value: contextValue, children: children }, tag._id));
        }) }));
});
TagItemRepeater.displayName = 'Blog.Post.TagRepeater';
export const Author = React.forwardRef((props, ref) => {
    const { asChild, children, className } = props;
    const { post } = usePostContext();
    const owner = post?.resolvedFields?.owner;
    if (!owner)
        return null;
    const attributes = {
        'data-testid': "blog-post-author" /* TestIds.author */,
    };
    return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { author: owner }, children: _jsx("span", { children: owner.profile?.nickname }) }));
});
Author.displayName = 'Blog.Post.Author';
/**
 * Renders only if there is an older or newer post
 * @example
 * ```tsx
 * <Blog.Post.SiblingPosts.Root>
 *   <h2>Continue reading</h2>
 *   <Blog.Post.SiblingPosts.Newer>
 *     <Blog.Post.Title />
 *   </Blog.Post.SiblingPosts.Newer>
 *   <Blog.Post.SiblingPosts.Older>
 *     <Blog.Post.Title />
 *   </Blog.Post.SiblingPosts.Older>
 * </Blog.Post.SiblingPosts.Root>
 * ```
 */
const SiblingPostsRoot = React.forwardRef((props, ref) => {
    const { children, className } = props;
    const { olderPost, newerPost } = usePostContext();
    if (!olderPost && !newerPost)
        return null;
    const attributes = {
        'data-testid': "blog-post-sibling-posts" /* TestIds.siblingPosts */,
    };
    return (_jsx("div", { ...attributes, ref: ref, className: className, children: children }));
});
SiblingPostsRoot.displayName = 'Blog.Post.SiblingPosts.Root';
/**
 * Creates a Post context for a newer post
 * @example
 * ```tsx
 * <Blog.Post.SiblingPosts.Newer>
 *   <Blog.Post.Title />
 * </Blog.Post.SiblingPosts.Newer>
 * ```
 */
const SiblingPostNewer = React.forwardRef((props, ref) => {
    const { children, className } = props;
    const { newerPost, coverImageUrl } = usePostContext();
    if (!newerPost)
        return null;
    const attributes = {
        'data-testid': "blog-post-sibling-newer-post" /* TestIds.siblingNewerPost */,
    };
    return (_jsx(Root, { post: newerPost, ref: ref, fallbackImageUrl: coverImageUrl, className: className, ...attributes, children: children }));
});
SiblingPostNewer.displayName = 'Blog.Post.SiblingPosts.Newer';
/**
 * Creates a Post context for an older post
 * @example
 * ```tsx
 * <Blog.Post.SiblingPosts.Older>
 *   <Blog.Post.Title />
 * </Blog.Post.SiblingPosts.Older>
 * ```
 */
const SiblingPostOlder = React.forwardRef((props, ref) => {
    const { children, className } = props;
    const { olderPost, coverImageUrl } = usePostContext();
    if (!olderPost)
        return null;
    const attributes = {
        'data-testid': "blog-post-sibling-older-post" /* TestIds.siblingOlderPost */,
    };
    return (_jsx(Root, { post: olderPost, ref: ref, fallbackImageUrl: coverImageUrl, className: className, ...attributes, children: children }));
});
SiblingPostOlder.displayName = 'Blog.Post.SiblingPosts.Older';
export const SiblingPosts = {
    Root: SiblingPostsRoot,
    Newer: SiblingPostNewer,
    Older: SiblingPostOlder,
};
/**
 * Renders `Comments.Root` linked to post. Doesn't render anything if post has no comment support (is under a paywall or commenting is disabled).
 * @example
 * ```tsx
 * <Blog.Post.Comments currentMember={member}>
 *   <Comments.CommentItemRepeater>
 *     <Comment.Author />
 *     <Comment.CommentDate />
 *     <Comment.Content />
 *   </Comments.CommentItemRepeater>
 * </Blog.Post.Comments>
 * ```
 */
export const Comments = React.forwardRef((props, ref) => {
    const { currentMember, commentsServiceConfig, children, className } = props;
    const { post } = usePostContext();
    if (!post || post.preview || !post.commentingEnabled || !post.referenceId)
        return null;
    return (_jsx(CommentsRoot, { className: className, ref: ref, currentMember: currentMember, commentsServiceConfig: {
            ...commentsServiceConfig,
            contextId: post.referenceId,
            resourceId: post.referenceId,
        }, children: children }));
});
Comments.displayName = 'Blog.Post.Comments';
