import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import { Sort as SortPrimitive } from '@wix/headless-components/react';
import { AsChildSlot } from '@wix/headless-utils/react';
import { createServicesMap } from '@wix/services-manager';
import { WixServices } from '@wix/services-manager-react';
import React from 'react';
import { BlogFeedService, BlogFeedServiceDefinition, } from '../services/blog-feed-service.js';
import * as CoreFeed from './core/Feed.js';
import { isValidChildren } from './helpers.js';
import * as Post from './Post.js';
/** https://manage.wix.com/apps/14bcded7-0066-7c35-14d7-466cb3f09103/extensions/dynamic/wix-vibe-component?component-id=83683a8a-9d7f-437a-9c15-d5cd083530da */
const HTML_CODE_TAG = 'blog.feed';
const PostsContext = React.createContext(null);
PostsContext.displayName = 'Blog.Feed.PostsContext';
export function usePostsContext() {
    const context = React.useContext(PostsContext);
    if (!context) {
        throw new Error('usePostsContext must be used within a BlogFeed.Root component');
    }
    return context;
}
/**
 * Root container for blog feed that provides posts context to all child components.
 * Follows Container Level pattern from architecture rules.
 *
 * @order 1
 * @component
 * @example
 * ```tsx
 * import { Blog } from '@wix/blog/components';
 *
 * function BlogPage() {
 *   return (
 *     <Blog.Feed.Root>
 *       <Blog.Feed.Posts emptyState={<div>No posts found</div>}>
 *         <Blog.Feed.PostRepeater>
 *           <Blog.Post.Title />
 *           <Blog.Post.Excerpt />
 *         </Blog.Feed.PostRepeater>
 *       </Blog.Feed.Posts>
 *     </Blog.Feed.Root>
 *   );
 * }
 * ```
 */
export const Root = React.forwardRef((props, ref) => {
    const { asChild, children, className, blogFeedServiceConfig, fallbackImageUrl } = props;
    return (_jsx(WixServices, { servicesMap: createServicesMap().addService(BlogFeedServiceDefinition, BlogFeedService, blogFeedServiceConfig), children: _jsx(CoreFeed.Posts, { children: ({ posts, hasPosts, totalPosts, isLoading }) => {
                const contextValue = {
                    hasPosts,
                    posts,
                    totalPosts,
                    isLoading,
                    fallbackImageUrl,
                };
                const attributes = {
                    'data-component-tag': HTML_CODE_TAG,
                    'data-testid': "blog-feed-root" /* TestIds.blogFeedRoot */,
                    'data-has-posts': hasPosts,
                    'data-loading': isLoading,
                };
                return (_jsx(PostsContext.Provider, { value: contextValue, children: _jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { hasPosts }, children: _jsx("div", { children: isValidChildren(children) ? children : null }) }) }));
            } }) }));
});
Root.displayName = 'Blog.Feed.Root';
/**
 * Container for the posts list with empty state support.
 * Follows List Container Level pattern from architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * <Blog.Feed.PostItems emptyState={<div>No posts found</div>}>
 *   <Blog.Feed.PostRepeater>
 *     <Blog.Post.Title />
 *     <Blog.Post.Excerpt />
 *   </Blog.Feed.PostRepeater>
 * </Blog.Feed.PostItems>
 * ```
 */
export const PostItems = React.forwardRef((props, ref) => {
    const { children, emptyState, className } = props;
    const { hasPosts, isLoading } = usePostsContext();
    if (!hasPosts) {
        return emptyState || null;
    }
    const attributes = {
        'data-testid': "blog-feed-posts" /* TestIds.blogFeedPosts */,
        'data-loading': isLoading,
    };
    return (_jsx("div", { ...attributes, ref: ref, className: className, children: children }));
});
PostItems.displayName = 'Blog.Feed.PostItems';
/**
 * Sort component for blog feed that provides sorting functionality.
 *
 * This component integrates with the BlogFeed service to provide predefined sort options
 * supports both controlled rendering via the asChild pattern and default UI rendering.
 *
 * @component
 * @example
 * ```tsx
 * // Default select dropdown
 * <Blog.Feed.Sort />
 *
 * // As list of clickable options
 * <Blog.Feed.Sort as="list" />
 *
 * // With custom styling
 * <Blog.Feed.Sort
 *   as="select"
 *   className="custom-sort-select"
 * />
 * ```
 */
export const Sort = React.forwardRef(({ children, className, as, asChild }, ref) => {
    return (_jsx(CoreFeed.Sort, { children: ({ currentSort, sortOptions, setSort }) => {
            if (asChild && children) {
                return children({ currentSort, sortOptions, setSort });
            }
            return (_jsx(SortPrimitive.Root, { ref: ref, value: currentSort, onChange: (value) => setSort(value), sortOptions: sortOptions, as: as, className: className, "data-testid": "blog-feed-sort" /* TestIds.blogFeedSort */, children: sortOptions.map((option) => {
                    if ('fieldName' in option) {
                        return (_jsx(SortPrimitive.Option, { fieldName: option.fieldName, order: 'order' in option ? option.order : 'ASC', label: option.label }, option.label));
                    }
                    return null;
                }) }));
        } }));
});
Sort.displayName = 'Blog.Feed.Sort';
/**
 * Repeater component that creates individual post contexts for each post.
 * Follows Repeater Level pattern from architecture rules.
 * Note: Repeater components do NOT support asChild as per architecture rules.
 *
 * @component
 * @example
 * ```tsx
 * <Blog.Feed.PostItemRepeater>
 *   <Blog.Post.Title />
 *   <Blog.Post.Excerpt />
 *   <Blog.Post.PublishDate />
 * </Blog.Feed.PostItemRepeater>
 * ```
 */
export const PostItemRepeater = React.forwardRef((props, _ref) => {
    const { children, offset = 0, limit = Infinity } = props;
    const { hasPosts, posts, fallbackImageUrl } = usePostsContext();
    if (!hasPosts)
        return null;
    const postsSlice = posts.slice(offset, offset + limit);
    return (_jsx(_Fragment, { children: postsSlice.map((post) => {
            return (_jsx(Post.Root, { post: post, asChild: true, fallbackImageUrl: fallbackImageUrl, children: children }, post._id));
        }) }));
});
PostItemRepeater.displayName = 'Blog.Feed.PostItemRepeater';
/**
 * Load more trigger component for pagination.
 *
 * @component
 * @example
 * ```tsx
 * <Blog.Feed.LoadMore asChild>
 *   {({ hasNextPage, isLoading, loadNextPage }) => (
 *     <button
 *       onClick={loadNextPage}
 *       disabled={!hasNextPage || isLoading}
 *     >
 *       {isLoading ? 'Loading...' : 'Load More'}
 *     </button>
 *   )}
 * </Blog.Feed.LoadMore>
 * ```
 */
export const LoadMore = React.forwardRef((props, ref) => {
    const { asChild, children, className, loadingState } = props;
    return (_jsx(CoreFeed.LoadMore, { children: ({ hasNextPage, isLoading, loadNextPage }) => {
            if (!hasNextPage)
                return null;
            const attributes = {
                'data-testid': "blog-feed-load-more" /* TestIds.blogFeedLoadMore */,
                'data-loading': isLoading,
                'data-has-next-page': hasNextPage,
                onClick: loadNextPage,
            };
            return (_jsx(AsChildSlot, { ref: ref, asChild: asChild, className: className, ...attributes, customElement: children, customElementProps: { isLoading, loadNextPage }, content: isLoading && loadingState ? loadingState : undefined, children: _jsx("button", { children: isValidChildren(children) ? children : null }) }));
        } }));
});
LoadMore.displayName = 'Blog.Feed.LoadMore';
