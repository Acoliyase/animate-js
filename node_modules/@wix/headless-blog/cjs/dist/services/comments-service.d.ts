import { comments } from '@wix/comments';
import { members } from '@wix/members';
import { type ServiceAPI } from '@wix/services-definitions';
import type { Signal } from '@wix/services-definitions/core-services/signals';
export interface CommentResolvedFields {
    author: members.Member | null | undefined;
    parentAuthor: members.Member | null | undefined;
}
export interface CommentWithResolvedFields extends comments.Comment {
    resolvedFields: CommentResolvedFields;
}
type RawQueryCommentsSortField = NonNullable<comments.CommentSort['order']>;
declare const supportedSortFields: ["NEWEST_FIRST", "OLDEST_FIRST"];
type QueryCommentsSortField = Extract<RawQueryCommentsSortField, (typeof supportedSortFields)[number]>;
export type QueryCommentsSort = {
    fieldName: QueryCommentsSortField;
};
type LoadingState = 'initial' | 'saving' | 'more' | false;
export declare const CommentsServiceDefinition: string & {
    __api: {
        isEmpty: (commentId?: string) => boolean;
        hasNextPage: (commentId?: string) => boolean;
        isLoading: (commentId?: string) => LoadingState;
        getComments: (commentId?: string) => CommentWithResolvedFields[];
        getComment: (commentId: string) => CommentWithResolvedFields | undefined;
        getError: (commentId?: string) => string | null;
        clearError: (commentId?: string) => void;
        initialLoad: () => Promise<void>;
        sort: Signal<QueryCommentsSort[]>;
        setSort: (sort: QueryCommentsSort[]) => void;
        createComment: (content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
        createReply: (
        /** Determines which comment will have the replied addded to */
        topCommentId: string, 
        /** Determines the parent comment of the reply (nested) */
        parentCommentId: string, content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
        deleteComment: (commentId: string) => Promise<void>;
        loadMore: () => Promise<void>;
        loadMoreReplies: (commentId: string) => Promise<void>;
    };
    __config: {};
    isServiceDefinition?: boolean;
} & {
    isEmpty: (commentId?: string) => boolean;
    hasNextPage: (commentId?: string) => boolean;
    isLoading: (commentId?: string) => LoadingState;
    getComments: (commentId?: string) => CommentWithResolvedFields[];
    getComment: (commentId: string) => CommentWithResolvedFields | undefined;
    getError: (commentId?: string) => string | null;
    clearError: (commentId?: string) => void;
    initialLoad: () => Promise<void>;
    sort: Signal<QueryCommentsSort[]>;
    setSort: (sort: QueryCommentsSort[]) => void;
    createComment: (content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
    createReply: (
    /** Determines which comment will have the replied addded to */
    topCommentId: string, 
    /** Determines the parent comment of the reply (nested) */
    parentCommentId: string, content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
    deleteComment: (commentId: string) => Promise<void>;
    loadMore: () => Promise<void>;
    loadMoreReplies: (commentId: string) => Promise<void>;
};
export type CommentsServiceAPI = ServiceAPI<typeof CommentsServiceDefinition>;
export type CommentsServiceConfig = {
    contextId: string;
    resourceId: string;
    pageSize?: number;
    sort?: QueryCommentsSort[];
};
export declare const CommentsService: import("@wix/services-definitions").ServiceFactory<string & {
    __api: {
        isEmpty: (commentId?: string) => boolean;
        hasNextPage: (commentId?: string) => boolean;
        isLoading: (commentId?: string) => LoadingState;
        getComments: (commentId?: string) => CommentWithResolvedFields[];
        getComment: (commentId: string) => CommentWithResolvedFields | undefined;
        getError: (commentId?: string) => string | null;
        clearError: (commentId?: string) => void;
        initialLoad: () => Promise<void>;
        sort: Signal<QueryCommentsSort[]>;
        setSort: (sort: QueryCommentsSort[]) => void;
        createComment: (content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
        createReply: (
        /** Determines which comment will have the replied addded to */
        topCommentId: string, 
        /** Determines the parent comment of the reply (nested) */
        parentCommentId: string, content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
        deleteComment: (commentId: string) => Promise<void>;
        loadMore: () => Promise<void>;
        loadMoreReplies: (commentId: string) => Promise<void>;
    };
    __config: {};
    isServiceDefinition?: boolean;
} & {
    isEmpty: (commentId?: string) => boolean;
    hasNextPage: (commentId?: string) => boolean;
    isLoading: (commentId?: string) => LoadingState;
    getComments: (commentId?: string) => CommentWithResolvedFields[];
    getComment: (commentId: string) => CommentWithResolvedFields | undefined;
    getError: (commentId?: string) => string | null;
    clearError: (commentId?: string) => void;
    initialLoad: () => Promise<void>;
    sort: Signal<QueryCommentsSort[]>;
    setSort: (sort: QueryCommentsSort[]) => void;
    createComment: (content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
    createReply: (
    /** Determines which comment will have the replied addded to */
    topCommentId: string, 
    /** Determines the parent comment of the reply (nested) */
    parentCommentId: string, content: comments.CommentContent) => Promise<CommentWithResolvedFields | null>;
    deleteComment: (commentId: string) => Promise<void>;
    loadMore: () => Promise<void>;
    loadMoreReplies: (commentId: string) => Promise<void>;
}, CommentsServiceConfig>;
export {};
//# sourceMappingURL=comments-service.d.ts.map