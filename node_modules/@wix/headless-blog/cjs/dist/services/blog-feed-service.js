import { categories, posts, tags } from '@wix/blog';
import { members } from '@wix/members';
import { media } from '@wix/sdk';
import { defineService, implementService } from '@wix/services-definitions';
import { SignalsServiceDefinition } from '@wix/services-definitions/core-services/signals';
const DEFAULT_PAGE_SIZE = 12;
export const BlogFeedServiceDefinition = defineService('blogService');
export const BlogFeedService = implementService.withConfig()(BlogFeedServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(SignalsServiceDefinition);
    const postsSignal = signalsService.signal(config.initialPosts);
    const categorySignal = signalsService.signal(config.initialCategory || null);
    const sortSignal = signalsService.signal(config.sort);
    const isLoadingSignal = signalsService.signal(false);
    const errorSignal = signalsService.signal(null);
    let nextPageCursor = config.nextPageCursor;
    const totalPostsSignal = signalsService.signal(config.totalPostCount || 0);
    const isEmpty = () => {
        return !isLoadingSignal.get() && totalPostsSignal.get() === 0;
    };
    const hasNextPage = () => {
        return !!nextPageCursor;
    };
    // Actions
    const load = async (loadMore) => {
        try {
            if (loadMore && !nextPageCursor) {
                return;
            }
            isLoadingSignal.set(true);
            errorSignal.set(null);
            const result = await fetchPosts({
                skipTo: loadMore ? nextPageCursor : undefined,
                sort: sortSignal.get(),
                showPinnedPostsFirst: config.showPinnedPostsFirst,
                pageSize: config.pageSize || DEFAULT_PAGE_SIZE,
                categoryId: config.initialCategory?._id,
                excludePostIds: config.excludePostIds || [],
                postIds: [],
            });
            if (loadMore) {
                postsSignal.set([...postsSignal.get(), ...result.items]);
            }
            else {
                postsSignal.set(result.items);
            }
            nextPageCursor = result?.cursors.next || undefined;
            return result;
        }
        catch (err) {
            console.error('Failed to load posts:', err);
            errorSignal.set('Failed to load posts');
        }
        finally {
            isLoadingSignal.set(false);
        }
    };
    const loadNextPage = async () => {
        await load(true);
    };
    const setSort = async (sort) => {
        sortSignal.set(sort);
        await load(false);
    };
    return {
        posts: postsSignal,
        category: categorySignal,
        isLoading: isLoadingSignal,
        error: errorSignal,
        totalPosts: totalPostsSignal,
        isEmpty,
        hasNextPage,
        loadNextPage: loadNextPage,
        sort: sortSignal,
        setSort,
    };
});
export async function loadBlogFeedServiceConfig(params = {}) {
    const pageSize = params.pageSize || 10;
    const showPinnedPostsFirst = params.showPinnedPostsFirst || false;
    const sort = params.sort || [
        {
            fieldName: 'firstPublishedDate',
            order: 'DESC',
        },
    ];
    const excludePostIds = params.excludePostIds?.filter(nonNullable) || [];
    const postIds = params.postIds?.filter(nonNullable) || [];
    try {
        let initialCategory;
        if (params.categorySlug) {
            const category = await categories.getCategoryBySlug(params.categorySlug, {
                fieldsets: ['SEO'],
            });
            if (category.category) {
                initialCategory = category.category;
            }
            else {
                throw new Error(`Category for slug "${params.categorySlug}" not found`);
            }
        }
        const result = await fetchPosts({
            skipTo: undefined,
            sort,
            pageSize,
            categoryId: initialCategory?._id,
            excludePostIds,
            postIds,
            showPinnedPostsFirst,
        });
        return {
            initialPosts: result.items || [],
            initialCategory,
            totalPostCount: result.length,
            pageSize,
            excludePostIds,
            sort,
            nextPageCursor: result.cursors.next || undefined,
            showPinnedPostsFirst,
        };
    }
    catch (error) {
        return {
            initialPosts: [],
            initialCategory: undefined,
            totalPostCount: 0,
            excludePostIds,
            pageSize,
            sort,
            nextPageCursor: undefined,
            showPinnedPostsFirst,
        };
    }
}
async function fetchPosts(params) {
    const { skipTo, sort, categoryId, pageSize = DEFAULT_PAGE_SIZE, excludePostIds = [], postIds, showPinnedPostsFirst, } = params;
    let query = posts.queryPosts().limit(pageSize);
    if (skipTo) {
        query = query.skipTo(skipTo);
    }
    if (showPinnedPostsFirst) {
        query = query.descending('pinned');
    }
    for (const sortOption of sort) {
        if (sortOption.fieldName) {
            if (sortOption.order === 'ASC') {
                query = query.ascending(sortOption.fieldName);
            }
            else if (sortOption.order === 'DESC') {
                query = query.descending(sortOption.fieldName);
            }
        }
    }
    if (categoryId) {
        query = query.hasSome('categoryIds', [categoryId]);
    }
    if (postIds.length) {
        query = query.in('_id', postIds);
    }
    for (const excludePostId of excludePostIds) {
        query = query.ne('_id', excludePostId);
    }
    const result = await query.find();
    const rawPosts = result.items || [];
    const enhancedPosts = await enhancePosts(rawPosts);
    return {
        ...result,
        items: enhancedPosts,
    };
}
export async function enhancePosts(rawPosts) {
    const filteredPosts = rawPosts.filter(nonNullable);
    const { members, categories, tags } = await fetchPostEntities(filteredPosts);
    // Ensure same amount of posts are returned as rawPosts
    return rawPosts.map((post) => {
        if (!post) {
            return undefined;
        }
        const coverImage = getCoverImage(post);
        return {
            ...post,
            resolvedFields: {
                owner: post.memberId ? members[post.memberId] : undefined,
                categories: post.categoryIds?.map((categoryId) => categories[categoryId]).filter(nonNullable) ?? [],
                tags: post.tagIds?.map((tagId) => tags[tagId]).filter(nonNullable) ?? [],
                coverImageUrl: coverImage.url,
                coverImageAlt: coverImage.alt,
            },
        };
    });
}
async function fetchPostEntities(posts) {
    const memberIdsToResolve = uniqueFlatMapByKey(posts, 'memberId');
    const categoryIdsToResolve = uniqueFlatMapByKey(posts, 'categoryIds');
    const tagIdsToResolve = uniqueFlatMapByKey(posts, 'tagIds');
    const memberPromises = memberIdsToResolve.map((memberId) => {
        return members
            .getMember(memberId)
            .then((response) => [memberId, response])
            .catch((err) => {
            console.error(`Failed to resolve member ${memberId}`, err?.message);
            return [memberId, null];
        });
    });
    const categoryPromises = categoryIdsToResolve.map((categoryId) => categories
        .getCategory(categoryId)
        .then((response) => [categoryId, response.category])
        .catch((err) => {
        console.error(`Failed to resolve category ${categoryId}`, err?.details);
        return [categoryId, null];
    }));
    const tagPromises = tagIdsToResolve.map((tagId) => tags
        .getTag(tagId)
        .then((response) => [tagId, response])
        .catch((err) => {
        console.error(`Failed to resolve tag ${tagId}`, err?.message);
        return [tagId, null];
    }));
    const [resolvedMembers, resolvedCategories, resolvedTags] = await Promise.all([
        Promise.all(memberPromises),
        Promise.all(categoryPromises),
        Promise.all(tagPromises),
    ]);
    return {
        members: Object.fromEntries(resolvedMembers),
        categories: Object.fromEntries(resolvedCategories),
        tags: Object.fromEntries(resolvedTags),
    };
}
function getCoverImage(post) {
    let coverImageUrl = null;
    if (post.media?.wixMedia?.image) {
        coverImageUrl = media.getImageUrl(post.media.wixMedia.image).url;
    }
    else if (post.media?.embedMedia?.thumbnail?.url) {
        coverImageUrl = post.media.embedMedia.thumbnail.url;
    }
    return {
        url: coverImageUrl,
        alt: post.media?.altText || post.title || null,
    };
}
function nonNullable(value) {
    return !!value;
}
function uniqueFlatMapByKey(collection, key) {
    const values = collection.flatMap((item) => {
        return item[key] || [];
    });
    const uniqueValues = [...new Set(values)];
    return uniqueValues;
}
