import { comments } from '@wix/comments';
import { members } from '@wix/members';
import { defineService, implementService } from '@wix/services-definitions';
import { SignalsServiceDefinition } from '@wix/services-definitions/core-services/signals';
const DEFAULT_PAGE_SIZE = 10;
const BLOG_APP_ID = '14bcded7-0066-7c35-14d7-466cb3f09103';
const ROOT_ID = 'ROOT';
const supportedSortFields = [
    'NEWEST_FIRST',
    'OLDEST_FIRST',
];
const DEFAULT_COMMENTS_SORT = [{ fieldName: 'NEWEST_FIRST' }];
const DEFAULT_REPLIES_SORT = [{ fieldName: 'OLDEST_FIRST' }];
export const CommentsServiceDefinition = defineService('commentsService');
export const CommentsService = implementService.withConfig()(CommentsServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(SignalsServiceDefinition);
    const threadStatesSignal = signalsService.signal({
        [ROOT_ID]: { comments: [], isLoading: false },
    });
    const sortSignal = signalsService.signal(config.sort ?? DEFAULT_COMMENTS_SORT);
    const resourceId = config.resourceId;
    const contextId = config.contextId;
    const pageSize = config.pageSize || DEFAULT_PAGE_SIZE;
    if (!contextId || !resourceId) {
        throw new Error('contextId and resourceId are required');
    }
    const getComments = (threadId) => {
        const threadStates = threadStatesSignal.get();
        const _commentId = threadId || ROOT_ID;
        return threadStates[_commentId]?.comments ?? [];
    };
    const getComment = (commentId) => {
        const threadStates = threadStatesSignal.get();
        const rootComments = threadStates[ROOT_ID]?.comments ?? [];
        const allThreadComments = rootComments.flatMap((comment) => {
            if (comment._id) {
                return threadStates[comment._id]?.comments ?? [];
            }
            return [];
        });
        const allComments = [...rootComments, ...allThreadComments];
        return allComments.find((comment) => comment._id === commentId);
    };
    const getAllComments = () => {
        return Object.values(threadStatesSignal.get()).flatMap((threadState) => threadState.comments);
    };
    const getHasLeafComments = (commentId) => {
        const allComments = getAllComments();
        return allComments.some((comment) => comment.parentComment?._id === commentId);
    };
    const findThreadStateByCommentId = (commentId) => {
        const threadState = Object.entries(threadStatesSignal.get()).find(([, threadState]) => threadState.comments.some((comment) => comment._id === commentId));
        return threadState
            ? { threadStateId: threadState[0], threadState: threadState[1] }
            : undefined;
    };
    const getMemberMap = () => {
        const allComments = getAllComments();
        const membersMap = {};
        for (const comment of allComments) {
            if (comment.resolvedFields.author?._id) {
                membersMap[comment.resolvedFields.author._id] = comment.resolvedFields.author;
            }
            if (comment.resolvedFields.parentAuthor?._id) {
                membersMap[comment.resolvedFields.parentAuthor._id] = comment.resolvedFields.parentAuthor;
            }
        }
        return membersMap;
    };
    const setThreadState = {
        loading: (commentId, isLoading) => {
            const threadState = threadStatesSignal.get()[commentId];
            const comments = threadState?.comments ?? [];
            threadStatesSignal.set({
                ...threadStatesSignal.get(),
                [commentId]: {
                    comments,
                    isLoading,
                    nextCursor: threadState?.nextCursor,
                    error: null,
                },
            });
        },
        loaded: (commentId, items, nextCursor) => {
            threadStatesSignal.set({
                ...threadStatesSignal.get(),
                [commentId]: {
                    comments: items,
                    isLoading: false,
                    nextCursor: nextCursor ?? undefined,
                    error: null,
                },
            });
        },
        error: (commentId, error) => {
            const threadState = threadStatesSignal.get()[commentId];
            threadStatesSignal.set({
                ...threadStatesSignal.get(),
                [commentId]: {
                    ...threadState,
                    comments: threadState?.comments ?? [],
                    isLoading: false,
                    error,
                },
            });
        },
    };
    const isLoading = (commentId) => {
        return threadStatesSignal.get()[commentId || ROOT_ID]?.isLoading ?? false;
    };
    const isEmpty = (commentId) => {
        return !isLoading(commentId) && getComments(commentId).length === 0;
    };
    const hasNextPage = (commentId) => {
        return !!getNextCursor(commentId);
    };
    const getError = (commentId) => {
        return threadStatesSignal.get()[commentId || ROOT_ID]?.error ?? null;
    };
    const clearError = (commentId) => {
        threadStatesSignal.set({
            ...threadStatesSignal.get(),
            [commentId || ROOT_ID]: { ...threadStatesSignal.get()[commentId || ROOT_ID], error: null },
        });
    };
    const getNextCursor = (commentId) => {
        return threadStatesSignal.get()[commentId || ROOT_ID]?.nextCursor;
    };
    // Actions
    const load = async (shouldLoadMore) => {
        try {
            const nextCursor = getNextCursor();
            if (shouldLoadMore && !nextCursor) {
                console.warn(`No next cursor available for thread ${ROOT_ID.toString()}`);
                return;
            }
            setThreadState.loading(ROOT_ID, shouldLoadMore ? 'more' : 'initial');
            const result = await fetchComments({
                contextId,
                resourceId,
                nextCursor: shouldLoadMore ? nextCursor : undefined,
                sort: sortSignal.get(),
                pageSize,
                memberMap: getMemberMap(),
            });
            const currentComments = getComments();
            const nextComments = shouldLoadMore
                ? mergePreserveOrderById(currentComments, result.items)
                : result.items;
            setThreadState.loaded(ROOT_ID, nextComments, result?.cursors?.next);
            for (const commentThread of result.commentThreads) {
                setThreadState.loaded(commentThread.parentCommentId, commentThread.comments, commentThread.nextCursor);
            }
            return result;
        }
        catch (err) {
            console.error('Failed to load comments:', err);
            setThreadState.error(ROOT_ID, 'Failed to load comments');
        }
    };
    const initialLoad = async () => {
        if (isLoading()) {
            return;
        }
        await load(false);
    };
    const setSort = async (sort) => {
        sortSignal.set(sort);
        await load(false);
    };
    const loadMore = async () => {
        if (isLoading()) {
            return;
        }
        await load(true);
    };
    const loadMoreReplies = async (commentId) => {
        const nextCursor = getNextCursor(commentId);
        setThreadState.loading(commentId, nextCursor ? 'more' : 'initial');
        try {
            const response = await fetchReplies({
                commentId,
                contextId: config.contextId,
                resourceId: config.resourceId,
                pageSize,
                nextCursor,
                memberMap: getMemberMap(),
            });
            const currentCommentReplies = getComments(commentId);
            const nextCommentReplies = mergePreserveOrderById(currentCommentReplies, response.items);
            setThreadState.loaded(commentId, nextCommentReplies, response.cursors?.next);
        }
        catch (err) {
            console.error('Failed to load more replies:', err);
            setThreadState.error(commentId, 'Failed to load more replies');
        }
    };
    const createComment = async (content) => {
        try {
            setThreadState.loading(ROOT_ID, 'saving');
            const newComment = await comments.createComment({
                appId: BLOG_APP_ID,
                contextId: config.contextId,
                resourceId: config.resourceId,
                content,
            });
            const { members: resolvedMembers } = await fetchCommentEntities([newComment], getMemberMap());
            const enhancedNewComment = toEnhancedComment(newComment, resolvedMembers);
            const threadState = threadStatesSignal.get()[ROOT_ID];
            // Add to the beginning of the comments list
            const currentComments = threadState.comments;
            const updatedComments = mergePreserveOrderById([enhancedNewComment], currentComments);
            setThreadState.loaded(ROOT_ID, updatedComments, threadState.nextCursor);
            return enhancedNewComment;
        }
        catch (err) {
            console.error('Failed to create comment:', err);
            setThreadState.error(ROOT_ID, 'Failed to create comment');
            return null;
        }
    };
    const createReply = async (
    /** Determines which comment will have the replied addded to */
    topCommentId, 
    /** Determines the parent comment of the reply (nested) */
    parentCommentId, content) => {
        try {
            const targetThread = topCommentId ?? parentCommentId;
            setThreadState.loading(parentCommentId, 'saving');
            const newReply = await comments.createComment({
                appId: BLOG_APP_ID,
                contextId: config.contextId,
                resourceId: config.resourceId,
                content,
                parentComment: {
                    _id: parentCommentId,
                },
            });
            const { members: resolvedMembers } = await fetchCommentEntities([newReply], getMemberMap());
            const enhancedReply = toEnhancedComment(newReply, resolvedMembers);
            const rootThreadState = threadStatesSignal.get()[ROOT_ID];
            const rootComments = rootThreadState?.comments ?? [];
            const nextRootComments = rootComments.map((comment) => {
                if (comment._id === parentCommentId || comment._id === topCommentId) {
                    return {
                        ...comment,
                        replyCount: (comment.replyCount ?? 0) + 1,
                    };
                }
                return comment;
            });
            const parentThread = threadStatesSignal.get()[targetThread];
            const currentThreadComments = parentThread?.comments ?? [];
            // Store new comment in top thread
            setThreadState.loaded(topCommentId, mergePreserveOrderById(currentThreadComments, [enhancedReply]), parentThread?.nextCursor);
            // Update "saving" state for parent comment (reply form saving state)
            setThreadState.loaded(parentCommentId, threadStatesSignal.get()[parentCommentId]?.comments ?? [], threadStatesSignal.get()[parentCommentId]?.nextCursor);
            // Update replyCount
            setThreadState.loaded(ROOT_ID, nextRootComments, rootThreadState?.nextCursor);
            return enhancedReply;
        }
        catch (err) {
            setThreadState.error(parentCommentId, 'Failed to create reply');
            return null;
        }
    };
    const deleteComment = async (commentIdToDelete) => {
        try {
            setThreadState.loading(commentIdToDelete, 'saving');
            await comments.deleteComment(commentIdToDelete);
            const hasLeafComments = getHasLeafComments(commentIdToDelete);
            const commentIdThread = findThreadStateByCommentId(commentIdToDelete);
            if (!commentIdThread) {
                console.warn('Comment not found in any thread');
                return;
            }
            const nextComments = hasLeafComments
                ? commentIdThread.threadState.comments.map((comment) => comment._id === commentIdToDelete ? toDeletedComment(comment) : comment)
                : commentIdThread.threadState.comments.filter((comment) => comment._id !== commentIdToDelete);
            setThreadState.loaded(commentIdThread.threadStateId, nextComments, commentIdThread.threadState.nextCursor);
        }
        catch (err) {
            console.error('Failed to delete comment:', err);
            setThreadState.error(commentIdToDelete, 'Failed to delete comment');
        }
    };
    return {
        getComments,
        getComment,
        isEmpty,
        isLoading,
        hasNextPage,
        getError,
        clearError,
        loadMore,
        loadMoreReplies,
        initialLoad,
        sort: sortSignal,
        setSort,
        createComment,
        createReply,
        deleteComment,
    };
});
async function fetchComments(params) {
    const options = {
        contextId: params.contextId,
        resourceId: params.resourceId,
        commentSort: {
            order: params.sort[0]?.fieldName || DEFAULT_COMMENTS_SORT[0].fieldName,
        },
        replySort: {
            order: 'OLDEST_FIRST',
            keepMarkedInOriginalOrder: false,
        },
        cursorPaging: {
            limit: params.pageSize,
            cursor: params.nextCursor,
            repliesLimit: 0,
        },
    };
    const response = await comments.listCommentsByResource(BLOG_APP_ID, options);
    const rawComments = response.comments || [];
    const rawReplies = Object.values(response.commentReplies ?? {}).flatMap((replies) => replies.replies ?? []);
    const { members: resolvedMembers } = await fetchCommentEntities([...rawComments, ...rawReplies], params.memberMap);
    const enhancedComments = rawComments.map((comment) => toEnhancedComment(comment, resolvedMembers));
    const commentThreads = Object.entries(response.commentReplies ?? {}).map(([parentCommentId, replies]) => {
        return {
            parentCommentId,
            comments: (replies.replies ?? []).map((reply) => toEnhancedComment(reply, resolvedMembers)),
            nextCursor: replies.pagingMetadata?.cursors?.next ?? undefined,
        };
    });
    return {
        items: enhancedComments,
        cursors: response.pagingMetadata?.cursors ?? { next: undefined, prev: undefined },
        length: response.comments?.length || 0,
        commentThreads,
    };
}
async function fetchReplies(params) {
    const nextCursor = params.nextCursor;
    if (!nextCursor) {
        console.warn(`No cursor available for comment ${params.commentId}`);
        return { items: [], cursors: { next: undefined, prev: undefined } };
    }
    const options = {
        contextId: params.contextId,
        resourceId: params.resourceId,
        cursorPaging: {
            limit: params.pageSize || DEFAULT_PAGE_SIZE,
            cursor: nextCursor,
        },
        replySort: {
            order: DEFAULT_REPLIES_SORT[0].fieldName,
            keepMarkedInOriginalOrder: false,
        },
    };
    const response = await comments.listCommentsByResource(BLOG_APP_ID, options);
    const replies = response.comments ?? [];
    if (replies.length === 0) {
        console.warn(`No replies found for comment ${params.commentId}`);
        return { items: [], cursors: { next: undefined, prev: undefined } };
    }
    const { members: resolvedMembers } = await fetchCommentEntities(replies, params.memberMap);
    const enhancedReplies = replies.map((reply) => toEnhancedComment(reply, resolvedMembers));
    return {
        items: enhancedReplies,
        cursors: response.pagingMetadata?.cursors ?? { next: undefined, prev: undefined },
    };
}
function toDeletedComment(comment) {
    return {
        ...comment,
        status: 'DELETED',
        content: undefined,
        author: undefined,
        resolvedFields: { author: undefined, parentAuthor: undefined },
    };
}
function toEnhancedComment(comment, resolvedMembers) {
    // store draft content until it's approved
    const draftContent = (comment.status === 'PENDING' && 'draftContent' in comment ? comment.draftContent : undefined);
    return {
        ...comment,
        content: comment.content ?? draftContent,
        resolvedFields: {
            author: comment.author?.memberId ? resolvedMembers[comment.author.memberId] : undefined,
            parentAuthor: comment.parentComment?.author?.memberId
                ? resolvedMembers[comment.parentComment.author.memberId]
                : undefined,
        },
    };
}
async function fetchCommentEntities(comments, memberMap) {
    const memberIdsToResolve = Array.from(new Set([
        ...uniqueFlatMapByKey(comments, 'author.memberId'),
        ...uniqueFlatMapByKey(comments, 'parentComment.author.memberId'),
    ]));
    const memberPromises = memberIdsToResolve.map((memberId) => {
        if (memberId in memberMap && memberMap[memberId]) {
            return [memberId, memberMap[memberId]];
        }
        return members
            .getMember(memberId)
            .then((response) => [memberId, response])
            .catch((err) => {
            console.error(`Failed to resolve member ${memberId}`, err?.message);
            return [memberId, null];
        });
    });
    const [resolvedMembers] = await Promise.all([Promise.all(memberPromises)]);
    return {
        members: Object.fromEntries(resolvedMembers),
    };
}
function nonNullable(value) {
    return !!value;
}
function uniqueFlatMapByKey(collection, key) {
    const values = collection
        .flatMap((item) => {
        const nestedValue = key.split('.').reduce((obj, prop) => obj?.[prop], item);
        return nestedValue || [];
    })
        .filter(nonNullable);
    const uniqueValues = [...new Set(values)];
    return uniqueValues;
}
function mergePreserveOrderById(items, newItems) {
    const map = new Map(items.map((item) => [item._id, item]));
    for (const newItem of newItems) {
        map.set(newItem._id, newItem);
    }
    const existingIds = new Set(items.map((item) => item._id));
    return [
        ...items.map((item) => map.get(item._id)),
        ...newItems.filter((item) => !existingIds.has(item._id)),
    ];
}
