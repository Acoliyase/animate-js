"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  createSentryBrowserClient: () => createSentryBrowserClient
});
module.exports = __toCommonJS(index_exports);

// src/factory.ts
var import_monitoring2 = require("@wix/monitoring");

// src/browser/client.ts
var import_monitoring_common_sentry2 = require("@wix/monitoring-common-sentry");

// src/abstract-browser-client.ts
var import_monitoring_common_sentry = require("@wix/monitoring-common-sentry");

// src/context-utils.ts
var import_monitoring = require("@wix/monitoring");
var setTagsAndContextsOnScope = (scope, { tags, contexts }) => {
  if (tags) {
    scope.setTags(tags);
  }
  if (contexts) {
    Object.entries(contexts).forEach(
      ([key, value]) => typeof value !== "undefined" && scope.setContext(key, value)
    );
  }
};
var setHostContextOnScope = (scope, hostContext) => {
  if (!hostContext) {
    return;
  }
  const { tags, contexts } = (0, import_monitoring.generateTagsAndContext)(hostContext);
  setTagsAndContextsOnScope(scope, { tags, contexts });
};

// src/abstract-browser-client.ts
var MandatorySDKMethods = ["onLoad", "forceLoad"];
var manualSpanRegistryMap = /* @__PURE__ */ new Map();
var AbstractSentryBrowserClient = class {
  constructor(options) {
    this.options = options;
    this.resolvedState = null;
    this.validateOptions = (options) => {
      const missingSDKMethods = MandatorySDKMethods.filter(
        (method) => typeof options.sentrySDK?.[method] !== "function"
      );
      if (missingSDKMethods.length > 0) {
        throw new Error(
          `Missing the following options.sentrySDK methods: ${missingSDKMethods.join(", ")}`
        );
      }
    };
    this.validateOptions(options);
    let manualSpanRegistry = manualSpanRegistryMap.get(options.dsn);
    if (!manualSpanRegistry) {
      manualSpanRegistry = (0, import_monitoring_common_sentry.createManualSpanRegistry)({
        // Force spans to be reported as individual transactions (one http request per one span)
        forceTransaction: true
      });
      manualSpanRegistryMap.set(options.dsn, manualSpanRegistry);
    }
    this.manualSpanRegistry = manualSpanRegistry;
  }
  isFullSDK() {
    return typeof this.options.sentrySDK.BrowserClient === "function";
  }
  init() {
    if (this.resolvedState) {
      return this.resolvedState;
    }
    const {
      sentrySDK,
      transport,
      hostContext,
      dsn,
      release,
      environment,
      tracesSampleRate = 1,
      debug = false
    } = this.options;
    const scope = new sentrySDK.Scope();
    const sentryClient = new sentrySDK.BrowserClient({
      dsn,
      transport: transport ?? sentrySDK.makeFetchTransport,
      integrations: sentrySDK.getDefaultIntegrations({}),
      stackParser: sentrySDK.defaultStackParser,
      tracesSampleRate: tracesSampleRate || 1,
      debug,
      environment,
      release
    });
    setHostContextOnScope(scope, hostContext);
    scope.setClient(sentryClient);
    sentryClient.init();
    this.resolvedState = {
      sentrySDK,
      scope,
      sentryClient
    };
    return this.resolvedState;
  }
  loadFullSDK(handler) {
    if (this.isFullSDK()) {
      handler?.(this.init());
      return;
    }
    if (this.promise) {
      this.promise.then(handler);
      return;
    }
    this.promise = new Promise((resolve) => {
      this.options.sentrySDK.onLoad(() => {
        if (this.resolvedState) {
          return;
        }
        const resolvedState = this.init();
        resolve(resolvedState);
        handler?.(resolvedState);
      });
    });
    this.options.sentrySDK.forceLoad();
  }
};

// src/browser/client.ts
var SentryBrowserClient = class extends AbstractSentryBrowserClient {
  constructor() {
    super(...arguments);
    /**
     * Records a new breadcrumb which will be attached to future events.
     * Breadcrumbs will be added to subsequent events to provide more context on user's actions prior to an error or crash.
     * @param breadcrumb The breadcrumb to record.
     */
    this.addBreadcrumb = (breadcrumb) => {
      const filteredBreadcrumb = {
        type: breadcrumb.type,
        category: breadcrumb.category,
        message: breadcrumb.message,
        level: breadcrumb.level,
        data: breadcrumb.data
      };
      this.loadFullSDK(({ scope }) => {
        scope.addBreadcrumb(filteredBreadcrumb);
      });
    };
    /**
     * Captures an exception event and sends it to Sentry.
     * @param error The error to capture
     * @param captureContext Optional additional data to attach to the Sentry event.
     */
    this.captureException = (error, captureContext) => {
      this.loadFullSDK(({ sentryClient, scope }) => {
        sentryClient.captureException(
          error,
          {
            captureContext: {
              level: captureContext?.level ?? "error",
              tags: captureContext?.tags,
              contexts: captureContext?.contexts
            }
          },
          scope
        );
      });
    };
    /**
     * Captures a message event and sends it to Sentry.
     * @param message The message to capture
     * @param captureContext Define the level of the message or pass in additional data to attach to the message.
     */
    this.captureMessage = (message, captureContext) => {
      this.loadFullSDK(({ sentryClient, scope }) => {
        sentryClient.captureMessage(
          message,
          captureContext?.level ?? "error",
          {
            captureContext: {
              level: captureContext?.level ?? "error",
              tags: captureContext?.tags,
              contexts: captureContext?.contexts
            }
          },
          scope
        );
      });
    };
    /**
     * Wraps a function with a span and finishes the span after the function is done. The created span is the active span and will be used as parent by other spans created inside the function, as long as the function is executed while the scope is active.
     * @param spanOptions The options for the span
     * @param callback The function to wrap with a span
     * @returns The return value of the callback
     */
    this.startSpan = (spanOptions, callback) => {
      if (this.isFullSDK()) {
        const { sentrySDK, scope } = this.init();
        return sentrySDK.startSpan({ ...spanOptions, scope }, callback);
      }
      this.loadFullSDK();
      const simulateAndReportSuccessfulSpan = (callbackResult2, startTime2) => {
        const spanDuration = Date.now() - startTime2;
        const simulatedCallback = () => {
          return new Promise(
            (resolve) => setTimeout(() => resolve(callbackResult2), spanDuration)
          );
        };
        this.loadFullSDK(async ({ sentrySDK, scope }) => {
          return sentrySDK.startSpan(
            { ...spanOptions, scope },
            simulatedCallback
          );
        });
      };
      const simulateAndReportFailedSpan = async (error2, startTime2) => {
        const spanDuration = Date.now() - startTime2;
        const simulatedCallback = () => {
          return new Promise(
            (_, reject) => setTimeout(() => reject(error2), spanDuration)
          );
        };
        this.loadFullSDK(async ({ sentrySDK, scope }) => {
          try {
            await sentrySDK.startSpan(
              { ...spanOptions, scope },
              simulatedCallback
            );
          } catch (e) {
            if (e?.message !== error2?.message) {
              throw e;
            }
          }
        });
      };
      const startTime = Date.now();
      let callbackResult;
      let error;
      try {
        callbackResult = callback();
      } catch (e) {
        error = e;
      }
      if (error) {
        simulateAndReportFailedSpan(error, startTime);
        throw error;
      } else {
        if ((0, import_monitoring_common_sentry2.isPromise)(callbackResult)) {
          callbackResult.then((res) => simulateAndReportSuccessfulSpan(res, startTime)).catch((e) => simulateAndReportFailedSpan(e, startTime));
        } else {
          simulateAndReportSuccessfulSpan(callbackResult, startTime);
        }
        return callbackResult;
      }
    };
    this.startSpanManual = (spanOptions) => {
      const resolvedStateOrPromise = this.isFullSDK() ? this.init() : new Promise((resolve) => this.loadFullSDK(resolve));
      const span = this.manualSpanRegistry.createSpan(
        spanOptions,
        resolvedStateOrPromise
      );
      return span;
    };
    this.endSpanManual = (spanOptions) => {
      const span = this.manualSpanRegistry.getSpan(spanOptions);
      span?.end();
    };
  }
};

// src/factory.ts
var unsupportedEnvironmentMessage = (version) => `Sentry SDK version "${version}" is not supported. Please make sure to use monitoring SDK only in supported environments.`;
var major = (version) => {
  try {
    return parseInt(version.split(".")[0], 10);
  } catch {
    console.warn("Failed to parse Sentry SDK version");
    return void 0;
  }
};
var createSentryBrowserClient = ({
  sentrySDK,
  dsn,
  ...options
}) => {
  if (!sentrySDK) {
    return (0, import_monitoring2.createFallbackMonitoringClient)(
      "Unsupported environment - Sentry SDK is not loaded into the environment. Please make sure to use monitoring SDK only in supported environments."
    );
  }
  if (!dsn) {
    return (0, import_monitoring2.createFallbackMonitoringClient)(
      "Missing Sentry DSN in the app's monitoring configuration. Please make sure to set it."
    );
  }
  try {
    const sentrySdkMajorVersion = sentrySDK.SDK_VERSION && major(sentrySDK.SDK_VERSION);
    if (sentrySdkMajorVersion && sentrySdkMajorVersion < 7) {
      return (0, import_monitoring2.createFallbackMonitoringClient)(
        unsupportedEnvironmentMessage(sentrySDK.SDK_VERSION)
      );
    }
    return new SentryBrowserClient({ ...options, dsn, sentrySDK });
  } catch (e) {
    return (0, import_monitoring2.createFallbackMonitoringClient)(
      `Failed to initialize monitoring client: ${e.message}`
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createSentryBrowserClient
});
