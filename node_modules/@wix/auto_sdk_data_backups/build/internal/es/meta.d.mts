import { CreateBackupRequest as CreateBackupRequest$1, CreateBackupResponse as CreateBackupResponse$1, ListBackupsRequest as ListBackupsRequest$1, ListBackupsResponse as ListBackupsResponse$1, RestoreBackupRequest as RestoreBackupRequest$1, RestoreBackupResponse as RestoreBackupResponse$1, RestorePartialBackupRequest as RestorePartialBackupRequest$1, RestorePartialBackupResponse as RestorePartialBackupResponse$1, ListRestorationsRequest as ListRestorationsRequest$1, ListRestorationsResponse as ListRestorationsResponse$1, DeleteBackupRequest as DeleteBackupRequest$1, DeleteBackupResponse as DeleteBackupResponse$1 } from './index.typings.mjs';
import '@wix/sdk-types';

interface Backup {
    /**
     * Backup ID.
     * @format GUID
     * @readonly
     */
    id?: string;
    /**
     * Backup status.
     * @readonly
     */
    status?: StatusWithLiterals;
    /**
     * Type of backup, based on how it was triggered.
     * @readonly
     */
    type?: TypeWithLiterals;
    /**
     * Date and time the backup was requested.
     * @readonly
     */
    requestedDate?: Date | null;
    /**
     * Date and time the backup commenced. Value is `null` until the backup process begins in the background.
     * @readonly
     */
    startedDate?: Date | null;
    /**
     * Date and time the backup process finished. Value is `null` until the backup process is completed in the background.
     * @readonly
     */
    finishedDate?: Date | null;
    /**
     * Date and time the backup was deleted. Value is `null` if that backup hasn't been deleted.
     * @readonly
     */
    deletedDate?: Date | null;
    /**
     * Backup size in bytes. Value is `null` until the backup process is completed.
     * @readonly
     */
    sizeInBytes?: string | null;
    /**
     * IDs and display names of collections the backup contains.
     * @readonly
     * @maxSize 1000
     */
    collections?: Collection[];
}
declare enum Status {
    /** Backup creation is in progress. */
    PENDING = "PENDING",
    /** Backup has been created successfully and can be used for data restoration. */
    READY = "READY",
    /** Backup creation has failed. */
    FAILED = "FAILED",
    /** Backup has been deleted. */
    DELETED = "DELETED",
    /** Backup has been canceled. */
    CANCELED = "CANCELED"
}
/** @enumType */
type StatusWithLiterals = Status | 'PENDING' | 'READY' | 'FAILED' | 'DELETED' | 'CANCELED';
declare enum Type {
    /** Backup taken on demand. */
    ON_DEMAND = "ON_DEMAND",
    /** Backup taken automatically by the system on a regular schedule. */
    AUTO = "AUTO"
}
/** @enumType */
type TypeWithLiterals = Type | 'ON_DEMAND' | 'AUTO';
interface Collection {
    /**
     * Collection ID.
     * @readonly
     * @maxLength 255
     */
    id?: string;
    /**
     * Collection display name.
     * @readonly
     * @maxLength 1000
     */
    displayName?: string | null;
}
/** event triggered when backup state is changed (i.e. it was created, started, completed or failed) */
interface BackupStateChanged {
    /**
     * current state of backup
     * @readonly
     */
    backup?: Backup;
}
/** event triggered when backup restoration state is changed (i.e. it was created, started or completed) */
interface RestorationStateChanged {
    /**
     * current state of restoration
     * @readonly
     */
    restoration?: Restoration;
}
interface Restoration {
    /**
     * Restoration ID.
     * @format GUID
     * @readonly
     */
    id?: string;
    /**
     * Details of the backup used for the restoration.
     * @readonly
     */
    backup?: Backup;
    /**
     * Status of restoration.
     * @readonly
     */
    status?: RestorationStatusWithLiterals;
    /**
     * Date and time the restoration was requested.
     * @readonly
     */
    requestedDate?: Date | null;
    /**
     * Date and time the restoration commenced. Value is `null` until the restoration process begins in the background.
     * @readonly
     */
    startedDate?: Date | null;
    /**
     * Date and time the restoration finished. Value is `null` until the restoration process is completed in the background.
     * @readonly
     */
    finishedDate?: Date | null;
    /**
     * Restored collections.
     * @readonly
     * @maxSize 1000
     */
    restorationCollections?: RestorationCollection[];
}
declare enum RestorationStatus {
    /** Restoration from a backup is in progress. */
    PENDING = "PENDING",
    /** Restoration from a backup has been successful. */
    COMPLETED = "COMPLETED",
    /** Restoration from a backup has failed. */
    FAILED = "FAILED"
}
/** @enumType */
type RestorationStatusWithLiterals = RestorationStatus | 'PENDING' | 'COMPLETED' | 'FAILED';
interface RestorationCollection {
    /**
     * Collections to be restored.
     *
     * Note: If collections have a multi-reference relationship,
     * the preexisting references will be restored if at least one of those collections are restored.
     * @minLength 1
     * @maxLength 1000
     */
    dataCollectionId?: string;
    /**
     * Destination where to restore the collection.
     * When not specified destination is taken from backup.
     */
    restoreDestination?: RestoreDestination;
}
interface RestoreDestination {
    /**
     * Collection ID.
     * @minLength 1
     * @maxLength 255
     */
    dataCollectionId?: string;
    /**
     * Collection's display name as shown in the CMS. If empty, `displayName` is taken from `backup.collections`.
     * @maxLength 1000
     */
    displayName?: string | null;
}
interface DisableInstanceRequest {
    /** @format GUID */
    instanceId?: string;
}
interface Empty {
}
interface EnableInstanceRequest {
    /** @format GUID */
    instanceId?: string;
}
interface DeleteAllRequest {
    /** @format GUID */
    instanceId?: string;
}
interface GetBackupMetadataRequest {
    /** @format GUID */
    backupId?: string;
}
interface GetBackupMetadataResponse {
    metaData?: Record<string, any> | null;
}
interface RebuildRequest {
    /** @format GUID */
    backupId?: string;
}
interface MoveRequest {
    /** @format GUID */
    backupId?: string;
}
interface RemoveDeletedRequest {
    limit?: number;
}
interface FailRestorationRequest {
    /** @format GUID */
    restorationId?: string;
}
interface TakeBackupRequest {
    /** @format GUID */
    instanceId?: string;
    type?: TypeWithLiterals;
}
interface UpdateBackupMetadataRequest {
    /** @format GUID */
    backupId?: string;
    s3Region?: string;
    s3Bucket?: string;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
interface ActionEvent {
    bodyAsJson?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface CreateBackupRequest {
}
interface CreateBackupResponse {
    /** Details of the requested backup. */
    backup?: Backup;
}
interface ListBackupsRequest {
    /**
     * Statuses to filter by.
     * If provided, only backups with the specified statuses are listed.
     * For example, to list only completed backups, use `?status=READY`.
     * To list completed and pending backups, use `?status=READY&status=PENDING`.
     *
     * Default: No filtering
     * @maxSize 10
     */
    status?: StatusWithLiterals[];
    /**
     * Type to filter by. If provided, only backups of the specified type are listed.
     *
     * Default: No filtering
     * @maxSize 10
     */
    type?: TypeWithLiterals[];
    /** Paging preferences. */
    paging?: Paging;
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface ListBackupsResponse {
    /**
     * Retrieved backups.
     * @maxSize 1000
     */
    backups?: Backup[];
    /** Paging information. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
}
interface RestoreBackupRequest {
    /**
     * ID of backup to be restored.
     * @format GUID
     */
    backupId: string;
}
interface RestoreBackupResponse {
    /** Details of data restoration from backup. */
    restoration?: Restoration;
}
interface RestorePartialBackupRequest {
    /**
     * ID of backup to be restored.
     * @format GUID
     */
    backupId: string;
    /**
     * **Required.** Collections to be restored.
     *
     * Note: If collections have a multi-reference relationship,
     * the preexisting references will be restored if at least one of those collections are restored.
     * @maxSize 1000
     */
    restorationCollections?: RestorationCollection[];
}
interface RestorePartialBackupResponse {
    /** Details of data restoration from backup. */
    restoration?: Restoration;
}
interface ListRestorationsRequest {
    /**
     * Statuses to filter by. If provided, only restorations with the specified statuses are listed.
     * For example, to list only completed restorations, use `?status=COMPLETED`.
     * To list completed and pending restorations, use `?status=COMPLETED&status=PENDING`.
     *
     * Default: No filtering
     * @maxSize 10
     */
    status?: RestorationStatusWithLiterals[];
    /** Offset and limit of items to retrieve. */
    paging?: Paging;
}
interface ListRestorationsResponse {
    /**
     * Retrieved restorations.
     * @maxSize 1000
     */
    restorations?: Restoration[];
    /** Paging information. */
    pagingMetadata?: PagingMetadataV2;
}
interface DeleteBackupRequest {
    /**
     * ID of the backup to be deleted.
     * @format GUID
     */
    backupId: string;
}
interface DeleteBackupResponse {
}
interface CancelBackupRequest {
    /**
     * ID of the backup to be cancelled.
     * @format GUID
     */
    backupId?: string;
}
interface CancelBackupResponse {
}
interface MigrateNamespaceRequest {
    /** @maxLength 255 */
    newNamespace?: string;
    /** @maxLength 255 */
    existingNamespace?: string;
}
interface MigrateNamespaceResponse {
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createBackup(): __PublicMethodMetaInfo<'POST', {}, CreateBackupRequest$1, CreateBackupRequest, CreateBackupResponse$1, CreateBackupResponse>;
declare function listBackups(): __PublicMethodMetaInfo<'GET', {}, ListBackupsRequest$1, ListBackupsRequest, ListBackupsResponse$1, ListBackupsResponse>;
declare function restoreBackup(): __PublicMethodMetaInfo<'POST', {
    backupId: string;
}, RestoreBackupRequest$1, RestoreBackupRequest, RestoreBackupResponse$1, RestoreBackupResponse>;
declare function restorePartialBackup(): __PublicMethodMetaInfo<'POST', {
    backupId: string;
}, RestorePartialBackupRequest$1, RestorePartialBackupRequest, RestorePartialBackupResponse$1, RestorePartialBackupResponse>;
declare function listRestorations(): __PublicMethodMetaInfo<'GET', {}, ListRestorationsRequest$1, ListRestorationsRequest, ListRestorationsResponse$1, ListRestorationsResponse>;
declare function deleteBackup(): __PublicMethodMetaInfo<'DELETE', {
    backupId: string;
}, DeleteBackupRequest$1, DeleteBackupRequest, DeleteBackupResponse$1, DeleteBackupResponse>;

export { type ActionEvent as ActionEventOriginal, type Backup as BackupOriginal, type BackupStateChanged as BackupStateChangedOriginal, type CancelBackupRequest as CancelBackupRequestOriginal, type CancelBackupResponse as CancelBackupResponseOriginal, type Collection as CollectionOriginal, type CreateBackupRequest as CreateBackupRequestOriginal, type CreateBackupResponse as CreateBackupResponseOriginal, type DeleteAllRequest as DeleteAllRequestOriginal, type DeleteBackupRequest as DeleteBackupRequestOriginal, type DeleteBackupResponse as DeleteBackupResponseOriginal, type DisableInstanceRequest as DisableInstanceRequestOriginal, type DomainEventBodyOneOf as DomainEventBodyOneOfOriginal, type DomainEvent as DomainEventOriginal, type Empty as EmptyOriginal, type EnableInstanceRequest as EnableInstanceRequestOriginal, type EntityCreatedEvent as EntityCreatedEventOriginal, type EntityDeletedEvent as EntityDeletedEventOriginal, type EntityUpdatedEvent as EntityUpdatedEventOriginal, type FailRestorationRequest as FailRestorationRequestOriginal, type GetBackupMetadataRequest as GetBackupMetadataRequestOriginal, type GetBackupMetadataResponse as GetBackupMetadataResponseOriginal, type IdentificationDataIdOneOf as IdentificationDataIdOneOfOriginal, type IdentificationData as IdentificationDataOriginal, type ListBackupsRequest as ListBackupsRequestOriginal, type ListBackupsResponse as ListBackupsResponseOriginal, type ListRestorationsRequest as ListRestorationsRequestOriginal, type ListRestorationsResponse as ListRestorationsResponseOriginal, type MessageEnvelope as MessageEnvelopeOriginal, type MigrateNamespaceRequest as MigrateNamespaceRequestOriginal, type MigrateNamespaceResponse as MigrateNamespaceResponseOriginal, type MoveRequest as MoveRequestOriginal, type PagingMetadataV2 as PagingMetadataV2Original, type Paging as PagingOriginal, type RebuildRequest as RebuildRequestOriginal, type RemoveDeletedRequest as RemoveDeletedRequestOriginal, type RestorationCollection as RestorationCollectionOriginal, type Restoration as RestorationOriginal, type RestorationStateChanged as RestorationStateChangedOriginal, RestorationStatus as RestorationStatusOriginal, type RestorationStatusWithLiterals as RestorationStatusWithLiteralsOriginal, type RestoreBackupRequest as RestoreBackupRequestOriginal, type RestoreBackupResponse as RestoreBackupResponseOriginal, type RestoreDestination as RestoreDestinationOriginal, type RestoreInfo as RestoreInfoOriginal, type RestorePartialBackupRequest as RestorePartialBackupRequestOriginal, type RestorePartialBackupResponse as RestorePartialBackupResponseOriginal, Status as StatusOriginal, type StatusWithLiterals as StatusWithLiteralsOriginal, type TakeBackupRequest as TakeBackupRequestOriginal, Type as TypeOriginal, type TypeWithLiterals as TypeWithLiteralsOriginal, type UpdateBackupMetadataRequest as UpdateBackupMetadataRequestOriginal, WebhookIdentityType as WebhookIdentityTypeOriginal, type WebhookIdentityTypeWithLiterals as WebhookIdentityTypeWithLiteralsOriginal, type __PublicMethodMetaInfo, createBackup, deleteBackup, listBackups, listRestorations, restoreBackup, restorePartialBackup };
