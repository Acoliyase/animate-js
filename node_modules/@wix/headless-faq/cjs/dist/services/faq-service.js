"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FaqService = exports.FaqServiceDefinition = void 0;
exports.loadFaqServiceConfig = loadFaqServiceConfig;
exports.loadAllFaqsByCategory = loadAllFaqsByCategory;
const services_definitions_1 = require("@wix/services-definitions");
const signals_1 = require("@wix/services-definitions/core-services/signals");
const faq_1 = require("@wix/faq");
/**
 * Service definition for the FAQ service.
 * This defines the reactive API contract for managing FAQ entries within a category.
 *
 * @constant
 */
exports.FaqServiceDefinition = (0, services_definitions_1.defineService)('faq');
/**
 * Implementation of the FAQ service that manages reactive FAQ entries data.
 * This service provides signals for FAQ data, loading state, and error handling.
 * The service is initialized with pre-loaded FAQ entries and maintains them in reactive signals.
 *
 * @example
 * ```tsx
 * import { FaqService, FaqServiceDefinition } from '@wix/faq/services';
 * import { useService } from '@wix/services-manager-react';
 *
 * function FaqComponent({ faqConfig }) {
 *   return (
 *     <ServiceProvider services={createServicesMap([
 *       [FaqServiceDefinition, FaqService.withConfig(faqConfig)]
 *     ])}>
 *       <FaqDisplay />
 *     </ServiceProvider>
 *   );
 * }
 *
 * function FaqDisplay() {
 *   const faqService = useService(FaqServiceDefinition);
 *   const faqs = faqService.faqs.get();
 *   const isLoading = faqService.isLoading.get();
 *   const error = faqService.error.get();
 *   const hasFaqs = faqService.hasFaqs.get();
 *
 *   if (isLoading) return <div>Loading FAQs...</div>;
 *   if (error) return <div>Error: {error}</div>;
 *   if (!hasFaqs) return <div>No FAQs found.</div>;
 *
 *   return (
 *     <ul>
 *       {faqs.map(faq => (
 *         <li key={faq._id}>
 *           <h3>{faq.question}</h3>
 *           <p>{faq.answer}</p>
 *         </li>
 *       ))}
 *     </ul>
 *   );
 * }
 * ```
 */
exports.FaqService = services_definitions_1.implementService.withConfig()(exports.FaqServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(signals_1.SignalsServiceDefinition);
    const faqsSignal = signalsService.signal(config.faqs);
    const isLoadingSignal = signalsService.signal(false);
    const errorSignal = signalsService.signal(null);
    const hasFaqsSignal = signalsService.signal(config.faqs.length > 0);
    const categoryIdSignal = signalsService.signal(config.categoryId);
    return {
        faqs: faqsSignal,
        isLoading: isLoadingSignal,
        error: errorSignal,
        hasFaqs: hasFaqsSignal,
        categoryId: categoryIdSignal,
    };
});
/**
 * Loads FAQ service configuration from the Wix FAQ API for a specific category for SSR initialization.
 * This function is designed to be used during Server-Side Rendering (SSR) to preload
 * FAQ entries for a specific category.
 *
 * @param categoryId - The ID of the category to load FAQs for
 * @returns {Promise<FaqServiceConfig>} Promise that resolves to the FAQ configuration
 *
 * @example
 * ```tsx
 * // Load FAQ data for a specific category during SSR
 * const faqConfig = await loadFaqServiceConfig('category-id');
 * ```
 */
async function loadFaqServiceConfig(categoryId) {
    try {
        // Use query-based approach like the reference
        let questionQuery = faq_1.questionEntry.queryQuestionEntries({
            contentFormat: faq_1.questionEntry.QueryQuestionEntriesRequestContentFormat.PLAIN_TEXT,
        });
        // Filter by category if specified
        if (categoryId) {
            questionQuery = questionQuery.eq('categoryId', categoryId);
        }
        const questionResult = await questionQuery.find();
        const rawFaqs = questionResult.items || [];
        // Transform and sort by sort order
        const transformedFaqs = rawFaqs
            .map((q) => ({
            _id: q._id,
            question: q.question,
            plainText: q.plainText,
            draftjs: q.draftjs,
            categoryId: q.categoryId,
            sortOrder: q.sortOrder,
            labels: q.labels?.map((label) => label.title || '').filter(Boolean) ||
                [],
            visible: true, // Default to visible
        }))
            .sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
        return {
            faqs: transformedFaqs,
            categoryId,
        };
    }
    catch (error) {
        console.warn(`Failed to load FAQ entries for category ${categoryId}:`, error);
        // Return empty FAQs in case of error - graceful fallback
        return {
            faqs: [],
            categoryId,
        };
    }
}
/**
 * Loads all FAQ entries grouped by category for SSR initialization.
 * This function is useful when you want to preload all FAQ data at once.
 *
 * @returns {Promise<Record<string, FaqEntry[]>>} Promise that resolves to FAQs grouped by category ID
 *
 * @example
 * ```tsx
 * // Load all FAQ data grouped by category during SSR
 * const allFaqsByCategory = await loadAllFaqsByCategory();
 * ```
 */
async function loadAllFaqsByCategory() {
    try {
        // Use query-based approach
        let questionQuery = faq_1.questionEntry.queryQuestionEntries({
            contentFormat: faq_1.questionEntry.QueryQuestionEntriesRequestContentFormat.PLAIN_TEXT,
        });
        const questionResult = await questionQuery.find();
        const rawFaqs = questionResult.items || [];
        // Transform questions
        const allQuestions = rawFaqs.map((q) => ({
            _id: q._id,
            question: q.question,
            plainText: q.plainText,
            draftjs: q.draftjs,
            categoryId: q.categoryId,
            sortOrder: q.sortOrder,
            labels: q.labels?.map((label) => label.title || '').filter(Boolean) || [],
            visible: true, // Default to visible
        }));
        // Group questions by category and sort within each category
        const faqsByCategory = {};
        allQuestions.forEach((faq) => {
            const categoryId = faq.categoryId || 'uncategorized';
            if (!faqsByCategory[categoryId]) {
                faqsByCategory[categoryId] = [];
            }
            faqsByCategory[categoryId].push(faq);
        });
        // Sort questions within each category
        Object.keys(faqsByCategory).forEach((categoryId) => {
            faqsByCategory[categoryId].sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
        });
        return faqsByCategory;
    }
    catch (error) {
        console.warn('Failed to load all FAQs by category:', error);
        // Return empty object in case of error - graceful fallback
        return {};
    }
}
//# sourceMappingURL=faq-service.js.map