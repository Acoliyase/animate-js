define(['exports'], function (exports) { 'use strict';

    var possibleSizeAttributeKeys = new Array('offsetHeight', 'scrollHeight', 'clientHeight');
    var shiftModifier = true;
    var selectableTypes = /text|password|search|tel|url/;
    /**
     * emulate tab keyboard events and default action (switch to next element)
     *
     * fist:
     * - dispatch tab keydown event at active element
     *
     * then emulate default action (if not prevented):
     * - blur on active element
     * - skip keypress action (it's between element switch so there is no target)
     * - find next element in selectable elemetns
     * - focus on next element
     * - tab keyup on next element
     *
     * or (if default action is prevented):
     * - tab keypress on active element
     * - tab keyup on active elment
     *
     * @returns true if switched elemenet and false if default action had been prevented
     */
    function emulateTab() {
        var source = activeElement() || document.body;
        var target = getNextElement(source);
        return emulateTabFromSourceToTarget(source, target);
    }
    (function (emulateTab) {
        /**
         * emulate tab from a given element (default is active element)
         *
         * @returns methods to select tab target
         */
        emulateTab.from = emulateTabFrom;
        /**
         * emulate tab from active element to a given target
         *
         * @param target element to switch to
         * @param sendKeyEventsWithShiftModifier like shift tab would do
         * @returns true if switched elemenet and false if default action had been prevented
         */
        emulateTab.to = function (target, sendKeyEventsWithShiftModifier) {
            if (sendKeyEventsWithShiftModifier === void 0) { sendKeyEventsWithShiftModifier = false; }
            return emulateTabFrom(activeElement()).to(target, sendKeyEventsWithShiftModifier);
        };
        /**
         * emulate tab to previous element
         *
         * @returns true if switched elemenet and false if default action had been prevented
         */
        emulateTab.backwards = function () { return emulateTab.to(getPreviousElement(activeElement()), shiftModifier); };
        /**
         * alias for emulateTab() that is more precise about it's direction
         *
         * @returns true if switched elemenet and false if default action had been prevented
         */
        emulateTab.forwards = function () { return emulateTab(); };
        /**
         * find all elements that are selectable by tab
         */
        emulateTab.findSelectableElements = findAllElementsSelectableByTab;
    })(emulateTab || (emulateTab = {}));
    function emulateTabFrom(source) {
        if (source === void 0) { source = document.body; }
        return {
            /**
             * emulate tab to the element before the starting element (which is the active element by default)
             *
             * @returns true if switched elemenet and false if default action had been prevented
             */
            toPreviousElement: function () { return emulateTabFromSourceToTarget(source, getPreviousElement(), shiftModifier); },
            /**
             * emulate tab to the element after the starting element (which is the active element by default)
             *
             * @returns true if switched elemenet and false if default action had been prevented
             */
            toNextElement: function () { return emulateTabFromSourceToTarget(source, getNextElement(source)); },
            /**
             * emulate tab to a custom given element
             *
             * @param target element after tab
             * @param sendKeyEventsWithShiftModifier like shift tab would do
             * @returns true if switched elemenet and false if default action had been prevented
             */
            to: function (target, sendKeyEventsWithShiftModifier) {
                if (sendKeyEventsWithShiftModifier === void 0) { sendKeyEventsWithShiftModifier = false; }
                return emulateTabFromSourceToTarget(source, target, sendKeyEventsWithShiftModifier);
            }
        };
    }
    function emulateTabFromSourceToTarget(source, target, sendKeyEventsWithShiftModifier) {
        if (sendKeyEventsWithShiftModifier === void 0) { sendKeyEventsWithShiftModifier = false; }
        var executeDefaultAction = source.dispatchEvent(createTabEvent('keydown', sendKeyEventsWithShiftModifier));
        if (executeDefaultAction) {
            source.blur();
            target.focus();
            if (document.activeElement !== target) {
                try {
                    document.activeElement = target;
                }
                catch (e) {
                    console.warn('could not switch active element');
                }
            }
            if (target instanceof HTMLInputElement && selectableTypes.test(target.type)) {
                target.selectionStart = 0;
            }
            var tabKeyup = createTabEvent('keyup', sendKeyEventsWithShiftModifier);
            target.dispatchEvent(tabKeyup);
            return true;
        }
        else {
            source.dispatchEvent(createTabEvent('keypress', sendKeyEventsWithShiftModifier));
            source.dispatchEvent(createTabEvent('keyup', sendKeyEventsWithShiftModifier));
            return false;
        }
    }
    function createTabEvent(type, sendKeyEventsWithShiftModifier) {
        if (sendKeyEventsWithShiftModifier === void 0) { sendKeyEventsWithShiftModifier = false; }
        return new KeyboardEvent(type, {
            code: 'Tab',
            key: 'Tab',
            cancelable: true,
            bubbles: true,
            shiftKey: sendKeyEventsWithShiftModifier
        });
    }
    function activeElement() {
        var element = document.activeElement;
        return element instanceof HTMLElement ? element : undefined;
    }
    function getPreviousElement(lastElement) {
        if (lastElement === void 0) { lastElement = document.body; }
        var selectableElements = findAllElementsSelectableByTab();
        if (selectableElements.length < 1) {
            throw new Error('no selectable elements found');
        }
        var currentIndex = selectableElements.indexOf(lastElement);
        var previousIndex = (currentIndex > 0 ? currentIndex : selectableElements.length) - 1;
        var previousElement = selectableElements[previousIndex];
        return previousElement;
    }
    function getNextElement(lastElement) {
        if (lastElement === void 0) { lastElement = document.body; }
        var selectableElements = findAllElementsSelectableByTab();
        if (selectableElements.length < 1) {
            throw new Error('no selectable elements found');
        }
        var currentIndex = selectableElements.indexOf(lastElement);
        var nextIndex = currentIndex + 1 < selectableElements.length ? currentIndex + 1 : 0;
        var nextElement = selectableElements[nextIndex];
        return nextElement;
    }
    function findAllElementsSelectableByTab() {
        var allElements = Array.from(document.querySelectorAll('*')).filter(isHtmlElement);
        initIsVisibleOnce();
        var tabGroups = allElements
            .filter(testAll(hasValidTabIndex, isVisible, isNotDisabledInput, isNotSkippableAnchor, isNotCollapsed))
            .reduce(function (grouped, element) {
            var tabIndex = element.tabIndex;
            var tabGroup = grouped['' + tabIndex] || { tabIndex: tabIndex, elements: [] };
            tabGroup.elements.push(element);
            grouped[tabIndex] = tabGroup;
            return grouped;
        }, {});
        var selectableElements = Object.values(tabGroups)
            .sort(byComparingTabIndex)
            .reduce(function (all, more) { return all.concat(more.elements); }, new Array());
        return selectableElements;
    }
    var isHtmlElement = function (element) { return element instanceof HTMLElement; };
    var isVisible;
    var initIsVisibleOnce = function () {
        var sizeAttributeKey = findSizeAttributeKey();
        if (sizeAttributeKey) {
            // console.log('use isVisible by size attribute: ' + sizeAttributeKey);
            isVisible = isVisibleBySize(sizeAttributeKey);
        }
        else {
            // console.log('use isVisible by parents');
            isVisible = isVisibleByParents;
        }
        initIsVisibleOnce = function () { };
    };
    var isVisibleBySize = function (sizeAttribute) { return function (element) {
        var size = element[sizeAttribute];
        return !!size && typeof size === 'number' && size > 0;
    }; };
    function findSizeAttributeKey(element) {
        if (element === void 0) { element = document.body; }
        var htmlElement = element;
        var sizeAttributeKey = possibleSizeAttributeKeys
            .find(function (key) {
            var value = htmlElement[key];
            return value && typeof value === 'number' && value > 0;
        });
        if (sizeAttributeKey) {
            return sizeAttributeKey;
        }
        var childNodes = element.children;
        for (var _i = 0, _a = Array.from(childNodes); _i < _a.length; _i++) {
            var childNode = _a[_i];
            var childAttribute = findSizeAttributeKey(childNode);
            if (childAttribute) {
                return childAttribute;
            }
        }
        return undefined;
    }
    var isVisibleByParents = function (element) {
        if (!element.isConnected) {
            return false;
        }
        if (element.tagName === 'BODY') {
            return true;
        }
        var style = getComputedStyle(element);
        if (style.display === 'none') {
            return false;
        }
        if (style.visibility === 'collapse') {
            return false;
        }
        var parent = element.parentElement;
        if (!parent) {
            return false;
        }
        return isVisibleByParents(parent);
    };
    function testAll() {
        var elementFilter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elementFilter[_i] = arguments[_i];
        }
        return function (element) { return !elementFilter.some(function (f) { return !f(element); }); };
    }
    function hasValidTabIndex(element) {
        return typeof element.tabIndex === 'number' && element.tabIndex >= 0;
    }
    var isNotDisabledInput = function (element) { return !element.disabled; };
    function isNotSkippableAnchor(element) {
        return !(element instanceof HTMLAnchorElement)
            || !!element.href
            || element.getAttribute('tabIndex') !== null;
    }
    var isNotCollapsed = function (element) {
        return getComputedStyle(element).visibility !== 'collapse';
    };
    function byComparingTabIndex(a, b) {
        if (a.tabIndex > 0 && b.tabIndex > 0) {
            return a.tabIndex - b.tabIndex;
        }
        if (a.tabIndex > 0) {
            return -a.tabIndex;
        }
        if (b.tabIndex > 0) {
            return b.tabIndex;
        }
        throw new Error('same tab index for two groups');
    }

    exports.emulateTab = emulateTab;

    Object.defineProperty(exports, '__esModule', { value: true });

});
